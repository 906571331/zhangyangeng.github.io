<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="mask-icon" href="/images/favicon-32x32.png" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css" integrity="sha256-no0c5ccDODBwp+9hSmV5VvPpKwHCpbVzXHexIkupM6U=" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js" integrity="sha256-a5YRB27CcBwBFcT5EF/f3E4vzIqyHrSR878nseNYw64=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;www.wrysmile.cn&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:true,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;manual&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/js/config.js"></script><meta name="description" content="介绍  记录在开发微信小程序时的一些知识点"><meta property="og:type" content="article"><meta property="og:title" content="学习笔记：微信小程序"><meta property="og:url" content="https://www.wrysmile.cn/Learn-Wechat.html"><meta property="og:site_name" content="Wrysmile 的博客"><meta property="og:description" content="介绍  记录在开发微信小程序时的一些知识点"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s3.ax1x.com/2021/02/22/yHUKM9.png"><meta property="article:published_time" content="2020-04-07T07:58:57.000Z"><meta property="article:modified_time" content="2023-01-17T09:08:24.681Z"><meta property="article:author" content="Zhang Yangeng"><meta property="article:tag" content="学习"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s3.ax1x.com/2021/02/22/yHUKM9.png"><link rel="canonical" href="https://www.wrysmile.cn/Learn-Wechat.html"><script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;www.wrysmile.cn&#x2F;Learn-Wechat.html&quot;,&quot;path&quot;:&quot;Learn-Wechat.html&quot;,&quot;title&quot;:&quot;学习笔记：微信小程序&quot;}</script><script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script><title>学习笔记：微信小程序 | Wrysmile 的博客</title><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=+new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/13e39436.js","daovoice"),daovoice("init",{app_id:"13e39436"}),daovoice("update")</script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Wrysmile 的博客" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Wrysmile 的博客</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">欢迎来到我的个人小屋</p><img class="custom-logo-image" src="/images/favicon-32x32.png" alt="Wrysmile 的博客"></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">一、储备</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">二、基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Flex%E5%B8%83%E5%B1%80"><span class="nav-text">1.Flex布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-text">(1).介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="nav-text">(2).容器属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-flex-direction"><span class="nav-text">1).flex-direction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-flex-wrap"><span class="nav-text">2).flex-wrap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-flex-flow"><span class="nav-text">3).flex-flow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-justify-content"><span class="nav-text">4).justify-content</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-align-items"><span class="nav-text">5).align-items</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-align-content"><span class="nav-text">6).align-content</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7"><span class="nav-text">(3).项目属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-order"><span class="nav-text">1).order</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-flex-grow"><span class="nav-text">2).flex-grow</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-flex-shrink"><span class="nav-text">3).flex-shrink</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-flex-basis"><span class="nav-text">4).flex-basis</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-flex"><span class="nav-text">5).flex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-align-self"><span class="nav-text">6).align-self</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%A7%BB%E5%8A%A8%E7%AB%AF"><span class="nav-text">2.移动端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%89%A9%E7%90%86%E5%83%8F%E7%B4%A0"><span class="nav-text">(1).物理像素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E5%83%8F%E7%B4%A0"><span class="nav-text">(2).设备独立像素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-dpr-%E6%AF%94"><span class="nav-text">(3).dpr 比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88"><span class="nav-text">(4).适配方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-%E8%A7%86%E5%8F%A3"><span class="nav-text">0).视口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-viewport-%E9%80%82%E9%85%8D"><span class="nav-text">1).viewport 适配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-rem-%E9%80%82%E9%85%8D"><span class="nav-text">2).rem 适配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="nav-text">3.小程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%89%B9%E7%82%B9"><span class="nav-text">(1).特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-text">(2).文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#font-color-F00-%EF%BC%81js%E4%B8%AD%E5%9B%BA%E5%AE%9A%E6%A0%BC%E5%BC%8F-font"><span class="nav-text">！js中固定格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88"><span class="nav-text">(3).适配方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84"><span class="nav-text">(4).图片路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E"><span class="nav-text">(5).项目文件说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-app-js"><span class="nav-text">a).app.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-app-json"><span class="nav-text">b).app.json</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-app-wxss"><span class="nav-text">c).app.wxss</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-index-js"><span class="nav-text">d).index.js</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F"><span class="nav-text">(6).编译模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87"><span class="nav-text">4.字体图标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D-2"><span class="nav-text">(1).介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">(2).使用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F"><span class="nav-text">5.内网穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="nav-text">6.登录流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E9%A1%B9%E6%95%B0%E6%8D%AE"><span class="nav-text">(1).收集表单项数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81"><span class="nav-text">(2).前端验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%90%8E%E7%AB%AF%E9%AA%8C%E8%AF%81"><span class="nav-text">(3).后端验证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D"><span class="nav-text">7.视口单位</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%95%B0%E6%8D%AE%E5%88%86%E9%A1%B5"><span class="nav-text">8.数据分页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-text">9.日期函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-npm-%E5%8C%85"><span class="nav-text">10.npm 包</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">(1).使用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96-package-json"><span class="nav-text">1).初始化 package.json</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BF%AE%E6%94%B9%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E7%BD%AE"><span class="nav-text">2).修改小程序设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%B8%8B%E8%BD%BDnpm%E5%8C%85"><span class="nav-text">3).下载npm包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%9E%84%E5%BB%BAnpm"><span class="nav-text">4).构建npm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%AF%BC%E5%85%A5npm%E5%8C%85"><span class="nav-text">5).导入npm包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B8%B8%E8%A7%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="nav-text">(2).常见第三方库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-PubSub"><span class="nav-text">1).PubSub</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Moment"><span class="nav-text">2).Moment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Fly"><span class="nav-text">3).Fly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-jsonwebtoken"><span class="nav-text">4).jsonwebtoken</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96"><span class="nav-text">11.函数节流与防抖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95"><span class="nav-text">12.小程序登录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%8E%B7%E5%8F%96%E7%99%BB%E5%BD%95%E5%87%AD%E8%AF%81"><span class="nav-text">(1).获取登录凭证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B0%86%E7%99%BB%E5%BD%95%E5%87%AD%E8%AF%81%E5%8F%91%E9%80%81%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-text">(2).将登录凭证发送给服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E8%B0%83%E8%AF%95%E9%94%99%E8%AF%AF"><span class="nav-text">13.调试错误</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">三、框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE"><span class="nav-text">1.小程序配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="nav-text">(1).全局配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-tabBar"><span class="nav-text">1).tabBar</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%A1%86%E6%9E%B6%E6%8E%A5%E5%8F%A3"><span class="nav-text">2.框架接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-getAPP"><span class="nav-text">(1).getAPP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-wxml%E8%AF%AD%E6%B3%95"><span class="nav-text">3.wxml语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A"><span class="nav-text">(1).数据绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE"><span class="nav-text">1).初始化数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="nav-text">2).使用数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="nav-text">3).修改数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%B8%8EVue%E5%92%8CReact%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">4).与Vue和React的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="nav-text">a).小程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-Vue"><span class="nav-text">b).Vue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-React"><span class="nav-text">c).React</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E4%BB%A3%E7%90%86"><span class="nav-text">扩展：数据劫持代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="nav-text">(2).事件绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6"><span class="nav-text">1).冒泡事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%9D%9E%E5%86%92%E6%B3%A1%E4%BA%8B%E4%BB%B6"><span class="nav-text">2).非冒泡事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83"><span class="nav-text">3).事件回调</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="nav-text">4).事件委托</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E6%A6%82%E5%BF%B5"><span class="nav-text">a).概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E5%A5%BD%E5%A4%84"><span class="nav-text">b).好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%8E%9F%E7%90%86"><span class="nav-text">c).原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#d-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%98%AF%E8%B0%81"><span class="nav-text">d).触发事件的是谁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#e-%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-text">e).如何找到触发事件的对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strong-style-color-red-%E6%8B%93%E5%B1%95%EF%BC%9A%E4%BA%8B%E4%BB%B6%E6%B5%81%E4%B8%89%E9%98%B6%E6%AE%B5-strong"><span class="nav-text">拓展：事件流三阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strong-style-color-red-%E6%8B%93%E5%B1%95%EF%BC%9A%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6-strong"><span class="nav-text">拓展：绑定事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strong-style-color-red-%E6%8B%93%E5%B1%95%EF%BC%9A-span-id-event-%E4%BA%8B%E4%BB%B6%E5%88%86%E7%B1%BB-span-strong"><span class="nav-text">拓展：事件分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="nav-text">(3).列表渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88wx-key%E4%B8%8D%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87index%E8%80%8C%E6%98%AFID%EF%BC%9F"><span class="nav-text">为什么wx:key不使用下标index而是ID？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="nav-text">(4).条件渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%B3%EF%BC%9A%E5%8A%A8%E6%80%81%E9%9A%90%E8%97%8F%E5%85%83%E7%B4%A0"><span class="nav-text">引申：动态隐藏元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-text">(5).生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%A8%A1%E6%9D%BF"><span class="nav-text">(6).模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF"><span class="nav-text">1).定义模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BC%95%E5%85%A5%E6%A8%A1%E6%9D%BF"><span class="nav-text">2).引入模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="nav-text">3).使用模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%BC%95%E7%94%A8"><span class="nav-text">(7).引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-text">(8).数组与对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">四、组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-swiper"><span class="nav-text">1.swiper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="nav-text">(1).常用属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-scroll-view"><span class="nav-text">2.scroll-view</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7-2"><span class="nav-text">(1).常用属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-video"><span class="nav-text">3.video</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-block"><span class="nav-text">4.block</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-button"><span class="nav-text">5.button</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-form"><span class="nav-text">6.form</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-radio"><span class="nav-text">7.radio</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%B0%81%E8%A3%85%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0-%E7%BB%84%E4%BB%B6"><span class="nav-text">8.封装功能函数&#x2F;组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B0%81%E8%A3%85%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0"><span class="nav-text">(1).封装功能函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%B0%81%E8%A3%85%E5%8A%9F%E8%83%BD%E7%BB%84%E4%BB%B6"><span class="nav-text">(2).封装功能组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95"><span class="nav-text">(3).小程序封装函数方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="nav-text">9.自定义组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%82%E6%95%B0"><span class="nav-text">(1).参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%B9%E6%B3%95"><span class="nav-text">(2).方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">五、API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="nav-text">1.路由跳转</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="nav-text">(1).路由传参</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="nav-text">2.本地存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%95%8C%E9%9D%A2"><span class="nav-text">3.界面</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%A4%E4%BA%92-%E2%80%94%E2%80%94-%E6%98%BE%E7%A4%BA%E7%AD%89%E5%BE%85%E6%8F%90%E7%A4%BA%E6%A1%86"><span class="nav-text">(1).交互 —— 显示等待提示框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%A4%E4%BA%92-%E2%80%94%E2%80%94-%E6%98%BE%E7%A4%BA%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="nav-text">(2).交互 —— 显示模态对话框</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AF%BC%E8%88%AA%E6%A0%8F-%E2%80%94%E2%80%94-%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%A0%87%E9%A2%98"><span class="nav-text">(3).导航栏 —— 动态设置当前页面的标题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AA%92%E4%BD%93"><span class="nav-text">4.媒体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%83%8C%E6%99%AF%E9%9F%B3%E9%A2%91"><span class="nav-text">(1).背景音频</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">六、动画</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%A7%A6%E6%91%B8%E6%BB%91%E5%8A%A8%E5%9B%9E%E5%BC%B9"><span class="nav-text">1.触摸滑动回弹</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A"><span class="nav-text">(1).事件绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%A1%E7%AE%97%E6%89%8B%E6%8C%87%E7%A7%BB%E5%8A%A8%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="nav-text">(2).计算手指移动的距离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%BE%E7%BD%AE%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C"><span class="nav-text">(3).设置滑动效果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AF%BC%E8%88%AA%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C"><span class="nav-text">2.导航过渡效果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%95%99%E5%A3%B0%E6%9C%BA%E7%A3%81%E7%9B%98%E6%97%8B%E8%BD%AC%E6%95%88%E6%9E%9C"><span class="nav-text">3.留声机磁盘旋转效果</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">七、分包</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D-3"><span class="nav-text">1.介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%88%86%E5%8C%85%E5%BD%A2%E5%BC%8F"><span class="nav-text">2.分包形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%B8%B8%E8%A7%84%E5%88%86%E5%8C%85"><span class="nav-text">(1).常规分包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%8B%AC%E7%AB%8B%E5%88%86%E5%8C%85"><span class="nav-text">(2).独立分包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%86%E5%8C%85%E9%A2%84%E4%B8%8B%E8%BD%BD"><span class="nav-text">(3).分包预下载</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">八、上传</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%B3%A8%E6%84%8F"><span class="nav-text">1.注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%89%88%E6%9C%AC%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="nav-text">2.版本命名规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%8F%90%E4%BA%A4%E5%AE%A1%E6%A0%B8"><span class="nav-text">3.提交审核</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">九、云开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E5%8C%BA%E5%88%86this"><span class="nav-text">0.区分this</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#strong-style-color-red-%E5%A6%82%E4%BD%95%E5%B0%86-get-%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91%E9%A1%B5%E9%9D%A2%EF%BC%9F-strong"><span class="nav-text">如何将.get()中的this指向页面？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">1.数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E6%9D%83%E9%99%90"><span class="nav-text">(0).权限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">(1).初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9F%A5%E8%AF%A2"><span class="nav-text">(2).查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E5%A4%9A%E5%B1%82%E6%88%90%E5%8A%9F%E5%9B%9E%E8%B0%83%E5%B5%8C%E5%A5%97"><span class="nav-text">!解决多层成功回调嵌套</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4"><span class="nav-text">!查询指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%B7%BB%E5%8A%A0"><span class="nav-text">(3).添加</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E6%99%AE%E9%80%9A%E6%B7%BB%E5%8A%A0"><span class="nav-text">a).普通添加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E6%B7%BB%E5%8A%A0"><span class="nav-text">b).表单提交添加</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9B%B4%E6%96%B0"><span class="nav-text">(4).更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%88%A0%E9%99%A4"><span class="nav-text">(5).删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-command"><span class="nav-text">(6).command</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89"><span class="nav-text">a).定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">b).逻辑操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#c-%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">c).比较操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#d-%E5%AD%97%E6%AE%B5%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">d).字段操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#e-%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">e).数组操作符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%BA%91%E5%87%BD%E6%95%B0"><span class="nav-text">2.云函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BA%91%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-text">(1).云函数调用数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%89%8D%E7%AB%AF%E4%B8%8E%E4%BA%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE"><span class="nav-text">(2).前端与云函数传递数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE-2"><span class="nav-text">(3).修改数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E4%BA%91%E5%AD%98%E5%82%A8"><span class="nav-text">3.云存储</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E9%80%89%E6%8B%A9%E5%9B%BE%E7%89%87"><span class="nav-text">(0).选择图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6"><span class="nav-text">(1).上传文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AB%AF"><span class="nav-text">a).小程序端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E4%BA%91%E5%87%BD%E6%95%B0%E7%AB%AF"><span class="nav-text">b).云函数端</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80"><span class="nav-text">(2).文件下载地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88"><span class="nav-text">4.问题集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Environment-not-found"><span class="nav-text">(1).Environment not found</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-%E4%BA%91%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%BD%93%E5%89%8D%E4%BA%91%E7%8E%AF%E5%A2%83"><span class="nav-text">a).云函数中指定当前云环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#b-%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BA%91%E7%8E%AF%E5%A2%83%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="nav-text">b).使用常量动态获取当前云环境（推荐）</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">十、基础案例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E5%B9%B6%E6%90%BA%E5%B8%A6%E6%95%B0%E6%8D%AE"><span class="nav-text">0.页面跳转并携带数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8F%91%E9%80%81%E9%A1%B5%E9%9D%A2"><span class="nav-text">(1).发送页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8E%A5%E6%94%B6%E9%A1%B5%E9%9D%A2"><span class="nav-text">(2).接收页面</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="nav-text">1.用户信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="nav-text">(1).获取用户信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%94%A8%E6%88%B7%E6%9C%AA%E6%8E%88%E6%9D%83%EF%BC%88%E9%A6%96%E6%AC%A1%E7%99%BB%E9%99%86%EF%BC%89"><span class="nav-text">1).用户未授权（首次登陆）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%94%A8%E6%88%B7%E5%B7%B2%E6%8E%88%E6%9D%83%EF%BC%88%E5%86%8D%E6%AC%A1%E7%99%BB%E9%99%86%EF%BC%89"><span class="nav-text">2).用户已授权（再次登陆）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A4%B4%E5%83%8F%E4%B8%8E%E6%8C%89%E9%92%AE%E7%9A%84%E9%9A%90%E8%97%8F"><span class="nav-text">3).头像与按钮的隐藏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7cookie"><span class="nav-text">(2).获取用户cookie</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%BD%AE%E6%92%AD%E5%9B%BE"><span class="nav-text">2.轮播图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%94%BE%E7%BD%AE%E8%BD%AE%E6%92%AD%E5%9B%BE%E5%AE%B9%E5%99%A8"><span class="nav-text">(1).放置轮播图容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%BE%E7%BD%AE%E5%AE%B9%E5%99%A8%E6%A0%B7%E5%BC%8F"><span class="nav-text">(2).设置容器样式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%AE%BE%E7%BD%AE%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-text">(3).设置组件属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E9%9A%90%E8%97%8F"><span class="nav-text">3.文本溢出隐藏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%8D%95%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA"><span class="nav-text">(1).单行文本溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA"><span class="nav-text">(2).多行文本溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92"><span class="nav-text">4.前后端交互</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E9%80%BB%E8%BE%91"><span class="nav-text">5.登录界面逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%94%B6%E9%9B%86%E8%A1%A8%E5%8D%95%E9%A1%B9%E6%95%B0%E6%8D%AE-2"><span class="nav-text">(1).收集表单项数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%89%8D%E7%AB%AF%E9%AA%8C%E8%AF%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">(2).前端验证实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%90%8E%E7%AB%AF%E9%AA%8C%E8%AF%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">(3).后端验证实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E4%B8%AA%E4%BA%BA%E4%B8%AD%E5%BF%83%E4%B8%8E%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2%E4%BA%A4%E4%BA%92"><span class="nav-text">(4).个人中心与登录界面交互</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%99%BB%E5%BD%95%E7%95%8C%E9%9D%A2"><span class="nav-text">1).跳转到登录界面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE"><span class="nav-text">2).本地存储用户数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%9C%AC%E5%9C%B0%E8%AF%BB%E5%8F%96%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE"><span class="nav-text">3).本地读取用户数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E4%BF%AE%E6%94%B9%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84"><span class="nav-text">4).修改页面结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE"><span class="nav-text">6.视频播放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A4%9A%E4%B8%AA%E8%A7%86%E9%A2%91%E5%90%8C%E6%97%B6%E6%92%AD%E6%94%BE"><span class="nav-text">(1).多个视频同时播放</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%9C%80%E6%B1%82"><span class="nav-text">1).需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%85%B3%E9%94%AE"><span class="nav-text">2).关键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%96%B9%E6%A1%88"><span class="nav-text">3).方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88"><span class="nav-text">4).终极方案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE"><span class="nav-text">7.音乐播放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E6%97%B6%E7%B3%BB%E7%BB%9F%E6%A0%8F%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="nav-text">(1).音乐播放时系统栏的控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98"><span class="nav-text">1).问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%96%B9%E6%A1%88"><span class="nav-text">2).方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%A1%B5%E9%9D%A2%E9%94%80%E6%AF%81%E6%97%B6%E9%9F%B3%E4%B9%90%E7%9A%84%E6%92%AD%E6%94%BE%E7%8A%B6%E6%80%81"><span class="nav-text">(2).页面销毁时音乐的播放状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98-2"><span class="nav-text">1).问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%85%B3%E9%94%AE-2"><span class="nav-text">2).关键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%96%B9%E6%A1%88-2"><span class="nav-text">3).方案</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%AD%8C%E6%9B%B2%E6%92%AD%E6%94%BE%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-text">(3).歌曲播放性能优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%8E%86%E5%8F%B2%E6%90%9C%E7%B4%A2"><span class="nav-text">8.历史搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%BF%9D%E5%AD%98%E5%8E%86%E5%8F%B2%E6%90%9C%E7%B4%A2%E8%AE%B0%E5%BD%95"><span class="nav-text">(1).保存历史搜索记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B8%85%E9%99%A4%E5%BD%93%E5%89%8D%E6%90%9C%E7%B4%A2%E6%A1%86%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-text">(2).清除当前搜索框中的内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4%E5%8E%86%E5%8F%B2%E6%90%9C%E7%B4%A2%E8%AE%B0%E5%BD%95"><span class="nav-text">(3).删除历史搜索记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%8A%A8%E6%80%81%E6%98%BE%E7%A4%BA%E5%8E%86%E5%8F%B2%E6%A0%8F%E4%B8%8E%E6%B8%85%E9%99%A4%E6%8C%89%E9%92%AE"><span class="nav-text">(4).动态显示历史栏与清除按钮</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">十一、云开发案例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%82%B9%E5%87%BB%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%8A%A0%E9%98%85%E8%AF%BB%E9%87%8F"><span class="nav-text">1.点击数据增加阅读量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%8E%B7%E5%8F%96%E7%82%B9%E5%87%BB%E7%9A%84id%E5%92%8Cindex"><span class="nav-text">(1).获取点击的id和index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%91%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%9B%B4%E6%96%B0%E6%93%8D%E4%BD%9C"><span class="nav-text">(2).云函数进行更新操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BA%A4%E4%BA%92"><span class="nav-text">(3).前后端交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%87%8D%E6%96%B0%E6%B8%B2%E6%9F%93%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE"><span class="nav-text">(4).重新渲染列表数据</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Zhang Yangeng" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Zhang Yangeng</p><div class="site-description" itemprop="description">保持独立思考，不卑不亢不怂，长成自己想要的样子！</div></div><div class="site-state-wrap site-overview-item animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">67</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">51</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author site-overview-item animated"><span class="links-of-author-item"><a href="https://github.com/zhangyangeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhangyangeng" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://weibo.com/u/2294901673" title="weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;2294901673" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-weibo fa-fw"></i>weibo</a></span></div><div class="cc-license site-overview-item animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-cn" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div><div class="links-of-blogroll site-overview-item animated"><div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i> 推荐网站</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://topbook.cc/" title="http:&#x2F;&#x2F;topbook.cc&#x2F;" rel="external nofollow noopener noreferrer" target="_blank">Topbook</a></li></ul></div></div></div></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.wrysmile.cn/Learn-Wechat.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Zhang Yangeng"><meta itemprop="description" content="保持独立思考，不卑不亢不怂，长成自己想要的样子！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Wrysmile 的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">学习笔记：微信小程序</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-04-07 15:58:57" itemprop="dateCreated datePublished" datetime="2020-04-07T15:58:57+08:00">2020-04-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-01-17 17:08:24" itemprop="dateModified" datetime="2023-01-17T17:08:24+08:00">2023-01-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a> </span></span><span id="/Learn-Wechat.html" class="post-meta-item leancloud_visitors" data-flag-title="学习笔记：微信小程序" title="阅读次数"><span class="post-meta-item-icon"><i class="far fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>29k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>26 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><h1>介绍</h1><ul class="lvl-0"><li class="lvl-2">记录在开发微信小程序时的一些知识点</li></ul><span id="more"></span><h1>一、储备</h1><ul class="lvl-0"><li class="lvl-2"><p>理解事件机制</p></li><li class="lvl-2"><p>理解组件化</p></li><li class="lvl-2"><p>理解数据绑定</p></li><li class="lvl-2"><p>Flex 布局</p></li><li class="lvl-2"><p>移动端适配方案</p></li></ul><h1>二、基础</h1><h2 id="1-Flex布局">1.Flex布局</h2><h3 id="1-介绍">(1).介绍</h3><blockquote><p>相关知识请前往<a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.runoob.com/w3cnote/flex-grammar.html">这里</a>查看</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>即弹性布局 —— <code>display: flex;</code></p></li><li class="lvl-2"><p>采用 Flex 布局的元素，称为 Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex项目（flex item），简称”项目”</p></li><li class="lvl-2"><p><strong style="color:red">注意：当一个元素设置为 flex，其子元素会自动成为 block 元素</strong></p></li></ul><h3 id="2-容器属性">(2).容器属性</h3><h4 id="1-flex-direction">1).flex-direction</h4><ul class="lvl-0"><li class="lvl-2"><p>决定主轴的方向（即项目的排列方向）</p></li><li class="lvl-2"><p>可选值：<br>row（默认值）：主轴为水平方向，起点在左端<br>row-reverse：主轴为水平方向，起点在右端<br>column：主轴为垂直方向，起点在上沿<br>column-reverse：主轴为垂直方向，起点在下沿</p></li></ul><h4 id="2-flex-wrap">2).flex-wrap</h4><ul class="lvl-0"><li class="lvl-2"><p>定义如果一条轴线排不下如何换行</p></li><li class="lvl-2"><p>可选值：<br>nowrap（默认）：不换行<br>wrap：换行，第一行在上方<br>wrap-reverse：换行，第一行在下方</p></li></ul><h4 id="3-flex-flow">3).flex-flow</h4><ul class="lvl-0"><li class="lvl-2"><p>是 <code>flex-direction</code> 属性和 <code>flex-wrap</code> 属性的简写形式</p></li><li class="lvl-2"><p>可选值：默认值为 row nowrap<br>其余自行组合</p></li></ul><h4 id="4-justify-content">4).justify-content</h4><ul class="lvl-0"><li class="lvl-2"><p>定义了项目在主轴上的对齐方式</p></li><li class="lvl-2"><p>可选值（具体对齐方式与轴的方向有关。下面假设主轴为从左到右）：<br>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</p></li></ul><h4 id="5-align-items">5).align-items</h4><ul class="lvl-0"><li class="lvl-2"><p>定义项目在交叉轴上如何对齐</p></li><li class="lvl-2"><p>可选值（具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下）：<br>flex-start：交叉轴的起点对齐<br>flex-end：交叉轴的终点对齐<br>center：交叉轴的中点对齐<br>baseline: 项目的第一行文字的基线对齐<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</p></li></ul><h4 id="6-align-content">6).align-content</h4><ul class="lvl-0"><li class="lvl-2"><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p></li><li class="lvl-2"><p>可选值：<br>flex-start：与交叉轴的起点对齐<br>flex-end：与交叉轴的终点对齐<br>center：与交叉轴的中点对齐<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍<br>stretch（默认值）：轴线占满整个交叉轴</p></li></ul><h3 id="3-项目属性">(3).项目属性</h3><h4 id="1-order">1).order</h4><ul class="lvl-0"><li class="lvl-2"><p>定义项目的排列顺序</p></li><li class="lvl-2"><p>数值越小，排列越靠前，默认为0</p></li></ul><h4 id="2-flex-grow">2).flex-grow</h4><ul class="lvl-0"><li class="lvl-2"><p>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</p></li><li class="lvl-2"><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）</p></li><li class="lvl-2"><p>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</p></li></ul><h4 id="3-flex-shrink">3).flex-shrink</h4><ul class="lvl-0"><li class="lvl-2"><p>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p></li><li class="lvl-2"><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小</p></li><li class="lvl-2"><p>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</p></li><li class="lvl-2"><p>负值对该属性无效</p></li></ul><h4 id="4-flex-basis">4).flex-basis</h4><ul class="lvl-0"><li class="lvl-2"><p>定义了在分配多余空间之前，项目占据的主轴空间（main size）</p></li><li class="lvl-2"><p>浏览器根据这个属性，计算主轴是否有多余空间</p></li><li class="lvl-2"><p>默认值为auto，即项目的本来大小</p></li></ul><h4 id="5-flex">5).flex</h4><ul class="lvl-0"><li class="lvl-2"><p>是 <code>flex-grow</code>、 <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为0 1 auto，其中后两个属性可选</p></li><li class="lvl-2"><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto) 以及 1(1 1 0%)</p></li><li class="lvl-2"><p><font color="#F00"><strong>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</strong></font></p></li></ul><h4 id="6-align-self">6).align-self</h4><ul class="lvl-0"><li class="lvl-2"><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</p></li><li class="lvl-2"><p>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</p></li><li class="lvl-2"><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致</p></li></ul><h2 id="2-移动端">2.移动端</h2><h3 id="1-物理像素">(1).物理像素</h3><ul class="lvl-0"><li class="lvl-2"><p>指屏幕的分辨率，即设备能控制显示的最小单元，可看成对应的像素点</p></li></ul><h3 id="2-设备独立像素">(2).设备独立像素</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>设备独立像素（也叫密度无关像素）</strong>：可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的虚拟像素（比如：css像素，只是在 android 机中 css 像素就不叫&quot;css像素&quot;了而是叫”设备独立像素&quot;），然后由相关系统转换为物理像素</p></li><li class="lvl-2"><p>设备独立像素相当于 CSS 像素</p></li></ul><h3 id="3-dpr-比">(3).dpr 比</h3><ul class="lvl-0"><li class="lvl-2"><p><strong>dpr</strong>：即设备像素比=物理像素/设备独立像素，一般以iPhone 6 的dpr为准，即dpr=2</p></li><li class="lvl-2"><p><strong>PPI</strong>：一英寸显示屏上的像素点个数</p></li><li class="lvl-2"><p><strong>DPI</strong>：最早指的是打印机在单位面积上打印的墨点数，墨点越多越清晰</p></li></ul><h3 id="4-适配方案">(4).适配方案</h3><h4 id="0-视口">0).视口</h4><ul class="lvl-0"><li class="lvl-2"><p>视觉视口：手机窗口大小</p></li><li class="lvl-2"><p>布局视口：指网页</p></li><li class="lvl-2"><p>完美视口/理想视口：为了使上面的两个视口基本一致</p></li></ul><h4 id="1-viewport-适配">1).viewport 适配</h4><ul class="lvl-0"><li class="lvl-2"><p>目的：为了将页面完全显示在不同手机屏幕上且不会出现滚动条</p></li><li class="lvl-2"><p>实现方案：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p><font color="#F00">微信底层就进行了 viewport 适配，即 width=device-width</font></p></li></ul><h4 id="2-rem-适配">2).rem 适配</h4><ul class="lvl-0"><li class="lvl-2"><p>目的：一套设计稿的内容在不同的机型上呈现的效果一致，根据屏幕大小不同的变化，页面中的内容也相应变化</p></li><li class="lvl-2"><p>实现方案（通过原生js实现）：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function remRefresh() &#123;</span><br><span class="line">	let clientWidth = document.documentElement.clientWidth;</span><br><span class="line">	// 将屏幕等分10份 </span><br><span class="line">	let rem = clientWidth / 10;</span><br><span class="line">	document.documentElement.style.fontSize = rem + &#x27;px&#x27;;</span><br><span class="line">	document.body.style.fontSize = &#x27;12px&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&#x27;pageshow&#x27;, () =&gt; &#123;</span><br><span class="line">	remRefresh()</span><br><span class="line">&#125;)</span><br><span class="line">// 函数防抖</span><br><span class="line">let timeoutId;</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123;</span><br><span class="line">	timeoutId &amp;&amp; clearTimeout(timeoutId);</span><br><span class="line">	timeoutId = setTimeout(() =&gt; &#123;</span><br><span class="line">		remRefresh()</span><br><span class="line">	&#125;, 300)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>实现方案（第三方库）：<code>lib-flexible + px2rem-loadelr</code></p></li></ul><h2 id="3-小程序">3.小程序</h2><h3 id="1-特点">(1).特点</h3><ul class="lvl-0"><li class="lvl-2"><p>没有 DOM</p></li><li class="lvl-2"><p>组件化开发：具备特定功能效果的代码集合</p></li><li class="lvl-2"><p>体积小，单个压缩包体积不大于2M</p></li></ul><h3 id="2-文件结构">(2).文件结构</h3><ul class="lvl-0"><li class="lvl-2"><p>wxml —— view结构</p></li><li class="lvl-2"><p>wxss —— view样式</p></li><li class="lvl-2"><p>js —— view行为</p></li><li class="lvl-2"><p>json —— 数据及配置</p></li></ul><h4 id="font-color-F00-！js中固定格式-font"><font color="#F00">！js中固定格式</font></h4><ul class="lvl-0"><li class="lvl-2"><p>注册小程序：<code>App()</code> 里面需要写个对象</p></li><li class="lvl-2"><p>注册页面：<code>Page()</code> 里面需要写个对象</p></li></ul><h3 id="3-适配方案">(3).适配方案</h3><ul class="lvl-0"><li class="lvl-2"><p>小程序适配单位：rpx（响应式像素单位）</p></li><li class="lvl-2"><p>规定任何屏幕下宽度为 <strong>750rpx</strong></p></li><li class="lvl-2"><p>小程序会根据屏幕的宽度自动计算 rpx值的大小</p></li><li class="lvl-2"><p>在 iPhone 6下：<font color="#F00">1rpx=1个物理像素=0.5px</font></p></li></ul><h3 id="4-图片路径">(4).图片路径</h3><ul class="lvl-0"><li class="lvl-2"><p>本地图片为静态资源，建议放在 <code>static/images</code> 目录下</p></li><li class="lvl-2"><p>建议使用绝对路径，当绝对路径无法使用时再使用相对路径</p></li></ul><h3 id="5-项目文件说明">(5).项目文件说明</h3><h4 id="a-app-js">a).app.js</h4><ul class="lvl-0"><li class="lvl-2"><p>在该文件中必须要有首字母大写的 <code>App</code> ，用来注册整个小程序应用</p></li></ul><h4 id="b-app-json">b).app.json</h4><ul class="lvl-0"><li class="lvl-2"><p><code>pages</code> 中哪个是第一个哪个默认就是首页，且不能加根路径</p></li><li class="lvl-2"><p><code>navigationBarBackgroundColor</code> ：导航栏背景颜色，只能使用16进制格式</p></li><li class="lvl-2"><p><code>navigationBarTextStyle</code> ：导航栏标题颜色，仅支持 <code>black</code> / <code>white</code></p></li></ul><h4 id="c-app-wxss">c).app.wxss</h4><ul class="lvl-0"><li class="lvl-2"><p>存放公共样式</p></li><li class="lvl-2"><p>小程序中只能使用 class 类</p></li><li class="lvl-2"><p>小程序会自动的为所有的页面加一个 <code>&lt;page&gt;</code> 标签，而该标签宽度指定但高度未指定，如果想要给整个页面添加背景颜色，那么需要在这里将高度设置为 100%，这样所有的页面就都可以继承它的大小了</p></li></ul><h4 id="d-index-js">d).index.js</h4><ul class="lvl-0"><li class="lvl-2"><p>在该文件中必须要有首字母大写的 <code>Page</code> ，用来注册当前页面的实例</p></li></ul><h3 id="6-编译模式">(6).编译模式</h3><ul class="lvl-0"><li class="lvl-2"><p>当我们想要同时看两个页面的显示情况时，可以<strong>自定义编译模式</strong></p></li><li class="lvl-2"><p>在开发者工具的最上方自定义一个，然后更改启动页面路径即可</p></li></ul><h2 id="4-字体图标">4.字体图标</h2><h3 id="1-介绍-2">(1).介绍</h3><ul class="lvl-0"><li class="lvl-2"><p>小程序中可以使用阿里云的 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://www.iconfont.cn/">iconfont</a> 字体图标库</p></li></ul><h3 id="2-使用方法">(2).使用方法</h3><ul class="lvl-0"><li class="lvl-2"><p>在官网选好自己需要的字体图标并加入购物车</p></li><li class="lvl-2"><p>选好之后将其添加进项目中去</p></li><li class="lvl-2"><p>在当前项目中点击 <code>Font class</code> 选项并查看在线链接生成最新代码（该代码可以在网页中直接引用，而在小程序中无法引入）</p></li><li class="lvl-2"><p>在浏览器地址栏输入该地址，将里面的内容复制到小程序的 <code>wxss</code> 文件中去</p></li><li class="lvl-2"><p>我们可以将该文件放入 <code>/static/iconfont</code> 目录下，并在全局的 <code>app.wxss</code> 中使用如下语句进行引入</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;/static/iconfont/iconfont.wxss&quot;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>如果想要使用某图标，在网站复制该图标的class名，按如下即可：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text class=&quot;iconfont icon-diantai&quot;&gt;&lt;/text&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>想要修改字体图标的样式，直接修改 <code>iconfont</code> 的样式即可</p></li></ul><h2 id="5-内网穿透">5.内网穿透</h2><ul class="lvl-0"><li class="lvl-2"><p>我们一般在做项目的时候使用的是电脑上本地的服务器，如果想要在真机上调试小程序需要使用到<strong>内网穿透</strong></p></li><li class="lvl-2"><p>推荐使用 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://u.tools/">utools</a> 工具，搜索安装<strong>内网穿透</strong>插件</p></li><li class="lvl-2"><p>按提示设置地址，修改项目的服务器配置文件即可</p></li><li class="lvl-2"><p>如果无法正常显示，可能是预览不会去发送请求，可以打开小程序的调试模式即可</p></li></ul><h2 id="6-登录流程">6.登录流程</h2><h3 id="1-收集表单项数据">(1).收集表单项数据</h3><ul class="lvl-0"><li class="lvl-2"><p>用户名，账号以及密码等</p></li></ul><h3 id="2-前端验证">(2).前端验证</h3><ul class="lvl-0"><li class="lvl-2"><p>验证用户信息（账号、密码）是否合法</p><ul class="lvl-2"><li class="lvl-4">验证不通过，提示用户，不需要发请求给后端</li><li class="lvl-4">验证通过，发请求（携带账号、密码）给服务器端</li></ul></li></ul><h3 id="3-后端验证">(3).后端验证</h3><ul class="lvl-0"><li class="lvl-2"><p>验证用户是否存在</p><ul class="lvl-2"><li class="lvl-4">用户不存在直接返回，告诉前端用户不存在</li><li class="lvl-4">用户存在需要验证密码是否正确<ul class="lvl-4"><li class="lvl-6">密码不正确返回给前端提示密码不正确</li><li class="lvl-6">密码正确返回给前端数据，提示用户登录成功（会携带用户的相关信息）</li></ul></li></ul></li></ul><h2 id="7-视口单位">7.视口单位</h2><ul class="lvl-0"><li class="lvl-2"><p>视口单位分别为：vh 和 vw</p></li><li class="lvl-2"><p>1vh = %1 的视口高度</p></li><li class="lvl-2"><p>1vw = %1 的视口宽度</p></li><li class="lvl-2"><p><code>calc()</code> 可以动态计算 css 的宽高，运算符左右两侧必须加空格，否则计算会失效</p></li></ul><h2 id="8-数据分页">8.数据分页</h2><ul class="lvl-0"><li class="lvl-2"><p>前端分页：总共接收到100条数据，每次给用户显示10条</p></li><li class="lvl-2"><p>后端分页：每发一次请求给用户显示10条数据</p></li></ul><h2 id="9-日期函数">9.日期函数</h2><ul class="lvl-0"><li class="lvl-2"><p>小程序中支持内置的日期函数用来获取当前的年月日</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 更新日期的状态</span><br><span class="line">this.setData(&#123;</span><br><span class="line">	day: new Date().getDate(),</span><br><span class="line">	month: new Date().getMonth() + 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="10-npm-包">10.npm 包</h2><h3 id="1-使用方法">(1).使用方法</h3><h4 id="1-初始化-package-json">1).初始化 package.json</h4><ul class="lvl-0"><li class="lvl-2"><p>在小程序调试器的终端中输入以下命令：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>该文件相当于整个项目的配置文件，并可初始化包名，一般只保留包名和版本号即可</p></li></ul><h4 id="2-修改小程序设置">2).修改小程序设置</h4><ul class="lvl-0"><li class="lvl-2"><p>在详情 - 本地设置中勾选 “使用npm模块”</p></li></ul><h4 id="3-下载npm包">3).下载npm包</h4><ul class="lvl-0"><li class="lvl-2"><p>在小程序调试器的终端中输入以下命令：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 包名</span><br></pre></td></tr></table></figure><h4 id="4-构建npm">4).构建npm</h4><ul class="lvl-0"><li class="lvl-2"><p>在开发工具的 工具 - 构建npm 选项，这样会将下载的包自动转化为小程序可以使用的格式，并放入指定路径</p></li><li class="lvl-2"><p>当小程序引入npm包时，该页面首先会从小程序指定npm包路径查找，查找不到会去当前文件夹内进行查找，所以如果不构建 npm 那么就会出现找不到该npm包</p></li></ul><h4 id="5-导入npm包">5).导入npm包</h4><ul class="lvl-0"><li class="lvl-2"><p>在需要导入npm的 js 文件中使用以下语句进行导入</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import 自定义名 from &#x27;包名&#x27;</span><br></pre></td></tr></table></figure><h3 id="2-常见第三方库">(2).常见第三方库</h3><h4 id="1-PubSub">1).PubSub</h4><ul class="lvl-0"><li class="lvl-2"><p>功能：用来在两个页面之间进行通信</p></li><li class="lvl-2"><p>地址：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/mroderick/PubSubJS">点击这里</a></p></li><li class="lvl-2"><p>使用 <code>npm install pubsub-js</code> 命令进行安装</p></li><li class="lvl-2"><p>关于订阅方与接收方的内容，请点击 <a href="#event">这里</a> 跳转查看</p></li></ul><h4 id="2-Moment">2).Moment</h4><ul class="lvl-0"><li class="lvl-2"><p>功能：使用JavaScript 日期处理类库来格式化时间</p></li><li class="lvl-2"><p>地址：<a target="_blank" rel="external nofollow noopener noreferrer" href="http://momentjs.cn/">点击这里</a></p></li><li class="lvl-2"><p>使用 <code>npm install moment</code> 命令进行安装</p></li><li class="lvl-2"><p>该js语法中使用的是单位是ms</p></li></ul><h4 id="3-Fly">3).Fly</h4><ul class="lvl-0"><li class="lvl-2"><p>功能：一个支持所有JavaScript运行环境的基于Promise的、支持请求转发、强大的http请求库。可以让您在多个端上尽可能大限度的实现代码复用</p></li><li class="lvl-2"><p>地址：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/wendux/fly">点击这里</a></p></li><li class="lvl-2"><p>使用 <code>npm install flyio</code> 命令进行安装</p></li><li class="lvl-2"><p>Node 中引入的方式：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const Fly=require(&quot;flyio/src/node&quot;);</span><br><span class="line">const fly=new Fly;</span><br></pre></td></tr></table></figure><h4 id="4-jsonwebtoken">4).jsonwebtoken</h4><ul class="lvl-0"><li class="lvl-2"><p>功能：可以对传输的数据进行加密解密</p></li><li class="lvl-2"><p>地址：<a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/auth0/node-jsonwebtoken">点击这里</a></p></li><li class="lvl-2"><p>使用 <code>npm install jsonwebtoken</code> 命令进行安装</p></li><li class="lvl-2"><p>Node 中引入的方式：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const jwt = require(&#x27;jsonwebtoken&#x27;);</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>加密与解密：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 加密</span><br><span class="line">const token = jwt.sign(&#123; foo: &#x27;bar&#x27; &#125;, &#x27;shhhhh&#x27;);</span><br><span class="line">// 解密</span><br><span class="line">const decoded = jwt.verify(token, &#x27;shhhhh&#x27;);</span><br><span class="line">console.log(decoded.foo)</span><br></pre></td></tr></table></figure><h2 id="11-函数节流与防抖">11.函数节流与防抖</h2><ul class="lvl-0"><li class="lvl-2"><p>使用延时定时器???</p></li></ul><h2 id="12-小程序登录">12.小程序登录</h2><ul class="lvl-0"><li class="lvl-2"><p>小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系</p></li></ul><h3 id="1-获取登录凭证">(1).获取登录凭证</h3><ul class="lvl-0"><li class="lvl-2"><p>wx.login()：使用该API进行获取，code是从成功的回调中获取到的</p></li><li class="lvl-2"><p>如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">	success: (res) =&gt; &#123;</span><br><span class="line">		let code = res.code;        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-将登录凭证发送给服务器">(2).将登录凭证发送给服务器</h3><ul class="lvl-0"><li class="lvl-2"><p>这里需要自己在个人服务器中写一个接口，然后这里调用接口即可：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let result = await request(&#x27;/getOpenId&#x27;, &#123;code&#125;);</span><br></pre></td></tr></table></figure><h2 id="13-调试错误">13.调试错误</h2><ul class="lvl-0"><li class="lvl-2"><p>当在写 js 语句时，如果发现有些地方有问题，可以在该处写一个 <code>return</code> 来阻断一下</p></li><li class="lvl-2"><p>这样该条语句下面的语句就不会执行了</p></li></ul><h1>三、框架</h1><ul class="lvl-0"><li class="lvl-2"><p>关于 框架 的详细内容请查看小程序官方<a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/reference/">文档</a></p></li></ul><h2 id="1-小程序配置">1.小程序配置</h2><h3 id="1-全局配置">(1).全局配置</h3><h4 id="1-tabBar">1).tabBar</h4><ul class="lvl-0"><li class="lvl-2"><p>可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面（需全局json文件中配置）</p></li><li class="lvl-2"><p>常用属性：</p><ul class="lvl-2"><li class="lvl-4">color：tab 上的文字默认颜色，仅支持十六进制颜色</li><li class="lvl-4">selectedColor：tab 上的文字选中时的颜色，仅支持十六进制颜色</li><li class="lvl-4">backgroundColor：tab 的背景色，仅支持十六进制颜色</li><li class="lvl-4">list：tab 的列表，最少 2 个、最多 5 个 tab</li><li class="lvl-4">position：tabBar 的位置，仅支持 <code>bottom</code> / <code>top</code></li></ul></li><li class="lvl-2"><p>**<code>&lt;list&gt;</code>**属性：</p><ul class="lvl-2"><li class="lvl-4">pagePath：页面路径，必须在 pages 中先定义</li><li class="lvl-4">text：tab 上按钮的文字</li><li class="lvl-4">iconPath：图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片</li><li class="lvl-4">selectedIconPath：选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片</li></ul></li></ul><h2 id="2-框架接口">2.框架接口</h2><h3 id="1-getAPP">(1).getAPP</h3><ul class="lvl-0"><li class="lvl-2"><p>获取到小程序全局唯一的 <code>App</code> 实例</p></li></ul><h2 id="3-wxml语法">3.wxml语法</h2><h3 id="1-数据绑定">(1).数据绑定</h3><h4 id="1-初始化数据">1).初始化数据</h4><ul class="lvl-0"><li class="lvl-2"><p>在当前页面的 js 文件中的 <strong>data</strong> 选项中</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		msg:&quot;Wrysmile的博客&quot;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="2-使用数据">2).使用数据</h4><ul class="lvl-0"><li class="lvl-2"><p>在页面模板结构中使用双大括号来使用数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;text class=&quot;userName&quot;&gt;&#123; &#123;msg&#125; &#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure><h4 id="3-修改数据">3).修改数据</h4><ul class="lvl-0"><li class="lvl-2"><p>修改数据需要在生命周期函数的 onLoad() 中进行</p></li><li class="lvl-2"><p>获取数据需要使用 <code>this.data.msg</code> 来获取</p></li><li class="lvl-2"><p>修改数据需要使用 <code>this.setData</code> 来修改，如下（回调函数可省）：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">	msg:&quot;Wrysmile的小站&quot;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>特点：</p><ul class="lvl-2"><li class="lvl-4">同步修改：this.data 的值同步修改，在非自身的钩子函数也是同步的</li><li class="lvl-4">异步更新：异步将 setData 函数用于将数据从逻辑层发送到视图层</li></ul></li></ul><h4 id="4-与Vue和React的对比">4).与Vue和React的对比</h4><h5 id="a-小程序">a).小程序</h5><ul class="lvl-0"><li class="lvl-2"><p>data 中初始化数据</p></li><li class="lvl-2"><p>修改数据：<code>this.setData()</code>（该行为始终是同步的）</p></li><li class="lvl-2"><p>数据流：</p><ul class="lvl-2"><li class="lvl-4">单向数据流：Model --&gt; View</li></ul></li></ul><h5 id="b-Vue">b).Vue</h5><ul class="lvl-0"><li class="lvl-2"><p>data 中初始化数据</p></li><li class="lvl-2"><p>修改数据：this.key = value</p></li><li class="lvl-2"><p>数据流：</p><ul class="lvl-2"><li class="lvl-4">单向数据流：Model --&gt; View</li><li class="lvl-4">实现了双向数据绑定：v-model</li></ul></li></ul><h5 id="c-React">c).React</h5><ul class="lvl-0"><li class="lvl-2"><p>state 中初始化状态数据</p></li><li class="lvl-2"><p>修改数据：<code>this.setState()</code></p><ul class="lvl-2"><li class="lvl-4">在自身的钩子函数中（componentDidMount）中是异步的</li><li class="lvl-4">在非自身的钩子函数中（定时器的回调）中是同步的</li></ul></li><li class="lvl-2"><p>数据流：</p><ul class="lvl-2"><li class="lvl-4">单向数据流：Model --&gt; View</li></ul></li></ul><h4 id="扩展：数据劫持代理">扩展：数据劫持代理</h4><ul class="lvl-0"><li class="lvl-2"><p>如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Vue数据劫持代理</span><br><span class="line">// 模拟Vue中data选项</span><br><span class="line">let data = &#123;</span><br><span class="line">  username: &#x27;curry&#x27;,</span><br><span class="line">  age: 33</span><br><span class="line">&#125;</span><br><span class="line">// 模拟组件的实例</span><br><span class="line">let _this = &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 利用Object.defineProperty()</span><br><span class="line">for(let item in data)&#123;</span><br><span class="line">  // console.log(item, data[item]);</span><br><span class="line">  Object.defineProperty(_this, item, &#123;</span><br><span class="line">    // get：用来获取扩展属性值的，当获取该属性值的时候调用get方法</span><br><span class="line">    get()&#123;</span><br><span class="line">      console.log(&#x27;get()&#x27;);</span><br><span class="line">      return data[item]</span><br><span class="line">    &#125;,</span><br><span class="line">    // set： 监视扩展属性的， 只要已修改就调用</span><br><span class="line">    set(newValue)&#123;</span><br><span class="line">      console.log(&#x27;set()&#x27;, newValue);</span><br><span class="line">      // _this.username = newValue; 千万不要在set方法中直接修改当前扩展属性的值，会出现死循环</span><br><span class="line">      data[item] = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(_this);</span><br><span class="line">// 通过Object.defineProperty的get方法添加的扩展属性不能直接对象.属性修改</span><br><span class="line">_this.username = &#x27;wade&#x27;;</span><br><span class="line">console.log(_this.username);</span><br></pre></td></tr></table></figure><h3 id="2-事件绑定">(2).事件绑定</h3><h4 id="1-冒泡事件">1).冒泡事件</h4><ul class="lvl-0"><li class="lvl-2"><p>当一个组件上的事件被触发后，该事件会向父节点传递</p></li><li class="lvl-2"><p><code>bind+事件名</code> ：该绑定不会阻止冒泡事件向上冒泡</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;goStudy&quot; bindtap=&quot;handleParent&quot;&gt;</span><br><span class="line">	&lt;text bindtap=&quot;handleChild&quot;&gt;Hello World!&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h4 id="2-非冒泡事件">2).非冒泡事件</h4><ul class="lvl-0"><li class="lvl-2"><p>当一个组件上的事件被触发后，该事件不会向父节点传递</p></li><li class="lvl-2"><p><code>catch+事件名</code> ：该绑定会阻止冒泡事件向上冒泡</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;goStudy&quot; catchtap=&quot;handleParent&quot;&gt;</span><br><span class="line">	&lt;text catchtap=&quot;handleChild&quot;&gt;Hello World!&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h4 id="3-事件回调">3).事件回调</h4><ul class="lvl-0"><li class="lvl-2"><p>对应的事件回调应该在对应页面的 js 文件中定义，且位置应该与 <code>data</code> 和 <code>生命周期函数</code> 平行</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handleParent()&#123;</span><br><span class="line">	console.log(&quot;parent&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">handleChild()&#123;</span><br><span class="line">	console.log(&quot;child&quot;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="4-事件委托">4).事件委托</h4><h5 id="a-概念">a).概念</h5><ul class="lvl-0"><li class="lvl-2"><p>将子元素的事件委托（绑定）给父元素</p></li></ul><h5 id="b-好处">b).好处</h5><ul class="lvl-0"><li class="lvl-2"><p>减少绑定的次数</p></li><li class="lvl-2"><p>后期新添加的元素也可以享用之前委托的事件</p></li></ul><h5 id="c-原理">c).原理</h5><ul class="lvl-0"><li class="lvl-2"><p>冒泡</p></li></ul><h5 id="d-触发事件的是谁">d).触发事件的是谁</h5><ul class="lvl-0"><li class="lvl-2"><p>子元素</p></li></ul><h5 id="e-如何找到触发事件的对象">e).如何找到触发事件的对象</h5><ul class="lvl-0"><li class="lvl-2"><p>event.target：绑定事件的元素不一定是触发事件的元素</p></li><li class="lvl-2"><p>event.currentTarget：要求绑定的元素一定是触发事件的元素</p></li></ul><h4 id="strong-style-color-red-拓展：事件流三阶段-strong"><strong style="color:red">拓展：事件流三阶段</strong></h4><ul class="lvl-0"><li class="lvl-2"><p>捕获：从外向内</p></li><li class="lvl-2"><p>执行目标阶段</p></li><li class="lvl-2"><p>冒泡：从内向外</p></li></ul><h4 id="strong-style-color-red-拓展：绑定事件-strong"><strong style="color:red">拓展：绑定事件</strong></h4><ul class="lvl-0"><li class="lvl-2"><p>bindtap</p></li><li class="lvl-2"><p>bindinput：表单项内容实时发生改变时触发</p></li><li class="lvl-2"><p>bindchange：表单项内容实时发生改变且失去焦点时触发</p></li></ul><h4 id="strong-style-color-red-拓展：-span-id-event-事件分类-span-strong"><strong style="color:red">拓展：<span id="event">事件分类</span></strong></h4><ul class="lvl-0"><li class="lvl-2"><p>标准DOM事件</p><ul class="lvl-2"><li class="lvl-4">事件名固定，事件由浏览器触发</li></ul></li><li class="lvl-2"><p>自定义事件</p><ul class="lvl-2"><li class="lvl-4">绑定事件<ul class="lvl-4"><li class="lvl-6">事件名</li><li class="lvl-6">事件的回调</li><li class="lvl-6">订阅方：是接收数据的一方，例如PubSub.subscribe(消息名,事件的回调)、PubSub.unsubscribr(消息名)取消订阅</li></ul></li><li class="lvl-4">触发事件<ul class="lvl-4"><li class="lvl-6">事件名</li><li class="lvl-6">提供事件参数对象，等同于原生事件的event事件</li><li class="lvl-6">发布方：是提供数据的一方，例如PubSub.publish(消息名,提供的数据)</li></ul></li></ul></li></ul><h3 id="3-列表渲染">(3).列表渲染</h3><ul class="lvl-0"><li class="lvl-2"><p><code>wx:for=&quot;&#123; &#123;array&#125; &#125;&quot;</code> （这里双大括号之间没有空格）</p><ul class="lvl-2"><li class="lvl-4">下标为 index，个体为 item</li></ul></li><li class="lvl-2"><p><code>wx:key=&quot;unique&quot;</code> 的值以两种形式提供：</p><ul class="lvl-2"><li class="lvl-4">字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变</li><li class="lvl-4">保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字<strong style="color:red">（几乎用不上）</strong></li></ul></li></ul><h4 id="为什么wx-key不使用下标index而是ID？">为什么wx:key不使用下标index而是ID？</h4><ul class="lvl-0"><li class="lvl-2"><p>因为使用下标时，当一个元素发生变化时，后面的其余元素全都需要重新计算</p></li><li class="lvl-2"><p>而使用ID时，只需要计算不同ID即可</p></li></ul><h3 id="4-条件渲染">(4).条件渲染</h3><ul class="lvl-0"><li class="lvl-2"><p>wx:if=‘条件’</p></li><li class="lvl-2"><p>wx:elif=‘条件’</p></li><li class="lvl-2"><p>wx:else</p></li></ul><h4 id="引申：动态隐藏元素">引申：动态隐藏元素</h4><ul class="lvl-0"><li class="lvl-2"><p>一般情况下使用 wx:if 来进行判断来使某元素动态显示或隐藏，但这种性能并不算好</p></li><li class="lvl-2"><p>这里可以使用 <code>hidden=&quot;&quot;</code> 来进行动态显示隐藏，这里需要一个布尔值来判断</p></li></ul><h3 id="5-生命周期">(5).生命周期</h3><ul class="lvl-0"><li class="lvl-2"><p>生命周期如下图：<br><img src="https://s3.ax1x.com/2021/02/22/yHUKM9.png" alt="mp01.png"></p></li></ul><h3 id="6-模板">(6).模板</h3><ul class="lvl-0"><li class="lvl-2"><p>模板（template），可以在模板中定义代码片段，然后在不同的地方调用</p></li><li class="lvl-2"><p>template 页面只需要 wxml 和 wxss 两个页面即可</p></li></ul><h4 id="1-定义模板">1).定义模板</h4><ul class="lvl-0"><li class="lvl-2"><p>使用 name 属性，作为模板的名字，然后在<code>&lt;template/&gt;</code>内定义代码片段</p></li></ul><h4 id="2-引入模板">2).引入模板</h4><ul class="lvl-0"><li class="lvl-2"><p>在目标页面的 wxml 中用下面语法引入页面结构</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import src=&quot;页面结构路径&quot; /&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在目标页面的 wxss 中用下面语法引入页面样式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;页面样式路径&quot;;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在需要模板的地方通过下面语法引入模板</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=&quot;name属性值&quot; data=&quot;&#123; &#123;...item&#125; &#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="3-使用模板">3).使用模板</h4><ul class="lvl-0"><li class="lvl-2"><p>使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入，如上</p></li></ul><h3 id="7-引用">(7).引用</h3><ul class="lvl-0"><li class="lvl-2"><p>wxml 提供两种文件引用方式 <code>import</code> 和 <code>include</code></p></li><li class="lvl-2"><p>wxss 提供一种文件引用方式 <code>@import &quot;&quot;</code></p></li></ul><h3 id="8-数组与对象">(8).数组与对象</h3><ul class="lvl-0"><li class="lvl-2"><p>在中括号中的是数组，在大括号中的是对象</p></li></ul><h1>四、组件</h1><ul class="lvl-0"><li class="lvl-2"><p>关于 组件 的详细内容请查看小程序官方<a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/component/">文档</a></p></li></ul><h2 id="1-swiper">1.swiper</h2><ul class="lvl-0"><li class="lvl-2"><p>滑块视图容器。其中只可放置 <code>&lt;swiper-item&gt;</code> 组件</p></li><li class="lvl-2"><p>有些属性默认为 flase，如果想要开启时需要在 <code>&lt;swiper&gt;</code> 中声明，但可以省略 true，因为只要声明了就为 true</p></li></ul><h3 id="1-常用属性">(1).常用属性</h3><ul class="lvl-0"><li class="lvl-2"><p>indicator-dots：是否显示面板指示点</p></li><li class="lvl-2"><p>indicator-color：指示点颜色</p></li><li class="lvl-2"><p>indicator-active-color：当前选中的指示点颜色</p></li><li class="lvl-2"><p>autoplay：是否自动切换</p></li><li class="lvl-2"><p>circular：是否采用衔接滑动</p></li><li class="lvl-2"><p>previous-margin：前边距，可用于露出前一项的一小部分，接受 px 和 rpx 值</p></li><li class="lvl-2"><p>next-margin：后边距，可用于露出后一项的一小部分，接受 px 和 rpx 值</p></li></ul><h2 id="2-scroll-view">2.scroll-view</h2><ul class="lvl-0"><li class="lvl-2"><p>可滚动视图区域。使用竖向滚动时，需要给 <code>&lt;croll-view&gt;</code> 一个固定高度，通过 WXSS 设置 height</p></li><li class="lvl-2"><p>如果想要设置 flex 布局，必须将 <code>&lt;croll-view&gt;</code> 中的 enable-flex 属性打开才可以生效</p></li><li class="lvl-2"><p><strong style="color:red">注意：该组件横向滚动时，也是需要给其设置高度的，否则高度会自动变大</strong></p></li></ul><h3 id="1-常用属性-2">(1).常用属性</h3><ul class="lvl-0"><li class="lvl-2"><p>enable-flex：启用 flexbox 布局</p></li><li class="lvl-2"><p>scroll-x/y：允许横/纵向滚动</p></li><li class="lvl-2"><p>scroll-into-view：设置哪个方向可滚动，则在哪个方向滚动到该元素。<strong style="color:red">注意：值应为某子元素id（id不能以数字开头）</strong></p></li><li class="lvl-2"><p>scroll-with-animation：在设置滚动条位置时使用动画过渡</p></li><li class="lvl-2"><p>refresher-enabled：开启自定义下拉刷新</p></li><li class="lvl-2"><p>refresher-triggered：设置当前下拉刷新状态，true 表示下拉刷新已经被触发，false 表示下拉刷新未被触发</p></li><li class="lvl-2"><p>bindscrolltoupper：滚动到顶部/左边时触发</p></li><li class="lvl-2"><p>bindscrolltolower：滚动到底部/右边时触发</p></li><li class="lvl-2"><p>bindrefresherrefresh：自定义下拉刷新被触发</p></li></ul><h2 id="3-video">3.video</h2><ul class="lvl-0"><li class="lvl-2"><p>bindplay：当开始/继续播放时触发play事件</p></li><li class="lvl-2"><p>object-fit：当视频大小与 video 容器大小不一致时，视频的表现形式<br>contain：包含<br>fill：填充<br>cover：覆盖</p></li><li class="lvl-2"><p>bindtimeupdate：播放进度变化时触发，<code>event.detail = &#123;currentTime, duration&#125;</code> 。触发频率 250ms 一次</p></li><li class="lvl-2"><p>bindended：当播放到末尾时触发 ended 事件</p></li></ul><h2 id="4-block">4.block</h2><ul class="lvl-0"><li class="lvl-2"><p>可以将 <code>&lt;view&gt;</code> 放在 <code>&lt;block&gt;</code> 标签中，表示块的意思，同时圈住多个元素表示一个整体</p></li><li class="lvl-2"><p>该标签在页面结构中并不会加载，所以可通过<strong>条件判断</strong>来让他显示哪个块</p></li></ul><h2 id="5-button">5.button</h2><ul class="lvl-0"><li class="lvl-2"><p>form-type：用于 form 组件，点击分别会触发 form 组件的 submit/reset 事件</p></li><li class="lvl-2"><p>type：按钮的样式类型</p></li></ul><h2 id="6-form">6.form</h2><ul class="lvl-0"><li class="lvl-2"><p>bindsubmit：携带 form 中的数据触发 submit 事件，此时需要组件中带有 name 属性</p></li></ul><h2 id="7-radio">7.radio</h2><ul class="lvl-0"><li class="lvl-2"><p>修改 <code>&lt;radio&gt;</code> 组件的大小方法：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">radio&#123;</span><br><span class="line">	transform: scale(0.7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>具体大小自行修改括号中数值，0-1以内</p></li></ul><h2 id="8-封装功能函数-组件">8.封装功能函数/组件</h2><h3 id="1-封装功能函数">(1).封装功能函数</h3><ul class="lvl-0"><li class="lvl-2"><p>功能点明确</p></li><li class="lvl-2"><p>函数内部应该保留固定代码（静态的）</p></li><li class="lvl-2"><p>将动态的数据抽取成形参，由使用者根据自身的情况动态的传入实参</p></li><li class="lvl-2"><p>一个良好的功能函数应该设置形参的默认值（ES6的形参默认值）</p></li></ul><h3 id="2-封装功能组件">(2).封装功能组件</h3><ul class="lvl-0"><li class="lvl-2"><p>功能点明确</p></li><li class="lvl-2"><p>组件内部保留静态的代码</p></li><li class="lvl-2"><p>将动态的数据抽取成 props 参数，由使用者根据自身的情况以标签属性的形式动态传入 props 数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">	msg: &#123;</span><br><span class="line">		required: true,</span><br><span class="line">		default: 默认值,</span><br><span class="line">		type: String</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>一个良好的组件应该设置组件的必要性及数据类型</p></li></ul><h3 id="3-小程序封装函数方法">(3).小程序封装函数方法</h3><ul class="lvl-0"><li class="lvl-2"><p>在根目录新建 <code>utils</code> 目录，将需要封装的函数放入该目录中</p></li><li class="lvl-2"><p>关于服务器中的配置内容，我们可以将其单独放在另一个 js 文件中，方便配置</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 配置服务器相关信息</span><br><span class="line">export default &#123;</span><br><span class="line">	host: &#x27;http://localhost:3000&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在封装好的函数中引入服务器配置文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 引入服务器配置信息</span><br><span class="line">import config from &#x27;./config&#x27;</span><br><span class="line">// 发送ajax请求</span><br><span class="line">// 为了复用，应该以模块化的思想将函数暴露出去;动态的内容应该抽取为参数</span><br><span class="line">export default (url,data=&#123;&#125;,method=&quot;GET&quot;) =&gt; &#123;</span><br><span class="line">	return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">		// new Promise 初始化 promise 实例的状态为 pending</span><br><span class="line">		wx.request(&#123;</span><br><span class="line">			// ES6 同名属性可以省略不写</span><br><span class="line">			url: config.host + url,</span><br><span class="line">			data,</span><br><span class="line">			method,</span><br><span class="line">			success: (res) =&gt; &#123;</span><br><span class="line">				// 修改promise的状态为成功状态resolved</span><br><span class="line">				resolve(res.data);</span><br><span class="line">			&#125;,</span><br><span class="line">			fail: (err) =&gt; &#123;</span><br><span class="line">				// 修改promise的状态为失败状态rejected</span><br><span class="line">				reject(err);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在需要引用该函数的文件中引入封装好的函数，并调用该函数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import request from &#x27;../../utils/request&#x27;</span><br><span class="line">····</span><br><span class="line">onLoad: async function (options) &#123;</span><br><span class="line">	// 使用 await 等待异步任务的结果，且需要搭配 async 来使用</span><br><span class="line">	let result = await request(&#x27;/banner&#x27;,&#123;type:2&#125;);</span><br><span class="line">	console.log(&#x27;结果数据为：&#x27;,result);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="9-自定义组件">9.自定义组件</h2><ul class="lvl-0"><li class="lvl-2"><p>自定义组件可以将相同的结构提取出来，提高复用率</p></li></ul><h3 id="1-参数">(1).参数</h3><ul class="lvl-0"><li class="lvl-2"><p>我们主要用到 <code>properties</code> 和 <code>data</code> 两个参数</p></li><li class="lvl-2"><p><code>properties</code>：组件的对外属性，是属性名到属性设置的映射表，其定义有：</p><ul class="lvl-2"><li class="lvl-4">type： 属性的类型</li><li class="lvl-4">optionalTypes：属性的类型（可以指定多个）</li><li class="lvl-4">value：属性的初始值</li></ul></li><li class="lvl-2"><p><code>data</code>：组件的内部数据，和 <code>properties</code> 一同用于组件的模板渲染</p></li></ul><h3 id="2-方法">(2).方法</h3><ul class="lvl-0"><li class="lvl-2"><p>在项目根目录新建 <code>components</code> 目录，并在其中创建所需的组件文件夹，在文件夹右键<strong>新建component</strong></p></li><li class="lvl-2"><p>在主页面的 json 文件中注册该组件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;usingComponents&quot;: &#123;</span><br><span class="line">		&quot;NavHeader&quot;:&quot;/components/NavHeader/NavHeader&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>将页面中所需自定义部分的结构和样式提取到组件相应文件中去</p></li><li class="lvl-2"><p>组件一般是复用的，所以其中内容我们应该用变量的形式</p></li><li class="lvl-2"><p>在组件的 js 文件中的 <code>properties</code> 中给这些变量设置type和value，如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">	title: &#123;</span><br><span class="line">		type: String,</span><br><span class="line">		value: &quot;title默认值&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	nav: &#123;</span><br><span class="line">		type: String,</span><br><span class="line">		value: &quot;nav默认值&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在主页面中以标签名（即json文件中设置的属性值）的方式引入设置好的组件，并设置相应变量值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavHeader title=&quot;推荐歌曲&quot; nav=&quot;为你精心推荐&quot;&gt;&lt;/NavHeader&gt;</span><br></pre></td></tr></table></figure><h1>五、API</h1><ul class="lvl-0"><li class="lvl-2"><p>关于 API 的详细内容请查看小程序官方<a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/api/">文档</a></p></li><li class="lvl-2"><p>小程序的全局对象是 <code>wx</code></p></li></ul><h2 id="1-路由跳转">1.路由跳转</h2><ul class="lvl-0"><li class="lvl-2"><p>可以从当前页面跳转到另一个页面</p></li><li class="lvl-2"><p>使用路由跳转的相关函数时，路径需要使用<strong>绝对路径</strong></p></li></ul><h3 id="1-路由传参">(1).路由传参</h3><ul class="lvl-0"><li class="lvl-2"><p>原生小程序中路由传参，对参数的长度有限制，如果参数长度过长会自动截取掉</p></li></ul><h2 id="2-本地存储">2.本地存储</h2><ul class="lvl-0"><li class="lvl-2"><p>将数据存储在本地缓存中指定的 key 中</p></li><li class="lvl-2"><p>语法：<code>wx.setStorage() || wx.setStorageSync() || ···</code></p></li><li class="lvl-2"><p>注意：</p><ul class="lvl-2"><li class="lvl-4">建议存储的数据为 json 数据</li><li class="lvl-4">单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB</li><li class="lvl-4">属于永久存储，同 H5 的 localStorage 一样</li></ul></li></ul><h2 id="3-界面">3.界面</h2><h3 id="1-交互-——-显示等待提示框">(1).交互 —— 显示等待提示框</h3><ul class="lvl-0"><li class="lvl-2"><p>语法：wx.showLoading()</p></li><li class="lvl-2"><p>需主动调用 wx.hideLoading 才能关闭提示框</p></li></ul><h3 id="2-交互-——-显示模态对话框">(2).交互 —— 显示模态对话框</h3><ul class="lvl-0"><li class="lvl-2"><p>语法：wx.showModal()</p></li><li class="lvl-2"><p>content：提示的内容</p></li><li class="lvl-2"><p>其 success 的回调中 confirm 为 true 时，表示用户点击了确定按钮</p></li></ul><h3 id="3-导航栏-——-动态设置当前页面的标题">(3).导航栏 —— 动态设置当前页面的标题</h3><ul class="lvl-0"><li class="lvl-2"><p>语法：wx.setNavigationBarTitle(Object object)</p></li></ul><h2 id="4-媒体">4.媒体</h2><h3 id="1-背景音频">(1).背景音频</h3><ul class="lvl-0"><li class="lvl-2"><p>BackgroundAudioManager 实例，可通过 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html">wx.getBackgroundAudioManager</a> 获取</p></li><li class="lvl-2"><p>要想播放音乐，必须设置该实例的 title 与 src 属性</p></li><li class="lvl-2"><p>若需要小程序在退到后台后继续播放音频，需要在 app.json 中配置 requiredBackgroundModes 属性</p></li><li class="lvl-2"><p>BackgroundAudioManager 实例，可通过 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html">wx.getBackgroundAudioManager</a> 获取</p><ul class="lvl-2"><li class="lvl-4">BackgroundAudioManager.onPlay(function callback)监听背景音频播放事件</li><li class="lvl-4">BackgroundAudioManager.onPause(function callback)监听背景音频暂停事件</li><li class="lvl-4">BackgroundAudioManager.onStop(function callback)监听背景音频停止事件</li><li class="lvl-4">BackgroundAudioManager.onTimeUpdate(function callback)监听背景音频播放进度更新事件，只有小程序在前台时会回调</li></ul></li></ul><h1>六、动画</h1><h2 id="1-触摸滑动回弹">1.触摸滑动回弹</h2><h3 id="1-事件绑定">(1).事件绑定</h3><ul class="lvl-0"><li class="lvl-2"><p>bindtouchstart：手指触摸时</p></li><li class="lvl-2"><p>bindtouchmove：手指移动时</p></li><li class="lvl-2"><p>bindtouchend：手指离开时</p></li></ul><h3 id="2-计算手指移动的距离">(2).计算手指移动的距离</h3><ul class="lvl-0"><li class="lvl-2"><p>在js文件中初始化三个值为0<br>手指起始的坐标：startY<br>手指移动的坐标：moveY<br>手指移动的距离：moveDistance</p></li><li class="lvl-2"><p>获取手指的起始坐标需要用到 <code>event</code> 对象</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">handleTouchStart(event)&#123;</span><br><span class="line">	// 拿到第一个手指的纵向起始坐标</span><br><span class="line">	startY = event.touches[0].clientY;</span><br><span class="line">&#125;,</span><br><span class="line">handleTouchMove(event)&#123;</span><br><span class="line">	moveY = event.touches[0].clientY;</span><br><span class="line">	moveDistance = moveY - startY;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="3-设置滑动效果">(3).设置滑动效果</h3><ul class="lvl-0"><li class="lvl-2"><p>这里可以使用 CSS3 的 <code>transform</code></p></li><li class="lvl-2"><p>在 data 中初始化数据，然后让其动态更新translateY的值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">	// 使用ES6的模板字符串，因为需要写变量值</span><br><span class="line">	coverTransform: `translateY($ &#123;moveDistance&#125;rpx)`,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>然后在手指松开时设置过渡让其恢复原样，并在手指点击时清除过渡效果</p></li></ul><h2 id="2-导航过渡效果">2.导航过渡效果</h2><ul class="lvl-0"><li class="lvl-2"><p>导航一般使用 <code>&lt;scroll-view&gt;</code> 来编写，当切换导航时，应当使该标签自动滑动到第一位</p></li><li class="lvl-2"><p>使用 scroll-into-view 来使其滚动</p></li><li class="lvl-2"><p>使用 scroll-with-animation 来设置滚动的过渡效果</p></li></ul><h2 id="3-留声机磁盘旋转效果">3.留声机磁盘旋转效果</h2><ul class="lvl-0"><li class="lvl-2"><p>使用 <code>animation</code> 来设置旋转动画</p></li><li class="lvl-2"><p>使用 <code>animation-dely</code> 来设置动画延迟</p></li><li class="lvl-2"><p>使用 <code>@keyframes</code> 来设置动画桢</p><ul class="lvl-2"><li class="lvl-4">from to：使用于简单的动画，只有起始帧和结束帧</li><li class="lvl-4">百分比：多用于复杂的动画，动画不止两帧</li></ul></li><li class="lvl-2"><p>使用 <code>transform</code> 来设置旋转角度</p></li></ul><h1>七、分包</h1><h2 id="1-介绍-3">1.介绍</h2><ul class="lvl-0"><li class="lvl-2"><p>小程序要求压缩包体积不能大于2M，否则无法发布，而实际开发中小程序体积如果大于2M就需要使用分包机制进行发布上传</p></li><li class="lvl-2"><p>作用：分包后可解决2M限制，并且能分包加载内容，提高性能</p></li><li class="lvl-2"><p>官方文档点击 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html">这里</a></p></li></ul><h2 id="2-分包形式">2.分包形式</h2><h3 id="1-常规分包">(1).常规分包</h3><ul class="lvl-0"><li class="lvl-2"><p>开发者通过在 <code>app.json</code> 中的 subpackages 字段声明项目分包结构</p></li><li class="lvl-2"><p>特点：</p><ul class="lvl-2"><li class="lvl-4">加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容</li><li class="lvl-4">分包的页面可以访问主包的文件，数据，图片等资源</li></ul></li><li class="lvl-2"><p>适用于：通常放置启动页/tabBar页面</p></li></ul><h3 id="2-独立分包">(2).独立分包</h3><ul class="lvl-0"><li class="lvl-2"><p>只要在 <code>app.json</code> 中的 subpackages 字段中设置 independent 为 true即可</p></li><li class="lvl-2"><p>特点：</p><ul class="lvl-2"><li class="lvl-4">独立分包可单独访问分包的内容，不需要下载主包</li><li class="lvl-4">独立分包不能依赖主包或者其他包的内容</li></ul></li><li class="lvl-2"><p>适用于：通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包，如：临时加的广告页或活动页</p></li></ul><h3 id="3-分包预下载">(3).分包预下载</h3><ul class="lvl-0"><li class="lvl-2"><p>配置：</p><ul class="lvl-2"><li class="lvl-4">在 <code>app.json</code> 中设置 preloadRule 选项</li><li class="lvl-4">语法：<code>key(页面路径) : &#123; packages: [预下载的包名 || 预下载的包的根路径] &#125;</code></li></ul></li><li class="lvl-2"><p>特点：</p><ul class="lvl-2"><li class="lvl-4">在加载当前包的时候可以设置预下载其他的包</li><li class="lvl-4">缩短用户等待时间，提高用户体验</li></ul></li></ul><h1>八、上传</h1><h2 id="1-注意">1.注意</h2><ul class="lvl-0"><li class="lvl-2"><p>上传正式版本时，一定要记得取消<strong>不校验合法域名</strong>的勾选，并将自己的外网域名添加到小程序的后台中</p></li><li class="lvl-2"><p>上传正式版本之前一定要进行本机测试</p></li></ul><h2 id="2-版本命名规则">2.版本命名规则</h2><ul class="lvl-0"><li class="lvl-2"><p>1.1.0</p><ul class="lvl-2"><li class="lvl-4">第一位代表大版本更新或迭代</li><li class="lvl-4">第二位代表重要功能的更新</li><li class="lvl-4">第三位代表最小的功能，如修补bug、修复补丁、进行局部优化之类的</li></ul></li></ul><h2 id="3-提交审核">3.提交审核</h2><ul class="lvl-0"><li class="lvl-2"><p>从小程序开发工具上传以后并不会上线</p></li><li class="lvl-2"><p>需要去小程序后台管理网站中进行<strong>提交审核</strong></p></li></ul><h1>九、云开发</h1><ul class="lvl-0"><li class="lvl-2"><p>关于<strong>云开发</strong>的详细内容请查看小程序官方<a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">文档</a></p></li></ul><h2 id="0-区分this">0.区分this</h2><ul class="lvl-0"><li class="lvl-2"><p><code>.onLoad()</code> 中的 this 指向的是这个页面，即 page</p></li><li class="lvl-2"><p><code>.get()</code> 中的成功回调中的 this 为这个成功回调函数，即 function</p></li><li class="lvl-2"><p><code>.then()</code> 中的回调中的 this 指向的是这个页面，即 page</p></li></ul><h3 id="strong-style-color-red-如何将-get-中的this指向页面？-strong"><strong style="color:red">如何将.get()中的this指向页面？</strong></h3><ul class="lvl-0"><li class="lvl-2"><p>如果想要在 <code>.get()</code> 的回调函数中获取到全局 this，则需要使用中间变量来获取</p></li><li class="lvl-2"><p>在 <code>.onLoad()</code> 中使用如下语句来获取到 this</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let that = this;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在 <code>.get()</code> 的成功回调中使用如下语句来更新 data 中的数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">that.setData(&#123;</span><br><span class="line">	xxx: xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="1-数据库">1.数据库</h2><h3 id="0-权限">(0).权限</h3><ul class="lvl-0"><li class="lvl-2"><p><strong style="color:red">读取、操作数据库时，必须修改 云开发-数据库-数据权限 中为第一个选项，否则无法读取到集合中的内容</strong></p></li></ul><h3 id="1-初始化">(1).初始化</h3><ul class="lvl-0"><li class="lvl-2"><p>引入数据库</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 引入默认环境的数据库</span><br><span class="line">const db = wx.cloud.database()</span><br><span class="line">// 引入其他环境的数据库</span><br><span class="line">const testDB = wx.cloud.database(&#123;</span><br><span class="line">  env: &#x27;test&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>引入数据库中的集合</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const todos = db.collection(&#x27;todos&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-查询">(2).查询</h3><ul class="lvl-0"><li class="lvl-2"><p>获取某个集合中的数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&#x27;todos&#x27;).get(&#123;</span><br><span class="line">	success: (res) =&gt; &#123;</span><br><span class="line">		console.log(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>获取某个集合中某个id的数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).get(&#123;</span><br><span class="line">	success: (res) =&gt; &#123;</span><br><span class="line">		console.log(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="解决多层成功回调嵌套">!解决多层成功回调嵌套</h4><ul class="lvl-0"><li class="lvl-2"><p>这里建议使用 <strong>ES6</strong> 的 promise</p></li><li class="lvl-2"><p>具体执行如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).get().then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">	console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>then() 为成功的回调，catch() 为失败的回调</p></li></ul><h4 id="查询指令">!查询指令</h4><ul class="lvl-0"><li class="lvl-2"><p><code>.doc(&quot;&quot;)</code>：只通过id来进行查询</p></li><li class="lvl-2"><p><code>.where(&#123;&#125;)</code>：可通过各个属性进行查询</p></li><li class="lvl-2"><p><code>.count()</code>：查询数据库集合中的数据个数</p></li><li class="lvl-2"><p><code>.watch()</code>：监听数据库集合中的数据变化，需要使用 <code>onChange()</code> 和 <code>onError()</code> 属性来返回成功与失败的回调</p><ul class="lvl-2"><li class="lvl-4">其中 res 返回的 docChanges 代表改变的数据、docs 代表数据库中最新的数据</li></ul></li><li class="lvl-2"><p><code>.limit()</code>：指定查询结果集数量上限（小程序端默认及最大上限为 20，在云函数端默认及最大上限为 1000）</p></li><li class="lvl-2"><p><code>.orderBy()</code>：指定查询排序条件，参数一为需要排序的属性，参数二中定义顺序（asc）、逆序（desc）</p></li><li class="lvl-2"><p><code>.skip()</code>：指定查询返回结果时从指定序列后的结果开始返回，常用于分页</p></li><li class="lvl-2"><p><code>.field()</code>：指定返回结果中记录需返回的字段</p></li></ul><h3 id="3-添加">(3).添加</h3><h4 id="a-普通添加">a).普通添加</h4><ul class="lvl-0"><li class="lvl-2"><p>代码如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).add(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		title: &quot;我是新添加的&quot;,</span><br><span class="line">		author: &quot;张三&quot;,</span><br><span class="line">		content: &quot;法外狂徒&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	// 成功的回调</span><br><span class="line">	console.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="b-表单提交添加">b).表单提交添加</h4><ul class="lvl-0"><li class="lvl-2"><p>方法一：定义相同变量来进行数据添加</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let title = res.detail.value.title;</span><br><span class="line">let author = res.detail.value.author;</span><br><span class="line">let content = res.detail.value.contebbbb//nt;</span><br><span class="line">db.collection(&quot;demolist&quot;).add(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		title: title,</span><br><span class="line">	bb	author: author,</span><br><span class="line">		content: content</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>方法二：通过ES6的解构赋值来进行数据添加</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let &#123;title,author,content&#125; = res.detail.value;</span><br><span class="line">db.collection(&quot;demolist&quot;).add(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		title,</span><br><span class="line">		author,</span><br><span class="line">		content</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>方法三：通过同名对象来进行数据提交（此方法必须保证数据库中对象名和表单中的name属性值相同）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let detailValue = res.detail.value;</span><br><span class="line">db.collection(&quot;demolist&quot;).add(&#123;</span><br><span class="line">	data: detailValue</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-更新">(4).更新</h3><ul class="lvl-0"><li class="lvl-2"><p>通过 <code>.update()</code> 来更新：只更新对应数据的某一项（可以使用where进行查询）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).where(&#123;</span><br><span class="line">	author: &quot;Wrysmile&quot;</span><br><span class="line">&#125;).update(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		author: &quot;wrysmile&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>通过 <code>.set()</code> 来更新：直接将对应数据覆盖掉所有内容（不可以使用where进行查询）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).doc(&quot;b00064a7606af40c0d563c370374ae1f&quot;).set(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		author: &quot;wrysmile&quot;,</span><br><span class="line">		title: &quot;通过set设置的标题&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-删除">(5).删除</h3><ul class="lvl-0"><li class="lvl-2"><p>通过 <code>.remove()</code> 来删除：小程序端只可以删除一条数（不可以使用where进行查询）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;)</span><br><span class="line">  .doc(inputValue)</span><br><span class="line">  .remove()</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">		console.log(res);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="6-command">(6).command</h3><ul class="lvl-0"><li class="lvl-2"><p>数据库操作符，通过 <code>db.command</code> 获取</p></li></ul><h4 id="a-定义">a).定义</h4><ul class="lvl-0"><li class="lvl-2"><p>一般在定义数据库的时候就顺便定义command指令</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const db = wx.cloud.database();</span><br><span class="line">const _ = db.command;</span><br></pre></td></tr></table></figure><h4 id="b-逻辑操作符">b).逻辑操作符</h4><ul class="lvl-0"><li class="lvl-2"><p>查询：</p><ul class="lvl-2"><li class="lvl-4"><code>.and()</code>：用于表示逻辑 “与” 的关系，表示需同时满足多个查询筛选条件</li><li class="lvl-4"><code>.or()</code>：用于表示逻辑 “或” 的关系，表示需同时满足多个查询筛选条件</li><li class="lvl-4"><code>.not()</code>：用于表示逻辑 “非” 的关系，表示需不满足指定的条件</li><li class="lvl-4"><code>.nor()</code>：用于表示逻辑 “都不” 的关系，表示需不满足指定的所有条件</li></ul></li></ul><h4 id="c-比较操作符">c).比较操作符</h4><ul class="lvl-0"><li class="lvl-2"><p>查询：</p><ul class="lvl-2"><li class="lvl-4"><code>.eq()</code>：表示字段等于某个值，可接收 <code>number</code>, <code>boolean</code>, <code>string</code>, <code>object</code>, <code>array</code>, <code>Date</code></li><li class="lvl-4"><code>.neq()</code>：表示字段不等于某个值，可接收 <code>number</code>, <code>boolean</code>, <code>string</code>, <code>object</code>, <code>array</code>, <code>Date</code></li><li class="lvl-4"><code>.lt/gt()</code>：表示需小于/大于指定值，可以传入 <code>Date</code> 对象用于进行日期比较</li><li class="lvl-4"><code>.lte/gte()</code>：表示需小于/大于或等于指定值，可以传入 <code>Date</code> 对象用于进行日期比较</li><li class="lvl-4"><code>.in/nin()</code>：表示要求值在/不在给定的数组内</li></ul></li></ul><h4 id="d-字段操作符">d).字段操作符</h4><ul class="lvl-0"><li class="lvl-2"><p>查询：</p><ul class="lvl-2"><li class="lvl-4"><code>.exists()</code>：判断字段是否存在</li></ul></li><li class="lvl-2"><p>更新：</p><ul class="lvl-2"><li class="lvl-4"><code>.set()</code>：用于设定字段等于指定值</li><li class="lvl-4"><code>.remove()</code>：用于表示删除某个字段</li><li class="lvl-4"><code>.inc()/mul()</code>：原子操作，用于指示字段自增/自乘某个值</li><li class="lvl-4"><code>.min()/max()</code>：给定一个值，只有该值小于/大于字段当前值才进行更新</li><li class="lvl-4"><code>.rename()</code>：字段重命名<ul class="lvl-4"><li class="lvl-6">如果需要对嵌套深层的字段做重命名，需要用点路径表示法</li><li class="lvl-6">不能对嵌套在数组里的对象的字段进行重命名</li></ul></li></ul></li></ul><h4 id="e-数组操作符">e).数组操作符</h4><ul class="lvl-0"><li class="lvl-2"><p>查询：</p><ul class="lvl-2"><li class="lvl-4"><code>.all()</code>：用于数组字段的查询筛选条件，要求数组字段中包含给定数组的所有元素</li><li class="lvl-4"><code>.elemMatch()</code>：用于数组字段的查询筛选条件，要求数组中包含至少一个满足 <code>elemMatch</code> 给定的所有条件的元素</li><li class="lvl-4"><code>.size()</code>：用于数组字段的查询筛选条件，要求数组长度为给定值</li></ul></li><li class="lvl-2"><p>更新：</p><ul class="lvl-2"><li class="lvl-4"><code>.push()</code>：对一个值为数组的字段，往数组添加一个或多个值；若字段原为空，则创建该字段并设数组为传入值</li><li class="lvl-4"><code>.pop()</code>：对一个值为数组的字段，将数组尾部元素删除</li><li class="lvl-4"><code>.unshift()</code>：对一个值为数组的字段，往数组头部添加一个或多个值；若字段原为空，则创建该字段并设数组为传入值</li><li class="lvl-4"><code>.shift()</code>：对一个值为数组的字段，将数组头部元素删除</li><li class="lvl-4"><code>.pull()</code>：给定一个值或一个查询条件，将数组中所有匹配给定值或查询条件的元素都移除掉</li><li class="lvl-4"><code>.pullAll()</code>：给定一个值或一个查询条件，将数组中所有匹配给定值的元素都移除掉。跟 <code>pull</code> 的差别在于只能指定常量值、传入的是数组</li><li class="lvl-4"><code>.addToSet()</code>：原子操作，给定一个或多个元素，除非数组中已存在该元素，否则添加进数组</li></ul></li></ul><h2 id="2-云函数">2.云函数</h2><ul class="lvl-0"><li class="lvl-2"><p>我们一般将调用数据库的操作放在云函数中，实现前后端分离</p></li><li class="lvl-2"><p>优势：突破小程序端只能返回20条数据的限制，最大支持100条数据</p></li></ul><h3 id="1-云函数调用数据库">(1).云函数调用数据库</h3><ul class="lvl-0"><li class="lvl-2"><p>在 <code>cloud.init()</code> 后面定义数据库</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 此时这里就不需要使用wx.了</span><br><span class="line">const db = cloud.database();</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在入口函数中返回数据库的请求</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里使用ES6的promise语法</span><br><span class="line">return await db.collection(&quot;demolist&quot;).get()</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在需要调用数据库的页面的onload中调用：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">	name: &quot;getData&quot;,</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-前端与云函数传递数据">(2).前端与云函数传递数据</h3><ul class="lvl-0"><li class="lvl-2"><p>前端是在调用云函数方法的 data 属性中传递需要给云函数的值</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">	name: &quot;getData&quot;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		num: 3</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>云函数则通过 event 来接收前端传送来的数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let num = event.num;</span><br><span class="line">return await db.collection(&quot;demolist&quot;).limit(num).get()</span><br></pre></td></tr></table></figure><h3 id="3-修改数据-2">(3).修改数据</h3><ul class="lvl-0"><li class="lvl-2"><p>小程序端只能创建数据的用户修改本条数据</p></li><li class="lvl-2"><p>而云函数端拥有最高权限，无论是谁都可以修改别人或者自己的数据</p></li></ul><h2 id="3-云存储">3.云存储</h2><h3 id="0-选择图片">(0).选择图片</h3><ul class="lvl-0"><li class="lvl-2"><p>上传文件之前需要用户自行选择本地文件来进行上传</p></li><li class="lvl-2"><p>使用 <code>wx.chooseImage()</code> API 来调用系统文件夹或者相册，属性有：</p><ul class="lvl-2"><li class="lvl-4">count：最多可以选择的图片张数</li><li class="lvl-4">sizeType：所选的图片的尺寸</li><li class="lvl-4">sourceType：选择图片的来源</li><li class="lvl-4">success：成功的回调函数</li></ul></li><li class="lvl-2"><p>使用该 API 上传图片时会返回一个临时链接，该链接无法在浏览器中打开，只用作上传作用</p></li></ul><h3 id="1-上传文件">(1).上传文件</h3><h4 id="a-小程序端">a).小程序端</h4><ul class="lvl-0"><li class="lvl-2"><p><code>wx.cloud.uploadFile()</code>：将本地资源上传至云存储空间，如果上传至同一路径则是覆盖写</p></li><li class="lvl-2"><p>属性：</p><ul class="lvl-2"><li class="lvl-4">cloudPath：云存储路径</li><li class="lvl-4">filePath：要上传文件资源的路径</li><li class="lvl-4">success：成功回调</li></ul></li></ul><h4 id="b-云函数端">b).云函数端</h4><ul class="lvl-0"><li class="lvl-2"><p><code>uploadFile()</code>：将本地资源上传至云存储空间，如果上传至同一路径则是覆盖</p></li><li class="lvl-2"><p>属性：</p><ul class="lvl-2"><li class="lvl-4">cloudPath：云存储路径</li><li class="lvl-4">fileContent：要上传文件的内容</li></ul></li></ul><h3 id="2-文件下载地址">(2).文件下载地址</h3><ul class="lvl-0"><li class="lvl-2"><p>当文件传入云开发存储后，可以点击文件查看相关信息</p></li><li class="lvl-2"><p>其中有个下载地址，可以直接预览文件</p><ul class="lvl-2"><li class="lvl-4">如果整条链接都复制，则文件有一定的有效期</li><li class="lvl-4">如果只复制问好前面的，则文件为永久有效</li></ul></li></ul><h2 id="4-问题集合">4.问题集合</h2><h3 id="1-Environment-not-found">(1).Environment not found</h3><ul class="lvl-0"><li class="lvl-2"><p>此问题一般出现在部署云函数时多个云环境共存导致的无法找到当前云环境</p></li><li class="lvl-2"><p>解决办法有如下两种：</p></li></ul><h4 id="a-云函数中指定当前云环境">a).云函数中指定当前云环境</h4><ul class="lvl-0"><li class="lvl-2"><p>在云函数中按如下进行当前环境的设置</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cloud.init(&#123;</span><br><span class="line">	env: &#x27;环境id&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>缺点：当切换云环境时，需要手动将这里的环境id进行更改</p></li></ul><h4 id="b-使用常量动态获取当前云环境（推荐）">b).使用常量动态获取当前云环境（推荐）</h4><ul class="lvl-0"><li class="lvl-2"><p>使用 <code>DYNAMIC_CURRENT_ENV</code> 常量值时，后续的 API 请求会自动请求当前所在环境的云资源</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cloud.init(&#123;</span><br><span class="line">	env: cloud.DYNAMIC_CURRENT_ENV</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1>十、基础案例</h1><h2 id="0-页面跳转并携带数据">0.页面跳转并携带数据</h2><h3 id="1-发送页面">(1).发送页面</h3><ul class="lvl-0"><li class="lvl-2"><p>在A页面中可以通过 <code>data-xx</code> 来设置需要传递的值</p></li><li class="lvl-2"><p>而上面设置的值可以在函数的 <code>res.currentTarget.dataset</code> 中获取到</p></li><li class="lvl-2"><p>然后在跳转页面的 API 中将URL以如下形式进行连接：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">	url: &#x27;/pages/demo-2/demo-2?title=&#x27; + res.currentTarget.dataset.title,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-接收页面">(2).接收页面</h3><ul class="lvl-0"><li class="lvl-2"><p>在B页面中的 onLoad() 函数中可以通过 <code>options.title</code> 来获取到A页面传送来的数据，然后渲染到页面即可</p></li></ul><h2 id="1-用户信息">1.用户信息</h2><h3 id="1-获取用户信息">(1).获取用户信息</h3><h4 id="1-用户未授权（首次登陆）">1).用户未授权（首次登陆）</h4><ul class="lvl-0"><li class="lvl-2"><p>所有需要调用的数据都需要在 data 中初始化，所以在 data 中添加 <code>userInfo:&#123; &#125;,</code></p></li><li class="lvl-2"><p>使用 <code>&lt;button&gt;</code> 组件，该组件有个 <code>open-type</code> 属性可以设置微信开放能力，该属性中的 <code>getUserInfo</code> 可以获取到用户信息，并且可通过 <code>bindgetuserinfo</code> 回调来取得信息，即：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;handleGetUserInfo&quot;&gt;授权&lt;/button&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>进行 <code>handleGetUserInfo</code> 回调函数的编写</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 获取用户基本信息</span><br><span class="line">handleGetUserInfo(res)&#123;</span><br><span class="line">	if(res.detail.userInfo)&#123;</span><br><span class="line">		// 修改 userInfo的状态数据</span><br><span class="line">		this.setData(&#123;</span><br><span class="line">			userInfo : res.detail.userInfo,</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>首页动态获取用户名和头像，变量需要使用双大括号括住</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;image src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; class=&quot;avatarUrl&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;text class=&quot;userName&quot;&gt;&#123; &#123;userInfo.nickName&#125; &#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure><h4 id="2-用户已授权（再次登陆）">2).用户已授权（再次登陆）</h4><ul class="lvl-0"><li class="lvl-2"><p>使用 API 中的开放接口 <code>wx.getUserInfo</code> 来获取用户信息，且应该在页面加载时就获取到，所以需要写在 <code>onload()</code> 中</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">	// 授权以后获取用户的信息</span><br><span class="line">	wx.getUserInfo(&#123;</span><br><span class="line">		// 这里使用箭头函数时 this可以指向当前页面</span><br><span class="line">		success: (res) =&gt; &#123;</span><br><span class="line">			// 更新用户信息</span><br><span class="line">			this.setData(&#123;</span><br><span class="line">				userInfo : res.userInfo,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		fail: (err) =&gt; &#123;</span><br><span class="line">			console.log(err);</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="3-头像与按钮的隐藏">3).头像与按钮的隐藏</h4><ul class="lvl-0"><li class="lvl-2"><p>用户名、头像和按钮是互斥关系，所以需要使用条件渲染</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;image wx:if=&quot;&#123; &#123;userInfo.avatarUrl&#125; &#125;&quot; src=&quot;&#123; &#123;userInfo.avatarUrl&#125; &#125;&quot; class=&quot;avatarUrl&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;button wx:else open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;handleGetUserInfo&quot;&gt;授权&lt;/button&gt;</span><br><span class="line">&lt;text wx:if=&quot;&#123; &#123;userInfo.nickName&#125; &#125;&quot; class=&quot;userName&quot;&gt;&#123; &#123;userInfo.nickName&#125; &#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>修改按钮样式，使其占据原本头像位置，当授权后不会显示很突兀</p></li></ul><h3 id="2-获取用户cookie">(2).获取用户cookie</h3><ul class="lvl-0"><li class="lvl-2"><p>获取cookie需要在用户登录请求时获取，将cookie存储在本地</p></li><li class="lvl-2"><p>在发请求时增加 header 字段，并在其中读取本地存储的cookie（为了防止用户未登录时报错，应该使用三元运算符进行判断，cookie为空时将其设置为空串）</p></li></ul><h2 id="2-轮播图">2.轮播图</h2><h3 id="1-放置轮播图容器">(1).放置轮播图容器</h3><ul class="lvl-0"><li class="lvl-2"><p>在小程序中使用 <code>&lt;swiper&gt;</code> 组件来制作轮播图，其中只可放置 <code>&lt;swiper-item&gt;</code> 组件，而文字和图片可以放在 <code>&lt;swiper-item&gt;</code> 组件中</p></li></ul><h3 id="2-设置容器样式">(2).设置容器样式</h3><ul class="lvl-0"><li class="lvl-2"><p>根据需求设置容器大小，并将图像的长宽设置为父元素的100%</p></li></ul><h3 id="3-设置组件属性">(3).设置组件属性</h3><ul class="lvl-0"><li class="lvl-2"><p><code>&lt;swiper&gt;</code> 组件有很多属性，如果想要面板指示点的相关设置，直接去开发者文档中找</p></li></ul><h2 id="3-文本溢出隐藏">3.文本溢出隐藏</h2><ul class="lvl-0"><li class="lvl-2"><p>当单行或者多行文本溢出某个容器时，我们一般将溢出部分隐藏起来，并在后面以省略号展示</p></li></ul><h3 id="1-单行文本溢出">(1).单行文本溢出</h3><ul class="lvl-0"><li class="lvl-2"><p>单行文本溢出时的解决办法：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 转换为块元素 */</span><br><span class="line">display: block;</span><br><span class="line">/* 规定段落中的文本不进行换行，属性值为文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止 */</span><br><span class="line">white-space: nowrap;</span><br><span class="line">/* 将溢出部分隐藏 */</span><br><span class="line">overflow: hidden;</span><br><span class="line">/* 规定当文本溢出包含元素时发生的事情，属性值为显示省略符号来代表被修剪的文本 */</span><br><span class="line">text-overflow: ellipsis;</span><br></pre></td></tr></table></figure><h3 id="2-多行文本溢出">(2).多行文本溢出</h3><ul class="lvl-0"><li class="lvl-2"><p>多行文本溢出时的解决办法：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">/* 设置对齐模式 */</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">/* 设置盒子内容的行数 */</span><br><span class="line">-webkit-line-clamp: 2;</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br></pre></td></tr></table></figure><h2 id="4-前后端交互">4.前后端交互</h2><ul class="lvl-0"><li class="lvl-2"><p>使用 API 来进行前后端交互，语法：<code>wx.request()</code></p></li><li class="lvl-2"><p>发起请求可以在生命周期函数的 onLoad 和 onReady 中填写</p></li><li class="lvl-2"><p>注意点：</p><ul class="lvl-2"><li class="lvl-4">协议必须是 https 协议</li><li class="lvl-4">一个接口最多配置20个域名</li><li class="lvl-4">并发限制上限是10个</li><li class="lvl-4"><strong>设置不检验合法域名</strong>：开发工具-详情-本地设置-不检验</li></ul></li><li class="lvl-2"><p>调用接口时，可以根据接口的参数在 data 中进行相应的调用，如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">	url: &#x27;http://localhost:3000/banner&#x27;,</span><br><span class="line">	data: &#123;type:2&#125;,</span><br><span class="line">	success: (res) =&gt; &#123;</span><br><span class="line">		console.log(res);</span><br><span class="line">	&#125;,</span><br><span class="line">	fail: (err) =&gt; &#123;</span><br><span class="line">		console.log(err);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-登录界面逻辑">5.登录界面逻辑</h2><h3 id="1-收集表单项数据-2">(1).收集表单项数据</h3><ul class="lvl-0"><li class="lvl-2"><p>给元素绑定 bindinput 事件</p></li><li class="lvl-2"><p>这里可以给不同输入框绑定相同事件名，然后用id或者data-来区分，详见<a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html">这里</a></p></li><li class="lvl-2"><p>在js中初始化数据</p></li><li class="lvl-2"><p>在事件回调中更新数据</p><ul class="lvl-2"><li class="lvl-4">若使用id，则使用 <code>event.currentTarget.id</code> 来获取不同输入框</li><li class="lvl-4">若使用data-，则使用 <code>event.currentTarget.dataset.type</code> 来获取不同输入框</li></ul></li></ul><h3 id="2-前端验证实现">(2).前端验证实现</h3><ul class="lvl-0"><li class="lvl-2"><p>首先需要从表单项中获取到数据，即 <code>let &#123;phone,password&#125; = this.data;</code></p></li><li class="lvl-2"><p>然后进行前端验证，是否账号为空，是否账号合法等</p></li><li class="lvl-2"><p>验证完以后使用 <code>wx.showToast</code> API 来进行提示用户</p></li></ul><h3 id="3-后端验证实现">(3).后端验证实现</h3><ul class="lvl-0"><li class="lvl-2"><p>首先需要发送请求给后端，并将账号密码作为参数传给后端</p></li><li class="lvl-2"><p>根据不同的返回值判断登录情况（账号错误、密码错误、账号不存在、登录成功）</p></li></ul><h3 id="4-个人中心与登录界面交互">(4).个人中心与登录界面交互</h3><h4 id="1-跳转到登录界面">1).跳转到登录界面</h4><ul class="lvl-0"><li class="lvl-2"><p>我们需要给头像与用户名区域绑定单击事件</p></li><li class="lvl-2"><p>通过单击事件的回调函数跳转到登录界面</p></li></ul><h4 id="2-本地存储用户数据">2).本地存储用户数据</h4><ul class="lvl-0"><li class="lvl-2"><p>在登录界面的后端验证中，如果手机与密码正确，则需要将我们获取到的用户信息存储在本地</p></li><li class="lvl-2"><p>使用 wx.setStorageSync() 来存储数据，建议这里使用 <code>JSON.stringify()</code> 转换为JSON对象</p></li><li class="lvl-2"><p>跳转到个人中心页面，这里为了让个人中心页面一进入就获取信息，使用 wx.reLaunch() 跳转，即关闭之前所有页面，跳转到目标页面</p></li></ul><h4 id="3-本地读取用户数据">3).本地读取用户数据</h4><ul class="lvl-0"><li class="lvl-2"><p>在个人中心页面的 onLoad() 中使用 wx.getStorageSync() 来获取数据</p></li><li class="lvl-2"><p>进行判断，如果用户数据不为空，则更新用户数据并将用户数据更新到 data 中去，同时使用 <code>JSON.parse()</code> 将JSON对象转换为js对象</p></li></ul><h4 id="4-修改页面结构">4).修改页面结构</h4><ul class="lvl-0"><li class="lvl-2"><p>此时页面结构中的头像和用户名需要动态更新，这里可以使用三目运算符</p><ul class="lvl-2"><li class="lvl-4">存在用户数据，将用户数据更新到页面上</li><li class="lvl-4">不存在用户数据，则显示默认内容</li></ul></li><li class="lvl-2"><p>代码如下：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;image src=&quot;&#123; &#123;userInfo.avatarUrl?userInfo.avatarUrl:&#x27;/static/images/personal/missing-face.png&#x27;&#125; &#125;&quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure><h2 id="6-视频播放">6.视频播放</h2><h3 id="1-多个视频同时播放">(1).多个视频同时播放</h3><h4 id="1-需求">1).需求</h4><ul class="lvl-0"><li class="lvl-2"><p>在点击播放的事件中需要找到上一个播放的视频</p></li><li class="lvl-2"><p>在播放新的视频之前关闭上一个正在播放的视频</p></li></ul><h4 id="2-关键">2).关键</h4><ul class="lvl-0"><li class="lvl-2"><p>如何找到上一个视频的实例对象</p></li><li class="lvl-2"><p>如何确认点击播放的视频和正在播放的视频不是同一个视频</p></li></ul><h4 id="3-方案">3).方案</h4><ul class="lvl-0"><li class="lvl-2"><p>将相关参数添加到 this 中来进行判断</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handlePlay(event)&#123;</span><br><span class="line">	let vid = event.currentTarget.id;</span><br><span class="line">	/*</span><br><span class="line">	 * 当第一次点击时，没有videoContext所以不执行关闭操作，且将当前的vid和videoContext赋给this</span><br><span class="line">	 * 当第二次点击时，判断当前vid是否与this中相等，相等不执行关闭操作；不相等说明不是同一个视频，此时执行关闭操作</span><br><span class="line">	 */</span><br><span class="line">	this.vid !== vid &amp;&amp; this.videoContext &amp;&amp; this.videoContext.stop();</span><br><span class="line">	this.vid = vid;</span><br><span class="line">	// 创建控制video标签的实例对象</span><br><span class="line">	this.videoContext = wx.createVideoContext(vid);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>以上方案使用了 <strong>单例模式</strong> ，即需要创建多个对象的场景下，通过一个变量接收，始终保持只有一个对象，可以节省内存空间</p></li></ul><h4 id="4-终极方案">4).终极方案</h4><ul class="lvl-0"><li class="lvl-2"><p>通过 <code>&lt;image&gt;</code> 代替 <code>&lt;video&gt;</code> 来进行性能优化同时解决多个视频同时播放</p></li><li class="lvl-2"><p>在 <code>&lt;video&gt;</code> 标签中通过poster属性获取到当前视频的封面图地址</p></li><li class="lvl-2"><p>在 <code>&lt;image&gt;</code> 标签中的地址就使用上面获取到的封面图地址，并绑定和video一样的点击事件与样式和id属性</p></li><li class="lvl-2"><p>在相应的点击回调函数中更新data中的视频id数据</p></li><li class="lvl-2"><p>在 <code>&lt;video&gt;</code> 中使用wx:if来判断视频id是否和当前项目的id一致，一致显示视频，不一致显示图片</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 点击播放、继续播放的回调</span><br><span class="line">handlePlay(event)&#123;</span><br><span class="line">	let vid = event.currentTarget.id;</span><br><span class="line">	// 更新data中videoId的状态数据</span><br><span class="line">	this.setData(&#123;</span><br><span class="line">		videoId: vid</span><br><span class="line">	&#125;)</span><br><span class="line">	// 创建控制video标签的实例对象</span><br><span class="line">	this.videoContext = wx.createVideoContext(vid);</span><br><span class="line">	// 当点击图片时，自动播放视频</span><br><span class="line">	this.videoContext.play();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="7-音乐播放">7.音乐播放</h2><h3 id="1-音乐播放时系统栏的控制">(1).音乐播放时系统栏的控制</h3><h4 id="1-问题">1).问题</h4><ul class="lvl-0"><li class="lvl-2"><p>当用户在操作系统的控制音乐播放/暂停的按钮时，页面并不知道播放状态而导致页面播放状态与真实播放状态不一致</p></li></ul><h4 id="2-方案">2).方案</h4><ul class="lvl-0"><li class="lvl-2"><p>我们需要在页面刚加载时监听音乐的播放/暂停/停止状态</p></li><li class="lvl-2"><p>当监听到某种状态时就执行回调函数中的内容</p></li><li class="lvl-2"><p>BackgroundAudioManager 实例，可通过 <a target="_blank" rel="external nofollow noopener noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html">wx.getBackgroundAudioManager</a> 获取</p><ul class="lvl-2"><li class="lvl-4">BackgroundAudioManager.onPlay(function callback)监听背景音频播放事件</li><li class="lvl-4">BackgroundAudioManager.onPause(function callback)监听背景音频暂停事件</li><li class="lvl-4">BackgroundAudioManager.onStop(function callback)监听背景音频停止事件</li></ul></li></ul><h3 id="2-页面销毁时音乐的播放状态">(2).页面销毁时音乐的播放状态</h3><h4 id="1-问题-2">1).问题</h4><ul class="lvl-0"><li class="lvl-2"><p>当从音乐播放页面返回时，再打开该首歌时，音乐的播放状态与页面显示并不相同</p></li></ul><h4 id="2-关键-2">2).关键</h4><ul class="lvl-0"><li class="lvl-2"><p>使用 globalData 来存放音乐的播放状态</p></li><li class="lvl-2"><p>使用 getApp 获取到小程序全局唯一的 <code>App</code> 实例</p></li></ul><h4 id="3-方案-2">3).方案</h4><ul class="lvl-0"><li class="lvl-2"><p>先在 app.js 页面中定义相应的全局数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">globalData: &#123;</span><br><span class="line">	isMusicPlay: false, // 某个音乐的播放状态</span><br><span class="line">	musicId: &#x27;&#x27;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在当前页面的 js 中获取全局数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 获取全局实例</span><br><span class="line">const appInstance = getApp();</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>在监听音乐播放/暂停/停止的回调中修改全局音乐播放的状态</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 修改全局音乐播放的状态</span><br><span class="line">appInstance.globalData.isMusicPlay = isPlay;</span><br><span class="line">appInstance.globalData.musicId = musicId;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>最后在页面加载刚开始判断全局数据中是否有播放状态，如果有则修改当前音乐的播放状态为播放</p></li></ul><h3 id="3-歌曲播放性能优化">(3).歌曲播放性能优化</h3><ul class="lvl-0"><li class="lvl-2"><p>当我们在播放/暂停歌曲时，如果代码编写不当，会重复发送多次请求，这样会很消耗我们的性能</p></li><li class="lvl-2"><p>所以我们应该在获取音乐链接时进行判断，如果音乐链接为空我们就发请求，如果不为空我们就不发送请求</p></li></ul><h2 id="8-历史搜索">8.历史搜索</h2><h3 id="1-保存历史搜索记录">(1).保存历史搜索记录</h3><ul class="lvl-0"><li class="lvl-2"><p>获取用户的搜索数据并更新到 data 中</p></li><li class="lvl-2"><p>将搜索的关键字添加到搜索历史记录中（如果历史记录中没有该字段，则直接添加；如果有，将该字段放在第一位）</p></li><li class="lvl-2"><p>将历史记录的相关内容存放在本地，然后将获取本地历史封装为一个函数，如果本地历史有值则将其更新到 data 中</p></li><li class="lvl-2"><p>在生命周期函数中的 onLoad() 中调用之前的函数</p></li></ul><h3 id="2-清除当前搜索框中的内容">(2).清除当前搜索框中的内容</h3><ul class="lvl-0"><li class="lvl-2"><p>给相应的组件绑定单击响应事件</p></li><li class="lvl-2"><p>将<strong>用户输入的表单项数据</strong>和<strong>关键字模糊匹配的数据</strong>都置为空并更新到 data 中（可以给input组件添加 value 值，将<strong>用户输入的表单项数据</strong>绑定到该 value 值中即可同时清空）</p></li></ul><h3 id="3-删除历史搜索记录">(3).删除历史搜索记录</h3><ul class="lvl-0"><li class="lvl-2"><p>使用 wx.showModal() 来提示用户是否进行删除</p></li><li class="lvl-2"><p>在 success 的回调中可以通过 res.confirm 来判断用户是否点击了确认</p></li><li class="lvl-2"><p>当用户点击确认时，清空 data 中 historyList 并且移除本地的历史记录缓存</p></li></ul><h3 id="4-动态显示历史栏与清除按钮">(4).动态显示历史栏与清除按钮</h3><ul class="lvl-0"><li class="lvl-2"><p>使用条件渲染，当 historyList 的长度存在时就显示，否则不显示</p></li><li class="lvl-2"><p>使用 <code>hidden=&quot;&quot;</code> 属性来动态显示或隐藏清除按钮</p></li></ul><h1>十一、云开发案例</h1><h2 id="1-点击数据增加阅读量">1.点击数据增加阅读量</h2><h3 id="1-获取点击的id和index">(1).获取点击的id和index</h3><ul class="lvl-0"><li class="lvl-2"><p>将获取到的id和index传给云函数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let &#123;id,index&#125; = res.currentTarget.dataset;</span><br><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">	name: &quot;updateData&quot;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		id: id,</span><br><span class="line">		index: index</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-云函数进行更新操作">(2).云函数进行更新操作</h3><ul class="lvl-0"><li class="lvl-2"><p>创建一个专门用来更新的云函数</p></li><li class="lvl-2"><p>在云函数中通过id获取到当前点击元素的阅读量并进行自增更新操作</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let id = event.id;</span><br><span class="line">return await db.collection(&quot;demolist&quot;).doc(id).update(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		hits: _.inc(1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-前后端交互">(3).前后端交互</h3><ul class="lvl-0"><li class="lvl-2"><p>前端在接收返回值的成功回调中执行获取数据的云函数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">	name: &quot;getData&quot;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		id: id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>这里获取数据的云函数可以通过判断传来的值来执行不同的返回语句</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let num = event.num;</span><br><span class="line">let page = event.page;</span><br><span class="line">let id = event.id;</span><br><span class="line">if(event.id)&#123;</span><br><span class="line">	return await db.collection(&quot;demolist&quot;).doc(id).get()</span><br><span class="line">&#125;</span><br><span class="line">if(event.num || event.page)&#123;</span><br><span class="line">	return await db.collection(&quot;demolist&quot;).skip(page).limit(num).get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-重新渲染列表数据">(4).重新渲染列表数据</h3><ul class="lvl-0"><li class="lvl-2"><p>因为我们只是更新了data中数组的一项数据，所以只需要更新该条数据就可以，无需更新整个数组</p></li><li class="lvl-2"><p>只要定义一个新的变量使用拼串的方法获取到当前数组中的某个值</p></li><li class="lvl-2"><p>最后使用ES6语法即可实现重新渲染指定列表数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let newHits = &quot;listData[&quot;+index+&quot;].hits&quot;;</span><br><span class="line">this.setData(&#123;</span><br><span class="line">	[newHits]: res.result.data.hits</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><footer class="post-footer"><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/Learn-Wechat.html">学习笔记：微信小程序</a></p><p><span>文章作者:</span><a href="/" title="访问 Zhang Yangeng 的个人博客">Zhang Yangeng</a></p><p><span>发布时间:</span>2020年04月07日 - 15:04</p><p><span>最后更新:</span>2023年01月17日 - 17:01</p><p><span>许可协议:</span><i class="fab fa-creative-commons"></i> <a rel="external nofollow noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a></p><p><span>注意事项:</span>转载请保留原文链接及作者，请尊重作者的劳动成果</p><p><span>原始链接:</span><a href="/Learn-Wechat.html" title="学习笔记：微信小程序">https://www.wrysmile.cn/Learn-Wechat.html</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://www.wrysmile.cn/Learn-Wechat.html" aria-label="复制成功！"></i></span></p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script><div class="reward-container"><div>坚持原创技术分享，您的支持将是对我最大的鼓励！</div><button onclick='document.querySelector(".post-reward").classList.toggle("active")'>赞赏</button><div class="post-reward"><div><img src="https://s2.ax1x.com/2019/01/28/kKrX7T.png" alt="Zhang Yangeng 微信"> <span>微信</span></div><div><img src="https://i.loli.net/2019/01/25/5c4ac75f2e5b7.jpg" alt="Zhang Yangeng 支付宝"> <span>支付宝</span></div></div></div><div class="post-tags"><a href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag"><i class="fa fa-tag"></i> 学习</a></div><div class="post-nav"><div class="post-nav-item"><a href="/Hexo-03.html" rel="prev" title="Hexo博客之高级优化教程"><i class="fa fa-chevron-left"></i> Hexo博客之高级优化教程</a></div><div class="post-nav-item"><a href="/Learn-JS.html" rel="next" title="学习笔记：JavaScript（尚硅谷）">学习笔记：JavaScript（尚硅谷） <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC80MjQ5Ni8xOTA0Mw=="></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Wrysmile</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">411k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">6:14</span></span></div><div class="busuanzi-count"><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js"></script><script type="text/javascript">!function(e,r){function t(){for(var e=0;e<n.length;e++)n[e].alpha<=0?(r.body.removeChild(n[e].el),n.splice(e,1)):(n[e].y--,n[e].scale+=.004,n[e].alpha-=.013,n[e].el.style.cssText="left:"+n[e].x+"px;top:"+n[e].y+"px;opacity:"+n[e].alpha+";transform:scale("+n[e].scale+","+n[e].scale+") rotate(45deg);background:"+n[e].color+";z-index:99999");requestAnimationFrame(t)}var o,n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(t){var a=r.createElement("style");a.type="text/css";try{a.appendChild(r.createTextNode(t))}catch(e){a.styleSheet.cssText=t}r.getElementsByTagName("head")[0].appendChild(a)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),o="function"==typeof e.onclick&&e.onclick,e.onclick=function(e){var t,a;o&&o(),t=e,(a=r.createElement("div")).className="heart",n.push({el:a,x:t.clientX-5,y:t.clientY-5,scale:1,alpha:1,color:"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}),r.body.appendChild(a)},t()}(window,document)</script><script type="text/javascript">var titleTime,OriginTitle=document.title;document.addEventListener("visibilitychange",function(){document.hidden?($('[rel="icon"]').attr("href","/img/TEP.ico"),document.title="╭(°A°`)╮ 页面崩溃啦 ~",clearTimeout(titleTime)):($('[rel="icon"]').attr("href","/favicon.ico"),document.title="(ฅ>ω<*ฅ) 噫又好了~"+OriginTitle,titleTime=setTimeout(function(){document.title=OriginTitle},2e3))})</script></div></footer><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/third-party/search/local-search.js"></script><script class="next-config" data-name="nprogress" type="application/json">{&quot;enable&quot;:true,&quot;spinner&quot;:false}</script><script src="/js/third-party/nprogress.js"></script><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script class="next-config" data-name="leancloud_visitors" type="application/json">{&quot;enable&quot;:true,&quot;app_id&quot;:&quot;mzhbgeWR9BA3SvqtvaAJulC1-gzGzoHsz&quot;,&quot;app_key&quot;:&quot;xcGndtx2gmyop5yrT6euUk9G&quot;,&quot;server_url&quot;:null,&quot;security&quot;:false}</script><script src="/js/third-party/statistics/lean-analytics.js"></script><script src="/js/third-party/comments/livere.js"></script></body></html>