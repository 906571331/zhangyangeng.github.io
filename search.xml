<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>强烈推荐：实用网站聚合</title>
    <url>/web-nav.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文档收录了个人觉得不错的一些网站</li>
<li>如有更好推荐，请在评论区留言</li>
<li>如有问题纠正，请在评论区留言<span id="more"></span></li>
</ul>
<h1 id="一、IT类网站"><a href="#一、IT类网站" class="headerlink" title="一、IT类网站"></a>一、IT类网站</h1><h2 id="0-博客收藏"><a href="#0-博客收藏" class="headerlink" title="0.博客收藏"></a>0.博客收藏</h2><ul>
<li>胡萝卜周  ——  分享一些好用的软件或者破解版软件。直通车：<a href="http://www.carrotchou.blog/">查看链接</a></li>
<li>博客园  ——  开发者的网上家园。直通车：<a href="https://www.cnblogs.com/">查看链接</a></li>
<li>大眼仔  ——  分享一些软件、教程资源。直通车：<a href="http://www.dayanzai.me/">查看链接</a></li>
</ul>
<h2 id="1-社区交流网站"><a href="#1-社区交流网站" class="headerlink" title="1.社区交流网站"></a>1.社区交流网站</h2><ul>
<li>吾爱破解网  ——  大佬聚集地，各种教程，菜鸟的飞升之路。直通车：<a href="https://www.52pojie.cn/">查看链接</a></li>
<li>瑞客论坛  ——  众多IT教程辅助工具破解资源分享论坛。直通车：<a href="https://www.ruike1.com/">查看链接</a></li>
<li>V2EX  ——  一个关于分享和探索的地方。直通车：<a href="https://www.v2ex.com/">查看链接</a></li>
<li>掘金  ——  一个帮助开发者成长的社区。直通车：<a href="https://juejin.im/">查看链接</a></li>
<li>InfoQ  ——  一个实践驱动的社区资讯站点，致力于促进软件开发领域知识与创新的传播。直通车：<a href="https://www.infoq.cn/">查看链接</a></li>
<li>开发者头条  ——  程序员分享平台。直通车：<a href="https://toutiao.io/posts/hot/7">查看链接</a></li>
<li>cocoachina  ——  一站式开发者成长社区。直通车：<a href="http://www.cocoachina.com/">查看链接</a></li>
<li>推酷  ——  IT人专属个性阅读社区。直通车：<a href="https://www.tuicool.com/">查看链接</a></li>
</ul>
<h2 id="2-教程向网站"><a href="#2-教程向网站" class="headerlink" title="2.教程向网站"></a>2.教程向网站</h2><ul>
<li>Topbook  ——  涉及app、小程序、电脑软件以及各种教程。直通车：<a href="https://topbook.cc/">查看链接</a></li>
<li>实验楼  ——  帮助你撸代码，搭配有各种虚拟环境，包你满意。直通车：<a href="https://www.shiyanlou.com/">查看链接</a></li>
<li>我要自学网  ——  免费的各类视频教程网站。直通车：<a href="https://www.51zxw.net/">查看链接</a></li>
<li>W3school  ——  全球最大的web技术教程网站。直通车：<a href="https://www.w3school.com.cn/">查看链接</a></li>
<li>W3cschool  ——  随时随地学编程。直通车：<a href="https://www.w3cschool.cn/">查看链接</a></li>
<li>菜鸟教程  ——  有些教程比较旧了一些。直通车：<a href="https://www.runoob.com/">查看链接</a></li>
<li>Linux命令大全(手册)  ——  可以查询相关命令。直通车：<a href="https://www.linuxcool.com/">查看链接</a></li>
<li>破解IDE网站 —— 可以破解Pychram、WebStrome等（密码4565）。直通车：<a href="http://vrg123.com/">查看链接</a></li>
</ul>
<h2 id="3-代码托管网站"><a href="#3-代码托管网站" class="headerlink" title="3.代码托管网站"></a>3.代码托管网站</h2><ul>
<li>Github。直通车：<a href="https://github.com/">查看链接</a></li>
<li>Gitee。直通车：<a href="https://gitee.com/">查看链接</a></li>
</ul>
<h2 id="4-操作系统重装-封装"><a href="#4-操作系统重装-封装" class="headerlink" title="4.操作系统重装/封装"></a>4.操作系统重装/封装</h2><p>MSDN——纯净操作系统下载网站。直通车：<a href="https://msdn.itellyou.cn/">查看链接</a></p>
<p>TechBench——一个下载操作系统和微软office网站，可以直接浏览器满速下载。直通车：<a href="https://tb.rg-adguard.net/public.php?lang=zh-CN&extract">查看链接</a></p>
<ul>
<li><strong style="color:red;">注意：如果此网站下载时显示<code>Access Denied</code>，只要将下载链接中的 <code>.edgesuite.net/db/</code> 字段换成 <code>/pr/</code> 即可正常下载</strong></li>
</ul>
<p>IT天空——详细系统封装教程网站。直通车：<a href="https://www.itsk.com/portal.php">查看链接</a></p>
<h2 id="5-VPS产商网站"><a href="#5-VPS产商网站" class="headerlink" title="5.VPS产商网站"></a>5.VPS产商网站</h2><ul>
<li>Vultr——比较实惠，多个国家的服务器应有尽有，首次注册充值$10美元还可以获得$50美元的折扣。直通车：<a href="https://www.vultr.com/?ref=8274420-4F">查看链接</a></li>
<li>Google Cloud —— 新用户注册即送300美金，可免费试用一年。直通车：<a href="https://cloud.google.com/">查看链接</a><br>关于谷歌云的注册方法，可以查看我的这篇文章 —— <a href="/V2Ray-01.html" title="[免费领取一年谷歌云]">[免费领取一年谷歌云]</a></li>
</ul>
<h2 id="6-云类网站"><a href="#6-云类网站" class="headerlink" title="6.云类网站"></a>6.云类网站</h2><ul>
<li>坚果云——可实现PC、Android、ios无缝同步，还可查看文件历史版本，唯一不足就是免费版每个月上传1G，下载3G。<a href="https://www.jianguoyun.com/">查看链接</a></li>
<li>蓝奏云——怎么说呢，相当于小型百度云，不限速，便于分享，就是不支持大文件。<a href="http://www.lanzou.com/">查看链接</a></li>
</ul>
<h2 id="7-开源网站"><a href="#7-开源网站" class="headerlink" title="7.开源网站"></a>7.开源网站</h2><ul>
<li>开源中国  ——  中文开源技术交流社区。<a href="https://www.oschina.net/">查看链接</a></li>
<li>深度开源  ——  开源项目、代码、文档、新闻的社区。<a href="https://www.open-open.com/">查看链接</a></li>
<li>HelloGitHub  ——  分享 GitHub 上有趣、入门级的开源项目。<a href="https://hellogithub.com/">查看链接</a></li>
<li>开源镜像站  ——  清华大学开源软件镜像站。<a href="https://mirrors.tuna.tsinghua.edu.cn/">查看链接</a></li>
</ul>
<h2 id="8-博客搭建网站"><a href="#8-博客搭建网站" class="headerlink" title="8.博客搭建网站"></a>8.博客搭建网站</h2><ul>
<li>来必力——为博客添加评论功能。直通车：<a href="https://www.livere.com/">查看链接</a></li>
<li>DaoVoice——为博客添加在线联系功能。直通车：<a href="http://www.daovoice.io/">查看链接</a></li>
<li>LeanCloud——为博客统计每篇文章的阅读量。<a href="https://leancloud.cn/dashboard/applist.html#/apps">查看链接</a></li>
</ul>
<h2 id="9-刷机类网站"><a href="#9-刷机类网站" class="headerlink" title="9.刷机类网站"></a>9.刷机类网站</h2><ul>
<li>Android 玩机伪段位认定 —— 滑稽网站，娱乐即可。<a href="https://bbs.letitfly.me/d/1029">查看链接</a></li>
</ul>
<h1 id="二、图像类网站"><a href="#二、图像类网站" class="headerlink" title="二、图像类网站"></a>二、图像类网站</h1><h2 id="1-图床网站"><a href="#1-图床网站" class="headerlink" title="1.图床网站"></a>1.图床网站</h2><ul>
<li>SM.MS。<a href="https://sm.ms/">查看链接</a></li>
<li>路过图床。<a href="https://imgchr.com/wrysmile">查看链接</a></li>
<li>ImageHub。<a href="https://www.imagehub.cc/">查看链接</a></li>
<li>聚合图床。<a href="https://www.superbed.cn/">查看链接</a></li>
<li>ImgUrl。<a href="https://imgurl.org/">查看链接</a></li>
<li>遇见图床。<a href="https://www.hualigs.cn/">查看链接</a></li>
<li>vgy.me。<a href="https://vgy.me/">查看链接</a></li>
</ul>
<h2 id="2-图片放大、压缩网站"><a href="#2-图片放大、压缩网站" class="headerlink" title="2.图片放大、压缩网站"></a>2.图片放大、压缩网站</h2><ul>
<li><strong>Bigjpg</strong> —— AI人工智能图片放大。<a href="http://bigjpg.com/">查看链接</a></li>
<li><strong>waifu2x</strong> —— 使用卷积神经网络对动漫风格的图片进行放大操作。<a href="http://waifu2x.udp.jp/">查看链接</a></li>
<li><strong>TinyPNG</strong> —— 使用智能有损压缩技术进行压缩图片。<a href="https://tinypng.com/">查看链接</a></li>
</ul>
<h2 id="3-图标素材网站"><a href="#3-图标素材网站" class="headerlink" title="3.图标素材网站"></a>3.图标素材网站</h2><ul>
<li><strong>iconfont</strong> —— 阿里云官方的字体图标库，可以添加到项目中直接获取该项目的css样式。<a href="https://www.iconfont.cn/">查看链接</a></li>
<li><strong>iconninja</strong> —— 国外免费图标素材下载，支持png、svg、ico格式下载。<a href="http://www.iconninja.com/">查看链接</a></li>
<li><strong>ICONS</strong> —— 国外图标下载，免费图标也不少，支持png、svg、eps、pdf格式下载。<a href="https://icons8.cn/icons">查看链接</a></li>
<li><strong>easyicon</strong> —— 国内图标下载，支持png、ico、icns格式下载。<a href="https://www.easyicon.net/">查看链接</a></li>
<li><strong>WORLDVECTORLOGO</strong> —— 可以免费下载来自世界各地大小公司的LOGO。<a href="https://worldvectorlogo.com/">查看链接</a></li>
<li><strong>SEEKLOGO</strong> —— 提供了更为详细的信息。<a href="https://seeklogo.com/">查看链接</a></li>
<li><strong>软件</strong> —— 直接提取原有程序的图标。<a href="https://www.lanzous.com/i3a8d7g">查看链接</a></li>
</ul>
<h2 id="4-渐变色配色网站"><a href="#4-渐变色配色网站" class="headerlink" title="4.渐变色配色网站"></a>4.渐变色配色网站</h2><ul>
<li>CoolHue——首页中含有60种渐变色背景，支持css代码、图片下载。直通车：<a href="https://webkul.github.io/coolhue/">查看链接</a></li>
<li>Uigradients——比较简单的配色网站，支持css代码、图片下载。直通车：<a href="https://uigradients.com/">查看链接</a></li>
<li>Webgradients——大概拥有180种渐变配色，支持css代码、图片下载。直通车：<a href="https://webgradients.com/">查看链接</a></li>
<li>Gradients of Shapefactory——整个网站的功能之一，支持css代码、图片下载。直通车：<a href="https://gradient.shapefactory.co/">查看链接</a></li>
</ul>
<h2 id="5-平面设计网站"><a href="#5-平面设计网站" class="headerlink" title="5.平面设计网站"></a>5.平面设计网站</h2><ul>
<li>创客贴。直通车：<a href="https://www.chuangkit.com/">查看链接</a></li>
</ul>
<h2 id="6-RGB颜色查询网站"><a href="#6-RGB颜色查询网站" class="headerlink" title="6.RGB颜色查询网站"></a>6.RGB颜色查询网站</h2><ul>
<li><a href="http://www.sioe.cn/">www.sioe.cn</a> 应用工具 —— 颜色种类较少，但支持RGB值与16进制颜色码转换。<a href="https://www.sioe.cn/yingyong/yanse-rgb-16/">查看链接</a></li>
<li>在线工具 —— 颜色种类较多，支持直接取色查询。<a href="http://tool.oschina.net/commons?type=3">查看链接</a></li>
<li>RGB颜色查询对照表 —— 颜色种类较多。<a href="https://www.114la.com/other/rgb.htm">查看链接</a></li>
</ul>
<h2 id="7-人工智能网站"><a href="#7-人工智能网站" class="headerlink" title="7.人工智能网站"></a>7.人工智能网站</h2><ul>
<li>抠图网站 —— 便捷、无需安装、抠图快、人物抠图效果十分惊艳。<a href="http://remove.bg/">查看链接</a></li>
<li>Facepixelizer —— 一款专门给照片中人脸区域打马赛克的工具。<a href="https://www.facepixelizer.com/">查看链接</a></li>
<li>一个在线PS工具，可以随时随地编辑图片，可以免去安装PS长时间的等待。<a href="uupoop.com/">查看链接</a></li>
<li>稿定设计在线PS —— 在线PS工具。<a href="https://ps.gaoding.com/#/">查看链接</a></li>
</ul>
<h2 id="8-设计类网站"><a href="#8-设计类网站" class="headerlink" title="8.设计类网站"></a>8.设计类网站</h2><ul>
<li>Dribbble —— 一个面向创作家、艺术工作者、设计师等创意类作品的人群，提供作品在线服务，供网友在线查看已经完成的作品或者正在创作的作品的交流网站。直通车：<a href="https://dribbble.com/">查看链接</a></li>
</ul>
<h2 id="9-壁纸网站"><a href="#9-壁纸网站" class="headerlink" title="9.壁纸网站"></a>9.壁纸网站</h2><ul>
<li>彼岸图网4K动漫壁纸 —— <a href="http://pic.netbian.com/4kdongman/">查看链接</a></li>
<li>二次元壁纸 —— <a href="https://bz.zzzmh.cn/?from=groupmessage#anime">查看链接</a></li>
<li>WinDynamicDesktop —— 一款仿Mac的动态壁纸软件，会根据日落日出自动更改。官网：<a href="https://www.microsoft.com/en-us/p/windynamicdesktop/9nm8n7dq3z5f?activetab=pivot:overviewtab">链接</a></li>
</ul>
<h1 id="三、影音类网站"><a href="#三、影音类网站" class="headerlink" title="三、影音类网站"></a>三、影音类网站</h1><h2 id="1-视频解析下载"><a href="#1-视频解析下载" class="headerlink" title="1.视频解析下载"></a>1.视频解析下载</h2><ul>
<li>唧唧 —— 用来下载B站视频。<a href="https://www.jijidown.com/">查看链接</a></li>
<li>urlgot —— 可以解析下载油管/B站/腾讯/优酷/爱奇艺等视频的在线网站。<a href="https://www.haobang.fun/">查看链接</a></li>
</ul>
<h2 id="2-动效制作平台——犸良"><a href="#2-动效制作平台——犸良" class="headerlink" title="2.动效制作平台——犸良"></a>2.动效制作平台——犸良</h2><ul>
<li>阿里出品的一个动效制作工具，通过网站提供的模板，可以让零基础的同学一键做出炫酷的动效。<a href="https://design.alipay.com/emotion/">查看链接</a></li>
</ul>
<h2 id="3-在线音乐平台"><a href="#3-在线音乐平台" class="headerlink" title="3.在线音乐平台"></a>3.在线音乐平台</h2><ul>
<li>刘明野的音乐盒 —— 专注于无损音乐的解析和下载，支持在线播放，支持搜索歌曲，曲库量整合网易、QQ、咪咕等平台。<a href="http://tool.liumingye.cn/music/">查看链接</a></li>
</ul>
<h2 id="4-人工智能网站"><a href="#4-人工智能网站" class="headerlink" title="4.人工智能网站"></a>4.人工智能网站</h2><ul>
<li>视频一键去背景 —— 可以智能识别视频中的主体，然后去除背景。<a href="https://www.unscreen.com/">查看链接</a></li>
</ul>
<h1 id="四、工具类网站"><a href="#四、工具类网站" class="headerlink" title="四、工具类网站"></a>四、工具类网站</h1><h2 id="0-格式转换工具"><a href="#0-格式转换工具" class="headerlink" title="0.格式转换工具"></a>0.格式转换工具</h2><ul>
<li>目前全网最全的格式转换工具，支持约200多种格式的文件转换。更为难得的是，这些工具是完全免费的。<a href="http://www.alltoall.net/">查看链接</a></li>
<li>文件转换器  ——  支持超过 300 种格式。<a href="https://convertio.co/zh/">查看链接</a></li>
<li>Office-converter  ——  多种格式转换，支持手机、平板和电脑。<a href="https://cn.office-converter.com/">查看链接</a></li>
<li>Smallpdf  ——  一体式在线PDF工具。直通车：<a href="https://smallpdf.com/">查看链接</a></li>
<li>ilovepdf  ——  PDF爱好者的在线工具。直通车：<a href="https://www.ilovepdf.com/zh_cn">查看链接</a></li>
<li>PDF24 Tools  ——  专注于PDF文档处理的在线工具。<a href="https://tools.pdf24.org/zh/">查看链接</a></li>
</ul>
<h2 id="1-云端在线网站"><a href="#1-云端在线网站" class="headerlink" title="1.云端在线网站"></a>1.云端在线网站</h2><ul>
<li>GitMind —— 一个免费在线思维导图软件。<a href="https://gitmind.cn/">查看链接</a></li>
<li>百度脑图。没有任何的广告，可以免费使用所有功能，并且支持导出多种格式的思维导图。<a href="https://naotu.baidu.com/">查看链接</a></li>
<li><del>吾爱大佬所写，可以在线查看腾讯和360的软件商店，可在线下载。直通车：<a href="http://soft.tinybad.cn/">查看链接</a></del><font color=#F00>（目前网站已失效）</font></li>
<li>NICETOOL  ——  在线工具大全。直通车：<a href="http://www.nicetool.net/">查看链接</a></li>
</ul>
<h2 id="2-浏览器插件网站"><a href="#2-浏览器插件网站" class="headerlink" title="2.浏览器插件网站"></a>2.浏览器插件网站</h2><ul>
<li>Chrome 插件网 —— 谷歌浏览器插件网站。<a href="https://chromecj.com/">查看链接</a></li>
<li>万能命令 —— 一个在线工具快捷跳转平台，将各种高质量的在线工具按应用站点聚合起来，可以让你方便快捷的找到合适的工具。<a href="https://wanneng.run/cn/">查看链接</a></li>
<li>Web前端助手 —— 字符串编解码、图片base64编码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成器、编码规范检测、页面性能检测、栅格检测、JS运行效率分析。<a href="https://github.com/zxlie/FeHelper">查看链接</a></li>
</ul>
<h2 id="3-正版中国"><a href="#3-正版中国" class="headerlink" title="3.正版中国"></a>3.正版中国</h2><ul>
<li>一个分享正版软件限时免费信息的网站。直通车：<a href="https://getitfree.cn/">查看链接</a></li>
</ul>
<h2 id="4-电脑插件网站"><a href="#4-电脑插件网站" class="headerlink" title="4.电脑插件网站"></a>4.电脑插件网站</h2><ul>
<li>Snipaste —— 一个集截图与贴图功能于一身的插件。官网：<a href="https://zh.snipaste.com/">链接</a></li>
<li>Everything —— 可以很快速全盘搜索文件。官网：<a href="https://www.voidtools.com/zh-cn/">链接</a></li>
<li>Quicker —— 强大的快捷操作指令。官网：<a href="https://www.getquicker.net/">链接</a></li>
<li>Listary —— 可以很快搜索指定文件与软件。官网：<a href="https://www.listary.com/">链接</a></li>
<li>Wox —— 与Listary类似，这个更新较为勤快。官网：<a href="http://www.wox.one/">链接</a></li>
<li>PowerToys —— 微软自家的小工具，现已更新中文。官网：<a href="https://github.com/microsoft/PowerToys">链接</a></li>
<li>uTools —— 一个极简、插件化、跨平台的现代桌面软件。官网：<a href="https://www.u.tools/">链接</a></li>
<li>MacType —— Windows 字体美化软件，可以像mac一样，作者停止维护。官网：<a href="https://github.com/snowie2000/MacType">链接</a></li>
<li>ContextMenuManager —— 右键管理工具，功能在逐渐完善中。官网：<a href="https://github.com/BluePointLilac/ContextMenuManager">链接</a></li>
</ul>
<h2 id="5-开发工具"><a href="#5-开发工具" class="headerlink" title="5.开发工具"></a>5.开发工具</h2><p><a href="https://cubic-bezier.com/#.17,.67,.83,.67"><strong>cubic-bezier</strong></a>：调节贝塞尔曲线，来展示不同的前端展示动画</p>
<h1 id="五、学习类网站"><a href="#五、学习类网站" class="headerlink" title="五、学习类网站"></a>五、学习类网站</h1><h2 id="1-学术文献资料推荐网站"><a href="#1-学术文献资料推荐网站" class="headerlink" title="1.学术文献资料推荐网站"></a>1.学术文献资料推荐网站</h2><blockquote>
<p>转自topbook，原文链接：<a href="https://mp.weixin.qq.com/s/MtTKx3hv2mh1munhEucD_g">查看</a></p>
</blockquote>
<ul>
<li>国家哲学社会科学文献中心——提供免费下载，提供各类哲学社会科学文献。</li>
<li>中国国家数字图书馆——中国国家图书馆的在线网站。</li>
<li>德国Springer-Verlag——是世界著名科技出版集团，日前在国内开通了SpringerLink服务。</li>
<li>国家数据——可搜索某个省10年内的GDP或城镇化的数据。</li>
<li>术语在线——含有各个领域论文的术语检索要求。</li>
<li>浙江图书馆——办理借阅证后可免费下载知网、万方的文献资料。方法请移步<a href="https://mp.weixin.qq.com/s/FqA8o_AEKGN3mO6VgiKmrA">这里</a>。</li>
<li>Idata —— </li>
</ul>
<h2 id="2-打字练习网站"><a href="#2-打字练习网站" class="headerlink" title="2.打字练习网站"></a>2.打字练习网站</h2><ul>
<li>TypingClud——国外打字练习网站，关卡众多，并附有视频教学以及小游戏。直通车：<a href="https://www.typingclub.com/">查看链接</a></li>
</ul>
<h2 id="3-电子书下载网站"><a href="#3-电子书下载网站" class="headerlink" title="3.电子书下载网站"></a>3.电子书下载网站</h2><ul>
<li>鸠摩搜书  ——  一个电子书搜索引擎，整合网上所有可以搜索的资源。直通车：<a href="https://www.jiumodiary.com/">查看链接</a></li>
<li>伴读  ——  电子书下载网站，出版的书籍基本上都有，新书热门书籍较少。直通车：<a href="https://www.bandubook.com/">查看链接</a></li>
<li>脚本之家  ——  计算机类的电子书下载网站。直通车：<a href="https://www.jb51.net/books/">查看链接</a></li>
<li>码农之家  ——  计算机电子书下载网。直通车：<a href="https://www.xz577.com/">查看链接</a></li>
<li>Z-Library  ——  英文书下载网站。直通车：<a href="https://b-ok.org/">查看链接</a></li>
<li>亚马逊电子书 —— 可下载免费电子书在相应设备上观看。官网：<a href="https://www.amazon.cn/Kindle%E5%85%8D%E8%B4%B9%E7%94%B5%E5%AD%90%E4%B9%A6/b?ie=UTF8&node=116175071&ref_=sa_menu_kindle_l3_b116175071">链接</a></li>
<li>图灵社区 —— 计算机类的电子书下载网站。官网：<a href="https://www.ituring.com.cn/">链接</a></li>
<li>书格 —— 古籍书籍下载网站。官网：<a href="https://new.shuge.org/">链接</a></li>
</ul>
<h1 id="六、简历类网站"><a href="#六、简历类网站" class="headerlink" title="六、简历类网站"></a>六、简历类网站</h1><ul>
<li><strong>ikono</strong> —— 一个免费简历模板网站，收录了很多人的简历模板，同时提供源文件给我们下载，包含PSD格式、AI格式、SKETCH格式，是不是很棒棒，对于着急找工作的我们直接可以下载使用，减少没必要浪费的时间！<a href="http://ikono.me/">查看链接</a></li>
<li><strong>SR</strong> —— 这是一个比较便捷的简历制作网站，便捷在哪里呢？他只需要你输入相关信息就可以弹出简洁精美大气的简历页面。<a href="https://standardresume.co/">查看链接</a></li>
<li><strong>freesumes</strong> —— 这个网站拥有上百个精美个人简历模板，满足你的多方面求职需求。<a href="https://www.freesumes.com/">查看链接</a></li>
<li><strong>Semplice</strong> —— 一个帮助设计师建立精美出色响应式个人作品集的网站，提供了简单的工具协助你制作出精美独特个人网站！<a href="https://www.semplice.com/">查看链接</a></li>
<li><strong>Behance</strong> —— 这个网站上面除了涵盖全球优秀设计作品以外，同时也包含大量精美的模板简历可供下载。<a href="https://www.behance.net/">查看链接</a></li>
<li><strong>Office Plus</strong> —— 微软官方文档模板网站，其中就提供了简历模板。<a href="http://www.officeplus.cn/Template/Home.shtml">查看链接</a></li>
<li><strong>创客贴</strong> —— 提供<strong>简历模板</strong>和<strong>在线编辑</strong>，一站式解决简历问题，部分简历模板收费。<a href="https://www.chuangkit.com/">查看链接</a></li>
<li><strong>五百丁</strong> —— 专业的简历在线制作工具，模板超多、类型很全、质量也挺高。属于付费产品，一个月12.9元办个基础会员能够满足一段时间的求职需要。<a href="https://www.500d.me/">查看链接</a></li>
<li><strong>站长素材</strong> —— 免费模板较多且质量较好。<a href="https://sc.chinaz.com/jianli/">查看链接</a></li>
<li><strong>592职业圈</strong> —— 整个网站都是免费可下载的，为word格式。<a href="https://www.job592.com/doc/">查看链接</a></li>
<li><strong>智联招聘</strong> —— 数量少但质量高，简单把网站的个人资料填写好即可进行下载。<a href="https://landing.zhaopin.com/resume-templates?source=article">查看链接</a></li>
</ul>
<h1 id="七、求职类网站"><a href="#七、求职类网站" class="headerlink" title="七、求职类网站"></a>七、求职类网站</h1><ul>
<li>九章算法：<a href="https://www.jiuzhang.com/">查看链接</a></li>
<li>领扣：<a href="https://www.lintcode.com/problem/">查看链接</a></li>
<li>careercup：<a href="https://careercup.com/">查看链接</a></li>
<li>BoSS直聘：<a href="https://www.zhipin.com/">查看链接</a></li>
<li>拉勾网：<a href="https://www.lagou.com/">查看链接</a></li>
<li>猎聘网：<a href="https://www.liepin.com/zhaopin/">查看链接</a></li>
<li>前程无忧：<a href="https://www.51job.com/">查看链接</a></li>
<li>智联招聘：<a href="https://www.zhaopin.com/">查看链接</a></li>
<li>58同城：<a href="https://dt.58.com/">查看链接</a></li>
<li>dajie大街：<a href="https://s.dajie.com/">查看链接</a></li>
<li>应届生求职网：<a href="http://www.yingjiesheng.com/">查看链接</a></li>
<li>中华英才网：<a href="http://www.chinahr.com/home/dt/">查看链接</a></li>
<li>百姓网：<a href="https://datong.baixing.com/">查看链接</a></li>
</ul>
<h1 id="八、导航类网站"><a href="#八、导航类网站" class="headerlink" title="八、导航类网站"></a>八、导航类网站</h1><blockquote>
<p>这里收录了一些别人比较好的导航网站</p>
</blockquote>
<h2 id="1-IT类导航"><a href="#1-IT类导航" class="headerlink" title="1.IT类导航"></a>1.IT类导航</h2><ul>
<li>三颗豆子：<a href="http://www.bewindoweb.com/dwg.php">链接</a></li>
<li>实用导航（可以代下载CSDN和PUDN资源）：<a href="https://goshare.site/resource/">链接</a></li>
</ul>
<h2 id="2-设计类导航"><a href="#2-设计类导航" class="headerlink" title="2.设计类导航"></a>2.设计类导航</h2><ul>
<li>奇迹秀工具箱：<a href="http://www.qijishow.com/down/index.html">链接</a></li>
</ul>
]]></content>
      <categories>
        <category>个人收藏</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>强烈推荐：快捷键集合</title>
    <url>/ShortcutKey.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本篇主要积累了从系统到软件的各种快捷键的用法</li>
</ul>
<span id="more"></span>

<h1 id="一、系统"><a href="#一、系统" class="headerlink" title="一、系统"></a>一、系统</h1><ul>
<li><code>F2</code>：重命名选中内容</li>
<li><code>Windows + A</code>：打开操作中心</li>
<li><code>Windows + D</code>：显示桌面</li>
<li><code>Windows + E</code>：打开资源管理器</li>
<li><code>Windows + I</code>：打开设置</li>
<li><code>Widnows + K</code>：打开连接设备栏</li>
<li><code>Windows + L</code>：锁定桌面</li>
<li><code>Windows + P</code>：多显示器切换</li>
<li><code>Windows + Q</code>：打开搜索框</li>
<li><code>Windows + Tab</code>：显示时间轴</li>
<li><code>Ctrl + Windows + D</code>：新建虚拟桌面</li>
<li><code>Ctrl + Windows + F4</code>：关闭当前的虚拟桌面</li>
<li><code>Ctrl + Windows + ←/→</code>：切换到其他虚拟桌面</li>
<li><code>Shift + Windows + S</code>：打开截图工具</li>
</ul>
<h1 id="二、开发工具"><a href="#二、开发工具" class="headerlink" title="二、开发工具"></a>二、开发工具</h1><h2 id="1-微信开发者工具"><a href="#1-微信开发者工具" class="headerlink" title="1.微信开发者工具"></a>1.微信开发者工具</h2><ul>
<li><code>Alt + Up/Alt Down</code>：上下移动一行</li>
<li><code>Ctrl + B</code>：重新编译项目</li>
<li><code>Ctrl + D</code>：选中匹配</li>
<li><code>Ctrl + F</code>：当前页面内搜索</li>
<li><code>Ctrl + H</code>：当前页面内搜索并替换文本</li>
<li><code>Ctrl + S</code>：保存并编译项目</li>
<li><code>Ctrl + U</code>：光标回退</li>
<li><code>Ctrl + i</code>：选中当前行</li>
<li><code>Ctrl + /</code>：单行注释</li>
<li><code>Ctrl + End</code>：移动到文件结尾</li>
<li><code>Ctrl + Home</code>：移动到文件开头</li>
<li><code>Ctrl + [ / Ctrl + ]</code>：代码行缩进</li>
<li><code>Ctrl + Shift + F</code>：全局搜索</li>
<li><code>Ctrl + Shift + H</code>：全局搜索并替换文本</li>
<li><code>Ctrl + Shift + L</code>：选中所有匹配</li>
<li><code>Ctrl + Shift + Enter</code>：在当前行上方插入一行</li>
<li><code>Ctrl + Shift + [ / Ctrl + Shift + ]</code>：折叠打开代码块</li>
<li><code>Shift + Alt + A</code>：多行注释</li>
<li><code>Shift + Alt + F</code>：代码格式化</li>
<li><code>Shift + Alt + Up / Down</code>：向上向下复制一行</li>
<li><code>Shift + End</code>：选择从光标到行尾</li>
<li><code>Shift + Home</code>：选择从行首到光标处</li>
</ul>
<h2 id="2-Eclipse"><a href="#2-Eclipse" class="headerlink" title="2.Eclipse"></a>2.Eclipse</h2><ul>
<li><code>Alt + /</code>：内容提示</li>
<li><code>Alt + Left</code>：回退到前一个编辑页面</li>
<li><code>Alt + Right</code>：进入到下一个编辑页面</li>
<li><code>Alt + Up/Alt Down</code>：向上下移动代码</li>
<li><code>Alt + Shift + S</code>：调出生成getter/setter/构造器等</li>
<li><code>Ctrl + 1</code>：快速修复</li>
<li><code>Ctrl + D</code>：删除选中行</li>
<li><code>Ctrl + K</code>：快速查找</li>
<li><code>Ctrl + T</code>：查看继承结构</li>
<li><code>Ctrl + O</code>：显示 outline</li>
<li><code>Ctrl + Alt + Down</code>：向下复制行</li>
<li><code>Ctrl + /</code>：单行注释</li>
<li><code>Ctrl + Shift + /</code>：多行注释</li>
<li><code>Ctrl + Shift + \</code>：取消多行注释</li>
<li><code>Ctrl + Shift + F</code>：格式化代码</li>
<li><code>Ctrl + Shift + O</code>：批量导包</li>
<li><code>Ctrl + Shift + Enter</code>：向上插入行</li>
<li><code>Shift + Enter</code>：向下插入行</li>
<li><code>Shift + Tab</code>：整体前移代码</li>
<li><code>Tab</code>：整体后移代码</li>
</ul>
<h2 id="3-Hbuilder"><a href="#3-Hbuilder" class="headerlink" title="3.Hbuilder"></a>3.Hbuilder</h2><h3 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="(1).快捷键"></a>(1).快捷键</h3><ul>
<li><code>Ctrl + K</code>：格式化代码</li>
<li><code>Ctrl + R</code>：运行到浏览器</li>
<li><code>Ctrl + /</code>：单行注释</li>
<li><code>Ctrl + Shift + /</code>：多行注释</li>
</ul>
<h3 id="2-技巧"><a href="#2-技巧" class="headerlink" title="(2).技巧"></a>(2).技巧</h3><ul>
<li>写 jQuery 代码时不会进行代码提示，只要在编辑器的右下角“语法提示库”选择 jQuery 语法即可</li>
</ul>
<h2 id="4-WebStrom"><a href="#4-WebStrom" class="headerlink" title="4.WebStrom"></a>4.WebStrom</h2><ul>
<li><code>Ctrl + Alt + S</code>：打开设置</li>
<li><code>Shift + Enter</code>：向下插入行</li>
</ul>
<h2 id="5-VSCode"><a href="#5-VSCode" class="headerlink" title="5.VSCode"></a>5.VSCode</h2><h3 id="1-快捷键-1"><a href="#1-快捷键-1" class="headerlink" title="(1).快捷键"></a>(1).快捷键</h3><ul>
<li>输入 <code>!</code> 并按 tab 键可以快速生成网页模板</li>
<li><code>Alt + Z</code>：自动换行</li>
<li><code>F2</code>：选中变量并按此键可以重命名变量</li>
<li><code>Ctrl + ~</code>：开启终端</li>
<li><code>Ctrl + Shift + K</code>：默认为删除当前行，但因为键长原因，可以去设置-键盘快捷方式中修改为 <code>Ctrl + D</code> </li>
</ul>
<h3 id="2-插件"><a href="#2-插件" class="headerlink" title="(2).插件"></a>(2).插件</h3><p><code>Bracket Pair Colorizer 2</code>：可以给代码中的括号、中括号、大括号进行着色来区分不同的代码块</p>
<ul>
<li>作者在 2021年12月14日发布通知以后将不再更新，因为 VSCode 本地已经支持该功能</li>
<li>但本人实测在 HTML 文件中的括号部分不会着色，可以配合使用</li>
</ul>
<p><code>Chinese (Simplified) Language Pack for Visual Studio</code>：中文插件</p>
<p><code>Color Highlight</code>：预览颜色代码，<code>可匹配 html/css/scss/sass/javascript/typescript</code> 等文件中的颜色代码</p>
<ul>
<li>在设置中还可以修改显示状态，默认为背景显示，还有边框显示，方块显示，下划线显示以及字体颜色显示</li>
</ul>
<p><code>Easy LESS</code>：支持运行less文件</p>
<p><code>ESlint</code>：规范代码格式</p>
<p><code>Git history</code>：查看Git提交记录</p>
<p><code>language-stylus</code>：支持 styl 文件的高亮显示</p>
<p><code>Live Server</code>：为静态和动态页面启动本地服务器</p>
<p><code>Markdown Preview Enhanced</code>：可以预览 Markdown 文件</p>
<p><code>ngx-translate-utils</code>：Angular 使用 ngx-translate 翻译时可以在代码中气泡显示翻译内容，并可直接跳转到对应翻译文件，需要去插件设置中设置本地语言</p>
<ul>
<li>如果 html 文件无效的话需要修改配置文件中 <code>Ngx-translate-utils: Translate JSONPlaceholder</code> 的值，将 <code>&#123;key&#125;</code> 换成 <code>&#123;&#123;key&#125;&#125;</code> </li>
</ul>
<p><code>Nunjucks</code>：支持 njk 文件的高亮显示</p>
<p><code>Open in External App</code>：将某个文件以外置应用方式打开</p>
<p><code>SQL Server (mssql)</code>：可连接数据库</p>
<p><code>Swig(.tpl)</code>：支持 swig 文件的高亮显示</p>
<p><code>Tiny Light</code>：主题插件 —— 仿HBuilder的柔绿色主题</p>
<p><code>VSCode Great Icons</code>：图标插件 —— 比较鲜艳的图标</p>
<p><code>wechat-snippet</code>：微信小程序代码片段自动完成</p>
<p><code>wxapp-helper</code>：微信小程序开发助手</p>
<p><code>微信小程序扩展</code>：一个灵活、好用、持续维护的微信小程序拓展</p>
<p><code>code runner</code>：可以右键运行代码</p>
<h3 id="3-技巧"><a href="#3-技巧" class="headerlink" title="(3).技巧"></a>(3).技巧</h3><h4 id="强制折叠注释代码"><a href="#强制折叠注释代码" class="headerlink" title="强制折叠注释代码"></a>强制折叠注释代码</h4><p>可以使用 <code>region</code> 来控制代码是否强制折叠</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#region</span><br><span class="line">public <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>

<h1 id="三、Adobe软件"><a href="#三、Adobe软件" class="headerlink" title="三、Adobe软件"></a>三、Adobe软件</h1><h2 id="1-Photoshop"><a href="#1-Photoshop" class="headerlink" title="1.Photoshop"></a>1.Photoshop</h2><ul>
<li><code>Ctrl + K</code>：首选项</li>
<li><code>Ctrl + N</code>：新建画布</li>
<li><code>Ctrl + S</code>：保存</li>
<li><code>Ctrl + Shift + S</code>：另存为</li>
<li><code>Ctrl + Shift + Alt + S</code>：存储为Web所用形式</li>
<li><code>Ctrl + +/-</code>：画布的放大缩小</li>
<li><code>Ctrl + Z</code>：返回上一步</li>
<li><code>Ctrl + Alt + Z</code>：返回多步</li>
</ul>
<h2 id="2-PR"><a href="#2-PR" class="headerlink" title="2.PR"></a>2.PR</h2><p><strong>主界面下</strong>：</p>
<ul>
<li><code>Ctrl + I</code>：导入素材</li>
<li><code>Ctrl + N</code>：新建序列</li>
<li><code>Ctrl + O</code>：打开项目</li>
<li><code>Ctrl + Alt + N</code>：新建项目</li>
</ul>
<p><strong>源.视频下：</strong></p>
<ul>
<li><code>i</code>：标记入点</li>
<li><code>o</code>：标记出点</li>
</ul>
<p><strong>时间轴中：</strong></p>
<ul>
<li><code>m</code>：标记点</li>
<li><code>S</code>：磁铁自动吸附</li>
<li><code>Alt + 左键</code>：点击音频可以只选择音频，然后进行删除</li>
<li><code>Alt + 左键 + 移动</code>：可以复制当前选中的素材</li>
<li><code>Ctrl + L</code>：点击素材时可以取消视音频链接</li>
<li><code>Ctrl + Shift + M</code>：向左移动标记点</li>
<li><code>Ctrl + Shift + 双击</code>：双击轨道处可以快速还原轨道的高度为默认大小</li>
<li><code>Shift + M</code>：向右移动标记点</li>
</ul>
<p><strong>调整图层下：</strong></p>
<ul>
<li><code>Ctrl + K</code>：选中调整图层时可以直接以当前点进行裁切</li>
<li><code>Shift + ←/→</code>：可以以5帧为一单位进行跳转</li>
</ul>
<p><strong>某一窗口</strong>下：</p>
<ul>
<li><code>~</code>：放大窗口</li>
</ul>
<h1 id="四、数据库软件"><a href="#四、数据库软件" class="headerlink" title="四、数据库软件"></a>四、数据库软件</h1><h2 id="1-Navicat"><a href="#1-Navicat" class="headerlink" title="1.Navicat"></a>1.Navicat</h2><ul>
<li><code>Ctrl + D</code>：复制当前行</li>
<li><code>Ctrl + Shift + R</code>：运行已选择的代码</li>
<li><code>Shift + End</code>：光标在行首时，选中当前行</li>
<li><code>Shift + Home</code>：光标在行尾时，选中当前行</li>
</ul>
<h1 id="五、其余软件"><a href="#五、其余软件" class="headerlink" title="五、其余软件"></a>五、其余软件</h1><h2 id="1-BitDock"><a href="#1-BitDock" class="headerlink" title="1.BitDock"></a>1.BitDock</h2><ul>
<li><code>Alt + D</code>：呼出Dock栏</li>
<li><code>Alt + H</code>：隐藏Dock栏</li>
<li><code>Alt + I</code>：隐藏/显示桌面图标</li>
<li><code>Alt + P</code>：电源管理</li>
<li><code>Alt + Q</code>：打开自带Launch</li>
<li><code>Alt + T</code>：打开Dock设置</li>
</ul>
<h2 id="2-Chrome"><a href="#2-Chrome" class="headerlink" title="2.Chrome"></a>2.Chrome</h2><h3 id="1-插件"><a href="#1-插件" class="headerlink" title="(1).插件"></a>(1).插件</h3><p><code>Ads Killer Adblocker Plus</code>：从所有网站中移除广告</p>
<p><code>Auto Tab Discard</code>：如果你打开了很多标签页，这个扩展能提升浏览器速度和减少内存占用</p>
<p><strong style="color:red;"><code>FeHelper(前端助手)</code></strong>： JSON自动格式化、手动格式化，支持排序、解码、下载等</p>
<p><strong style="color:red;"><code>Font Rendering Enhancer</code></strong>：使页面上的文字颜色更深、更清晰</p>
<p><code>IE Tab</code>：在Chrome浏览器中使用IE显示网页</p>
<p><code>Infinity 新标签页</code>：自由添加网站图标，云端高清壁纸，快速访问书签、天气、笔记、待办事项、扩展管理与历史记录</p>
<p><code>SteamDB</code>：可以查看 Steam 上最低的游戏价格和统计</p>
<p><code>二维码（生成及识别）</code>：将当前页面地址、选中的文本或链接等生成二维码，也可以识别网页中的二维码图片（支持识别中文）</p>
<p><code>沙拉查词</code>：一款专业划词翻译扩展</p>
<p><code>图片另存为JPG/PNG/WebP</code>：为图片添加右键菜单：另存为PNG，另存为JPG，另存为WebP</p>
<p><code>下载管理</code>：用于接管浏览器自带的下载功能，免去打开下载页面来查看下载文件的麻烦</p>
<h2 id="3-Snipaste"><a href="#3-Snipaste" class="headerlink" title="3.Snipaste"></a>3.Snipaste</h2><ul>
<li>本人将该软件的截图和贴图更改为了 F3 和 F4</li>
<li>但是贴图的”切换另一贴图组“功能会与 Quicker 软件的关闭网页标签重复，导致 Quicker 无法正常关闭网页标签</li>
<li>所以该选项如果不常用可以不设置快捷键或换其他快捷键</li>
</ul>
]]></content>
      <categories>
        <category>个人收藏</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title>玩机：一加刷机一站式教程</title>
    <url>/Oneplus.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>关于一加刷机的一些步骤和技巧</li>
<li>这里写下来是为了防止自己遗忘的，毕竟现在刷机也不经常刷了<span id="more"></span></li>
</ul>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="!写在前面!"></a><font color=#F00>!写在前面!</font></h1><ul>
<li>双清前或者刷系统或者恢复出厂时一定要退出谷歌账号，不然首次启动时不翻墙是无法跳过谷歌验证的</li>
<li>大侠阿木云盘：<a href="https://yun.daxiaamu.com/">查看链接</a></li>
</ul>
<h2 id="1-刷机前的备份"><a href="#1-刷机前的备份" class="headerlink" title="1.刷机前的备份"></a>1.刷机前的备份</h2><ul>
<li>照片：相册、截图、QQ图片、微信/企业微信图片、酷安图片、微博、谷歌相册</li>
<li>云备份：照片、便签、联系人、日历、短信</li>
<li>聊天记录：QQ、微信、企业微信、Telegram</li>
<li>软件：搞机软件、常用软件</li>
<li>文档文件：QQ下载、微信下载、浏览器下载、酷安下载</li>
<li>软件配置：账号本子、存储重定向、灭霸、Lawnchair</li>
</ul>
<h3 id="必备份的软件"><a href="#必备份的软件" class="headerlink" title="!必备份的软件!"></a>!必备份的软件!</h3><ul>
<li>QQ、微信、企业微信、Telegram</li>
<li>via浏览器、账号本子、阅读、冰箱、V2Ray、老王VPN、PerfectColorBar、全局负一屏、灭霸、WPS、</li>
</ul>
<h2 id="2-刷机前的准备"><a href="#2-刷机前的准备" class="headerlink" title="2.刷机前的准备"></a>2.刷机前的准备</h2><ul>
<li>关闭 Magisk所有模块</li>
<li>关闭 Edxposed所有模块</li>
<li>取消锁屏密码、退出谷歌账号</li>
<li>将所有软件从冰箱中解冻出来</li>
<li>适配当前版本的 TWRP、Magisk、Riru、Edxposed 的模块</li>
<li>适配当前版本的全量包</li>
</ul>
<h2 id="3-刷机后的流程"><a href="#3-刷机后的流程" class="headerlink" title="3.刷机后的流程"></a>3.刷机后的流程</h2><ul>
<li>刷入 Magisk、Edxposed/LSPosed 并成功激活框架</li>
<li>恢复梯子备份，安装谷歌框架</li>
<li>安装存储重定向以及灭霸，并将所有设置配置好</li>
<li>安装谷歌商店的部分软件</li>
</ul>
<h1 id="一、解锁篇"><a href="#一、解锁篇" class="headerlink" title="一、解锁篇"></a>一、解锁篇</h1><h2 id="1-ADB命令法"><a href="#1-ADB命令法" class="headerlink" title="1.ADB命令法"></a>1.ADB命令法</h2><ul>
<li><p>手机打开开发者模式（设置→关于手机→快速连按5次版本号开启），然后在开发者模式中设置 OEM锁为允许，这个解锁以后就要一直开着，没事不要手欠去关了。并且打开 USB 调试开关。</p>
</li>
<li><p>安装ADB工具包到电脑，ADB下载链接点 <a href="https://pan.baidu.com/s/1kSoo4rxnS-lZilbJrSA_NQ#list/path=%2F">这里</a></p>
</li>
<li><p>启动到 bootloader 模式（设置→开发者选项→打开高级重启），按电源键选择“引导加载器”重启，或者使用adb 命令让手机重启进入 bootloader 界面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure></li>
<li><p>首次进入 bootloader 模式下连接电脑要确定驱动自动安装成功，一定要耐心等待并确定驱动安装完成，否则会影响到后面的使用，进 bootloader 刷机可能会出现 waiting for device 的提示</p>
</li>
<li><p>成功进入 bootloader 绿色机器人界面以后，输入以下命令开始解锁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot oem unlock</span><br></pre></td></tr></table></figure></li>
<li><p>此时手机会出现一个选择界面，通过音量键定位光标到 unlock 的选项，按电源键确认即可解锁了，注意这一步会丢失所有数据，包括照片，所以提前做好备份，不过，解锁终身只要一次，以后的 root 和官方系统升级操作，通常都不会再丢数据。</p>
</li>
<li><p>解锁完成后，通过命令退出bootloader并重启手机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure></li>
<li><p>重启手机，自带的应用程序有一部分会丢失，联网后静放一会看是否会恢复回来，如果不行的话手动刷一下当前版本的全量包即可。各版本全量包请点击 <a href="https://www.oneplusbbs.com/forum.php?mod=viewthread&tid=4733198">这里</a></p>
</li>
<li><p>全量包刷取方法：下载全量包，放到手机存储的根目录，然后打开手机设置-系统-系统更新-右上角齿轮图标-本地升级</p>
</li>
</ul>
<h2 id="2-工具箱无脑法"><a href="#2-工具箱无脑法" class="headerlink" title="2.工具箱无脑法"></a>2.工具箱无脑法</h2><ul>
<li>这里推荐 <code>@千古风流帝</code> 的工具箱，原文链接在 <a href="https://www.oneplusbbs.com/thread-4701007-1.html">这里</a></li>
<li>该工具箱里包含了解锁、TWRP、Root 等一系列无脑操作</li>
</ul>
<h2 id="3-上锁方法"><a href="#3-上锁方法" class="headerlink" title="3.上锁方法"></a>3.上锁方法</h2><ul>
<li>重新上锁前记得先确定已经完全消除 Root</li>
<li>进入 bootloader 界面，在cmd窗口内输入adb命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot oem lock</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、REC（即TWRP）篇"><a href="#二、REC（即TWRP）篇" class="headerlink" title="二、REC（即TWRP）篇"></a>二、REC（即TWRP）篇</h1><h2 id="1-有-Magisk的方法"><a href="#1-有-Magisk的方法" class="headerlink" title="1.有 Magisk的方法"></a>1.有 Magisk的方法</h2><ul>
<li>下载对应安卓版本的 TWRP卡刷包</li>
<li>在 Magisk刷模块的界面刷入 TWRP即可</li>
</ul>
<h2 id="2-无-Magisk的方法"><a href="#2-无-Magisk的方法" class="headerlink" title="2.无 Magisk的方法"></a>2.无 Magisk的方法</h2><ul>
<li>下载 <a href="https://yunpan.360.cn/surl_yubQxZ83BTQ">这里</a> 的与当前手机系统相对应的文件并且解压文件</li>
<li>手机解锁以后，手机进 fastboot模式，插入数据线</li>
<li>打开以 <code>.bat</code> 结尾的文件 ，输入 <code>fastboot flash boot twrp-boot.img</code> 回车，等待出现两个OK以后就算成功刷入了<br><img src="https://s1.ax1x.com/2020/10/15/0oBoZT.png" alt="REC1.png"></li>
<li>然后手机按音量键移动到 <code>recovery mode</code> ，按电源键确认</li>
<li>等手机进 TWRP之后默认是英文，点击 settings，然后点击最右边的小按钮，选择 Chinese 并点击 Set language ，这样就变成中文了</li>
<li>输入密码或者手势进 TWRP主界面，接着点击 高级-一加工具箱-Magisk，安装好后重启系统就可以了</li>
<li>原文看 <a href="https://www.oneplusbbs.com/forum.php?mod=viewthread&tid=5055277">这里</a>，只看安卓Q的部分</li>
</ul>
<h2 id="3-一加5t版"><a href="#3-一加5t版" class="headerlink" title="3.一加5t版"></a>3.一加5t版</h2><ul>
<li>下载 Official TWRP APP，选择一加5t，下载最新安卓10的 TWRP 的 img 文件</li>
<li>先用工具箱刷入安卓9的 TWRP</li>
<li>然后在安卓9的 TWRP 中直接刷入之前下载好的安卓10的 img 镜像</li>
<li>然后重启进入恢复模式，即进入新版 TWRP 中</li>
<li>刷入支持安卓10的 Magisk 包（应该在20.1版本以上），不要重启</li>
<li>最后再刷1次新版 TWRP 的 img 镜像即可重启进入系统</li>
</ul>
<h1 id="三、Root（即Magisk）篇"><a href="#三、Root（即Magisk）篇" class="headerlink" title="三、Root（即Magisk）篇"></a>三、Root（即Magisk）篇</h1><ul>
<li>先重启手机到新的TWRP，选择 高级→ADB Sideload，滑动按钮开始（这步很重要）</li>
<li>在 cmd窗口输入以下命令刷入 Magisk的卡刷包<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb sideload (卡刷包的名字).zip</span><br></pre></td></tr></table></figure></li>
<li>成功后直接点击重启系统，就能在手机抽屉里找到安装好的 Magisk管理器，ROOT即已完成</li>
<li><font color=#F00>注：最新官方版TWRP可以不用以下教程，直接将卡刷包拷贝到手机上刷入</font></li>
</ul>
<h1 id="四、系统更新篇"><a href="#四、系统更新篇" class="headerlink" title="四、系统更新篇"></a>四、系统更新篇</h1><h2 id="1-同一个安卓版本下的更新"><a href="#1-同一个安卓版本下的更新" class="headerlink" title="1.同一个安卓版本下的更新"></a>1.同一个安卓版本下的更新</h2><h3 id="1-保留-TWRP-的方法"><a href="#1-保留-TWRP-的方法" class="headerlink" title="(1).保留 TWRP 的方法"></a>(1).保留 TWRP 的方法</h3><ul>
<li><p>先安装官方的系统更新，建议直接下载全量包然后本地更新，在安装完成之后不要立即去点重启手机<br><img src="https://s1.ax1x.com/2020/10/15/0oDcm6.jpg" alt="系统更新1.jpg"></p>
</li>
<li><p>打开 magisk 下载里面搜索 TWRP，选择第一个下载并安装<br><img src="https://s1.ax1x.com/2020/10/15/0oDXtg.jpg" alt="系统更新3.jpg"></p>
</li>
<li><p>如果这里无法下载的话，你也可以下载 <a href="https://pan.baidu.com/s/1g3-USNsOBqTXzBqzwLiWkg">这里</a> （提取码: r1b6），然后像刷入模块一样刷入即可</p>
</li>
<li><p>刷入完成后如果想要保留 root 不要重启，返回 magisk 首页执行下面操作</p>
</li>
</ul>
<h3 id="2-保留-root-的方法（安装最新Magisk）"><a href="#2-保留-root-的方法（安装最新Magisk）" class="headerlink" title="(2).保留 root 的方法（安装最新Magisk）"></a>(2).保留 root 的方法（安装最新Magisk）</h3><ul>
<li>先安装官方的系统更新，建议直接下载全量包然后本地更新，在安装完成之后不要立即去点重启手机<br><img src="https://s1.ax1x.com/2020/10/15/0oDcm6.jpg" alt="系统更新1.jpg"></li>
<li>打开 Magisk Manager，点击安装/更新Magisk，然后选择 <code>安装到未使用的槽位（OTA后）</code> 直到看到“Next reboot will boot to second slot！”，以及提示“All done”，也就是下图右三我红字圈出来的文字<br><img src="https://s1.ax1x.com/2020/10/15/0oDjhQ.jpg" alt="系统更新2.jpg"></li>
<li>然后重启即可正常成功保留 root</li>
</ul>
<h3 id="3-保留-root-的方法（安装旧版Magisk）"><a href="#3-保留-root-的方法（安装旧版Magisk）" class="headerlink" title="(3).保留 root 的方法（安装旧版Magisk）"></a>(3).保留 root 的方法（安装旧版Magisk）</h3><ul>
<li>提前准备好旧版 Magisk 的卡刷包和 Twrp 的卡刷包</li>
<li>先下载官方的系统更新（或直接下载全量包但不安装），下载完成以后系统会自动安装，<font color=#F00>此时不要让它安装，立即执行下一步，不然会回到官方 rec</font></li>
<li>长按关机键，重启到恢复模式，点击安装找到 <code>.ota</code> 文件夹，刷入下载好的系统但不重启</li>
<li>安装 Twrp 卡刷包但不重启系统，返回主界面重启到 rec</li>
<li>安装旧版本的 Magisk 卡刷包并重启</li>
</ul>
<h2 id="2-不同安卓版本下的更新"><a href="#2-不同安卓版本下的更新" class="headerlink" title="2.不同安卓版本下的更新"></a>2.不同安卓版本下的更新</h2><h3 id="0-保留TWRP和Root-！！！推荐"><a href="#0-保留TWRP和Root-！！！推荐" class="headerlink" title="(0).保留TWRP和Root ！！！推荐"></a>(0).保留TWRP和Root ！！！推荐</h3><ul>
<li>升级前去 Magisk 取消或卸载所有模块（建议卸载，防止部分模块问题卡开机，可后续再刷入）</li>
<li>将新版的 TWRP（安卓9的 TWRP 不支持安卓10，推荐版本为70或71的 TWRP）和Magisk（不是必须的，但推荐20.1版本）压缩包放到文件根目录，重启手机（这里重启是为了让模块卸载生效）</li>
<li>通过OTA推送或是下载全量包升级，无论何种方式升级，在更新后不要重启手机</li>
<li>到 Magisk 中点击安装，安装到未使用卡槽，安装完后返回，不要重启</li>
<li>进入 Magisk 模块界面，像安装模块一样点击+号，刷入前面放好的 TWRP，不要重启，点击返回</li>
<li>点击 Magisk 右上角，选择重启到 Recovery，重启后等待一会儿，会进入到 TWRP 界面，输入解锁密码进入 TWRP，并刷入之前放好的 Magisk，完成后点击重启，此时，手机已获取永久 Root 权限且保留 TWRP 和 Magisk</li>
<li>手机重启后只需耐心等待一段时间，大概三五分钟，就会进入到 H2OS 界面，开机后输入密码，升级成功，然后可以去 Magisk 刷入其他模块，慢慢享受（建议一个个刷入，防止模块冲突或不适应造成重启卡机）</li>
</ul>
<h3 id="1-保留-TWRP-的方法-1"><a href="#1-保留-TWRP-的方法-1" class="headerlink" title="(1).保留 TWRP 的方法"></a>(1).保留 TWRP 的方法</h3><ul>
<li>貌似跨安卓版本时上面的方法并不适用，所以可以试试这种办法</li>
<li>像上面一样安装完系统更新以后，不要重启，进入 Magisk 中刷入与你将要刷的安卓版本相对应的 TWRP</li>
<li>刷完以后不要重启，进行保留 root 的方法</li>
</ul>
<h3 id="2-保留-root-的方法"><a href="#2-保留-root-的方法" class="headerlink" title="(2).保留 root 的方法"></a>(2).保留 root 的方法</h3><ul>
<li>跨版本保留 root 时，尽量先把开启的模块禁用甚至是卸载</li>
<li>然后像上面的方法安装到另一个槽位，然后重启即可</li>
</ul>
<h2 id="3-有-TWRP-的刷入方法"><a href="#3-有-TWRP-的刷入方法" class="headerlink" title="3.有 TWRP 的刷入方法"></a>3.有 TWRP 的刷入方法</h2><ul>
<li>首先准备需要升的系统的全量包、REC卡刷包和 Magisk面具包</li>
<li>重启进入 REC 里刷入全量包，再刷入 REC卡刷包，再刷入 Magisk面具包，最后刷一遍REC卡刷包</li>
<li>上面中间任意一步都不可以重启，只有最后一次刷完 REC 以后才可以重启</li>
<li><font color=#FF0000>注意：该方法不确定跨安卓版本时是否适用，谨慎操作</font></li>
</ul>
<h2 id="4-手贱重启手机丢失-root-的方法（更新中）"><a href="#4-手贱重启手机丢失-root-的方法（更新中）" class="headerlink" title="4.手贱重启手机丢失 root 的方法（更新中）"></a>4.手贱重启手机丢失 root 的方法（更新中）</h2><ul>
<li><p>解锁，然后用数据线连电脑，通过一条命令，让手机重启进入bootloader界面:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">adb reboot bootloader</span><br></pre></td></tr></table></figure></li>
<li><p>下载 Magisk Root补丁 <code>magisk_patched.img</code>，注意选择和系统版本号匹配的版本，再通过命令引导启动Root补丁，获得临时Root权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastboot boot magisk_patched.img</span><br></pre></td></tr></table></figure></li>
<li><p>这里命令中的 <code>magisk_patched.img</code> 需要和该文件的路径保持一致，如果就在adb工具的同路径，直接这么写即可。如果不是，需要和下图这样带完整路径（或者拖拽文件到命令行界面也行）<br><img src="https://s1.ax1x.com/2020/10/15/0oDOAS.png" alt="系统更新4.png"></p>
</li>
<li><p>此时手机会自动重启，开机后，安装 <code>MagiskManager.apk</code> ，打开后会看到 Magisk 已安装，但这个 Magisk 只是临时的，重启手机之后会丢失</p>
</li>
<li><p>所以需要手动再操作一遍安装 Magisk，选择 <code>直接安装（推荐）</code>，提示安装成功后，就获得了永久的Root权限，重启不丢失</p>
</li>
<li><p>关于上面说的两个文件，目前还没有找到</p>
</li>
</ul>
<h2 id="5-安卓10升级安卓11"><a href="#5-安卓10升级安卓11" class="headerlink" title="5.安卓10升级安卓11"></a>5.安卓10升级安卓11</h2><blockquote>
<p>这里我是从安卓10的公测18直接升安卓11的公测1，理论上稳定版也通用</p>
</blockquote>
<h3 id="1-升级"><a href="#1-升级" class="headerlink" title="(1).升级"></a>(1).升级</h3><ul>
<li>首先需要在b18刷入安卓10可用的TWRP</li>
<li>进入 twrp 中格式化 data，然后重启到 twrp（一定记得是重启到twrp而不是系统，因为这样会导致data重新加密）</li>
<li>在 twrp 中用数据线连接电脑，把上面的3个文件和氢11的全量包复制到手机里面</li>
<li>然后在 twrp 中刷入氢11版本（大概5-6分钟），接着刷入 twrp，再次重启到 twrp</li>
<li>刷入 Disable 开头的解密补丁文件，接着刷入 Magisk，重启到系统，此时已经正常升级到氢11并刷入了 twrp 和 Magisk</li>
</ul>
<h3 id="2-更新"><a href="#2-更新" class="headerlink" title="(2).更新"></a>(2).更新</h3><ul>
<li>如果进入系统后发现丢失了很多内置app或者想要更新到新版系统，请按如下操作：</li>
<li>先进入 Magisk 查看 Magisk 有没有成功刷入，如果成功刷入再进行以下操作</li>
<li>去系统更新界面使用本地更新刷入当前系统全量包或者最新系统的全量包，成功刷入以后不要重启</li>
<li>去 Magisk 中以本地安装的方式刷入 twrp，然后重启到 twrp 中</li>
<li>在 twrp 中刷入 Magisk 和 解密补丁，然后就可以直接重启到系统中了</li>
<li>以后每次升级系统都这样进行操作一下即可</li>
</ul>
<h3 id="3-注意"><a href="#3-注意" class="headerlink" title="(3).注意"></a>(3).注意</h3><ul>
<li>氢10从 b15 后官核不支持解密data导致刷入会卡开机，目前不知道氢11哪个版本也会如此操作</li>
<li>如果以后新版本刷入解密补丁开不了机时，可以进行如下选择的操作：<ul>
<li>重新格式化 data</li>
<li>重刷当前版本的原版boot，放弃解密data</li>
<li>使用第三方内核，一般都支持解密data（但建议补刷阻止加密data补丁）</li>
</ul>
</li>
</ul>
<h1 id="五、官方降级篇"><a href="#五、官方降级篇" class="headerlink" title="五、官方降级篇"></a>五、官方降级篇</h1><h2 id="安卓10降安卓9"><a href="#安卓10降安卓9" class="headerlink" title="安卓10降安卓9"></a>安卓10降安卓9</h2><ul>
<li>用一加搬家备份手机，备份后所有软件和资料都存在一个名称为 <code>opbackup</code> 的文件夹里</li>
<li>将 <code>opbackup</code> 文件夹复制到电脑里，等以后恢复手机用</li>
<li>在本地升级处刷入专用降级包（即双清全量包）进行降级，降级包下载地址点 <a href="http://download.h2os.com/OnePlus7/fulldowngrade_wipe_MSM_18857_190501_2342_user.zip">这里</a></li>
<li>开机重启后在本地升级处刷入一加7安卓9的 9.5.8全量包，全量包下载地址点 <a href="http://download.h2os.com/OnePlus7/MP/OnePlus7Hydrogen_14.H.14_OTA_014_all_1908301703_8e29ef5336fa4eea.zip">这里</a></li>
<li>成功刷回安卓9稳定版，打开一加搬家选择恢复数据</li>
<li><font color=#F00>注意：降级并不会回锁，而且如果手机系统应用出现故障，可以通过降级然后直接OTA更新回最新系统</font></li>
</ul>
<h1 id="六、刷-ROM-篇"><a href="#六、刷-ROM-篇" class="headerlink" title="六、刷 ROM 篇"></a>六、刷 ROM 篇</h1><h2 id="1-稳定刷公测篇"><a href="#1-稳定刷公测篇" class="headerlink" title="1.稳定刷公测篇"></a>1.稳定刷公测篇</h2><ul>
<li>目前未收录</li>
</ul>
<h2 id="2-氢OS刷氧OS篇"><a href="#2-氢OS刷氧OS篇" class="headerlink" title="2.氢OS刷氧OS篇"></a>2.氢OS刷氧OS篇</h2><h3 id="1-注意"><a href="#1-注意" class="headerlink" title="(1).注意"></a>(1).注意</h3><ul>
<li>在刷之前一定要退出谷歌、一加账号；关闭无线流量并取出SIM卡，防止开机卡谷歌验证</li>
<li>刷完之后一定要去REC中双清，防止无法登录谷歌账号</li>
</ul>
<h3 id="2-步骤"><a href="#2-步骤" class="headerlink" title="(2).步骤"></a>(2).步骤</h3><ul>
<li>完成账号与网络与SIM卡的退出</li>
<li>下载氧OS全量包（一定要比当前氢OS的版本高）</li>
<li>在本地升级处刷入氧OS</li>
<li>刷完后重启进入TWRP中，执行双清重启即可</li>
</ul>
<h3 id="3-回氢之法"><a href="#3-回氢之法" class="headerlink" title="(3).回氢之法"></a>(3).回氢之法</h3><ul>
<li>本地升级方法：刷同级或更高级的氢系统</li>
<li>TWRP方法：直接刷</li>
</ul>
<h2 id="3-氢OS刷类原生篇"><a href="#3-氢OS刷类原生篇" class="headerlink" title="3.氢OS刷类原生篇"></a>3.氢OS刷类原生篇</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><ul>
<li>此方法没有试验过，存疑</li>
<li>清理 data</li>
<li>重启进入 TWRP，刷氧底包，刷 TWRP，重启进入TWRP（如果不行的话，这里再重复一次，玄学）</li>
<li>刷包，刷 TWRP，重启进入 TWRP （如果不行的话，这里再重复一次，玄学）</li>
<li>刷 Magisk 和 Gapps，开机</li>
</ul>
<h2 id="4-氧OS刷PE-plus"><a href="#4-氧OS刷PE-plus" class="headerlink" title="4.氧OS刷PE plus"></a>4.氧OS刷PE plus</h2><h3 id="1-准备"><a href="#1-准备" class="headerlink" title="(1).准备"></a>(1).准备</h3><ul>
<li><p>PE plus卡刷包：<a href="https://download.pixelexperience.org/">官网链接</a></p>
</li>
<li><p>刷机前一定要拔掉SIM卡！这是跳过开机验证的最好方法！</p>
</li>
</ul>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="(2).方法"></a>(2).方法</h3><ol>
<li><p>全清（清除data、cache、dalvik、system），刷入 ROM</p>
</li>
<li><p>刷入解密补丁并开机</p>
</li>
<li><p>关机，刷入 Magisk（至少20.1版本 以上）</p>
</li>
<li><p>根据步骤走，不要联网，一直跳过</p>
</li>
<li><p>登录谷歌账号，需要工具</p>
</li>
<li><p>根据 Google 设置向导进行谷歌设置</p>
</li>
</ol>
<h1 id="七、9008-救砖篇"><a href="#七、9008-救砖篇" class="headerlink" title="七、9008 救砖篇"></a>七、9008 救砖篇</h1><h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h2><ul>
<li>所需工具下载点 <a href="https://pan.baidu.com/s/1cZXjgdQYmptg_KlTh7r5Fg#list/path=%2F">这里</a>，密码：<strong>lbwa</strong></li>
<li>下载线刷格式的 Rom包，下载下来放到电脑上进行解压</li>
<li>电脑下载安装 Qualcomm 驱动（记得先禁用驱动签名验证，禁用方法点 <a href="http://iknow.lenovo.com/detail/dc_132524.html?clickid=VQHXKY1N9xyOUDswUx0Mo3Q3UknX1lR2Ly-GQQ0&Program=4037&pid=357605&acid=ww:affiliate:lx67i4&cid=sg:affiliate:q97yci">这里</a>）</li>
<li>这里引用的论坛里的教程，原贴在 <a href="http://www.oneplusbbs.com/thread-4446250-1-1.html">这里</a></li>
<li><font color=#F00>注意：如果之前电脑如果有安装过9008驱动的，可能会出现连接手机后一旦把音量键放开，手机就会开机到 fastboot模式，如有出现此情况，你需要连接电脑后按住音量双键不放，并电脑点击桌面计算机右键→设备管理器，找到并卸载干净9008驱动，再重新下载安装「一加7专用的9008驱动」即可</font></li>
</ul>
<h2 id="1-安装底层驱动"><a href="#1-安装底层驱动" class="headerlink" title="1.安装底层驱动"></a>1.安装底层驱动</h2><ul>
<li>完全关机状态下按住 <strong>左侧音量+</strong> 不放，同时插入数据线，等待 <strong>PC</strong> 识别到 <strong>QHSUSB BULCK</strong>设备</li>
<li>打开设备管理器，在 <strong>QHSUSB BULCK</strong> 上点右键—更新驱动程序—-浏览计算机以查找驱动程序软件，定位到驱动文件夹，点下一步，出现红色警告框选择<strong>始终安装此驱动程序</strong>，直到提示安装完成<br><img src="https://i.loli.net/2020/03/01/zg8bRSIsDCOAP24.png" alt="救砖1.png"></li>
<li>打开设备管理器，查看 <strong>端口（COM和LPT）</strong>，如果出现 <strong>Qualcomm HS-USB QDLoader 9008</strong> 或者 <strong>Qualcomm HS-USB Diagnostics 9006</strong> 底层驱动就安装好了<br><img src="https://i.loli.net/2020/03/01/e9kDn85EqpFVahZ.png" alt="救砖2.png"></li>
</ul>
<h2 id="2-开始线刷"><a href="#2-开始线刷" class="headerlink" title="2.开始线刷"></a>2.开始线刷</h2><ul>
<li><p>把线刷格式的 Rom包电脑上进行解压，解压出来一个文件夹，然后在文件夹里还有一个文件夹，里面就有线刷要用到的文件<br><img src="https://i.loli.net/2020/03/01/H5olDmgei1YKqBP.png" alt="救砖3.png"></p>
</li>
<li><p>进入解压出来的文件夹，接着找到<strong>【MsmDownloadTool V3.0.exe】</strong>文件，点击鼠标右键以管理员身份运行<br><img src="https://i.loli.net/2020/03/01/MQuFSW1l7kfaEvG.png" alt="救砖4.png"></p>
</li>
<li><p>接着 <strong>完全关机（很重要）</strong>，即同时按住音量增加键和电源键，在屏幕变黑以后立即松手</p>
<ul>
<li><p>还能进入fastboot的：就进入fastboot，按音量键选择power off关掉电源</p>
</li>
<li><p>完全黑砖的：长按电源键40s，等一分钟</p>
</li>
</ul>
</li>
<li><p>同时按住手机的 <strong>音量加减键</strong> 不放的同时用数据线连接电脑</p>
</li>
<li><p>如果刷机工具没有显示，点击 <strong>Enum</strong> 键刷新一下</p>
</li>
<li><p>当出现 com端口时表示连接正常<br><img src="https://i.loli.net/2020/03/01/UAgeB1LDF34nJ5f.png" alt="救砖5.png"></p>
</li>
<li><p>然后点击 <strong>Start</strong> 开始刷机，刷机过程中软件会有进度条显示，此时就可以松开音量键了</p>
</li>
<li><p>完成后软件会有刷机成功的提示，此时我们拔掉数据线等待开机即可</p>
</li>
</ul>
<h2 id="3-更新系统"><a href="#3-更新系统" class="headerlink" title="3.更新系统"></a>3.更新系统</h2><ul>
<li>线刷仅仅用于救砖，救砖之后还是尽快刷回官方原版的固件系统包</li>
<li>可以 OTA 亦可以直接刷全量包</li>
</ul>
<h3 id="！注意："><a href="#！注意：" class="headerlink" title="！注意："></a><font color=#F00>！注意：</font></h3><ul>
<li>9008 以后只能 OTA 或者卡刷同安卓版本的全量包</li>
<li>以一加5t为例：9008 以后为安卓7.1.1，且该版本无法连接无线网，需要分别卡刷安卓7的最后一个版本、安卓8的第一个版本、安卓8的最后一个版本、安卓9的第一个版本和安卓9的最后一个版本</li>
</ul>
<h1 id="八、安卓10优化篇"><a href="#八、安卓10优化篇" class="headerlink" title="八、安卓10优化篇"></a>八、安卓10优化篇</h1><h2 id="1-刷内核"><a href="#1-刷内核" class="headerlink" title="1.刷内核"></a>1.刷内核</h2><ul>
<li>干掉一加服务的模块：刷内核之后防止异常满频</li>
</ul>
<h2 id="2-小横条修改"><a href="#2-小横条修改" class="headerlink" title="2.小横条修改"></a>2.小横条修改</h2><h2 id="3-小横条隐藏"><a href="#3-小横条隐藏" class="headerlink" title="3.小横条隐藏"></a>3.小横条隐藏</h2><h1 id="九、手机软件篇"><a href="#九、手机软件篇" class="headerlink" title="九、手机软件篇"></a>九、手机软件篇</h1><h2 id="0-LSPosed"><a href="#0-LSPosed" class="headerlink" title="0.LSPosed"></a>0.LSPosed</h2><h3 id="1-常用软件作用域"><a href="#1-常用软件作用域" class="headerlink" title="(1).常用软件作用域"></a>(1).常用软件作用域</h3><ul>
<li>核心破解、绿色守护、Thanox、PerfectColor：Android系统（系统框架）</li>
<li>Xposed Edge Pro：SystemUI（系统界面）</li>
<li>Chimi：模块文档有介绍</li>
<li>验证码提取器：Android系统（系统框架）、电话服务</li>
<li>一加拓展、重力工具箱：系统框架、系统界面</li>
</ul>
<h2 id="1-灭霸（即thanox）"><a href="#1-灭霸（即thanox）" class="headerlink" title="1.灭霸（即thanox）"></a>1.灭霸（即thanox）</h2><h3 id="0-引言"><a href="#0-引言" class="headerlink" title="(0).引言"></a>(0).引言</h3><ul>
<li>建议直接刷入 <code>@城北栀花开</code> 的备份（<a href="https://www.coolapk.com/feed/19433186?shareKey=MjI0NmRiMDE1NWQwNWYxMTg3NDE~&shareUid=1519576&shareFrom=com.coolapk.market_10.4">点击这里</a>）</li>
<li>然后根据自己需求进行修改</li>
</ul>
<h3 id="1-加速-后台启动"><a href="#1-加速-后台启动" class="headerlink" title="(1).加速-后台启动"></a>(1).加速-后台启动</h3><ul>
<li>启用后 <strong>允许选中的应用自启动、关联启动</strong> </li>
<li>简单说来就是 —— 不想让某软件自启动，就禁用它</li>
<li>如果禁用以后还是会启动（俗称压不死，可以在右上角启动记录里看到），那么就需要右上角添加规则，规则如：<code>DENY * 应用包名</code></li>
</ul>
<h3 id="2-拓展-移花接木"><a href="#2-拓展-移花接木" class="headerlink" title="(2).拓展-移花接木"></a>(2).拓展-移花接木</h3><ul>
<li>该功能主要是用来 <strong>跳过软件的开屏广告</strong> 的</li>
<li>将灭霸的 <strong>设置-开发者-显示当前活动</strong> 的开关打开</li>
<li>打开一个有开屏广告的软件，复制小框中的活动，添加在<font color=#F00>原Activity</font>中</li>
<li>等广告结束，进入软件主界面后，复制小框中的活动，添加在<font color=#F00>替换为Activity</font>中</li>
</ul>
<h3 id="3-拓展-乖巧模式"><a href="#3-拓展-乖巧模式" class="headerlink" title="(3).拓展-乖巧模式"></a>(3).拓展-乖巧模式</h3><ul>
<li>可以参考桓清山的方案进行添加，直接在灭霸里找到该应用，点服务，长按即可添加到乖巧规则内</li>
</ul>
<h3 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="(4).注意事项"></a>(4).注意事项</h3><ul>
<li>QQ 音乐软件无法显示导航栏的播放条是因为 <strong>查询意图活动</strong> 权限被关掉了，打开即可</li>
</ul>
<h2 id="2-存储空间隔离"><a href="#2-存储空间隔离" class="headerlink" title="2.存储空间隔离"></a>2.存储空间隔离</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="(1).准备工作"></a>(1).准备工作</h3><ul>
<li>官网：<a href="https://sr.rikka.app/zh-hans/guide/">点击这里</a></li>
<li>安装软件，刷增强模块</li>
<li>开启在线规则 <strong>设置-在线规则</strong></li>
<li>建立标准文件夹模板 <strong>设置-行为-可访问文件夹模板</strong> 。这里建议将默认的进行拆分，因为照片和保存的图片是不一样的。如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">照片（标准文件夹）		DCIM</span><br><span class="line">图片（标准文件夹）		Picture</span><br><span class="line">音乐（标准文件夹）		Music</span><br><span class="line">录屏（标准文件夹）		Movies</span><br><span class="line">录音（标准文件夹）		Record</span><br><span class="line">下载（标准文件夹）		Download</span><br><span class="line">文档（标准文件夹）		Documents</span><br><span class="line">Wrysmile（私人文件夹）  Wrysmile</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-重定向配置篇"><a href="#2-重定向配置篇" class="headerlink" title="(2).重定向配置篇"></a>(2).重定向配置篇</h3><ul>
<li>可访问的文件夹：根据不同 App 进行配置，如地图软件仅仅需要导航，就不需要让他访问这些文件夹</li>
<li>导出被隔离的文件：这个操作只能作用于被隔离空间，例如 QQ 保存的文件在 Tencent 中，而 Tencent 刚好是被隔离空间， 那么就可以将该文件导出到<strong>可访问的文件夹</strong>中</li>
</ul>
<h3 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="(3).注意事项"></a>(3).注意事项</h3><ul>
<li>QQ 和微信重定向以后，会互相看不到保存的图片，需要在 <strong>可访问的文件夹</strong> 中添加对方的文件夹</li>
<li>如果因未知原因导致购买失效显示恢复试用时，可以尝试删除 <code>/data/adb/storage-isolation/bin/local.license</code> 后重新启动服务</li>
</ul>
<h3 id="4-无需重定向软件"><a href="#4-无需重定向软件" class="headerlink" title="(4).无需重定向软件"></a>(4).无需重定向软件</h3><ul>
<li>轻雨图标包</li>
</ul>
<h3 id="5-支付宝插件问题"><a href="#5-支付宝插件问题" class="headerlink" title="(5).支付宝插件问题"></a>(5).支付宝插件问题</h3><ul>
<li>支付宝插件一般有 <strong>秋风、XQ_Crystal、蜡笔小新</strong></li>
<li>支付宝重定向后悔导致这些插件无法读取到支付宝信息，需要按如下进行设置：<ul>
<li>如果插件需要开启重定向就先开启重定向</li>
<li>然后在支付宝的 <strong>可访问的文件夹</strong> - <strong>其他应用的文件夹</strong> 中选择上面插件的文件夹即可</li>
</ul>
</li>
</ul>
<h2 id="3-via浏览器"><a href="#3-via浏览器" class="headerlink" title="3.via浏览器"></a>3.via浏览器</h2><h3 id="1-获取主页代码"><a href="#1-获取主页代码" class="headerlink" title="(1).获取主页代码"></a>(1).获取主页代码</h3><ul>
<li>如果手机已经 Root，那么使用RE、ES等文件管理软件进入该目录进行查看 —— <code>/data/user/0/mark.via/files/homepage.html</code></li>
<li>如果有电脑，可以打开调试开关，到电脑浏览器里 inspect 调试主页</li>
<li>复制下面代码，粘贴到浏览器的地址栏并进入，可以读取到主页代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:a=document.querySelector(&quot;html&quot;).innerHTML;b=document.createElement(&quot;textarea&quot;);b.innerHTML=a;b.style.position=&quot;absolute&quot;;b.style.top=&quot;45%&quot;;b.style.left=&quot;5%&quot;;b.style.height=&quot;50%&quot;;b.style.width=&quot;90%&quot;;b.style.backgroundColor=&quot;#FFFFCC&quot;;document.body.appendChild(b);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-标题栏随机一句古诗词"><a href="#2-标题栏随机一句古诗词" class="headerlink" title="(2).标题栏随机一句古诗词"></a>(2).标题栏随机一句古诗词</h3><ul>
<li>在 <strong>设置-定制-Logo-HTML代码</strong> 中，将下面的代码粘贴进去即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;http://yijuzhan.com/api/word.php?m=js&quot;&gt;&lt;/script&gt; </span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">/*Via 标题栏随机一句古诗词(适用于任何网页)</span><br><span class="line">//Made by z1576796635 on May 28, 2017 . </span><br><span class="line">//Powered by YiJu , h t t p : / / y i j u . m l</span><br><span class="line">*/</span><br><span class="line">var s = false; //显示来源信息，true为显示，false为不显示，默认不显示</span><br><span class="line">var t =document.getElementsByTagName(&quot;title&quot;)[0];</span><br><span class="line">if(s)&#123;</span><br><span class="line">t.innerHTML = str[0]+str[1];</span><br><span class="line">&#125;else&#123;</span><br><span class="line">t.innerHTML = str[0];</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-搜索框与书签整体上移"><a href="#3-搜索框与书签整体上移" class="headerlink" title="(3).搜索框与书签整体上移"></a>(3).搜索框与书签整体上移</h3><ul>
<li>在 <strong>设置-定制-设置-添加自定义CSS</strong> 中粘贴以下内容，并自行修改百分比<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#content&#123; top: 10%;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-搜索框与书签互换位置"><a href="#4-搜索框与书签互换位置" class="headerlink" title="(4).搜索框与书签互换位置"></a>(4).搜索框与书签互换位置</h3><ul>
<li>在 <strong>设置-定制-设置-添加自定义CSS</strong> 中粘贴以下内容，并自行修改百分比<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#content &#123; display:flex; flex-direction:column-reverse; bottom:10%&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-首页添加书签和历史入口"><a href="#5-首页添加书签和历史入口" class="headerlink" title="(5).首页添加书签和历史入口"></a>(5).首页添加书签和历史入口</h3><ul>
<li>在菜单中找到 <strong>添加书签</strong> 按钮</li>
<li>标题写 <code>书签</code>，地址写 <code>folder://</code>，文件夹不要管，并勾选 <strong>添加到主页</strong></li>
<li>标题写 <code>历史</code>，地址写 <code>history://</code>，文件夹不要管，并勾选 <strong>添加到主页</strong></li>
</ul>
<h3 id="6-减小主页图标与侧边的距离"><a href="#6-减小主页图标与侧边的距离" class="headerlink" title="(6).减小主页图标与侧边的距离"></a>(6).减小主页图标与侧边的距离</h3><ul>
<li><p>官方主页在果味风格下，主页图标距离两边有点宽</p>
</li>
<li><p>在 <strong>设置-定制-设置-添加自定义CSS</strong> 中粘贴以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#box_container&#123;width:100%;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>修改完以后，一行显示的图标个数也会变多，一般是5个，个别手机可能会更多</p>
</li>
</ul>
<h3 id="7-搜索框与主页图标宽度一致"><a href="#7-搜索框与主页图标宽度一致" class="headerlink" title="(7).搜索框与主页图标宽度一致"></a>(7).搜索框与主页图标宽度一致</h3><ul>
<li><p>很明显，默认主页搜索框过长且图标过短</p>
</li>
<li><p>在 <strong>设置-定制-设置-添加自定义CSS</strong> 中粘贴以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.search_bar&#123;width:83%;&#125;</span><br><span class="line">#bookmark_part&#123;padding-left:6px;&#125;</span><br><span class="line">#box_container&#123;width:100%;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>每个手机对应数值可能不同，修改第一行和第二行参数即可，第一行为修改搜索框的长度，第二行为修改主页图标距离左边的距离，第三行是用来将盒子容器大小设置为父元素的100%，这个不用修改</p>
</li>
</ul>
<h3 id="7-增加主页每行显示图标"><a href="#7-增加主页每行显示图标" class="headerlink" title="(7).增加主页每行显示图标"></a>(7).增加主页每行显示图标</h3><ul>
<li><p>在 <strong>设置-定制-设置-添加自定义CSS</strong> 中粘贴以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#box_container .box&#123;width: 60px;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>里面数字越小，一排显示的图标越多</p>
</li>
</ul>
<h3 id="8-搜索框内添加文字"><a href="#8-搜索框内添加文字" class="headerlink" title="(8).搜索框内添加文字"></a>(8).搜索框内添加文字</h3><ul>
<li><p>在 <strong>设置-定制-Logo-HTML代码</strong> 中粘贴以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">document.querySelector(&quot;#search_input&quot;).placeholder=&quot;Hello World！&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>如果想要修改字体颜色和显示位置，在 <strong>设置-定制-设置-添加自定义CSS</strong> 中粘贴以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//纯色</span><br><span class="line">#search_input::-webkit-input-placeholder &#123; color: red;text-align:center;&#125;</span><br><span class="line">//渐变色</span><br><span class="line">#search_input::-webkit-input-placeholder &#123; background: linear-gradient(to right, #147B96, #E6D205); -webkit-background-clip: text; color: transparent;text-align:center;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><ul>
<li>上面渐变色中的 css</li>
<li><code>background: linear-gradient(to right, red, blue);</code> 是给背景设置为渐变色</li>
<li><code>-webkit-background-clip: text;</code>  规定背景的绘制区域及以区块内的文字作为裁剪区域向外裁剪，文字的背景即为区块的背景，文字之外的区域都将被裁剪掉</li>
<li><code>color: transparent;</code> 正因为文字的背景即为区块的背景，所以需要把文字的颜色设置为透明</li>
</ul>
<h3 id="9-搜索框半透明效果"><a href="#9-搜索框半透明效果" class="headerlink" title="(9).搜索框半透明效果"></a>(9).搜索框半透明效果</h3><ul>
<li>在 <strong>设置-定制-设置-添加自定义CSS</strong> 中粘贴以下内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.search_bar&#123;background:rgba(255,255,255,0.5);&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-搜索框晕影效果"><a href="#10-搜索框晕影效果" class="headerlink" title="(10).搜索框晕影效果"></a>(10).搜索框晕影效果</h3><ul>
<li>在 <strong>设置-定制-设置-添加自定义CSS</strong> 中粘贴以下内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.search_bar &#123;</span><br><span class="line">    box-shadow: 0 0 18px rgba(70,70,40,.255);</span><br><span class="line">    -webkit-animation: fadeIn 2.5s;</span><br><span class="line">    animation: fadeIn 2.5s;</span><br><span class="line">    background-color: rgba(255,255,255,.100);</span><br><span class="line">    border-radius: 50px;</span><br><span class="line">    display: table;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">    width: 80%;</span><br><span class="line">    height: 40px;</span><br><span class="line">    max-width: 400px;</span><br><span class="line">    margin: 10px auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-微信"><a href="#4-微信" class="headerlink" title="4.微信"></a>4.微信</h2><h3 id="1-网名下面加下划线"><a href="#1-网名下面加下划线" class="headerlink" title="(1).网名下面加下划线"></a>(1).网名下面加下划线</h3><ul>
<li>因为代码特殊需要通过公众号发放，关注 <code>Wrysmile 的小站</code> 公众号，回复 <font color=#FF0000>微信01</font> 即可获得</li>
<li>复制收到的内容，到昵称那里先删掉你原本的昵称，然后粘贴，粘贴一次写一个字</li>
<li>注意：该代码仅可在 Android 机子上显示，在 IOS 和 Windows 上会显示乱码，如下：<br><img src="https://s2.ax1x.com/2020/02/18/3FNXXn.th.png" alt="3FNXXn.th.png"></li>
</ul>
<h3 id="2-朋友圈个性签名竖行显示"><a href="#2-朋友圈个性签名竖行显示" class="headerlink" title="(2).朋友圈个性签名竖行显示"></a>(2).朋友圈个性签名竖行显示</h3><ul>
<li>苹果手机端：先再好友列表一个字换行一个字换行的打出来，然后整体复制到个性签名那里就可以了</li>
<li>安卓手机端：直接在个性签名界面打字换行即可。</li>
</ul>
<h3 id="3-朋友圈粘贴的内容不折叠"><a href="#3-朋友圈粘贴的内容不折叠" class="headerlink" title="(3).朋友圈粘贴的内容不折叠"></a>(3).朋友圈粘贴的内容不折叠</h3><ul>
<li>先在发朋友圈的地方打几个字，整体选中然后粘贴你要复制的内容即可</li>
</ul>
<h3 id="4-关闭朋友圈个性化广告"><a href="#4-关闭朋友圈个性化广告" class="headerlink" title="(4).关闭朋友圈个性化广告"></a>(4).关闭朋友圈个性化广告</h3><ul>
<li>依次进入以下目录进行相应设置，注意该方法只可以关闭该功能6个月，6个月以后还需要重新进行设置</li>
<li>微信主界面 - 我 - 设置 - 关于微信 -《隐私保护指引》</li>
<li>然后下拉有个第四点 - 4.我们如何使用信息 - 关于广告 - 管理</li>
<li>在这个页面右上角登录你需要关闭广告的账号，然后下拉把开关关掉即可</li>
</ul>
<h2 id="5-阅读"><a href="#5-阅读" class="headerlink" title="5.阅读"></a>5.阅读</h2><ul>
<li>阅读是一款开源的，可以自定义来源阅读网络内容的工具，为广大网络文学爱好者提供一种方便、快捷舒适的试读体验，下载请前往<a href="https://www.coolapk.com/apk/io.legado.app.release">这里</a>，建议关注作者公众号 <code>开源阅读</code> ，基本教程都有</li>
</ul>
<h3 id="1-背景与字体"><a href="#1-背景与字体" class="headerlink" title="(1).背景与字体"></a>(1).背景与字体</h3><ul>
<li>修改背景、字体以及页面调整，请点击<a href="https://mp.weixin.qq.com/s/1JOuv4-p6zyIkqfN-0LYqA">这里</a></li>
</ul>
<h3 id="2-订阅源"><a href="#2-订阅源" class="headerlink" title="(2).订阅源"></a>(2).订阅源</h3><ul>
<li>一个比较好的订阅源仓库：<a href="http://yck.mumuceo.com/">前往</a></li>
</ul>
<h4 id="书源订阅"><a href="#书源订阅" class="headerlink" title="书源订阅"></a>书源订阅</h4><ul>
<li>这里推荐几个比较质量高的书源，直接使用网络导入即可</li>
<li>一程：<code>https://gitee.com/vpq/codes/kiy2st16c4l5fqov7hnjg26/raw?blob_name=sy.json</code></li>
<li>namofree：<code>https://gitee.com/namofree/yuedu3/raw/legado3booksource/legado3_booksource_by_Namo.json</code></li>
<li>南笙星辰：<code>https://gitee.com/ch4nge/readbook/raw/master/booksource9</code></li>
<li>芜恙：<code>https://gitee.com/slaijie/legado/raw/master/legado/faloo.json</code></li>
</ul>
<h4 id="杂志订阅"><a href="#杂志订阅" class="headerlink" title="杂志订阅"></a>杂志订阅</h4><ul>
<li>直接网络导入即可</li>
<li><code>https://gitee.com/slght/yuedu_booksource/raw/master/%E4%B9%A6%E6%BA%90/%E6%9D%82%E5%BF%97%E8%AE%A2%E9%98%85.json</code> </li>
</ul>
<h3 id="3-备份与恢复"><a href="#3-备份与恢复" class="headerlink" title="(3).备份与恢复"></a>(3).备份与恢复</h3><ul>
<li>备份支持本地备份与云备份（WebDav）</li>
<li>云备份建议备份到坚果云，且会在软件进入与退出时进行相应的备份与恢复，<font color=#F00><strong>也就是说可以在两个以上设备上进行同步设置、阅读进度等内容（只要有网）</strong></font></li>
<li>云备份步骤请看作者发布的教程：<a href="https://mp.weixin.qq.com/s/DxGsn9W2yT7s-ITUk_HSGw">前往</a></li>
</ul>
<h2 id="6-腾讯QQ"><a href="#6-腾讯QQ" class="headerlink" title="6.腾讯QQ"></a>6.腾讯QQ</h2><h3 id="1-无Root保存闪照"><a href="#1-无Root保存闪照" class="headerlink" title="(1).无Root保存闪照"></a>(1).无Root保存闪照</h3><ul>
<li>在收到闪照时不要打开它，先使用自带手机浏览器找到如下路径：<code>Android/data/com.tencent.mobileqq/Tencent/MobileQQ/chatpic/chatimg/</code></li>
<li>把 <code>chatimg</code> 文件夹下的所有文件夹全选以后直接删除掉</li>
<li>进入QQ点开闪照，<font color=#F00><strong>但不要长按</strong></font>，即停在显示马赛克的页面即可</li>
<li>此时 <code>chatimg</code> 文件夹中就会多了一个文件夹</li>
<li>进入该文件夹把里面唯一的一个文件加上图片后缀（即.jpg）即可</li>
</ul>
<h2 id="7-重力工具箱"><a href="#7-重力工具箱" class="headerlink" title="7.重力工具箱"></a>7.重力工具箱</h2><h3 id="1-系统框架未响应问题"><a href="#1-系统框架未响应问题" class="headerlink" title="(1).系统框架未响应问题"></a>(1).系统框架未响应问题</h3><ul>
<li>如果出现该种情况，试试找到该文件 <code>/data/adb/modules/riru_edxposed/post-fs-data.sh</code> </li>
<li>找到 <code>sepolicy()</code> 字段，看看其代码块中的 <code>supolicy</code> 字段前面是否用#号注释掉了，如果是删掉#号即可</li>
<li><strong>貌似在最新版的edxp中该段并未被注释，自测。</strong></li>
</ul>
<h2 id="8-检测Root软件"><a href="#8-检测Root软件" class="headerlink" title="8.检测Root软件"></a>8.检测Root软件</h2><h3 id="1-农业银行"><a href="#1-农业银行" class="headerlink" title="(1).农业银行"></a>(1).农业银行</h3><ul>
<li>安装以后禁止读取应用列表</li>
<li>Magisk 中随机包名，Magisk hide</li>
<li>Edxposed中黑名单</li>
<li>关闭 <code>isolateservice</code> 服务</li>
<li>开启 SELinux（使用镧）</li>
</ul>
<h1 id="十、问题集合篇"><a href="#十、问题集合篇" class="headerlink" title="十、问题集合篇"></a>十、问题集合篇</h1><h2 id="1-密码问题"><a href="#1-密码问题" class="headerlink" title="1.密码问题"></a>1.密码问题</h2><ul>
<li>手机密码千真万确，但就是提示密码错误进不了系统</li>
<li>方法一：不担心数据，直接9008即可</li>
<li>方法二：担心数据，提取当前系统刷机包的内核，重新刷一下内核即可</li>
</ul>
<h2 id="2-数据清理问题"><a href="#2-数据清理问题" class="headerlink" title="2.数据清理问题"></a>2.数据清理问题</h2><ul>
<li><font color=#F00>双清会导致系统应用丢失，所以需要刷全量包来补救，但又会掉 Root ，所以需要按以下操作</font></li>
<li>先进 REC进行双清操作，然后刷全量包，刷REC，刷Magisk，刷REC重启。</li>
<li>进系统以后再重启到 REC，格式化 data分区（为了删除内置存储上的文件），此时所有文件被清理，系统应用丢失</li>
<li>然后进系统，用电脑传进手机全量包、REC和Magisk</li>
<li>最后进REC，刷全量包，刷REC，刷Magisk，刷REC重启</li>
</ul>
<h2 id="3-刷入模块进不了系统问题"><a href="#3-刷入模块进不了系统问题" class="headerlink" title="3.刷入模块进不了系统问题"></a>3.刷入模块进不了系统问题</h2><ul>
<li>按电源+音量减键进入TWRP</li>
<li>在 高级 - 文件管理 - data - adb - modules 删除相应模块即可</li>
</ul>
<h2 id="4-面具反复刷新问题"><a href="#4-面具反复刷新问题" class="headerlink" title="4.面具反复刷新问题"></a>4.面具反复刷新问题</h2><ul>
<li>如果没有梯子的话，更新面具时就会一直转圈，按下面的方法就可以了</li>
<li>打开面具，在 <strong>设置 - 更新通道 - 自定义</strong> 中输入以下网址即可：</li>
<li><code>https://qianyegroup.gitee.io/magiskbuilds/updates/custom.json </code></li>
<li><code>http://magisk.tsyinpin.com/canary.json</code> </li>
<li><code>https://gitee.com/QingFeiDeiYi/Magisk/raw/master/stable.json</code></li>
</ul>
<h2 id="5-框架未安装问题"><a href="#5-框架未安装问题" class="headerlink" title="5.框架未安装问题"></a>5.框架未安装问题</h2><ul>
<li>面具成功安装，edxp的模块也成功安装，但是显示未安装</li>
<li>试试将面具设置里面的 <strong>核心功能模式</strong> 关掉</li>
</ul>
<h2 id="6-双清、三清、四清"><a href="#6-双清、三清、四清" class="headerlink" title="6.双清、三清、四清"></a>6.双清、三清、四清</h2><ul>
<li><p>双清：<br><code>wipe data/factory reset</code>：清除用户数据并恢复出厂设置（刷机前必须执行的选项）<br><code>wipe cache partition</code>：清除系统缓存（刷机前执行（系统出问题也可尝试此选项，一般能够解决</p>
</li>
<li><p>三清：<br><code>wipe data/factory reset</code>：清除用户数据并恢复出厂设置（刷机前必须执行的选项）<br><code>wipe cache partition</code>：清除系统缓存（刷机前执行（系统出问题也可尝试此选项，一般能够解决<br><code>Wipe  Dalvik  Cache</code>：清空虚拟机缓存（可以解决一些程序FC的问题）</p>
</li>
<li><p>四清：<br><code>wipe data/factory reset</code>：清除用户数据并恢复出厂设置（刷机前必须执行的选项）<br><code>wipe cache partition</code>：清除系统缓存（刷机前执行（系统出问题也可尝试此选项，一般能够解决<br><code>Wipe  Dalvik  Cache</code>：清空虚拟机缓存（可以解决一些程序FC的问题）<br><code>Wipe  Battery  Stats</code>: 清空电池调试记录数据（刷机前做下这个，会比较好，感觉自己电量有问题的机油也可以试试）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>一加</tag>
        <tag>玩机技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue开发：TypeScript开发Vue3项目</title>
    <url>/Vue-Of-TypeScript.html</url>
    <content><![CDATA[<center>用 TypeScript 全面拥抱 Vue 吧！</center>

<span id="more"></span>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在 Vue3 中使用 TypeScript，可以使用官方的 <strong>Vue-Class-Component</strong> 插件来开发</p>
<p>本文介绍的也是基于该插件来开发的</p>
<p><strong>文档</strong>：<a href="https://class-component.vuejs.org/">官方链接</a> / <a href="https://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_20210725.html">翻译</a></p>
<p><strong>注意</strong>：文档并不是最新的，可关注 Issue 部分</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p><strong style="color:#42b983;">原 Vue 开发方式</strong>：直接在 <code>Computed</code> 将所需内容通过函数返回即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attr">firstName</span>: <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line">		lastName: <span class="string">&#x27;Mike&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	<span class="function"><span class="title">name</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong style="color:#42b983;">Class 开发方式</strong>：将原 <code>Computed</code> 函数拆封成 <code>getter/setter</code> 方式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> firstName = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> lastName = <span class="string">&#x27;Mike&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>)&#123;</span><br><span class="line">	<span class="keyword">const</span> splited = value.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">	<span class="built_in">this</span>.firstName = splited[<span class="number">0</span>];</span><br><span class="line">	<span class="built_in">this</span>.lastName = splited[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue开发：三方库扩充功能</title>
    <url>/Vue-OtherRep.html</url>
    <content><![CDATA[<center>不会偷懒的程序员不是一个好的程序员 (bushi</center>

<center>但是，有现成封装好的组件库为什么不用呢？</center>
<span id="more"></span>

<h1 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h1><h2 id="1-v-for循环图表时只显示第一个图表"><a href="#1-v-for循环图表时只显示第一个图表" class="headerlink" title="1.v-for循环图表时只显示第一个图表"></a>1.v-for循环图表时只显示第一个图表</h2><p><strong>错误现象</strong>：当某个子组件专门封装了一个Echarts图表，在父组件中循环子组件时会出现只有第一个子组件可以正常渲染，剩下的子组件图表不正常显示</p>
<p><strong>错误原因</strong>：因为在循环的时候 Echarts 图表的容器id都是一样的，导致 Vue 无法判断后面几个图表怎么渲染，所以就显示异常</p>
<p><strong>解决办法</strong>：当使用 <code>v-for</code> 时，我们可以获取到index值，因此直接在id上使用 ES6 的模板字符串引入这个index值，同时在实例化 Echarts 时也这样即可正常显示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;chart&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;`pieEcharts$&#123;index&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">const pieEcharts = echarts.init(document.getElementById(`pieEcharts$&#123;this.index&#125;`));</span><br></pre></td></tr></table></figure>

<h2 id="2-使用resize-方法时报错"><a href="#2-使用resize-方法时报错" class="headerlink" title="2.使用resize()方法时报错"></a>2.使用resize()方法时报错</h2><p><strong>报错信息</strong>：<code>Cannot read properties of undefined (reading &#39;type&#39;)</code></p>
<p><strong>报错原因</strong>：Vue3中使用 proxy 的方式监听响应式，Echarts 的实例会在 Vue 内部转换成响应式对象，从而在执行 <code>resize()</code> 方法时获取不到 <code>coordSys.type</code> </p>
<p><strong>解决办法</strong>：在实例化 Echarts 时，将其指定为非响应式即可，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> chartsInstance: echarts.ECharts = markRaw(echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;echarts&#x27;</span>)));</span><br></pre></td></tr></table></figure>

<p><strong>原文链接</strong>：源自 <a href="https://www.cnblogs.com/Bin-x/p/15342949.html">@Bin_x</a></p>
<h1 id="Font-Awesome"><a href="#Font-Awesome" class="headerlink" title="Font Awesome"></a>Font Awesome</h1><blockquote>
<p>我们常会在项目中使用各种的图标字体，Font Awesome 会是很多人不错的选择</p>
<p>Font Awesome 5也支持了在 Vue 中通过 Component 的形式来引入图标</p>
<p><a href="https://fontawesome.com/docs/web/use-with/vue/">官网</a>详细的说明了如何在 Vue 中引入，但却是针对于 Vue2的</p>
<p>以下总结 Vue3+Vue-cli5 中如何引入 Font Awesome</p>
</blockquote>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h2><p>根据如下命令进行安装依赖：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">// 安装核心库</span><br><span class="line">npm i --save @fortawesome/fontawesome-svg-core</span><br><span class="line"> </span><br><span class="line">// 安装免费图标类型（可选，并非全部安装）</span><br><span class="line">npm i --save @fortawesome/free-solid-svg-icons</span><br><span class="line">npm i --save @fortawesome/free-brands-svg-icons</span><br><span class="line">npm i --save @fortawesome/free-regular-svg-icons</span><br><span class="line"> </span><br><span class="line">// 安装 Font Awesome 在Vue中的组件</span><br><span class="line">Vue2中： npm i --save @fortawesome/vue-fontawesome@latest</span><br><span class="line">Vue3中： npm i --save @fortawesome/vue-fontawesome@prerelease</span><br></pre></td></tr></table></figure>

<p>关于 Vue2 与 Vue3 安装的区别，可前往 <a href="https://github.com/FortAwesome/vue-fontawesome">GitHub</a> 进行查看</p>
<h2 id="2-注册"><a href="#2-注册" class="headerlink" title="2.注册"></a>2.注册</h2><p>根据 <a href="https://fontawesome.com/docs/web/use-with/vue/add-icons">官网</a> 流程操作即可，但需注意的是——官网中依然是 Vue2 的教程，所以你需要在 <code>main.js</code> 中这样更改：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue3 默认导出不再是 Vue 了</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"><span class="comment">// 引入库和图标类型（描边和实心）</span></span><br><span class="line"><span class="keyword">import</span> &#123; library &#125; <span class="keyword">from</span> <span class="string">&#x27;@fortawesome/fontawesome-svg-core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; faUserSecret &#125; <span class="keyword">from</span> <span class="string">&#x27;@fortawesome/free-solid-svg-icons&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; FontAwesomeIcon &#125; <span class="keyword">from</span> <span class="string">&#x27;@fortawesome/vue-fontawesome&#x27;</span>;</span><br><span class="line"><span class="comment">// 向库中按需引入图标</span></span><br><span class="line">library.add(faUserSecret);</span><br><span class="line"><span class="comment">// 创建 Vue 的实例</span></span><br><span class="line"><span class="keyword">const</span> app = createApp(App);</span><br><span class="line"><span class="comment">// 添加字体图标组件</span></span><br><span class="line">app.component(<span class="string">&#x27;font-awesome-icon&#x27;</span>, FontAwesomeIcon);</span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h2><p>当在 <code>main.js</code> 文件中添加字体图标组件后，我们就可以像正常的组件一样使用了，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// X 官网案例不生效，应该是Vue2下的</span><br><span class="line"><span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">icon</span>=<span class="string">&quot;fa-solid fa-user-secret&quot;</span> /&gt;</span></span><br><span class="line">// √ Github案例1生效</span><br><span class="line"><span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">icon</span>=<span class="string">&quot;user-secret&quot;</span> /&gt;</span></span><br><span class="line">// √ Github案例2生效(这里传入的第一个参数表示图标类型，第二个参数表示图标class名)</span><br><span class="line">// fas：solid，fab：brands，far：regular，fal：light，fad：duotone</span><br><span class="line"><span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">:icon</span>=<span class="string">&quot;[&#x27;fas&#x27;, &#x27;user-secret&#x27;]&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>将你的项目从Angular迁移至Vue需要注意什么？</title>
    <url>/Angular-Migrate-Vue.html</url>
    <content><![CDATA[<p>如果你是一名前端开发工程师</p>
<p>且正在尝试将你的项目从 <strong>Angular</strong>迁移至 <strong>Vue</strong></p>
<p>那么本篇文章可以帮你少踩一些坑</p>
<span id="more"></span>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>因为公司项目需要 TS 语言的支持</p>
<p>在开发项目时使用的是 <strong>Vue Class Component</strong> 写法，如下：</p>
<ul>
<li>文档：<a href="https://class-component.vuejs.org/">https://class-component.vuejs.org/</a></li>
<li>教程：<ul>
<li><a href="https://www.cnblogs.com/qingheshiguang/p/14696557.html">https://www.cnblogs.com/qingheshiguang/p/14696557.html</a></li>
<li><a href="https://blog.csdn.net/baidu_39195199/article/details/115678096">https://blog.csdn.net/baidu_39195199/article/details/115678096</a></li>
<li><a href="https://www.jianshu.com/p/3cbcdd766295">https://www.jianshu.com/p/3cbcdd766295</a></li>
</ul>
</li>
</ul>
<p>在本篇中涉及到的语法大部分都是基于此，请知悉</p>
<h1 id="LifeCycle"><a href="#LifeCycle" class="headerlink" title="LifeCycle"></a>LifeCycle</h1><table>
<thead>
<tr>
<th align="center">钩子</th>
<th align="center">Angular</th>
<th align="center">Vue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">构造函数</td>
<td align="center">constructor()</td>
<td align="center">created()</td>
</tr>
<tr>
<td align="center">初始化</td>
<td align="center">ngOnInit()</td>
<td align="center">mounted()</td>
</tr>
<tr>
<td align="center">视图渲染完成</td>
<td align="center">ngAfterViewInit()</td>
<td align="center">mounted()<strong style="color:red;">【存疑】</strong></td>
</tr>
</tbody></table>
<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><p><strong>Angular</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 ts 文件中</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloComponent</span> <span class="title">implements</span> <span class="title">OnInit</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Vue</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 vue 文件的 `&lt;script&gt;` 标签中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloComponent</span> <span class="keyword">extends</span> <span class="title">Vue</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="1-导入导出"><a href="#1-导入导出" class="headerlink" title="1. 导入导出"></a>1. 导入导出</h2><p><strong>Angular</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelOperationService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Vue</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;HttpRequestService&#125; <span class="keyword">from</span> <span class="string">&#x27;@/apis/http-service&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">ModelOperationService</span> <span class="keyword">extends</span> <span class="title">HttpRequestService</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-注入"><a href="#2-注入" class="headerlink" title="2.注入"></a>2.注入</h2><p><strong>Angular</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Angular 中是有构造函数的概念的，而一些服务是直接在构造函数中注入的</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> translateService: TranslateService</span>)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Vue</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Vue 中是没有构造函数的概念的，所以直接在导出的 class 中直接实例化即可</span></span><br><span class="line"><span class="keyword">private</span> userService = <span class="keyword">new</span> UserService();</span><br><span class="line"><span class="comment">// 同时多个组件使用同一个服务时，需要注意是否采用单例模式，例如用户信息，只需要在登录的时候获取即可</span></span><br><span class="line"><span class="comment">// 这里的SingleFactory是自己封装的单例模式</span></span><br><span class="line"><span class="keyword">private</span> userService = SingleFactory.getInstance(UserService);</span><br></pre></td></tr></table></figure>

<h1 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h1><h2 id="1-输入输出"><a href="#1-输入输出" class="headerlink" title="1.输入输出"></a>1.输入输出</h2><table>
<thead>
<tr>
<th align="center">比较项</th>
<th align="center">Angular</th>
<th align="center">Vue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入</td>
<td align="center">@Input()</td>
<td align="center">@Prop()</td>
</tr>
<tr>
<td align="center">输出</td>
<td align="center">@Output()</td>
<td align="center">@Emit()</td>
</tr>
<tr>
<td align="center">输入初始值</td>
<td align="center">可以通过 = 来直接赋值</td>
<td align="center">不可通过 = 直接设置初始值，需要使用 <code>default</code> 项来指明</td>
</tr>
<tr>
<td align="center">输出类型</td>
<td align="center">事件类型</td>
<td align="center">函数，且返回具体的值</td>
</tr>
<tr>
<td align="center">仓库</td>
<td align="center"></td>
<td align="center"><a href="https://github.com/kaorun343/vue-property-decorator">Github</a></td>
</tr>
</tbody></table>
<h2 id="2-引入子组件"><a href="#2-引入子组件" class="headerlink" title="2.引入子组件"></a>2.引入子组件</h2><p><strong>Angular</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;tag&#x27;</span>, &#123; <span class="attr">static</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> customerTag: CustomerTagComponent;</span><br></pre></td></tr></table></figure>

<p><strong>Vue</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模板</span></span><br><span class="line">&lt;CustomerTag ref=<span class="string">&quot;customerTag&quot;</span>&gt;&lt;/CustomerTag&gt;</span><br><span class="line"><span class="comment">// 逻辑</span></span><br><span class="line"><span class="meta">@Ref</span>(<span class="string">&#x27;customerTag&#x27;</span>)</span><br><span class="line"><span class="keyword">public</span> customerTag: CustomerTag;</span><br><span class="line">或</span><br><span class="line"><span class="meta">@Ref</span>(<span class="string">&#x27;customerTag&#x27;</span>)</span><br><span class="line"><span class="keyword">public</span> customerTag: InstanceType&lt;<span class="keyword">typeof</span> CustomerTag&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="3-获取组件中的元素"><a href="#3-获取组件中的元素" class="headerlink" title="3.获取组件中的元素"></a>3.获取组件中的元素</h2><p><strong>Angular</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过el来进行获取类名为total的元素</span></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> el: ElementRef</span>)</span> &#123; &#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">this</span>.el.nativeElement.querySelector(<span class="string">&#x27;.total&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Vue</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过ref来获取类名为total的元素</span></span><br><span class="line"><span class="meta">@Ref</span>(<span class="string">&#x27;total&#x27;</span>)</span><br><span class="line"><span class="keyword">public</span> total: HTMLDivElement;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="built_in">this</span>.container;</span><br></pre></td></tr></table></figure>

<h1 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h1><p>Angular 中自带了 formatDate 日期格式化</p>
<p>Vue解决方法：</p>
<ul>
<li><code>moment.js</code> —— vue-moment</li>
<li><code>day.js</code></li>
<li>自己封装格式化逻辑</li>
</ul>
<p>对比如下：</p>
<table>
<thead>
<tr>
<th align="center">比较项</th>
<th align="center">Moment.js</th>
<th align="center">Day.js</th>
<th align="center">date-fns</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>大小</strong></td>
<td align="center">16.7k（重）</td>
<td align="center">2.87k（轻）</td>
<td align="center">5.76k（轻）</td>
</tr>
<tr>
<td align="center"><strong>最后更新时间</strong></td>
<td align="center">2021.02（停止开发，仅维护）</td>
<td align="center">2021.09</td>
<td align="center">2021.12</td>
</tr>
<tr>
<td align="center"><strong>优势</strong></td>
<td align="center">支持number类型直接转换为时间对象</td>
<td align="center">返回新的实例，不可变数据，支持链式操作，API与Moment一致，支持插件</td>
<td align="center">模块化加载，适用复杂项目，不可变性和纯粹性</td>
</tr>
<tr>
<td align="center"><strong>劣势</strong></td>
<td align="center">可变对象</td>
<td align="center">不支持number类型直接转换</td>
<td align="center">不支持全局导入</td>
</tr>
<tr>
<td align="center"><strong>浏览器兼容</strong></td>
<td align="center">FireFox与Safari有异常</td>
<td align="center">全浏览器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>Tree-shaking</strong></td>
<td align="center">不支持</td>
<td align="center">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center"><strong>模式</strong></td>
<td align="center">OO</td>
<td align="center">OO</td>
<td align="center">Functional</td>
</tr>
<tr>
<td align="center"><strong>国际化</strong></td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center"><strong>TypeScript</strong></td>
<td align="center">支持</td>
<td align="center">支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="center"><strong>License</strong></td>
<td align="center">MIT</td>
<td align="center">MIT</td>
<td align="center">MIT</td>
</tr>
<tr>
<td align="center"><strong>文档</strong></td>
<td align="center"><a href="http://momentjs.cn/">中文</a></td>
<td align="center"><a href="https://dayjs.gitee.io/docs/zh-CN/installation/typescript">中文</a></td>
<td align="center"><a href="https://date-fns.org/docs/Getting-Started/">外文</a></td>
</tr>
<tr>
<td align="center"><strong>仓库</strong></td>
<td align="center"><a href="https://github.com/moment/moment">GitHub</a></td>
<td align="center"><a href="https://github.com/iamkun/dayjs">GitHub</a></td>
<td align="center"><a href="https://github.com/date-fns/date-fns">GitHub</a></td>
</tr>
</tbody></table>
<p>参考链接：</p>
<ul>
<li><a href="https://juejin.cn/post/6844903681029046280">【译】你可能不需要Moment.js</a></li>
<li><a href="https://duola8789.github.io/2017/04/26/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98/%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9809%20Moment.js%E5%92%8Cdate-fns/">零散专题09 Moment.js和date-fns</a></li>
<li><a href="https://www.yht7.com/news/25869">moment、dayjs、date-fns时间日期库比较</a></li>
</ul>
<h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><p>对比如下：</p>
<table>
<thead>
<tr>
<th align="center">比较项</th>
<th align="center">Angular</th>
<th align="center">Vue</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插件</td>
<td align="center">ngx-translate</td>
<td align="center">vue-i18n</td>
</tr>
<tr>
<td align="center">html内容中使用</td>
<td align="center"><code>&#123;&#123;'public' | translate&#125;&#125;</code></td>
<td align="center"><code>&#123;&#123; $t('public') &#125;&#125;</code></td>
</tr>
<tr>
<td align="center">html标签中使用</td>
<td align="center"><code>&lt;span translate=&#39;public&#39;&gt;&lt;/span&gt;</code></td>
<td align="center"><code>&lt;span v-t=&quot;&#39;public&#39;&quot;&gt;&lt;/span&gt;</code></td>
</tr>
<tr>
<td align="center">属性中使用</td>
<td align="center"></td>
<td align="center"><code>&lt;span :title=&quot;$t(&#39;public&#39;)&quot;&gt;public&lt;/span&gt;</code></td>
</tr>
<tr>
<td align="center">ts/js文件中使用</td>
<td align="center"><code>translate.instant(&#39;public&#39;)</code></td>
<td align="center"><code>this.translate.t(&#39;public&#39;);</code></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue开发：国际化项目</title>
    <url>/Vue-i18n.html</url>
    <content><![CDATA[<p><img src="https://s4.ax1x.com/2022/01/13/7M9w0H.png"></p>
<center>想要让自己的项目供不同国家的人使用</center>

<center>那么我推荐你使用 <strong>vue-i18n</strong> 来进行国际化项目</center>

<span id="more"></span>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p><strong>Vue3</strong> 与 <strong>Vue2</strong> 有一些<strong style="color:red;">破坏性的变化</strong>，导致组件的使用上有些不一样，以下选择合适自己的仓库与使用文档</p>
<h1 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h1><p><strong>Vue2：</strong></p>
<ul>
<li>仓库：<a href="https://github.com/kazupon/vue-i18n">前往</a></li>
<li>文档：<a href="https://kazupon.github.io/vue-i18n/">前往</a></li>
</ul>
<p><strong>Vue3：</strong></p>
<ul>
<li>仓库：<a href="https://github.com/intlify/vue-i18n-next">前往</a></li>
<li>文档：<a href="https://vue-i18n.intlify.dev/">前往</a></li>
</ul>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="动态参数翻译"><a href="#动态参数翻译" class="headerlink" title="动态参数翻译"></a>动态参数翻译</h2><p>即翻译文件中有某些地方需要通过传入的内容动态翻译</p>
<p>翻译文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;public&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;hello&quot;</span>: <span class="string">&quot;你好，&#123;world&#125;！&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译部分如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; $t(&#x27;public.hello&#x27;, &#123;world: &quot;世界&quot;&#125;) &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="翻译文件字段跟随动态参数变化"><a href="#翻译文件字段跟随动态参数变化" class="headerlink" title="翻译文件字段跟随动态参数变化"></a>翻译文件字段跟随动态参数变化</h2><p>即翻译文件中的属性名可以跟随动态参数进行变化</p>
<p>翻译文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;public&quot;</span>: &#123;</span><br><span class="line">		<span class="attr">&quot;this-is-#number#-day&quot;</span>: <span class="string">&quot;今天是&#123;number&#125;号&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>翻译部分如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; $t(&#x27;public.this-is-#number#-day&#x27;, &#123;number: 2&#125;) &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue开发：组件库美化项目</title>
    <url>/Vue-UI.html</url>
    <content><![CDATA[<p><img src="https://s4.ax1x.com/2022/01/13/7M9OuF.png"></p>
<center>不会偷懒的程序员不是一个好的程序员 (bushi</center>

<center>但是，有现成封装好的组件库为什么不用呢？</center>

<center>本文主要以 <strong style="color:red;">Ant Design Vue</strong> 为例</center>

<span id="more"></span>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h2><blockquote>
<p>根据 Ant Design 设计规范要求，我们会在按钮内(文本按钮和链接按钮除外)只有两个汉字时自动添加空格，如果你不需要这个特性，可以设置 ConfigProvider 的 autoInsertSpaceInButton 为 false。<br>——引自 Ant Design Vue 官网</p>
</blockquote>
<p>为了美观，官方会自动在文字中间添加空格，但有时我们可能并不需要，可以如下进行操作：</p>
<p>从 <strong>Antd</strong> 中引入 <code>ConfigProvider</code> 组件，然后将该 Button 包裹在 <code>ConfigProvider</code> 组件中，并设置 <code>autoInsertSpaceInButton</code> 属性即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a-config-provider</span> <span class="attr">:autoInsertSpaceInButton</span>=<span class="string">&quot;false&quot;</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span></span><br><span class="line">		按钮</span><br><span class="line">	<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a-config-provider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-DatePicker"><a href="#1-DatePicker" class="headerlink" title="1.DatePicker"></a>1.DatePicker</h2><p>该组件中可以通过 <code>disabled-date</code> 来限制可选择日期的范围，其通过箭头函数来返回需要限制的条件，官方写法如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> disabledDate = <span class="function">(<span class="params">current: Dayjs</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// Can not select days before today and today</span></span><br><span class="line">	<span class="keyword">return</span> current &amp;&amp; current &lt; dayjs().endOf(<span class="string">&#x27;day&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>参数 <code>current</code> 指的是当前时间选择面板的日期，语句 <code>dayjs().endOf(&#39;day&#39;)</code> 指的是返回当前 dayjs 对象并设置为时间末尾</p>
<p>整个返回语句表明今天和比时间末尾小的时间都不可以选择</p>
<h2 id="2-Table"><a href="#2-Table" class="headerlink" title="2.Table"></a>2.Table</h2><p><a href="https://blog.csdn.net/weixin_41301816/article/details/121055948">ant design 表格columns配置解析(text, record)</a></p>
<h3 id="设置复选框"><a href="#设置复选框" class="headerlink" title="设置复选框"></a>设置复选框</h3><p>需要给表格设置复选框时，如果从后台接收的源数据没有key值，则需要给源数据中指定 key 值用于区分选中的是哪一行</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this.historyList 从后台获取的源数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i: <span class="built_in">number</span> = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.historyList.length; i++) &#123;</span><br><span class="line">    <span class="built_in">this</span>.historyList[i].key = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改复选框"><a href="#修改复选框" class="headerlink" title="修改复选框"></a>修改复选框</h3><p><strong>现象</strong>：在 Antd 组件库表格中的复选框默认大小为<strong>16px</strong>，当开发人员手动修改复选框大小时，会发现复选框的对号位置整体偏右下了</p>
<p><strong>原因</strong>：造成该现象是因为修改宽高时真正变化的时右侧宽度和底部高度，而对号相对于复选框定位时，实际并没有变化，所以感官上感觉是偏右下移动了</p>
<p><strong>方法</strong>：只需要修改 <code>.ant-checkbox-inner::after</code> 该class中的left和top值让其重新定位即可解决</p>
<h2 id="ToolTip"><a href="#ToolTip" class="headerlink" title="ToolTip"></a>ToolTip</h2><h3 id="1-包裹元素被禁用时无法显示ToolTip"><a href="#1-包裹元素被禁用时无法显示ToolTip" class="headerlink" title="(1).包裹元素被禁用时无法显示ToolTip"></a>(1).包裹元素被禁用时无法显示ToolTip</h3><p>当 ToolTip 标签包裹的元素被禁用时就无法正常显示，如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ToolTip</span> <span class="attr">:title</span>=<span class="string">&quot;标题&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;true&quot;</span>&gt;</span>禁用<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ToolTip</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这时只要给被禁用元素套一层容器即可，<code>&lt;div&gt;/&lt;span&gt;</code> 等都可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ToolTip</span> <span class="attr">:title</span>=<span class="string">&quot;标题&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;true&quot;</span>&gt;</span>禁用<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ToolTip</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h2><h3 id="1-自定义节点"><a href="#1-自定义节点" class="headerlink" title="(1).自定义节点"></a>(1).自定义节点</h3><blockquote>
<p>在官网的案例及API中，只提到了如何自定义切换图标以及节点图标，唯独没有提到如何自定义节点，以下记录使用插槽来自定义节点使其具备添加删除按钮等</p>
</blockquote>
<h3 id="2-TypeScript类型定义"><a href="#2-TypeScript类型定义" class="headerlink" title="(2).TypeScript类型定义"></a>(2).TypeScript类型定义</h3><p>在 <strong>TypeScript</strong> 中需要给变量定义类型，包括函数参数返回值等，而针对于 tree 这个组件中，可能需要定义的类型如下：</p>
<ul>
<li><code>DataNode</code> ：表示树的每一个节点信息</li>
<li><code>EventDataNode</code> ：表示某些事件中的节点信息，如 <code>select()/expand()</code> 等事件</li>
<li><code>AntTreeNodeSelectedEvent</code> ：表示某些事件中返回的 Event 类型，如 <code>select()</code> 事件中的第二个参数就是该类型</li>
</ul>
<h3 id="3-Flex布局影响竖向滚动条"><a href="#3-Flex布局影响竖向滚动条" class="headerlink" title="(3).Flex布局影响竖向滚动条"></a>(3).Flex布局影响竖向滚动条</h3><p>如果该组件的父元素使用了 <strong>Flex</strong> 布局时，当该组件的层级较多时，会导致超出父元素的高度，这时并不会出现竖向滚动条</p>
<p>如果给 <code>&lt;a-tree&gt;</code> 的父元素设置高度时就不会超出父元素且会正常显示竖向滚动条，但此时高度固定</p>
<p>因此可以将高度设置为0，即 <code>height: 0;</code> ，这时高度就不是固定的了，会自动根据 <code>flex-grow: 1;</code> 来进行计算（该方法参考自<a href="https://www.cnblogs.com/strangerqt/p/6090173.html">@winenr123</a>）</p>
<h3 id="4-双击事件"><a href="#4-双击事件" class="headerlink" title="(4).双击事件"></a>(4).双击事件</h3><p>公司项目前端框架从 Angular 迁移到了 Vue3，所用组件库从 ng-zorro 迁移到了 ant design vue</p>
<p>在之前的组件库中是可以给树的节点绑定双击事件的，但现在的组件库中貌似并没有提供双击事件（至少在文档中是看不到的）</p>
<p>实际上如果查看源代码是有的，如下：</p>
<p>可以看到该该事件和 <code>select()</code> 类似的，同样接收两个参数</p>
<h2 id="Tree-Select"><a href="#Tree-Select" class="headerlink" title="Tree-Select"></a>Tree-Select</h2><h3 id="1-横线滚动丢失问题"><a href="#1-横线滚动丢失问题" class="headerlink" title="(1).横线滚动丢失问题"></a>(1).横线滚动丢失问题</h3><p>将该组件放入某些布局时，会导致下拉框中的内容无法横向滚动</p>
<p>这时需要使用<code>dropdownClassName=“tree-select-dropdown”</code> 字段给该组件设置class类名</p>
<p>然后修改相应样式来覆盖点原本的样式（需要放置在全局样式中）</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修复tree-select组件下拉框无横向滚动条问题</span></span><br><span class="line"><span class="selector-class">.tree-select-dropdown</span> &#123;</span><br><span class="line">    <span class="selector-class">.ant-select-tree-list-holder</span> &#123;</span><br><span class="line">        &amp; &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">            <span class="attribute">overflow</span>: unset <span class="meta">!important</span>;</span><br><span class="line">            <span class="selector-class">.ant-select-tree-node-content-wrapper</span> &#123;</span><br><span class="line">                <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Select"><a href="#3-Select" class="headerlink" title="3.Select"></a>3.Select</h2><p>关于 placeholder 的显示，Angular 和 Vue 下是不同的</p>
<ul>
<li>前者只需要将 value 为 <code>&#39;&#39;</code> 即可显示 placeholder</li>
<li>而后者需要将 value 设置为 <code>undefined</code> 才可以正常显示 placeholder</li>
</ul>
<h1 id="快速设置样式"><a href="#快速设置样式" class="headerlink" title="快速设置样式"></a>快速设置样式</h1><p>在 <strong>Angular</strong> 中可以使用 <code>:host ::ng-deep .ant-upload-drag</code> 来跳过DOM的层层嵌套直接定位到 <strong>upload</strong> 组件</p>
<p>在 <strong>Vue</strong> 中可以使用 <code>:deep(.ant-upload-drag)</code> 来跳过DOM的层层嵌套直接定位到 <strong>upload</strong> 组件</p>
<h2 id="注意1"><a href="#注意1" class="headerlink" title="注意1"></a>注意1</h2><p>之前的 <code>::v-deep</code> 虽然可以使用，但会在控制台警告被废弃</p>
<h2 id="注意2"><a href="#注意2" class="headerlink" title="注意2"></a>注意2</h2><p>虽然在样式标签中使用了 <code>scoped</code> 来限制当前的样式只应用于当前的组件</p>
<p>但是当需要使用 <code>:deep</code> 来修改组件库样式时，如果子组件也使用了和父组件一样的组件库时，父组件修改的样式就会覆盖到子组件上</p>
<p>所以需要在子组件的样式前面限定一样，这个样式只作用于某一容器中的组件中</p>
]]></content>
      <categories>
        <category>Vue开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>组件库</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue开发：报错相关</title>
    <url>/Vue-Error.html</url>
    <content><![CDATA[<center>本篇主要列举了学习Vue时遇到的一些报错内容</center>

<span id="more"></span>

<h1 id="不能将类型”-”分配给类型”xxx”"><a href="#不能将类型”-”分配给类型”xxx”" class="headerlink" title="不能将类型”{}”分配给类型”xxx”"></a>不能将类型”{}”分配给类型”xxx”</h1><p><strong>报错信息：</strong><code>不能将类型&quot;&#123;&#125;&quot;分配给类型&quot;IntrinsicAttributes......&quot;</code></p>
<p><strong>报错原因：</strong>此报错大概率出现在使用代码片段生成一个Vue模板时，且使用了 <code>new Vue(&#123;&#125;)</code> 方法来创建Vue实例</p>
<p><strong>解决方法：</strong>检查子组件Vue实例的配置项中是否有空的 <code>props</code> 属性，删掉该无用配置项即可（如果你不需要父子组件之前传值）</p>
<h1 id="Extraneous-non-emits-event-listeners…"><a href="#Extraneous-non-emits-event-listeners…" class="headerlink" title="Extraneous non-emits event listeners…"></a>Extraneous non-emits event listeners…</h1><p><strong>报错信息</strong>：<code>Extraneous non-emits event listeners (viewModeChange, modelConfigChange) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.</code></p>
<p><strong>报错原因</strong>：子组件中的结构没有放在一个根容器中</p>
<p><strong>解决办法</strong>：将子组件的结构放在一个div中即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        ...子组件内容</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Property-“options”-was-accessed…"><a href="#Property-“options”-was-accessed…" class="headerlink" title="Property “options” was accessed…"></a>Property “options” was accessed…</h1><p><strong>报错信息</strong>：<code>Property &quot;options&quot; was accessed during render but is not defined on instance</code></p>
<p><strong>报错原因</strong>：该组件上使用 v-model 绑定的属性没有定义初始值</p>
<p><strong>解决办法</strong>：找到该属性值，根据其类型定义一个初始值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里是使用了 vue-class-component 插件写的语法</span></span><br><span class="line"><span class="keyword">public</span> showSelectValues: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue开发：基础内容</title>
    <url>/Vue-basics.html</url>
    <content><![CDATA[<center>Vue 需要掌握的基础内容</center>

<span id="more"></span>

<h1 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h1><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><p>特殊系统修饰键：</p>
<ul>
<li><code>tab</code>：需要配合 <code>keydown</code> 使用</li>
<li><code>ctrl、alt、shift、meta</code>：<ul>
<li>配合 <code>keyup</code>：需要按下该系统修饰键，再按下其他键，再松开其他键才会触发</li>
<li>配合 <code>keydown</code>：正常触发</li>
</ul>
</li>
</ul>
<p><strong>需求</strong>：</p>
<ul>
<li>按下 <code>ctrl + y</code> 时触发事件</li>
<li>可以使用 <code>@keyup.ctrl.y = &quot;show&quot;</code> 来触发</li>
</ul>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>computed 与 methods 的区别：</p>
<ul>
<li>前者带有缓存，一次执行其余地方执行时可以直接读取缓存；后者不带有缓存，每一次调用时都会执行</li>
</ul>
<p>简写：</p>
<ul>
<li>只考虑读取，不考虑修改的时候可以使用简写形式：<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">	<span class="attr">fullName</span>: &#123;</span><br><span class="line">		<span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;wrysmile&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可简写为：</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">	<span class="function"><span class="title">fullName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;wrysmile&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="监视属性"><a href="#监视属性" class="headerlink" title="监视属性"></a>监视属性</h1><p>作用：可以监视某属性是否发生变化</p>
<p>监视属性可以直接在 Vue 中配置，也可以在 vm 实例中进行配置，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 中配置</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="attr">watch</span>: &#123;</span><br><span class="line">		<span class="attr">info</span>: &#123;</span><br><span class="line">			<span class="attr">immediate</span>: <span class="literal">false</span>,	<span class="comment">// 是否立即触发</span></span><br><span class="line">			<span class="attr">deep</span>: <span class="literal">true</span>,			<span class="comment">// 监视多级结构中所有属性是否发生变化</span></span><br><span class="line">			<span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span> &#123;	<span class="comment">// 回调函数</span></span><br><span class="line">				...代码片段</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// vm 中配置</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;info&#x27;</span>, &#123;</span><br><span class="line">	<span class="attr">immediate</span>: <span class="literal">false</span>,	<span class="comment">// 是否立即触发</span></span><br><span class="line">	<span class="function"><span class="title">handler</span>(<span class="params">newValue, oldValue</span>)</span> &#123;	<span class="comment">// 回调函数</span></span><br><span class="line">		...代码片段</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当无需配置 <code>immediate</code> 和 <code>deep</code> 属性时可以使用简写形式，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 中配置</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="attr">watch</span>: &#123;</span><br><span class="line">		<span class="function"><span class="title">info</span>(<span class="params">newValue, oldValue</span>)</span> &#123;</span><br><span class="line">			...代码片段</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// vm 中配置</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;info&#x27;</span>, (newValue, oldValue) &#123;</span><br><span class="line">	...代码片段</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="1-组件间通信"><a href="#1-组件间通信" class="headerlink" title="1.组件间通信"></a>1.组件间通信</h2><p><strong>父组件 ——&gt; 子组件</strong>：</p>
<p><strong>子组件 ——&gt; 父组件</strong>：</p>
<ul>
<li>基础：父组件定义一个方法并传给子组件，当子组件需要传值时，可以在事件中调用通过 <code>prop</code> 属性传入的方法来形成通信</li>
<li>进阶1：通过 <code>v-on:xxx=&quot;update&quot;</code> 自定义事件来给子组件绑定个事件，当子组件需要传值时，使用 <code>this.$emit(&#39;xxx&#39;, params)</code> 来将参数弹射给父组件</li>
<li>进阶2：通过 <code>ref=&#39;a&#39;</code> 传给子组件，父组件在挂载时调用 <code>this.$refs.a.on(&#39;xxx&#39;, [methods中的方法])</code>，就会监听到子组件中通过 <code>this.$emit(&#39;xxx&#39;, params)</code> 弹射的内容</li>
</ul>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><h2 id="1-携带参数跳转路由"><a href="#1-携带参数跳转路由" class="headerlink" title="1.携带参数跳转路由"></a>1.携带参数跳转路由</h2><p>点击<a href="https://www.cnblogs.com/ysx215/p/14990691.html">这里</a></p>
<h2 id="2-query和params的区别"><a href="#2-query和params的区别" class="headerlink" title="2.query和params的区别"></a>2.query和params的区别</h2><p>点击<a href="https://blog.csdn.net/weixin_44867717/article/details/109773945">这里</a></p>
<h2 id="3-使用watch监听参数变化"><a href="#3-使用watch监听参数变化" class="headerlink" title="3.使用watch监听参数变化"></a>3.使用watch监听参数变化</h2><p>点击<a href="https://next.router.vuejs.org/zh/guide/essentials/dynamic-matching.html#%E5%93%8D%E5%BA%94%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8F%98%E5%8C%96">这里</a></p>
<h1 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h1><h2 id="1-生成唯一ID"><a href="#1-生成唯一ID" class="headerlink" title="1.生成唯一ID"></a>1.生成唯一ID</h2><p>可以使用 <code>uuid</code> 或 <code>nanoid</code> 等库来生成唯一ID值</p>
<p>使用：</p>
<ul>
<li><code>npm i nanoid</code> 安装依赖包</li>
<li>nanoid 使用了分别暴露的方法，所以需要使用 <code>import &#123;nanoid&#125; from &#39;nanoid&#39;</code></li>
<li>在需要使用的地方直接调用函数即可 <code>nanoid()</code> </li>
</ul>
<h2 id="2-根据条件遍历数组对象，返回满足条件的长度"><a href="#2-根据条件遍历数组对象，返回满足条件的长度" class="headerlink" title="2.根据条件遍历数组对象，返回满足条件的长度"></a>2.根据条件遍历数组对象，返回满足条件的长度</h2><p>方法1：使用 for 循环，控制变量 ++</p>
<p>方法2：使用数组的 <code>reduce()</code> 方法</p>
<ul>
<li>第一个参数为函数，接收之前的值和当前的值，最终该方法返回最后一次的值</li>
<li>第二个参数即为计数器</li>
</ul>
<h2 id="3-消息订阅与发布"><a href="#3-消息订阅与发布" class="headerlink" title="3.消息订阅与发布"></a>3.消息订阅与发布</h2><p>可以使用第三方库来实现，如 <code>pubsub-js</code> </p>
<h2 id="4-强制更新模板"><a href="#4-强制更新模板" class="headerlink" title="4.强制更新模板"></a>4.强制更新模板</h2><p>当 Vue 监测一个对象的时候，如果对象中的某一属性发生变化，Vue可能监测不到其变化，因为对象的引用地址并没有变化</p>
<p>因此，这个时候我们就需要手动强制更新模板来重新渲染</p>
<p>方法可参考 <a href="https://blog.csdn.net/qq449245884/article/details/104057886">这里</a></p>
<h2 id="5-引入的SVG图像无法修改样式"><a href="#5-引入的SVG图像无法修改样式" class="headerlink" title="5.引入的SVG图像无法修改样式"></a>5.引入的SVG图像无法修改样式</h2><p>有时我们需要引入一些 SVG 图标，但是通过该方法引入时是无法直接修改图标的样式的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;./dot.svg&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;svg-img&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以我们需要通过一个库来将页面中的 img 图像转化成为 svg</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm install --savee @iconfu/svg-inject</span><br></pre></td></tr></table></figure>

<p>在自己的项目入门文件中 引入该库</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@iconfu/svg-inject&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后在 img 标签中通过 <code>onload</code> 方法来注入 svg 图像</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;./dot.svg&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;svg-img&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;SVGInject(this)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后就可以通过类选择器对该图标进行样式的修改</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.svg-img</span> &#123;</span><br><span class="line">	fill: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular开发：第三方组件库的使用</title>
    <url>/Angular-Library.html</url>
    <content><![CDATA[<center>开发时使用合适的组件库可以有效的避免重复造轮子</center>

<span id="more"></span>

<h1 id="Echarts"><a href="#Echarts" class="headerlink" title="Echarts"></a>Echarts</h1><blockquote>
<p><a href="https://echarts.apache.org/zh/index.html">Apache ECharts</a>，一个基于 JavaScript 的开源可视化图表库</p>
</blockquote>
<h2 id="1-TS方式引入组件"><a href="#1-TS方式引入组件" class="headerlink" title="1.TS方式引入组件"></a>1.TS方式引入组件</h2><p>前往 <a href="https://echarts.apache.org/handbook/zh/basics/import">官网</a> 按步骤在 TypeScript 文件中引入 Echarts</p>
<p>html中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 600px;height:400px;&quot;</span> #<span class="attr">demo</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>)=<span class="string">&quot;click()&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ts中：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&#x27;demo&#x27;</span>, &#123;<span class="attr">static</span>:<span class="literal">false</span>&#125;) demo!: ElementRef;</span><br><span class="line"><span class="keyword">public</span> click(): <span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> myChart = echarts.init(<span class="built_in">this</span>.demo.nativeElement);</span><br><span class="line">    myChart.setOption(option);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-Angular专用引入组件"><a href="#2-Angular专用引入组件" class="headerlink" title="2.Angular专用引入组件"></a>2.Angular专用引入组件</h2><p>前往 <a href="https://www.jianshu.com/p/2b73280c4829">@BigDipper</a> 进行查看</p>
<h1 id="AntV-G6"><a href="#AntV-G6" class="headerlink" title="AntV-G6"></a>AntV-G6</h1><blockquote>
<p><a href="https://g6.antv.vision/zh/">G6</a> 是一个简单、易用、完备的图可视化引擎，它在高定制能力的基础上，提供了一系列设计优雅、便于使用的图可视化解决方案。能帮助开发者搭建属于自己的图可视化、图分析、或图编辑器应用</p>
</blockquote>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="Property-‘getUpdateType’-in-type-‘Node’-is-not-assignable-to-the-same-property-in-base-type-‘INode’"><a href="#Property-‘getUpdateType’-in-type-‘Node’-is-not-assignable-to-the-same-property-in-base-type-‘INode’" class="headerlink" title="Property ‘getUpdateType’ in type ‘Node’ is not assignable to the same property in base type ‘INode’"></a>Property ‘getUpdateType’ in type ‘Node’ is not assignable to the same property in base type ‘INode’</h3><p><strong>报错信息</strong>：<code>Property &#39;getUpdateType&#39; in type &#39;Node&#39; is not assignable to the same property in base type &#39;INode&#39;.</code></p>
<p><strong>报错原因</strong>：经检测是下载的 AntV-G6 依赖中出现的问题</p>
<p><strong>解决办法</strong>：在 <code>tsconfig.json</code> 文件中添加 <code>&quot;skipLibCheck&quot;:true</code> 配置项，参考 <a href="https://github.com/antvis/G6/issues/2691">@973782523</a></p>
]]></content>
      <categories>
        <category>Angular开发</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>组件库</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular开发：操作DOM元素</title>
    <url>/Angular-DOM.html</url>
    <content><![CDATA[<center>Angular开发时应该操作DOM元素吗？</center>

<span id="more"></span>

<p><a href="https://blog.csdn.net/wjyyhhxit/article/details/102225638">https://blog.csdn.net/wjyyhhxit/article/details/102225638</a></p>
<p><a href="https://tc9011.com/2018/06/12/%E3%80%90%E8%AF%91%E3%80%91%E5%9C%A8angular%E4%B8%AD%E4%BD%BF%E7%94%A8dom%EF%BC%9A%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E5%90%8E%E6%9E%9C%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/">https://tc9011.com/2018/06/12/%E3%80%90%E8%AF%91%E3%80%91%E5%9C%A8angular%E4%B8%AD%E4%BD%BF%E7%94%A8dom%EF%BC%9A%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E5%90%8E%E6%9E%9C%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</a></p>
<p><a href="https://blog.csdn.net/changyinling520/article/details/78014052">https://blog.csdn.net/changyinling520/article/details/78014052</a></p>
]]></content>
      <categories>
        <category>Angular开发</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>开发：你永远不知道报错和成功哪一个先来</title>
    <url>/KillError.html</url>
    <content><![CDATA[<center>人类终于回想起了被 <strong style="color:red;">Error</strong> 支配的恐惧</center>

<span id="more"></span>

<h1 id="前端-Error"><a href="#前端-Error" class="headerlink" title="前端 Error"></a>前端 Error</h1><h2 id="1-npm-install-时安装-node-sass-失败"><a href="#1-npm-install-时安装-node-sass-失败" class="headerlink" title="1.npm install 时安装 node-sass 失败"></a>1.npm install 时安装 node-sass 失败</h2><p><strong>报错信息</strong>：<code>Failed at the node-sass@4.13.0 postinstall script</code></p>
<p><strong>报错原因</strong>：待查证，网上说是因为npm国外镜像不稳定的原因</p>
<p><strong>解决办法</strong>：</p>
<ul>
<li><p>去 <a href="https://github.com/sass/node-sass/releases">Github</a> 中下载对应系统的最新 <code>node-sass</code> 文件，并放置到一个比较容易找到的目录中</p>
</li>
<li><p>在自己的项目中找到 <code>.npmrc</code> 文件（没有请自建），添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry=设置npm源</span><br><span class="line">SASS_BINARY_PATH=E:/xxx/win32-x64-57_binding.node(下载文件对应位置)</span><br></pre></td></tr></table></figure></li>
<li><p>重新执行 <code>npm install</code> 报错消失</p>
</li>
</ul>
<h2 id="2-npm-ERR-errno-ETIMEDOUT"><a href="#2-npm-ERR-errno-ETIMEDOUT" class="headerlink" title="2.npm ERR! errno ETIMEDOUT"></a>2.npm ERR! errno ETIMEDOUT</h2><p><strong>报错信息</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR! errno ETIMEDOUT</span><br><span class="line">npm ERR! network request to https://registry.npmjs.org/@antv%2fg6 failed, reason: connect ETIMEDOUT 104.16.16.35:443</span><br><span class="line">npm ERR! network This is a problem related to network connectivity.</span><br><span class="line">npm ERR! network In most cases you are behind a proxy or have bad network settings.</span><br><span class="line">npm ERR! network</span><br><span class="line">npm ERR! network If you are behind a proxy, please make sure that the</span><br><span class="line">npm ERR! network &#x27;proxy&#x27; config is set properly.  See: &#x27;npm help config&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>报错原因</strong>：考虑到可能是未知的代理导致的该问题</p>
<p><strong>解决办法</strong>：</p>
<ul>
<li>将 proxy 和 https-proxy 设置为 null，参考 <a href="https://www.jianshu.com/p/3fd7d90db01a">@Sunnky</a></li>
<li>将代理配置删除，参考 <a href="https://stackoverflow.com/questions/56784405/how-to-fix-npm-err-network-if-you-are-behind-a-proxy">@Akshay Reddy</a></li>
</ul>
<h1 id="后端-Error"><a href="#后端-Error" class="headerlink" title="后端 Error"></a>后端 Error</h1><h2 id="1-This-application-has-no-explicit-mapping-for-error-so-you-are-seeing-this-a-fallback-404-Not-found"><a href="#1-This-application-has-no-explicit-mapping-for-error-so-you-are-seeing-this-a-fallback-404-Not-found" class="headerlink" title="1.This application has no explicit mapping for /error, so you are seeing this a fallback 404 Not found"></a>1.This application has no explicit mapping for /error, so you are seeing this a fallback 404 Not found</h2><p><strong>报错信息</strong>：<code>This application has no explicit mapping for /error, so you are seeing this a fallback 404 Not found</code></p>
<p><strong>报错原因</strong>：本人在本地部署了公司的项目，前端静态资源路径配置出错导致</p>
<p><strong>解决办法</strong>：重新配置前端静态资源路径，重启服务，解决问题</p>
<h2 id="2-PKIX-path-building-failed-sun-security-provider-certpath-SunCertPathBuilde"><a href="#2-PKIX-path-building-failed-sun-security-provider-certpath-SunCertPathBuilde" class="headerlink" title="2.PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilde"></a>2.PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilde</h2><p><strong>报错信息</strong>：<code>PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilde</code></p>
<p><strong>报错原因</strong>：生成的安全证书未导入到 jdk 信任库中</p>
<p><strong>解决办法</strong>：</p>
<ul>
<li><p>将安全证书 <code>andy_cer_ip.cer</code> 复制web服务运行的 jdk 安装目录的 <code>jre/lib/security</code> 或者 <code>jdk-11.0.12\lib\security</code>（jdk11 以上无 jre 路径） 目录中</p>
</li>
<li><p>在命令行中执行：<code>keytool -import -alias andy_keystore_ip -keystore cacerts -file andy_cer_ip.cer</code> 即可（执行更改证书路径与名称）</p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>报错</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular开发：性能优化</title>
    <url>/Angular-Capability.html</url>
    <content><![CDATA[<center>在 Angular 中如何进行性能优化呢？</center>

<span id="more"></span>

<h1 id="引"><a href="#引" class="headerlink" title="引"></a>引</h1><p>在我们开发 Angular 的项目时，不单单只是完成开发任务，我们还应该考虑和性能相关的内容</p>
<p>减少不必要的操作，减少不必要的请求，不需要的页面进行懒加载等等</p>
<p>本篇文章记录了自己在开发时学到的一些性能优化</p>
<p>持续更新中</p>
<h1 id="ngFor"><a href="#ngFor" class="headerlink" title="ngFor*"></a>ngFor*</h1><p><strong>现象复现</strong>：在 Angular 中使用 <code>ngFor*</code> 进行循环时，如果循环的数据发生变化时（<strong style="color:red;">无论是所有数据改变还是数据集中的某一个改变</strong>），Angular 默认会将所有的节点都删除，再重新绘制新数据</p>
<p><strong>分析原因</strong>：这看起来是正常的，但是如果在大量的数据中修改了几项内容的时候，这样的渲染机制很显然是不正常的</p>
<p><strong>解决办法</strong>：Angular 官方有一个 <code>trackBy</code> 属性来监听是哪个数据发生了变化，监听到以后 Angular 会重新绘制发生变化的内容，而未变化的内容不做任何修改</p>
<p><strong>参考链接</strong>：<a href="https://www.cnblogs.com/cme-kai/p/8358915.html">@无er不乐</a></p>
]]></content>
      <categories>
        <category>Angular开发</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：Angular开发专栏</title>
    <url>/Angular-Column.html</url>
    <content><![CDATA[<center>考虑到Angular本身难于理解与使用</center>

<center>特开设专栏留存自己学习时的一些问题</center>

<center>↓ 查看 ↓</center>

<span id="more"></span>

<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>本文收录了博客中关于 Angular 相关的博文，点击链接即可进行跳转</p>
<h1 id="专栏"><a href="#专栏" class="headerlink" title="专栏"></a>专栏</h1><ol>
<li><a href="/Learn-Angular.html" title="[Angular开发：基础内容]">[Angular开发：基础内容]</a></li>
<li><a href="/Angular-i18n.html" title="[Angular开发：国际化翻译]">[Angular开发：国际化翻译]</a></li>
<li><a href="/Angular-ViewChild.html" title="[Angular开发：了解@ViewChild中的static]">[Angular开发：了解@ViewChild中的static]</a></li>
<li><a href="/Angular-DOM.html" title="[Angular开发：如何操作DOM元素]">[Angular开发：如何操作DOM元素]</a></li>
<li><a href="/Angular-Capability.html" title="[Angular开发：性能优化]">[Angular开发：性能优化]</a></li>
<li><a href="/Angular-Library.html" title="[Angular开发：第三方组件库的使用]">[Angular开发：第三方组件库的使用]</a></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>专栏</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular开发：了解@ViewChild中的static</title>
    <url>/Angular-ViewChild.html</url>
    <content><![CDATA[<center>如何正确使用@ViewChild中的static？</center>

<span id="more"></span>

<p>在 Angular8+ 的项目中，如果你想要使用 <code>@ViewChild</code></p>
<p>你必须在 <code>@ViewChild</code> 中携带一个名为 <code>static</code> 的参数，其代表为<strong style="color:red;">静态的</strong>，其默认值为 <strong style="color:red;">false</strong></p>
<p>个人理解如下：</p>
<ul>
<li>当使用默认值时，可以在父组件的 <code>ngAfterViewInit</code> 阶段获取到子组件的属性或者方法</li>
<li>如果想要在父组件的 <code>ngOnInit()</code> 阶段就获取到子组件中的属性或者方法，那么你就需要将其设置为 true</li>
</ul>
<p>具体解释可以看 <a href="https://tommy0604.github.io/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Angular%E4%B8%AD%E7%9A%84ViewChild/">@TommyKi</a>  相关的博文</p>
]]></content>
      <categories>
        <category>Angular开发</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular开发：国际化翻译</title>
    <url>/Angular-i18n.html</url>
    <content><![CDATA[<center>使用 ngx-translate 来翻译你的 Angular 项目吧</center>

<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>NGX-Translate</strong> 是 Angular 的一个国际化库</p>
<p>它允许您定义不同语言的内容翻译，并在它们之间轻松切换</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>参考 <a href="https://www.jianshu.com/p/dae17d7d44e3">这里</a></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="Html中"><a href="#Html中" class="headerlink" title="Html中"></a>Html中</h2><p>使用管道或指令来进行翻译：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; &#x27;public.hello&#x27; | translate&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> [<span class="attr">translate</span>]=<span class="string">&quot;&#x27;public.hello&#x27;&quot;</span>&gt;</span>public.hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>翻译带有动态修改的数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;&#x27;flow-manager.flow-counts-#flowCounts#&#x27; | translate: &#123;flowCounts:flowCounts&#125; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>翻译后台传回的数据，可以使用连字符将两个字符串连接起来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;&#x27;asr.&#x27; + pattern | translate&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以在翻译文件中携带参数：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;&#x27;flow-manager.confirm-to-delete-flow&#x27; | translate:&#123;deleteFlowName:deleteFlowName&#125; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="TypeScript中"><a href="#TypeScript中" class="headerlink" title="TypeScript中"></a>TypeScript中</h2><p><strong style="color:red;">待更新</strong></p>
]]></content>
      <categories>
        <category>Angular开发</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>保姆级教程：如何打造属于自己的桌面？</title>
    <url>/Mine-Desktop.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>想要真正打造一个属于自己的桌面，那么一定要搞清楚自己想要什么，而不是所谓的“抄作业”，那要只是为了好看而好看！</p>
<p>本文从零基础开始，根据自己实际情况，同时参考了网上成品，分点进行打造，大家可以选择观看！</p>
<span id="more"></span>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h1 id="房间布局"><a href="#房间布局" class="headerlink" title="房间布局"></a>房间布局</h1><p><strong>房间布局</strong>是需要格外关注的点</p>
<h1 id="风格规划"><a href="#风格规划" class="headerlink" title="风格规划"></a>风格规划</h1><p>即颜色格调</p>
<h1 id="桌面元素"><a href="#桌面元素" class="headerlink" title="桌面元素"></a>桌面元素</h1><p>桌面需要有哪些东西，各放哪里？</p>
<p>显示器及支架？、笔记本及支架、音响、键盘、鼠标、桌垫/鼠标垫、头戴式耳机及支架、二手手机时钟显示及支架、IPad及支架、手机及支架</p>
<p>香薰/植物、手办、加湿器、水杯及杯垫、</p>
<h1 id="物品收纳"><a href="#物品收纳" class="headerlink" title="物品收纳"></a>物品收纳</h1><p>桌下小柜？桌下塑料收纳？桌上塑料收纳？垃圾投放？</p>
<h1 id="边角装饰"><a href="#边角装饰" class="headerlink" title="边角装饰"></a>边角装饰</h1><p>周边需要一些东西进行装饰</p>
<p>主灯光（照明）、RGB灯带（渲染气氛）、洞洞板、壁画？</p>
<h1 id="无线生活"><a href="#无线生活" class="headerlink" title="无线生活"></a>无线生活</h1><p>如何？</p>
<p>磁吸插头？</p>
<p>束线器？</p>
<p>扩展坞？</p>
<h1 id="日常保洁"><a href="#日常保洁" class="headerlink" title="日常保洁"></a>日常保洁</h1><p>如何清理？</p>
<h1 id="学习游戏"><a href="#学习游戏" class="headerlink" title="学习游戏"></a>学习游戏</h1><p>分桌子</p>
<h1 id="后续扩展"><a href="#后续扩展" class="headerlink" title="后续扩展"></a>后续扩展</h1><p>主机、多显示器？</p>
]]></content>
  </entry>
  <entry>
    <title>记录 npm 出现 npm ERR! code EINTEGRITY 原因排查</title>
    <url>/npm-error.html</url>
    <content><![CDATA[<p>​    </p>
<span id="more"></span>

<p>报错场景：新 clone 的项目代码执行 <code>npm i</code> 安装依赖时出现</p>
<p>报错信息：<code>npm ERR! code EINTEGRITY</code></p>
<p>报错原因：<code>package-lock.json</code> 中对应依赖的哈希值与库中的哈希值不一致导致</p>
<p>网上解决办法：</p>
<ul>
<li><code>npm cache clean --force</code>  之后再执行 <code>npm install</code>，结果无效</li>
<li><code>npm install -g npm</code> 之后再执行 <code>npm install</code>，结果无效</li>
<li>删除 <code>package-lock.json</code> 再执行 <code>npm install</code>，结果无效（公司项目使用Angular版本低于全局Angular版本，无法安装）</li>
</ul>
<p>个人解决办法：</p>
<ul>
<li>根据报错哈希值定位到是 <code>package-lock.json</code> 中的哪个依赖包</li>
<li>发现是公司自己封装的共享库，执行公司提供的更新脚本</li>
<li>该依赖包成功更新，之后执行 <code>npm install</code> 成功安装无报错</li>
</ul>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>哈希值</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次更改MySQL编码导致的问题</title>
    <url>/Mysql-Emoji-Problem.html</url>
    <content><![CDATA[<p>​    </p>
<span id="more"></span>

<h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>公司项目部署的时候因为运维文档没有更新，导致在初始化数据库的时候使用的是 <code>utf-8</code> 的编码格式，实际上是需要使用 <code>utf-8mb4</code> 的编码格式</p>
<p>当时自己并没有注意，直到后来做有关 emoji 表情的需求的时候，才发现 <code>utf-8</code> 的格式根本无法存储表情字符</p>
<p>既然是编码出了问题，我第一想法就是直接修改数据库和表的编码格式</p>
<p>所以我按着 <a href="https://blog.csdn.net/weixin_30213173/article/details/111971346">@Wonder王达</a> 教程的指令修改了数据库编码和表的编码</p>
<p>然后就可以正常存储 Emoji 表情</p>
<h1 id="囧"><a href="#囧" class="headerlink" title="囧"></a>囧</h1><p>虽然这里看着问题解决了，可以存储表情了，但是后续的表情搜索却出现了问题</p>
<p>当通过😊这个表情进行搜索的时候，返回结果并不是含有这个表情的结果，而是只要含有 emoji 表情就都会返回</p>
<p>检查了前后台相关逻辑，都没有问题，最终我把目光放在了数据库上</p>
<p>重新建了一个 utf-8mb4 编码的数据库，重新测试收到正确结果</p>
<h1 id="终"><a href="#终" class="headerlink" title="终"></a>终</h1><p>猜想：可能是一开始编码以及排序格式都是 utf-8 格式，而手动更改以后排序方式并没有变，所以出现了预期之外的返回结果</p>
<p>教训：尽量不要手动修改数据库相关内容，一定要确保在初始化的时候就设置好！！</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>编码</tag>
        <tag>Emoji</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：ng-zorro</title>
    <url>/Learn-ng-zorro.html</url>
    <content><![CDATA[<center>ng-zorro 是一个用在 Angular 项目上的组件库</center>

<span id="more"></span>

<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="1-自动安装"><a href="#1-自动安装" class="headerlink" title="1.自动安装"></a>1.自动安装</h2><p>新建一个 Angular 项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng new project</span><br></pre></td></tr></table></figure>

<p>进入项目目录，完成组件的初始化，包括引入国际化文件、导入模块、引入样式文件等：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng add ng-zorro-antd</span><br></pre></td></tr></table></figure>

<p>运行项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng serve --open</span><br></pre></td></tr></table></figure>

<h2 id="2-手动安装"><a href="#2-手动安装" class="headerlink" title="2.手动安装"></a>2.手动安装</h2><blockquote>
<p>如果项目本身已经存在时可以手动进行安装该组件</p>
</blockquote>
<p>安装组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install ng-zorro-antd --save</span><br></pre></td></tr></table></figure>

<p><strong style="color:red;">使用全局样式：</strong></p>
<ul>
<li><p>在 <code>angular.json</code> 中引入全部组件样式:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;styles&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;node_modules/ng-zorro-antd/ng-zorro-antd.min.css&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>style.css</code> 中引入预构建样式文件:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;~ng-zorro-antd/ng-zorro-antd.min.css&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong style="color:red;">使用特定组件样式：</strong></p>
<ul>
<li>先引入基本样式，再引入组件样式<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;~ng-zorro-antd/style/index.min.css&quot;</span>; <span class="comment">/* 引入基本样式 */</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;~ng-zorro-antd/button/style/index.min.css&quot;</span>; <span class="comment">/* 引入组件样式 */</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>在 <code>app.module.ts</code> 中引入组件模块：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NzButtonModule &#125; <span class="keyword">from</span> <span class="string">&#x27;ng-zorro-antd/button&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.component&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    AppComponent</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    NzButtonModule</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>在模板中使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">nz-button</span> <span class="attr">nzType</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Primary<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="组件相关"><a href="#组件相关" class="headerlink" title="组件相关"></a>组件相关</h1><h2 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h2><p>找到各个组件的模块引入语句：</p>
<ul>
<li>如果整个项目只有 app 一个 module，那么就需要在它中引入，并加入到 imports 数组中</li>
<li>如果整个项目中还有其他 module，且是该 module 下的页面需要引用该组件，那么加需要在 该 module 中引入，并加入到 imports 数组中</li>
</ul>
<p>复制组件代码，粘贴到需要使用的页面中即可</p>
<h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><h3 id="1-静态加载"><a href="#1-静态加载" class="headerlink" title="(1).静态加载"></a>(1).静态加载</h3><p>官方推荐<strong style="color:red;">只加载需要的图标</strong>，方法如下：</p>
<ul>
<li><p>先引入图标模块</p>
</li>
<li><p>然后找到需要的图标，引入该图标，命名方式如下：</p>
<ul>
<li>先首字母大写，如果有 <code>-</code>，去掉连字符并将连字符后面的单词首字母大写，最后接着图标主题风格(Outline、Fill、TwoTone)</li>
<li>例：<code>account-book</code> 即为 <code>AccountBookOutline</code> <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; AccountBookOutline, AccountBookFill, AccountBookTwoTone &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons-angular/icons&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>定义一个数组来接收这些图标</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; IconDefinition &#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons-angular&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> icons: IconDefinition[] = [AccountBookOutline, AccountBookFill, AccountBookTwoTone];</span><br></pre></td></tr></table></figure></li>
<li><p>修改 imports 数组</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">NzIconModule.forRoot(icons)</span><br></pre></td></tr></table></figure></li>
<li><p>最后将组件代码复制进去即可</p>
</li>
</ul>
<hr>
<p>官方不推荐的<strong style="color:red;">加载全部图标</strong>，请前往 <a href="https://ng.ant.design/components/icon/zh">这里</a> 查看</p>
<h3 id="2-动态加载"><a href="#2-动态加载" class="headerlink" title="(2).动态加载"></a>(2).动态加载</h3><p>引入图标模块</p>
<p>修改 <code>angular.json</code> 文件如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;assets&quot;</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;glob&quot;</span>: <span class="string">&quot;**/*&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;input&quot;</span>: <span class="string">&quot;./node_modules/@ant-design/icons-angular/src/inline-svg/&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;/assets/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<p>重新编译项目即可正常加载图标</p>
<h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p><a href="https://zhuanlan.zhihu.com/p/38373638">待办事项</a></p>
<p><a href="https://juejin.cn/post/6844903778164949000#heading-36">https://juejin.cn/post/6844903778164949000#heading-36</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular开发：基础内容</title>
    <url>/Learn-Angular.html</url>
    <content><![CDATA[<center>本篇是Angular开发中需要掌握的基础内容</center>

<span id="more"></span>

<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h2><p>使用 <code>ng new 项目名</code> 来创建一个新的项目</p>
<p>使用 <code>ng new project -S</code> 来创建一个不使用测试文件的新项目</p>
<p>使用 <code>ng new project --skip-install</code> 来创建一个新项目，且跳过安装依赖</p>
<h2 id="2-单向绑定"><a href="#2-单向绑定" class="headerlink" title="2.单向绑定"></a>2.单向绑定</h2><p>绑定数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ts 中</span><br><span class="line">title: string = &quot;标题&quot;;</span><br><span class="line">// html 中</span><br><span class="line">&lt;div&gt;&#123;&#123;title&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>绑定属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ts 中</span><br><span class="line">msg: string = &quot;提示信息&quot;;</span><br><span class="line">// html 中</span><br><span class="line">&lt;div [title]=&quot;msg&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>绑定 html</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// ts 中</span><br><span class="line">h2: string = &quot;&lt;h2&gt;这是h2&lt;/h2&gt;&quot;</span><br><span class="line">// html 中</span><br><span class="line">&lt;div [innerHTML]=&quot;h2&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="视图包装"><a href="#视图包装" class="headerlink" title="视图包装"></a>视图包装</h2><p>在 Angular 中，组件的 CSS 样式被封装进了自己的视图，可以通过在组件的元数据上设置<strong>视图封装模式</strong>，你可以分别控制<strong>每个组件</strong>的封装模式</p>
<p>封装模式如下：</p>
<ul>
<li><code>ShadowDom</code>：使用浏览器原生的 Shadow DOM 来实现（不进不出，全局样式进不来，组件样式出不去）</li>
<li><code>Emulated</code>：默认值，通过预处理 CSS 代码来模拟 Shadow DOM 的行为（只进不出，全局样式能进来，组件样式出不去）</li>
<li><code>None</code>：不使用视图封装，即把 CSS 添加到全局样式中（能进能出）</li>
</ul>
<p>设置封装模式：组件元数据中的 <code>encapsulation</code> 属性来设置组件封装模式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">encapsulation: ViewEncapsulation.ShadowDom</span><br></pre></td></tr></table></figure>

<h2 id="组件交互"><a href="#组件交互" class="headerlink" title="组件交互"></a>组件交互</h2><h3 id="1-input"><a href="#1-input" class="headerlink" title="(1).@input()"></a>(1).@input()</h3><p>父组件通过 <code>@input()</code> 给子组件绑定属性设置输入类数据</p>
<p>方法如下：</p>
<ul>
<li><p>在父组件中定义一个属性</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">title: <span class="built_in">string</span> = <span class="string">&quot;Wrysmile&#x27;s Blog&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在父组件的页面中给子组件传值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-title</span> [<span class="attr">title</span>] = <span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-title</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在子组件中注入该属性</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Input</span>() title?: <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>在子组件的页面中即可使用该属性了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>同时也可以在父组件中修改该值，会实时同步到子组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// html文件</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>) = <span class="string">&quot;titleChange()&quot;</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ts文件</span></span><br><span class="line"><span class="function"><span class="title">titleChange</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = <span class="string">&quot;Wrysmile 的小站&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-output"><a href="#2-output" class="headerlink" title="(2).@output()"></a>(2).@output()</h3><p>父组件给子组件传递一个事件，子组件通过 <code>@output()</code> 弹射触发事件</p>
<p>@Output() 必须是 <code>EventEmitter</code> 类型的</p>
<p>方法如下：</p>
<ul>
<li><p>在父组件中定义属性以及触发的事件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">list: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;Angular&quot;</span>];</span><br><span class="line"><span class="function"><span class="title">addList</span>(<span class="params">str: <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 将内容添加到列表中</span></span><br><span class="line">  <span class="built_in">this</span>.list?.push(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在父组件的页面中给子组件绑定该事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> *<span class="attr">ngFor</span>=<span class="string">&quot;let item of list&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">app-title</span> (<span class="attr">addList</span>) = <span class="string">&quot;addList($event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-title</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在子组件中弹射触发父组件中的事件</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Output</span>() addList = <span class="keyword">new</span> EventEmitter();</span><br><span class="line"><span class="function"><span class="title">btnAdd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.addList.emit(<span class="string">&quot;Vue&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在子组件的页面中触发定义好的事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>) = <span class="string">&quot;btnAdd()&quot;</span>&gt;</span>我要学Vue<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-ViewChild"><a href="#3-ViewChild" class="headerlink" title="(3).@ViewChild()"></a>(3).@ViewChild()</h3><p>通过 <code>@ViewChild()</code> 来获取子组件的实例，来获取子组件的数据</p>
<p>该方法需要结合第二个使用，方法如下：</p>
<ul>
<li><p>在父组件的页面中给子组件定义一个<strong>模板引用变量</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">app-title</span> #<span class="attr">titleDom</span> (<span class="attr">addList</span>) = <span class="string">&quot;addList($event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">app-title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> (<span class="attr">click</span>) = <span class="string">&quot;viewChildAdd()&quot;</span>&gt;</span>父子组件交互<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在父组件中获取子组件的实例，然后就通过 <code>.child</code> 来调用子组件中的方法</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ViewChild</span>(<span class="string">&quot;titleDom&quot;</span>) child: <span class="built_in">any</span>;</span><br><span class="line"><span class="function"><span class="title">viewChildAdd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.child.btnAdd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后在子组件中弹射触发事件即可</p>
</li>
</ul>
<h2 id="组件样式"><a href="#组件样式" class="headerlink" title="组件样式"></a>组件样式</h2><h3 id="1-host"><a href="#1-host" class="headerlink" title="(1).:host"></a>(1).:host</h3><p>作用：用来选择当前组件中的子元素</p>
<p>场景：若想给某组件中的所有元素设置 flex 布局，可以不需要单独加一个盒子，而直接通过该伪类选择器给该组件设置 flex 布局</p>
<p>引申：</p>
<ul>
<li><code>:host(.active)</code>符合该类的组件</li>
<li><code>:host h2</code>组件中符合该选择器的元素</li>
</ul>
<h3 id="2-host-content"><a href="#2-host-content" class="headerlink" title="(2).:host-content"></a>(2).:host-content</h3><p>作用：用来选择当前组件中的祖先节点</p>
<h2 id="内容投影"><a href="#内容投影" class="headerlink" title="内容投影"></a>内容投影</h2><h3 id="1-单插槽内容投影"><a href="#1-单插槽内容投影" class="headerlink" title="(1).单插槽内容投影"></a>(1).单插槽内容投影</h3><p>使用 <code>&lt;ng-content&gt;</code> 来进行投影</p>
<h3 id="2-多插槽内容投影"><a href="#2-多插槽内容投影" class="headerlink" title="(2).多插槽内容投影"></a>(2).多插槽内容投影</h3><p>使用 <code>&lt;ng-content select=&quot;[question]&quot;&gt;</code> 来进行投影</p>
<h2 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h2><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="1-内置指令"><a href="#1-内置指令" class="headerlink" title="1.内置指令"></a>1.内置指令</h2><p>内置属性型指令：</p>
<ul>
<li><p>NgClass：添加和删除一组 CSS 类</p>
</li>
<li><p>NgStyle：添加和删除一组 HTML 样式</p>
</li>
<li><p>NgModel：将数据双向绑定添加到 HTML 表单元素</p>
</li>
</ul>
<p>内置结构型指令：</p>
<ul>
<li><p>NgIf：从模板中创建和销毁子视图</p>
</li>
<li><p>NgFor：为列表中的每个条目重复渲染一个节点</p>
</li>
<li><p>NgSwitch：一组在备用视图之间切换的指令</p>
</li>
</ul>
<h2 id="2-属性型指令"><a href="#2-属性型指令" class="headerlink" title="2.属性型指令"></a>2.属性型指令</h2><p>建立属性型指令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ng generate directive xxx</span><br><span class="line">或</span><br><span class="line">ng g d xxx</span><br></pre></td></tr></table></figure>

<p>应用属性型指令：只要在相应的 HTML 模板中应用指令选择器名即可</p>
<h2 id="3-结构型指令"><a href="#3-结构型指令" class="headerlink" title="3.结构型指令"></a>3.结构型指令</h2><p>简写形式： Angular 将结构型指令前面的星号转换为围绕宿主元素及其后代的 <code>&lt;ng-template&gt;</code></p>
<h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><h2 id="1-创建服务"><a href="#1-创建服务" class="headerlink" title="1.创建服务"></a>1.创建服务</h2><p>使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng generate service 服务名</span><br><span class="line">或</span><br><span class="line">ng g s 服务名</span><br></pre></td></tr></table></figure>

<p>最好在单独的文件中定义组件和服务，如果需要合并在同一个文件中，则必须<strong style="color:red;">先定义服务，再定义组件</strong>（顺序不对时会返回运行时的空引用错误）</p>
<p>服务文件中需要 <code>@injectable()</code> 装饰器来进行配置，其中 <code>provideIn</code> 共有三个属性值，如下：</p>
<ul>
<li><code>root</code>：注入到 <code>app.module.ts</code> 中，所有子组件都可以是用（推荐）</li>
<li><code>none</code>：不设定服务作用域（不推荐）</li>
<li><code>组件名</code>：只作用于该组件（懒加载模式）</li>
</ul>
<h2 id="2-依赖注入"><a href="#2-依赖注入" class="headerlink" title="2.依赖注入"></a>2.依赖注入</h2><p>需要在 <code>app.module.ts</code> 中手动进行注入</p>
<p>使用 <code>import</code> 引入服务，并在 <code>providers</code> 中进行注入</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ListService &#125; <span class="keyword">from</span> <span class="string">&#x27;./service/list.service&#x27;</span>;</span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">declarations</span>: [</span><br><span class="line">    <span class="comment">// 组件注入</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    BrowserModule,</span><br><span class="line">    AppRoutingModule,</span><br><span class="line">    FormsModule,</span><br><span class="line">    ReactiveFormsModule</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">providers</span>: [</span><br><span class="line">    <span class="comment">// 服务注入</span></span><br><span class="line">    ListService</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">bootstrap</span>: [AppComponent]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>依赖项注入（DI）是一种设计模式，在这种设计模式中，类会从外部源请求依赖项而不是创建它们</p>
<p>在组件中注入服务时需要将依赖项注入组件的 <code>constructor()</code> 中</p>
<h2 id="3-服务嵌套"><a href="#3-服务嵌套" class="headerlink" title="3.服务嵌套"></a>3.服务嵌套</h2><p>当某个服务(B)依赖于另一个服务(A)时，需要在该服务(B)中注入另一个服务(A)</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; HEROES &#125; <span class="keyword">from</span> <span class="string">&#x27;./mock-heroes&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Logger &#125; <span class="keyword">from</span> <span class="string">&#x27;../logger.service&#x27;</span>;</span><br><span class="line"><span class="meta">@Injectable</span>(&#123;</span><br><span class="line">  <span class="attr">providedIn</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HeroService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注入Logger服务</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> logger: Logger</span>)</span> &#123;  &#125;</span><br><span class="line">  <span class="function"><span class="title">getHeroes</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.logger.log(<span class="string">&#x27;Getting heroes ...&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> HEROES;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>&emsp;&emsp;使用路由可以在 Angular 中实现路径的导航模式，具体表现就是不同视图的切换。在 Angular 中，组件的实例化与销毁、模块的加载、组件某些生命周期钩子的发起都与路由相关</p>
<p><strong>路由器</strong> 是一个调度中心，是一套规则的列表，能够查询当前 URL 对应的规则，并呈现出相关的视图</p>
<p><strong>路由</strong> 是列表里面的一个规则，有如下字段：</p>
<ul>
<li><code>path</code>：表示该路由中的 URL 路径</li>
<li><code>component</code>：表示与该路由相关联的组件</li>
</ul>
<h2 id="1-创建路由"><a href="#1-创建路由" class="headerlink" title="1.创建路由"></a>1.创建路由</h2><p>如果使用脚手架安装时会询问是否创建路由文件，选择是时会自动生成 <code>app-routing.module.ts</code></p>
<p>如果使用脚手架想要跳过询问直接生成路由文件可以使用 <code>ng new 项目名 --routing</code> 来生成一个带有应用路由模块的基本项目</p>
<p>如果使用脚手架创建项目时没有使用默认配置创建路由器，可以使用如下命令进行创建，其中参数如下：</p>
<ul>
<li><code>--flat</code> 把这个文件放进了 <code>src/app</code> 中，而不是单独的目录中</li>
<li><code>--module=app</code> 告诉 CLI 把它注册到 <code>AppModule</code> 的 <code>imports</code> 数组中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng generate module app-routing --flat --module=app</span><br></pre></td></tr></table></figure></li>
</ul>
<p>然后用下面的代码替换生成的文件中的代码：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/core&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; RouterModule, Routes &#125; <span class="keyword">from</span> <span class="string">&#x27;@angular/router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes: Routes = [];</span><br><span class="line"></span><br><span class="line"><span class="meta">@NgModule</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [RouterModule.forRoot(routes)],</span><br><span class="line">  <span class="attr">exports</span>: [RouterModule]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRoutingModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-配置路由规则"><a href="#2-配置路由规则" class="headerlink" title="2.配置路由规则"></a>2.配置路由规则</h2><p>在路由文件中引入需要的组件，并在 <code>routes</code> 字段中配置规则</p>
<h3 id="1-基础路由配置规则"><a href="#1-基础路由配置规则" class="headerlink" title="(1).基础路由配置规则"></a>(1).基础路由配置规则</h3><p>即包含 URL 的路由配置，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: HelloComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-默认路由配置规则"><a href="#2-默认路由配置规则" class="headerlink" title="(2).默认路由配置规则"></a>(2).默认路由配置规则</h3><p>即根据端口进入页面时默认显示，如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: HomeComponent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但默认配置状况下，如果地址栏输入错误，会显示项目的根目录网页，并不合适，使用 <strong>通配路由配置规则</strong> 可以解决</p>
<h3 id="3-通配路由配置规则"><a href="#3-通配路由配置规则" class="headerlink" title="(3).通配路由配置规则"></a>(3).通配路由配置规则</h3><p>即 URL 错误时显示该界面（此时可以配置404页面），如下；</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: HomeComponent</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="3-组件渲染输出"><a href="#3-组件渲染输出" class="headerlink" title="3.组件渲染输出"></a>3.组件渲染输出</h2><p>在根页面中使用如下语句进行渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-导航"><a href="#4-导航" class="headerlink" title="4.导航"></a>4.导航</h2><p>可以在 <code>&lt;a&gt;</code> 标签中进行导航</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">&quot;[&#x27;/hello&#x27;]&quot;</span> <span class="attr">routerLinkActive</span>=<span class="string">&quot;router-link-active&quot;</span> &gt;</span>进入hello页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-路由嵌套"><a href="#5-路由嵌套" class="headerlink" title="5.路由嵌套"></a>5.路由嵌套</h2><p>在需要嵌套的路由规则中通过 <code>children</code> 字段来进行设置：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: HomeComponent,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;list&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: ListComponent</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要嵌套的页面中进行渲染</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">&quot;[&#x27;/home/list&#x27;]&quot;</span> <span class="attr">routerLinkActive</span>=<span class="string">&quot;router-link-active&quot;</span> &gt;</span>进入list页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-outlet</span>&gt;</span><span class="tag">&lt;/<span class="name">router-outlet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-路由传值"><a href="#6-路由传值" class="headerlink" title="6.路由传值"></a>6.路由传值</h2><h3 id="1-queryParams"><a href="#1-queryParams" class="headerlink" title="(1).queryParams"></a>(1).queryParams</h3><p>在 <code>&lt;a&gt;</code> 标签中添加一个 <code>queryParams</code> 参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">&quot;[&#x27;/home/list&#x27;]&quot;</span> [<span class="attr">queryParams</span>]=<span class="string">&quot;&#123;id: 1&#125;&quot;</span> <span class="attr">routerLinkActive</span>=<span class="string">&quot;router-link-active&quot;</span> &gt;</span>进入list页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件中注入 route 服务</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">private</span> routerInfo: ActivatedRoute</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以通过 <code>routerInfo.snapshot.queryParams</code> 来获取传递的参数</p>
<h3 id="2-params"><a href="#2-params" class="headerlink" title="(2).params"></a>(2).params</h3><p>通过修改路由配置文件中的路径来进行传值</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&quot;hello/:name&quot;</span>,</span><br><span class="line">  <span class="attr">component</span>: HelloComponent</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>修改超链接中 <code>routerLink</code> 的第二个参数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> [<span class="attr">routerLink</span>]=<span class="string">&quot;[&#x27;/hello&#x27;, &#x27;params传参&#x27;]&quot;</span>  <span class="attr">routerLinkActive</span>=<span class="string">&quot;router-link-active&quot;</span> &gt;</span>进入hello页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在子组件中注入 route 服务</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">private</span> routerInfo: ActivatedRoute</span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>subscribe</code> 订阅的方式获取 <code>name</code> 参数</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.routerInfo.params.subscribe(<span class="function">(<span class="params">params: Params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = params[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong style="color:red;">注意：使用该方式时参数位置必须对应</strong></p>
<h2 id="7-路由顺序"><a href="#7-路由顺序" class="headerlink" title="7.路由顺序"></a>7.路由顺序</h2><p><strong>Router</strong>在匹配路由时遵循的是<strong>先到先得</strong>的策略，所以路由顺序如下：</p>
<ul>
<li>先配置静态路径的路由</li>
<li>再配置与默认路由匹配的空路径路由</li>
<li>最后配置通配符路径</li>
</ul>
<h3 id="1-默认路径路由"><a href="#1-默认路径路由" class="headerlink" title="(1).默认路径路由"></a>(1).默认路径路由</h3><p>当所请求的 URL 与任何路由器路径都不匹配时，就会选择该路由</p>
<p>作用：展示404页面或跳转到应用的主组件</p>
<p>**两个星号</p>
<h3 id="2-重定向路由"><a href="#2-重定向路由" class="headerlink" title="(2).重定向路由"></a>(2).重定向路由</h3><p>当时用重定向路由时，浏览器会默认跳转到该路由上</p>
<p>重定向路由需要设置以下三个参数：</p>
<ul>
<li><code>path</code>：重定向源</li>
<li><code>redirectTo</code>：重定向目标</li>
<li><code>pathMatch</code>：如何匹配URL（full、prefix）</li>
</ul>
<p>配置如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: HomeComponent</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">redirectTo</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">pathMatch</span>: <span class="string">&#x27;full&#x27;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="8-编写位置"><a href="#8-编写位置" class="headerlink" title="8.编写位置"></a>8.编写位置</h2><h3 id="1-app-moudule-ts文件"><a href="#1-app-moudule-ts文件" class="headerlink" title="(1).app.moudule.ts文件"></a>(1).app.moudule.ts文件</h3><p>在该文件中导入 <code>RouterModule</code>，然后在 <code>imports</code> 字段中填写如下代码，并在代码中书写需要定义的路由规则：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">RouterModule.forRoot([]),</span><br></pre></td></tr></table></figure>

<h3 id="2-路由模块"><a href="#2-路由模块" class="headerlink" title="(2).路由模块"></a>(2).路由模块</h3><p>使用如下命令创建一个默认路由配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng generate module app-routing --module app --flat</span><br><span class="line">或</span><br><span class="line">ng g m app-routing --module app --flat</span><br></pre></td></tr></table></figure>

<p>在 <code>app.module.ts</code> 中引入该配置文件</p>
<p>进入该文件，引入 <code>RouterModule</code> 以及各个组件</p>
<p>在 <code>imports</code> 字段中填写如下代码，并在代码中书写需要定义的路由规则：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">RouterModule.forRoot([]),</span><br></pre></td></tr></table></figure>

<p>在 <code>exports</code> 字段中导出 <code>RouterModule</code></p>
<h2 id="9-路由守卫"><a href="#9-路由守卫" class="headerlink" title="9.路由守卫"></a>9.路由守卫</h2><p>路由守卫分为如下几种：</p>
<ul>
<li><code>CanActivate</code>：处理导航到某路由的情况</li>
<li><code>CanActivateChild</code>：处理导航到某子路由的情况</li>
<li><code>CanDeactivate</code>：处理从当前路由离开的情况</li>
<li><code>Resolve</code>：在路由激活之前获取路由的数据</li>
<li><code>CanLoad</code>：处理异步导航到某特性模块的情况</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>为守卫创建服务，创建的时候可以选择守卫的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng generate gurad 守卫名</span><br><span class="line">或</span><br><span class="line">ng g g 守卫名</span><br></pre></td></tr></table></figure>

<p>在路由配置文件中按如下配置即可：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/your-path&#x27;</span>,</span><br><span class="line">  <span class="attr">component</span>: YourComponent,</span><br><span class="line">  <span class="attr">canActivate</span>: [YourGuard],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-路由策略"><a href="#10-路由策略" class="headerlink" title="10.路由策略"></a>10.路由策略</h2><p>&emsp;&emsp;路由器导航时其中的 URL 都存在于本地，并不会请求服务器，而当前浏览器提供两种策略来展示 URL 的样式：</p>
<ul>
<li><code>PathLocationStrategy</code>：默认策略，支持 “HTML 5 pushState” 风格</li>
<li><code>HashLocationStrategy</code>：支持“hash URL”风格，即 URL 前必须加入井号才可以避免请求服务端</li>
</ul>
<h3 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h3><p>如果使用默认策略，需要在项目的 <code>index.html</code> 中添加 <code>&lt;base href&gt;</code> 元素才可以正常工作</p>
<p>如果应用的根目录是 <code>app</code> 目录，那么可以设置如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>RoutingApp<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;favicon.ico&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="响应式表单"><a href="#响应式表单" class="headerlink" title="响应式表单"></a>响应式表单</h2><h2 id="模板驱动表单"><a href="#模板驱动表单" class="headerlink" title="模板驱动表单"></a>模板驱动表单</h2><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><h3 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h3><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-添加-localize-包"><a href="#1-添加-localize-包" class="headerlink" title="(1).添加 localize 包"></a>(1).添加 localize 包</h3><p>在项目根目录中使用以下命令添加 localize 包到项目中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng add @angular/localize</span><br></pre></td></tr></table></figure>


<h3 id="2-标记要翻译的文本"><a href="#2-标记要翻译的文本" class="headerlink" title="(2).标记要翻译的文本"></a>(2).标记要翻译的文本</h3><p>Html 文件只需要在需要进行翻译的标签中添加 <code>i18n</code>，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">i18n</span>&gt;</span>Top Heroes<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 文件只需要在构造函数中指定以下语句即可：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">title = <span class="string">&#x27;Tour of Heroes&#x27;</span>;</span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.title = $localize <span class="string">`Tour of Heroes`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-提取源语言文件"><a href="#3-提取源语言文件" class="headerlink" title="(3).提取源语言文件"></a>(3).提取源语言文件</h3><p>使用下面的命令将标记好的文本提取到源语言文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng extract-i18n								// 在项目的根目录中生成源语言文件</span><br><span class="line">ng extract-i18n --output-path src/locale	// 修改生成地址到 src/locale</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>--output-path</code>：改变生成文件的位置</li>
<li><code>--format</code>：改变生成文件的格式（XLIFF1.2、XLIFF2、XML消息包）</li>
<li><code>--outFile</code>：改变生成文件的文件名</li>
</ul>
<h3 id="4-生成语言文件副本"><a href="#4-生成语言文件副本" class="headerlink" title="(4).生成语言文件副本"></a>(4).生成语言文件副本</h3><p>提取出来的源语言文件是一个叫做 <code>messages.xlf</code>，当有不同语言需求时需要为不同语言生成源语言文件副本</p>
<p>复制并重命名为 <code>messages.zh.xlf</code>，zh 即为目标语言</p>
<h3 id="5-翻译语言文件副本"><a href="#5-翻译语言文件副本" class="headerlink" title="(5).翻译语言文件副本"></a>(5).翻译语言文件副本</h3><p>交由专业的翻译人员使用 XLIFF 文件编辑器来创建和编辑翻译</p>
<p>打开该文件，将 <code>&lt;source&gt;&lt;/source&gt;</code> 标签复制并粘贴在其下方，改为 <code>&lt;target&gt;&lt;/target&gt;</code> 标签，然后翻译标签中的文本即可</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>Dashboard<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>仪表盘<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-定义本地环境"><a href="#6-定义本地环境" class="headerlink" title="(6).定义本地环境"></a>(6).定义本地环境</h3><p>修改项目的 <code>Angular.json</code> 中相关配置，修改如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;你的项目名&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;i18n&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;sourceLocale&quot;</span>: <span class="string">&quot;en-US&quot;</span>,              <span class="comment">// 当前本地环境语言，en表示语言，US表示国家，这里即美国英语区</span></span><br><span class="line">    <span class="attr">&quot;locales&quot;</span>: &#123;						  <span class="comment">// 本地环境标识符到翻译文件的映射表</span></span><br><span class="line">      <span class="attr">&quot;zh&quot;</span>: <span class="string">&quot;src/locale/messages.zh.xlf&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;architect&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;localize&quot;</span>: <span class="literal">true</span>,				  <span class="comment">// true表示为每种本地环境生成一个应用版本</span></span><br><span class="line">        <span class="attr">&quot;aot&quot;</span>: <span class="literal">true</span>,					  <span class="comment">// 本地化组件模块需要进行预先编译</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="string">&quot;configurations&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;zh&quot;</span>: &#123;							  <span class="comment">// 使用ng serve时配置</span></span><br><span class="line">          <span class="attr">&quot;localize&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;zh&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&quot;serve&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;configurations&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;zh&quot;</span>: &#123;							  <span class="comment">// 使用ng serve 时配置</span></span><br><span class="line">          <span class="attr">&quot;browserTarget&quot;</span>: <span class="string">&quot;你的项目名:build:zh&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-合并翻译文件"><a href="#7-合并翻译文件" class="headerlink" title="(7).合并翻译文件"></a>(7).合并翻译文件</h3><p>构建项目时使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng build --localize</span><br></pre></td></tr></table></figure>

<p>直接在本地运行项目时需要将上一点中后面两个进行配置后使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng serve --open --configuration=zh</span><br></pre></td></tr></table></figure>

<h3 id="引申：生成翻译文件时自动追加新内容"><a href="#引申：生成翻译文件时自动追加新内容" class="headerlink" title="引申：生成翻译文件时自动追加新内容"></a>引申：生成翻译文件时自动追加新内容</h3><blockquote>
<p>直接步骤操作时，当增加新内容时都会重新生成翻译文件，之前翻译过的内容还需重新翻译并不方便，所以可以使用插件来进行追加翻译，参考自 <a href="https://www.cnblogs.com/chen8840/p/14338895.html">这里</a></p>
</blockquote>
<p>导入 <code>ngx-i18nsupport</code> 包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install ngx-i18nsupport --save-dev</span><br></pre></td></tr></table></figure>

<p>在项目的根目录中新增 <code>xliffmerge.json</code> 文件，并写入如下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;xliffmergeOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;srcDir&quot;</span>: <span class="string">&quot;src/locale&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;genDir&quot;</span>: <span class="string">&quot;src/locale&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>package.json</code> 文件中添加翻译合并脚本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="comment">// 生成翻译文件并存放在指定目录下</span></span><br><span class="line">  <span class="attr">&quot;extract-i18n&quot;</span>: <span class="string">&quot;ng extract-i18n --output-path src/locale&quot;</span>,</span><br><span class="line">  <span class="comment">// 调用配置文件将修改追加到指定语言的翻译文件中</span></span><br><span class="line">  <span class="attr">&quot;xliffmerge&quot;</span>: <span class="string">&quot;xliffmerge --profile xliffmerge.json zh&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>之后在生成翻译文件时执行下面语句即可生成且追加修改了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run extract-i18n;npm run xliffmerge;</span><br></pre></td></tr></table></figure>

<p>最后合并翻译文件即可</p>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>在根模块中引入 <code>BrowserAnimationsModule</code> </p>
<p>将动画功能导入组件文件中：</p>
<ul>
<li>直接导入：即执行下面的动画定义即可</li>
<li>导入动画文件：<ul>
<li>将整个触发器都定义在动画文件中</li>
<li>在需要的组件中引入该动画文件，并引入 <code>HostBinding</code></li>
<li>使用 <code>@HostBinding(&#39;@detailTransition&#39;) state = &#39;activated&#39;;</code> 来绑定动画</li>
<li>在注入器中的 <code>animations</code> 数组中传入该动画</li>
</ul>
</li>
<li>可复用动画：见下方</li>
</ul>
<h3 id="动画定义"><a href="#动画定义" class="headerlink" title="动画定义"></a>动画定义</h3><p>在组件中的 <code>@Component()</code> 装饰器的 <code>animations:</code> 属性下用代码定义你要用的动画，该属性传入的是一个数组</p>
<h3 id="动画触发"><a href="#动画触发" class="headerlink" title="动画触发"></a>动画触发</h3><p>使用 <code>trigger()</code> 函数来进行触发，其包含两个参数：</p>
<ul>
<li>触发器的名字</li>
<li>数组，需要触发的动画</li>
</ul>
<h3 id="动画状态和样式"><a href="#动画状态和样式" class="headerlink" title="动画状态和样式"></a>动画状态和样式</h3><p>在触发器的第二个参数中定义动画状态和样式</p>
<p>使用 <code>state()</code> 函数来进行定义，其包含两个参数：</p>
<ul>
<li>状态的名字</li>
<li>该状态的样式，使用 <code>style()</code> 函数来进行定义，其参数为一个对象，对象中传入需要设置的样式（小驼峰命名法）</li>
</ul>
<h3 id="动画转场和时序"><a href="#动画转场和时序" class="headerlink" title="动画转场和时序"></a>动画转场和时序</h3><p>在触发器的第二个参数中定义动画转场和时序</p>
<p>使用 <code>transition()</code> 函数来进行定义，其包含两个参数：</p>
<ul>
<li>表达式，定义两个转场状态之间的方向</li>
<li>数组，接收一个或一系列的 <code>animate()</code> 函数，其包含3个参数<ul>
<li>持续时间，纯数字表示毫秒，表示秒需要使用字符串 <code>&#39;1s&#39;</code> </li>
<li>延迟时间，同上</li>
<li>速度动画：<code>ease-in/ease-out/ease-in-out</code></li>
</ul>
</li>
</ul>
<p><strong>执行顺序</strong>：上面的动画转场设置会覆盖下面的动画转场设置</p>
<h3 id="动画展示"><a href="#动画展示" class="headerlink" title="动画展示"></a>动画展示</h3><p>当动画的相关配置做完以后，就可以附加到页面模板中了</p>
<p>给定义好的动画触发器名前面加上 @ 符号并放入方括号中，然后使用属性绑定语法来绑定到模板表达式上，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;open-close-container&quot;</span> [@<span class="attr">openClose</span>]=<span class="string">&quot;isOpen ? &#x27;open&#x27; : &#x27;close&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>盒子现在是 &#123;&#123;isOpen ? &#x27;开启&#x27; : &#x27;关闭&#x27;&#125;&#125;！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="动画禁用"><a href="#动画禁用" class="headerlink" title="动画禁用"></a>动画禁用</h3><p>当我们想要禁用某元素及其子元素的动画时，可以给该元素绑定 <code>@.disabled</code>，当其值为 true 时会禁止渲染所有动画</p>
<h2 id="转场与触发器"><a href="#转场与触发器" class="headerlink" title="转场与触发器"></a>转场与触发器</h2><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>使用 <code>*</code> 通配符表示任意状态，类似于路由，我们可以把以下状态放置到最后，当所有转场都不匹配时，就使用通配符定义的转场</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">transition(<span class="string">&#x27;* =&gt; *&#x27;</span>, [</span><br><span class="line">    animate(<span class="string">&#x27;1s&#x27;</span>)</span><br><span class="line">]),</span><br></pre></td></tr></table></figure>

<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p><strong>场景</strong>：使用 void 状态可以为进入或离开页面配置转场</p>
<p><strong>使用</strong>：可以配合通配符进行使用</p>
<ul>
<li>当元素离开视图时，就会触发 <code>* =&gt; void(别名:leave)</code> 转场，而不管它离开前处于什么状态</li>
<li>当元素进入视图时，就会触发 <code>void =&gt; *(别名:enter)</code> 转场，而不管它进入时处于什么状态</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>通配符状态 <code>*</code> 会匹配任何状态 —— 包括 <code>void</code></li>
<li>使用别名时可以与 <code>ngIf/ngFor</code> 一起使用</li>
</ul>
<h3 id="父子动画"><a href="#父子动画" class="headerlink" title="父子动画"></a>父子动画</h3><p>每次在 Angular 中触发动画时，父动画始终会优先，而子动画会被阻塞</p>
<p>为了运行子动画，父动画必须查询出包含子动画的每个元素，然后使用 <code>animateChild()</code> 函数来运行它们</p>
<p>若父动画被禁用时，子动画可以使用如下方式运行：</p>
<ul>
<li>父动画可以使用 <code>query()</code> 函数来收集 HTML 模板中位于禁止动画区域内部的元素。这些元素仍然可以播放动画</li>
<li>子动画可以被父动画查询，并且之后使用 <code>animateChild()</code> 来播放它</li>
</ul>
<h2 id="复杂序列"><a href="#复杂序列" class="headerlink" title="复杂序列"></a>复杂序列</h2><p>用于控制复杂序列的函数有：</p>
<ul>
<li><code>query()</code>：查找一个或多个内部 HTML 元素，其包含两个参数：<ul>
<li>css 选择器</li>
<li>数组，传入需要设置的样式和 <code>stagger()</code> 函数</li>
</ul>
</li>
<li><code>stagger()</code>：为多元素动画应用级联延迟，其包含两个参数：<ul>
<li>延迟时间</li>
<li>数组，传入一个或多个 <code>animate()</code> </li>
</ul>
</li>
<li><code>group()</code>：并行执行多个动画步骤，其包含一个数组参数，传入一个或多个 <code>animate()</code></li>
<li><code>sequence()</code>：逐个顺序执行多个动画步骤，其包含两个参数：<ul>
<li><code>style()</code> 函数用来立即应用所指定的样式数据</li>
<li><code>animate()</code> 函数用来在一定的时间间隔内应用样式数据</li>
</ul>
</li>
</ul>
<h2 id="可复用动画"><a href="#可复用动画" class="headerlink" title="可复用动画"></a>可复用动画</h2><p>可以将动画单独定义在一个文件中，然后在需要的组件中引入即可</p>
<p>使用方法如下：</p>
<ul>
<li><p>在 ts 文件中导出一个用 const 定义的变量，其包含两个参数：<code>style()</code> 和 <code>animate()</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> transAnimation = animation([</span><br><span class="line">    style(&#123;</span><br><span class="line">        <span class="attr">height</span>: <span class="string">&#x27;&#123;&#123;height&#125;&#125;&#x27;</span>,</span><br><span class="line">        <span class="attr">opacity</span>: <span class="string">&#x27;&#123;&#123;opacity&#125;&#125;&#x27;</span>,</span><br><span class="line">        <span class="attr">backgroundColor</span>: <span class="string">&#x27;&#123;&#123;backgroundColor&#125;&#125;&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    animate(<span class="string">&#x27;&#123;&#123;time&#125;&#125;&#x27;</span>)</span><br><span class="line">]);</span><br></pre></td></tr></table></figure></li>
<li><p>在组件设置的 <code>animation()</code> 函数的数组中使用 <code>useAnimation()</code> 函数来调用自定义动画，其包含两个参数：动画文件名和参数配置对象</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">transition(<span class="string">&#x27;open =&gt; close&#x27;</span>, [</span><br><span class="line">  useAnimation(transAnimation, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">height</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">opacity</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">      <span class="attr">time</span>: <span class="string">&#x27;1s&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">]),</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>使用 <strong>Express</strong> 来进行渲染</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>通过搜索引擎优化(SEO)来帮助网络爬虫<br>提升在手机和低功耗设备上的性能<br>迅速显示出第一个支持首次内容绘制(FCP)的页面</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>在项目根目录的命令行窗口使用如下命令创建 <code>app.server.module.ts</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ng add @nguniversal/express-engine</span><br></pre></td></tr></table></figure>

<p>渲染项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev:ssr</span><br></pre></td></tr></table></figure>


<h1 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h1><h2 id="error-NG8002"><a href="#error-NG8002" class="headerlink" title="error NG8002"></a>error NG8002</h2><p>报错信息：<code>Can&#39;t bind to &#39;formControl&#39; since it isn&#39;t a known property of &#39;input&#39;.</code></p>
<p>报错场景：试图给 <code>&lt;input&gt;</code> 标签施加 formControl 这个 Directive 的时候出现</p>
<p>解决方法：在 <code>app.module.ts</code> 中导入 <code>ReactiveFormsModule</code> 模块，并在 <strong>NGModule</strong> 中的 imports 字段中引入</p>
<h2 id="ng-build-后的错误"><a href="#ng-build-后的错误" class="headerlink" title="ng build 后的错误"></a>ng build 后的错误</h2><p>参考<a href="https://blog.csdn.net/muguli2008/article/details/105653433/">这里</a></p>
<h2 id="代码内错误"><a href="#代码内错误" class="headerlink" title="代码内错误"></a>代码内错误</h2><p>报错信息：类型“string | null”的参数不能赋给类型“string”的参数</p>
<p>报错场景：当将 localstorage 获取到的值转化为JSON格式时出现</p>
<p>报错原因：localstorage 返回的类型为 <code>string || null</code>，而 <code>JSON.parse()</code> 函数接收的是字符串类型，所以会报错</p>
<p>解决办法：</p>
<ul>
<li>先使用判断语句判断返回值是否为空，不为空时强制将其类型设置为 string</li>
<li>也可以在 <code>JSON.parse()</code> 函数中使用或运算符，当 localstorage 返回为 null 时就使用或运算符后面的内容</li>
</ul>
<h2 id="终端错误"><a href="#终端错误" class="headerlink" title="终端错误"></a>终端错误</h2><p>error TS2322</p>
<p>报错信息： Type ‘Event’ is not assignable to type ‘string’.</p>
<p>报错场景：当我在模板中使用 <code>[(ngModule)]</code> 时出现该错误</p>
<p>报错原因：缺少 <code>FormModule</code> 模块</p>
<p>解决办法：</p>
<ul>
<li>如果项目中只有一个 module，那么就在 <code>app.module.ts</code> 中引入</li>
<li>如果项目中有其他 module，且该模板基于该 module，那么就在该 module 中进行引入</li>
</ul>
<h2 id="页面控制台错误"><a href="#页面控制台错误" class="headerlink" title="页面控制台错误"></a>页面控制台错误</h2><p>报错信息：<code>No value accessor for form control with unspecified name attribute</code></p>
<p>报错场景：当我在模板中使用 <code>[(ngModule)]</code> 时出现该错误</p>
<p>报错原因：双向绑定出现在了非常规的地方，比如我这里是绑定在了 <code>&lt;label&gt;</code> 标签上，同理 <code>&lt;span&gt;/&lt;div&gt;</code> 等都会出现</p>
<p>解决办法：在双向绑定的标签内加入这一选项 <code>ngDefaultControl</code>，用于写入值和侦听输入元素更改</p>
<h1 id="开发技巧"><a href="#开发技巧" class="headerlink" title="开发技巧"></a>开发技巧</h1><h2 id="1-求数组中最大值"><a href="#1-求数组中最大值" class="headerlink" title="1.求数组中最大值"></a>1.求数组中最大值</h2><p>方法如下：</p>
<ul>
<li>排序</li>
<li>使用 <code>Math.max.apply(null, arr)</code> ，apply方法可以将传入的数组展开为对应的参数，然后再执行max方法即可</li>
</ul>
<h2 id="2-click-妙用"><a href="#2-click-妙用" class="headerlink" title="2.(click)妙用"></a>2.(click)妙用</h2><p>可以直接在其中修改值，如 <code>(click)=&quot;isVisible = true;&quot;</code></p>
<p>也可以传入多个事件，如 <code>(click)=&quot;clearModel();changeTab(&#39;/model/create&#39; , &#39;split&#39;);&quot;</code></p>
]]></content>
      <categories>
        <category>Angular开发</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在一台电脑上分别向 GitHub 与 GitLab 提交不同代码？</title>
    <url>/Git-commit.html</url>
    <content><![CDATA[<center>如何在工作电脑上同时向两个仓库提交代码？</center>

<center>如何将工作代码和私人代码区分开？</center>

<center>↓ 看这里 ↓</center>

<span id="more"></span>

<h1 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h1><p>密钥一般存在 <code>c/Users/用户名/.ssh</code> 目录下，如无该目录，自行创建</p>
<p>给两个网站生成不同的密钥</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;公司Gitlab邮箱地址&quot;		// 生成对应的密钥：id_ras与id_ras.pub</span><br><span class="line">ssh-keygen -t rsa -C &quot;个人GitHub邮箱地址” -f ~/.ssh/id_rsa_github	// 生成对应的密钥：id_rsa_github与id_rsa_github.pub</span><br></pre></td></tr></table></figure>

<p>将这两个密钥分别配置到GitLab和GitHub上的设置中</p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>在生成密钥的地方创建一个 <code>config</code> 文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># self(<span class="number">126</span>）</span><br><span class="line">Host github.com</span><br><span class="line">        port <span class="number">22</span></span><br><span class="line">        User git</span><br><span class="line">        HostName github.com</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"># company(FoxMail)</span><br><span class="line">Host gitlab.com</span><br><span class="line">        port <span class="number">22</span></span><br><span class="line">        User git</span><br><span class="line">        HostName 你公司gitlab的地址，注意不需要带http://</span><br><span class="line">        PreferredAuthentications publickey</span><br><span class="line">        IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<h1 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h1><p>在命令行中分别运行以下两个命令，得出相同语句时说明连接成功</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi zhangyangeng! You&#x27;ve successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell access.</span><br><span class="line">$ ssh -T git@gitlab.com</span><br><span class="line">Welcome to GitLab, @zhangyangeng!</span><br></pre></td></tr></table></figure>

<h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><p>这里因为公司电脑经常用到Git，所以我将公司的用户名和邮箱设置为了全局配置</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>将个人配置到单个文件夹里</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config user.name &quot;用户名&quot;</span><br><span class="line">git config user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>之后就可以成功的远程连接仓库了</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用 GitHub 的单个仓库管理多个项目？</title>
    <url>/Git-orphan.html</url>
    <content><![CDATA[<center>想要使用 GitHub 的一个仓库来管理自己多个项目？</center>

<center>不想建立多个文件夹而想要保持主分支的干净？</center>

<center>那么你只要看这篇文章就够了！</center>

<span id="more"></span>

<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>自己近期在公司学习的时候练习的项目也比较多，但存放于公司电脑并不是一个合适的选择<strong style="color:red;">（不方便随处查看）</strong></p>
<p>起初想法是在一个仓库中建立文件夹来区分项目，后来感觉并不合适（每次从别处看的时候整个分支上的内容全clone下来了）</p>
<p>最后发现 orphan 分支（将N个完全不同的项目作为N个分支放在同一个仓库中, 并且分支之间互不影响）完全可以解决该问题</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h2><p>本地创建仓库，并连接到远程仓库</p>
<h2 id="2-创建orphan分支"><a href="#2-创建orphan分支" class="headerlink" title="2.创建orphan分支"></a>2.创建orphan分支</h2><p>按需创建，我这里需要创建一个 Android 分支来单独存放 Android 代码，执行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout --orphan Android</span><br></pre></td></tr></table></figure>

<p>分支虽然创建，但如果不进行提交的话远程仓库是没有该分支的</p>
<h2 id="3-提交代码"><a href="#3-提交代码" class="headerlink" title="3.提交代码"></a>3.提交代码</h2><p>执行如下命令进行提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add ./</span><br><span class="line">git commit -m &quot;test&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-推送到远程仓库"><a href="#4-推送到远程仓库" class="headerlink" title="4.推送到远程仓库"></a>4.推送到远程仓库</h2><p>因为我们是在 orphan 分支上进行的操作，所以在推送的时候也要推送到相应的远程分支上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin Android	// 注意：一定要推送到对应分支上</span><br></pre></td></tr></table></figure>

<h2 id="5-创建其他orphan分支"><a href="#5-创建其他orphan分支" class="headerlink" title="5.创建其他orphan分支"></a>5.创建其他orphan分支</h2><p>操作同上，但建议切换回主分支以后再新建 orphan 分支</p>
<h1 id="克隆问题"><a href="#克隆问题" class="headerlink" title="克隆问题"></a>克隆问题</h1><p>当其他电脑或者其他人想要克隆该项目时该怎么办呢？</p>
<p>操作方法如下：</p>
<h2 id="1-克隆仓库并进入项目"><a href="#1-克隆仓库并进入项目" class="headerlink" title="1.克隆仓库并进入项目"></a>1.克隆仓库并进入项目</h2><p>先将该远程仓库克隆到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:~~~.git</span><br><span class="line">cd xxx</span><br></pre></td></tr></table></figure>

<h2 id="2-查看当前所有分支"><a href="#2-查看当前所有分支" class="headerlink" title="2.查看当前所有分支"></a>2.查看当前所有分支</h2><p>使用如下命令可以看到远程的所有分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<h2 id="3-创建本地分支"><a href="#3-创建本地分支" class="headerlink" title="3.创建本地分支"></a>3.创建本地分支</h2><p>为了在某分支上工作，我们需要在本地创建一个和远程分支同名的分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b Android origin/Android</span><br><span class="line">// 或</span><br><span class="line">git checkout -t origin/Android		// 默认会在本地建立一个和远程分支名字一样的分支</span><br></pre></td></tr></table></figure>

<h2 id="4-拉取远程仓库最新内容"><a href="#4-拉取远程仓库最新内容" class="headerlink" title="4.拉取远程仓库最新内容"></a>4.拉取远程仓库最新内容</h2><p>使用如下命令将该分支上的所有内容全都拉到本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h2 id="5-修改代码并推送"><a href="#5-修改代码并推送" class="headerlink" title="5.修改代码并推送"></a>5.修改代码并推送</h2><p>注意推送到推送到对应分支上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin Android</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>仓库</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：Sass</title>
    <url>/Learn-Sass.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习 Sass 课程时的一些笔记<span id="more"></span></li>
</ul>
<h1 id="一、基础内容"><a href="#一、基础内容" class="headerlink" title="一、基础内容"></a>一、基础内容</h1><h2 id="1-文档"><a href="#1-文档" class="headerlink" title="1.文档"></a>1.文档</h2><ul>
<li>官方 <a href="https://sass-lang.com/">文档</a></li>
<li>中文 <a href="https://sass.bootcss.com/">文档1</a></li>
<li>中文 <a href="https://sass-china.com/">文档2</a></li>
<li>中文 <a href="https://www.sass.hk/">文档3</a></li>
</ul>
<h2 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2.介绍"></a>2.介绍</h2><ul>
<li>Sass 是一种 CSS 的预编译语言。</li>
<li>它提供了 <a href="https://sass.bootcss.com/documentation/variables">变量（variables）</a>、<a href="https://sass.bootcss.com/documentation/style-rules#nesting">嵌套（nested rules）</a>、 <a href="https://sass.bootcss.com/documentation/at-rules/mixin">混合（mixins）</a>、 <a href="https://sass.bootcss.com/documentation/modules">函数（functions）</a>等功能，并且完全兼容 CSS 语法</li>
<li>Sass 能够帮助复杂的样式表更有条理，并且易于在项目内部或跨项目共享设计</li>
</ul>
<h2 id="3-安装编译"><a href="#3-安装编译" class="headerlink" title="3.安装编译"></a>3.安装编译</h2><ul>
<li>如果电脑中有 Node.JS，那么可以通过以下命令来安装</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g sass</span><br></pre></td></tr></table></figure>

<ul>
<li>安装好以后可以使用该命令进行编译</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sass input.scss output.css</span><br><span class="line">sass app/sass:public/stylesheets	// 使用文件夹路径作为输入输出</span><br></pre></td></tr></table></figure>

<h2 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h2><ul>
<li>sass 中使用 <code>$</code> 来定义变量，变量中可以存储字符串、数字、颜色值、布尔值、列表、null值</li>
<li>变量的作用于只在当前层级上有效果，但我们也可以使用 <code>!global</code> 来设置变量为全局的</li>
<li>在 sass 中变量名可以使用中划线分隔也可以使用下划线分隔，两个通用</li>
<li><strong style="color:red;">注意：所有的全局变量我们一般定义在同一个文件，如：<code>_globals.scss</code>，然后我们使用 <code>@include</code> 来包含该文件</strong></li>
</ul>
<h2 id="5-语法"><a href="#5-语法" class="headerlink" title="5.语法"></a>5.语法</h2><h3 id="1-SCSS语法"><a href="#1-SCSS语法" class="headerlink" title="(1).SCSS语法"></a>(1).SCSS语法</h3><ul>
<li>SCSS 语法使用 <code>.scss</code> 文件扩展名，格式中使用花括号来表示：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// scss样式</span></span><br><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif;</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span>;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">font</span>: <span class="number">100%</span> <span class="variable">$font-stack</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$primary-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-SASS语法"><a href="#2-SASS语法" class="headerlink" title="(2).SASS语法"></a>(2).SASS语法</h3><ul>
<li>SASS 语法即缩进语法是原始语法，使用 <code>.sass</code> 文件扩展名，格式中没有括号和分号：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sass样式</span></span><br><span class="line"><span class="variable">$font-stack</span>: Helvetica, sans-serif</span><br><span class="line"><span class="variable">$primary-color</span>: <span class="number">#333</span></span><br><span class="line">body</span><br><span class="line">    font: <span class="number">100%</span> <span class="variable">$font-stack</span></span><br><span class="line">    color: <span class="variable">$primary-color</span></span><br></pre></td></tr></table></figure>

<h2 id="6-功能拓展"><a href="#6-功能拓展" class="headerlink" title="6.功能拓展"></a>6.功能拓展</h2><h3 id="1-嵌套"><a href="#1-嵌套" class="headerlink" title="(1).嵌套"></a>(1).嵌套</h3><ul>
<li>嵌套越深，生成的 CSS 代码就越多，所以注意控制嵌套的深度</li>
<li>Sass 嵌套 CSS 选择器类似于 HTML 的嵌套规则，如下：<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="variable">$heigth</span>: <span class="number">200px</span>;</span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="variable">$heigth</span>;</span><br><span class="line">    <span class="selector-tag">li</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">$heigth</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="variable">$width</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-嵌套属性"><a href="#2-嵌套属性" class="headerlink" title="(2).嵌套属性"></a>(2).嵌套属性</h3><ul>
<li>很多 CSS 属性都有同样的前缀，例如：<code>font-family, font-size 和 font-weight ， text-align, text-transform 和 text-overflow</code></li>
<li>在 Sass 中，我们可以使用嵌套属性来编写它们，如下：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    <span class="comment">// 嵌套属性</span></span><br><span class="line">    <span class="attribute">font</span>: &#123;</span><br><span class="line">        family: Helvetica, sans-serif;</span><br><span class="line">        size: <span class="number">18px</span>;</span><br><span class="line">        weight: bold;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-父节点选择器"><a href="#3-父节点选择器" class="headerlink" title="(3).父节点选择器"></a>(3).父节点选择器</h3><ul>
<li>当给父元素设置伪类时，sass 会以后代选择器的方式进行拼接，这样时不对的，所以我们可以在内部使用 <code>&amp;</code> 来表示父选择器<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    &amp;<span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-占位符选择器"><a href="#4-占位符选择器" class="headerlink" title="(4).占位符选择器"></a>(4).占位符选择器</h3><ul>
<li>使用 <code>%</code> 开头，且不会输出在 CSS 当中</li>
<li>作用：主要用于继承时使用，不会影响到原有的样式<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">%default&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#bfa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span>&#123;</span><br><span class="line">    <span class="keyword">@extend</span> %default;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-注释"><a href="#7-注释" class="headerlink" title="7.注释"></a>7.注释</h2><h3 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="(1).单行注释"></a>(1).单行注释</h3><ul>
<li>使用 <code>//</code> 来指定，被称为 <strong>静默注释</strong>，因为不生成 CSS 语句</li>
</ul>
<h3 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="(2).多行注释"></a>(2).多行注释</h3><ul>
<li>使用 <code>/* */</code> 来指定，多行注释会被编译为 CSS 注释，所以被称为 <strong>显示注释</strong></li>
<li>多行注释在<strong>压缩模式</strong>时会从 CSS 中删除，可以使用 <code>/*! */</code> 来强制显示在 CSS 的输出中</li>
</ul>
<h3 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="(3).文档注释"></a>(3).文档注释</h3><ul>
<li>文档注释是静默注释，用三个斜杠（<code>///</code>）直接写在文档的正上方</li>
</ul>
<h1 id="二、SassScript"><a href="#二、SassScript" class="headerlink" title="二、SassScript"></a>二、SassScript</h1><ul>
<li>SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能</li>
</ul>
<h2 id="1-Interactive-Shell"><a href="#1-Interactive-Shell" class="headerlink" title="1.Interactive Shell"></a>1.Interactive Shell</h2><ul>
<li>在命令行中输入 <code>sass -i</code> 即可在命令行中测试相关内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt; 6px + 10px</span><br><span class="line">16px</span><br><span class="line">&gt;&gt; &quot;Hello World&quot;</span><br><span class="line">&quot;Hello World&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><ul>
<li></li>
</ul>
<h2 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3.数据类型"></a>3.数据类型</h2><h3 id="1-字符串"><a href="#1-字符串" class="headerlink" title="(1).字符串"></a>(1).字符串</h3><ul>
<li>分为有引号字符串和无引号字符串</li>
<li>使用<strong>插值</strong>时会将有引号字符串编译为无引号字符串</li>
</ul>
<h2 id="4-运算"><a href="#4-运算" class="headerlink" title="4.运算"></a>4.运算</h2><ul>
<li></li>
</ul>
<h1 id="三、-规则"><a href="#三、-规则" class="headerlink" title="三、@规则"></a>三、@规则</h1><h2 id="1-import"><a href="#1-import" class="headerlink" title="1.@import"></a>1.@import</h2><ul>
<li>sass 使用 <code>@import</code> 语法来导入文件<ul>
<li>使用 css 导入时会创建一个额外的 HTTP 请求</li>
<li>但是使用 sass 导入式不需要额外的 HTTP 请求</li>
</ul>
</li>
<li>语法：<code>@import filename</code></li>
</ul>
<h3 id="Sass-Partials"><a href="#Sass-Partials" class="headerlink" title="Sass Partials"></a>Sass Partials</h3><ul>
<li>如果不想让某个 sass 文件编译为 css 文件，可以在该文件的开头加一个下划线</li>
<li>语法：<code>_filename</code> </li>
<li>导入该文件时不需要使用下划线</li>
<li><strong style="color:red;">注意：请不要将带下划线与不带下划线的同名文件放置在同一个目录下，比如 _colors.scss 和 colors.scss 不能同时存在于同一个目录下，否则带下划线的文件将会被忽略</strong></li>
</ul>
<h2 id="2-mixin"><a href="#2-mixin" class="headerlink" title="2.@mixin"></a>2.@mixin</h2><ul>
<li><p>混入：允许我们定义一个可以在整个样式表中重复使用的样式</p>
</li>
<li><p>语法：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> important-text&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>混入中也可以包含混入</p>
</li>
<li><p>混入中可以传入参数（同时可以设置默认参数）：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> bordered(<span class="variable">$color</span>,<span class="variable">$width</span>) &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="variable">$width</span> solid <span class="variable">$color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.myArticle</span>&#123;</span><br><span class="line">    <span class="keyword">@include</span> bordered(red, <span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>混入中也可以传入可变参数，即不能确定使用多少个参数时，可以使用 <code>...</code> 来设置可变参数</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> box-shadow(<span class="variable">$shadows</span>...) &#123;</span><br><span class="line">    -moz-<span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">    -webkit-<span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.shadows</span>&#123;</span><br><span class="line">    <span class="keyword">@include</span> box-shadow(<span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>混入也可以使用在浏览器前缀上</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> transform(<span class="variable">$property</span>) &#123;</span><br><span class="line">    -webkit-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">    -ms-<span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="variable">$property</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.myBox</span>&#123;</span><br><span class="line">    <span class="keyword">@include</span> transform(rotate(<span class="number">20deg</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-include"><a href="#3-include" class="headerlink" title="3.@include"></a>3.@include</h2><ul>
<li>使用该指令可以使用上面定义好的混入</li>
<li>语法；</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> important-text&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.danger</span>&#123;</span><br><span class="line">    <span class="keyword">@include</span> important-text;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-extend"><a href="#4-extend" class="headerlink" title="4.@extend"></a>4.@extend</h2><ul>
<li>继承：可以使改选择器的样式从另一个选择器继承</li>
<li>语法：</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button-basic</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: none;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span> <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button-report</span>&#123;</span><br><span class="line">    <span class="keyword">@extend</span> .button-basic;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button-submit</span>&#123;</span><br><span class="line">    <span class="keyword">@extend</span> .button-basic;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果被继承的选择器的子选择器设置了样式，那么继承的选择器的子选择器也同样会继承到该样式</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li></li>
</ul>
<h2 id="原生规则"><a href="#原生规则" class="headerlink" title="原生规则"></a>原生规则</h2><h3 id="1-media"><a href="#1-media" class="headerlink" title="(1).@media"></a>(1).@media</h3><ul>
<li>Sass 中的 <code>@media</code> 支持嵌套使用<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bar</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape)&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、函数"><a href="#四、函数" class="headerlink" title="四、函数"></a>四、函数</h1><ul>
<li><a href="https://www.runoob.com/sass/sass-functions.html">https://www.runoob.com/sass/sass-functions.html</a></li>
</ul>
<h2 id="1-字符串-1"><a href="#1-字符串-1" class="headerlink" title="1.字符串"></a>1.字符串</h2><ul>
<li></li>
</ul>
<h2 id="2-数字"><a href="#2-数字" class="headerlink" title="2.数字"></a>2.数字</h2><ul>
<li></li>
</ul>
<h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h2><ul>
<li></li>
</ul>
<h2 id="4-映射"><a href="#4-映射" class="headerlink" title="4.映射"></a>4.映射</h2><ul>
<li></li>
</ul>
<h2 id="5-选择器"><a href="#5-选择器" class="headerlink" title="5.选择器"></a>5.选择器</h2><ul>
<li></li>
</ul>
<h2 id="6-Introspection"><a href="#6-Introspection" class="headerlink" title="6.Introspection"></a>6.Introspection</h2><ul>
<li></li>
</ul>
<h2 id="7-颜色"><a href="#7-颜色" class="headerlink" title="7.颜色"></a>7.颜色</h2><ul>
<li></li>
</ul>
<h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8.其他"></a>8.其他</h2><h3 id="1-url"><a href="#1-url" class="headerlink" title="(1).url()"></a>(1).url()</h3><ul>
<li>可以接受带引号的 url，也可以不带引号的 url<ul>
<li>如果<code>url()</code>的参数是一个有效的未引用 URL，那么 Sass 将按原样解析它，不过也可以使用插值注入 SassScript 值</li>
<li>如果它不是一个有效的未引用 URL（如果它包含变量或函数调用）它将被解析为一个原生的 CSS 函数调用</li>
</ul>
</li>
</ul>
<h3 id="2-calc-element"><a href="#2-calc-element" class="headerlink" title="(2).calc()/element()"></a>(2).calc()/element()</h3><ul>
<li><code>calc()</code>的数学表达式与Sass的算法冲突，而且<code>element()</code>的id可以被解析为颜色，所以它们需要特殊的解析<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$width</span>: <span class="number">800px</span>;</span><br><span class="line"><span class="attribute">left</span>: calc(<span class="number">50%</span> - #&#123;<span class="variable">$width</span> / <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-min-max"><a href="#3-min-max" class="headerlink" title="(3).min()/max()"></a>(3).min()/max()</h3><ul>
<li><p>如果是原生 CSS 调用，则会编译成一个 CSS 的 <code>min()/max()</code> 调用，包括对 <code>calc()/env()/var()/min()/max()</code> 的嵌套调用或者插值</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: max(#&#123;<span class="variable">$padding</span>&#125;, env(safe-area-inset-left));</span><br><span class="line">  <span class="attribute">padding-right</span>: max(#&#123;<span class="variable">$padding</span>&#125;, env(safe-area-inset-right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果调用的任何部分包含 SassScript 的特性，包括变量或函数调用，则会解析成 sass 的 <code>min()/max()</code> 调用</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: max(<span class="variable">$padding</span>, <span class="number">20px</span>);</span><br><span class="line">  <span class="attribute">padding-right</span>: max(<span class="variable">$padding</span>, <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：TypeScript（尚硅谷）</title>
    <url>/Learn-TS.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 TypeScript 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><ul>
<li>什么是 TS？<ul>
<li>是添加了类型系统的 JS，适用于任何规模的项目</li>
<li>是一门静态类型、弱类型的语言</li>
<li>是完全兼容 JS 的，它不会修改 JS 运行时的特性</li>
</ul>
</li>
<li>TS 特点：<ul>
<li>TS 需要先编译为 JS，然后运行在浏览器、Node.js 等任何能运行 JS 的环境中</li>
<li>拥有很多编译选项，可自由决定类型检查的严格程度</li>
<li>可以和 JS 共存</li>
<li>增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力</li>
<li>拥有活跃的社区，大多数常用的第三方库都提供了类型声明</li>
<li>与标准同步发展，符合最新的 ES 标准</li>
</ul>
</li>
<li>核心设计理念：在完整保留 JS 运行时行为的基础上，通过引入静态类型系统来提高代码的可维护性，减少可能出现的 bug</li>
<li>TS 与 JS 的不同点：<ul>
<li>TS 是静态类型，它在运行前需要先编译为 JS，而在编译阶段就会进行类型检查；TS 坚持与 ES 标准同步发展；TS 非常适用于大型项目</li>
<li>JS 是动态类型，它在运行时才会进行类型检查</li>
</ul>
</li>
<li>TS 与 JS 的相同点：<ul>
<li>它们都是弱类型，允许隐式类型转换</li>
</ul>
</li>
</ul>
<h2 id="1-开发环境"><a href="#1-开发环境" class="headerlink" title="1.开发环境"></a>1.开发环境</h2><ul>
<li><p>下载并安装 Node.js</p>
</li>
<li><p>使用 npm 全局安装 TypeScript：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个 ts 文件</li>
<li>编译一个 ts 文件：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>

<h2 id="2-编辑器"><a href="#2-编辑器" class="headerlink" title="2.编辑器"></a>2.编辑器</h2><ul>
<li>推荐使用 VSCode</li>
</ul>
<h2 id="3-参考教程"><a href="#3-参考教程" class="headerlink" title="3.参考教程"></a>3.参考教程</h2><ul>
<li>官方<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html">文档</a></li>
<li>阮一峰<a href="http://ts.xcatliu.com/">教程</a></li>
</ul>
<h1 id="二、基础内容"><a href="#二、基础内容" class="headerlink" title="二、基础内容"></a>二、基础内容</h1><h2 id="1-类型声明"><a href="#1-类型声明" class="headerlink" title="1.类型声明"></a>1.类型声明</h2><ul>
<li>使用 <code>:</code> 声明变量的类型，<code>:</code> 的前后有没有空格都可以</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给变量指定类型</span></span><br><span class="line"><span class="keyword">let</span> a : <span class="built_in">number</span> = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 给函数的参数指定类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a : <span class="built_in">number</span>, b : <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给函数的返回值指定类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = sum(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>如果变量的声明和赋值是同时进行的，ts 可以自动对变量进行类型检测</li>
<li>即使指定不符合的变量类型，执行 ts 文件时依然会生成 js 文件；如果要在报错的时候终止 js 文件的生成，可以在 <code>tsconfig.json</code> 中配置 <code>noEmitOnError</code> 即可</li>
</ul>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h2><h3 id="1-number"><a href="#1-number" class="headerlink" title="(1).number"></a>(1).number</h3><ul>
<li>表示数值类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-string"><a href="#2-string" class="headerlink" title="(2).string"></a>(2).string</h3><ul>
<li>表示字符串类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">string</span> = <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-Boolean"><a href="#3-Boolean" class="headerlink" title="(3).Boolean"></a>(3).Boolean</h3><ul>
<li>表示布尔类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意，使用构造函数 <code>Boolean</code> 创造的对象<strong>不是</strong>布尔值，其返回的是一个 <code>Boolean</code> 对象</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> createdByNewBoolean: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4"><a href="#4" class="headerlink" title="(4).|"></a>(4).|</h3><ul>
<li><p>联合类型表示取值可以为多种类型中的一种</p>
</li>
<li><p>当使用字面量进行类型声明时，是无法修改其值的</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这时我们可以使用联合类型 <code>|</code> 来连接多个类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="string">&quot;male&quot;</span> | <span class="string">&quot;female&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当使用联合类型时我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong></li>
</ul>
<h3 id="5-any"><a href="#5-any" class="headerlink" title="(5).any"></a>(5).any</h3><ul>
<li>表示任意类型，当一个变量设置为 any 相当于关闭了对该变量的 ts 类型检测</li>
<li>声明变量如果不指定类型，则 ts 解析器会自动判断变量的类型为 any（隐式any）</li>
<li><strong style="color:red;">当把一个 any 类型的值赋值给其他变量时不会报错，不建议使用</strong></li>
</ul>
<h3 id="6-unknown"><a href="#6-unknown" class="headerlink" title="(6).unknown"></a>(6).unknown</h3><ul>
<li>表示未知类型的值，是类型安全的 any</li>
<li><strong style="color:red;">当把一个 unknown 类型的值赋值给其他变量时会报错，建议使用</strong></li>
<li>解决报错1：进行类型判断</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: unknown;</span><br><span class="line">a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s: <span class="built_in">string</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a === <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">    s = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决报错2：类型断言</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: unknown;</span><br><span class="line">a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s: <span class="built_in">string</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">s = a <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">s = &lt;<span class="built_in">string</span>&gt;a;</span><br></pre></td></tr></table></figure>

<h3 id="7-void"><a href="#7-void" class="headerlink" title="(7).void"></a>(7).void</h3><ul>
<li>表示空，在函数中表示没有返回值</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>声明 void 类型的变量只能赋值给 undefined 和 null，而不能赋值给 <code>number</code> 类型</li>
</ul>
<h3 id="8-undefined-amp-null"><a href="#8-undefined-amp-null" class="headerlink" title="(8).undefined &amp; null"></a>(8).undefined &amp; null</h3><ul>
<li>可以使用其来定义这两个原始数据类型</li>
<li><code>undefined</code> 和 <code>null</code> 是所有类型的子类型，所以其可以赋值给 <code>number</code> 类型的变量</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="built_in">number</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="9-never"><a href="#9-never" class="headerlink" title="(9).never"></a>(9).never</h3><ul>
<li>表示永远不会返回结果，用于进行报错</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>): <span class="title">never</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;报错了！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-object"><a href="#10-object" class="headerlink" title="(10).object"></a>(10).object</h3><ul>
<li>表示对象，使用 <code>&#123;&#125;</code> 指定对象中可以包含哪些属性</li>
<li>属性名后加 <code>?</code> 表示属性是可选的</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, age?: <span class="built_in">number</span>&#125;;</span><br><span class="line">b = &#123;<span class="attr">name</span>: <span class="string">&quot;孙悟空&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以使用 <code>[propName: string]: any</code> 表示任意类型的属性</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c: &#123;<span class="attr">name</span>: <span class="built_in">string</span>, [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>&#125;;</span><br><span class="line">c = &#123;<span class="attr">name</span>: <span class="string">&quot;孙悟空&quot;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-function"><a href="#11-function" class="headerlink" title="(11).function"></a>(11).function</h3><ul>
<li>使用箭头函数来设置函数的类型声明</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> d: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">d = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-array"><a href="#12-array" class="headerlink" title="(12).array"></a>(12).array</h3><ul>
<li><p>表示数组，数组表示法主要有以下几个：</p>
</li>
<li><p>类型+方括号：</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> e: <span class="built_in">string</span>[];</span><br><span class="line">e = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>数组泛型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> f: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line">f = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>接口：不常用，主要用来表示类数组</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只要索引的类型是数字时，那么值的类型必须是数字</span></span><br><span class="line"><span class="keyword">interface</span> NumberArray&#123;</span><br><span class="line">	[index: <span class="built_in">number</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fibonacci: NumberArray = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>


<h3 id="13-tuple"><a href="#13-tuple" class="headerlink" title="(13).tuple"></a>(13).tuple</h3><ul>
<li>表示元组，元组就是固定长度的数组</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> g: [<span class="built_in">string</span>, <span class="built_in">string</span>];</span><br><span class="line">g = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="14-enum"><a href="#14-enum" class="headerlink" title="(14).enum"></a>(14).enum</h3><ul>
<li>表示枚举</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Gender&#123;</span><br><span class="line">    male = <span class="number">0</span>,</span><br><span class="line">    female = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">gender</span>: Gender</span><br><span class="line">&#125;</span><br><span class="line">h = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">    <span class="attr">gender</span>: Gender.male</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-类型推论"><a href="#3-类型推论" class="headerlink" title="3.类型推论"></a>3.类型推论</h2><ul>
<li>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型</li>
<li>例如：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">string</span> = <span class="string">&quot;a&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-类型别名"><a href="#4-类型别名" class="headerlink" title="4.类型别名"></a>4.类型别名</h2><ul>
<li>当我们需要很多类型时，可能会因为太长而增加书写量，所以可以给类型设置别名</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> myType = <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">let</span> a1: myType;</span><br><span class="line"><span class="keyword">let</span> a2: myType;</span><br><span class="line"><span class="keyword">let</span> a3: myType;</span><br><span class="line">a1 = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">a2 = <span class="number">1</span>;</span><br><span class="line">a3 = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-编译选项"><a href="#5-编译选项" class="headerlink" title="5.编译选项"></a>5.编译选项</h2><h3 id="1-自动编译"><a href="#1-自动编译" class="headerlink" title="(1).自动编译"></a>(1).自动编译</h3><ul>
<li>可以监视 ts 文件的变化，自动编译，在命令行中执行命令即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tsc app.ts -w</span><br></pre></td></tr></table></figure>

<ul>
<li>缺点：只可以监视当前文件，且无法关闭监视窗口</li>
</ul>
<h3 id="2-全部编译"><a href="#2-全部编译" class="headerlink" title="(2).全部编译"></a>(2).全部编译</h3><ul>
<li>当我们想要编译全部 ts 文件时，需要现在该目录的根目录中创建 ts 的配置文件 —— <code>tsconfig.json</code> </li>
<li>在命令行中使用 <code>tsc/tsc -w</code> 命令即可</li>
</ul>
<h4 id="引申：配置文件"><a href="#引申：配置文件" class="headerlink" title="引申：配置文件"></a>引申：配置文件</h4><ul>
<li>配置文件中以 <code>&#123;&#125;</code> 为最外部，其中主要有以下几个参数</li>
<li><code>include</code>：表示需要编译的目录或文件<ul>
<li><code>**</code> 表示任意目录</li>
<li><code>*</code> 表示任意文件</li>
</ul>
</li>
<li><code>exclude</code>：表示不需要编译的目录或文件<ul>
<li>默认值有：<code>[&quot;node_modules&quot;, &quot;bower_components&quot;, jspm_packages]</code> </li>
</ul>
</li>
<li><code>extends</code>：表示继承哪个配置文件的配置</li>
<li><code>files</code>：表示需要编译的文件</li>
<li><code>compilerOptions</code>：表示编译器的选项<ul>
<li><code>target</code>：指定 ts 编译时 IE 版本</li>
<li><code>module</code>：指定要使用的模块规范</li>
<li><code>lib</code>：指定项目中要使用的库，一般不需要修改，只有在非浏览器哦环境下运行时才会需要改</li>
<li><code>outdir</code>：指定编译后文件所在目录</li>
<li><code>outfile</code>：将代码合并为一个文件</li>
<li><code>allowJs</code>：是否对 js 文件进行编译，默认为 false</li>
<li><code>removeComments</code>：是否在编译的时候移除注释</li>
<li><code>noEmit</code>：不生成编译后的文件，默认为 false</li>
<li><code>noEmitOnError</code>：当有错误时不生成编译文件</li>
<li><code>strict</code>：所有的严格检查的总开关，即控制以下4个，建议设置为 true</li>
<li><code>alwaysStrict</code>：设置编译后的文件是否使用严格模式</li>
<li><code>noImplictAny</code>：不允许隐式 any 类型</li>
<li><code>noImplictThis</code>：不允许不明确类型的 this</li>
<li><code>strictNullChecks</code>：严格的检查空值</li>
</ul>
</li>
</ul>
<h2 id="6-使用Webpack打包"><a href="#6-使用Webpack打包" class="headerlink" title="6.使用Webpack打包"></a>6.使用Webpack打包</h2><h3 id="1-安装相关依赖"><a href="#1-安装相关依赖" class="headerlink" title="(1).安装相关依赖"></a>(1).安装相关依赖</h3><ul>
<li>在根目录中初始化package包</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<ul>
<li>在项目根目录中安装如下依赖；</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm i -D webpack webpack-cli typescript ts-loader</span><br></pre></td></tr></table></figure>

<ul>
<li>依赖分别为：Webpack包、Webpack命令行工具、TypeScript包、ts编译器</li>
</ul>
<h3 id="2-创建webpack配置文件"><a href="#2-创建webpack配置文件" class="headerlink" title="(2).创建webpack配置文件"></a>(2).创建webpack配置文件</h3><ul>
<li>在根目录中创建 <code>webpack.config.js</code> 文件</li>
<li>根据以下内容配置：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入一个包</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="comment">// webpack 中的所有配置信息都应该写在 module.exports 中</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 指定入口文件</span></span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/index.ts&quot;</span>,</span><br><span class="line">    <span class="comment">// 指定打包文件所在目录</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定打包文件的目录</span></span><br><span class="line">        <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">        <span class="comment">// 打包后文件的名字</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 指定webpack打包时要用的模块</span></span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定要加载的规则</span></span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 指定规则生效的文件</span></span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>,</span><br><span class="line">                <span class="comment">// 指定要使用的loader</span></span><br><span class="line">                use: <span class="string">&quot;ts-loader&quot;</span>,</span><br><span class="line">                <span class="comment">// 指定要排除的文件</span></span><br><span class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 配置webpack插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;这里可以自定义标题&quot;</span>,</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 设置引用模块</span></span><br><span class="line">    <span class="attr">resolve</span>: &#123;</span><br><span class="line">    	<span class="attr">extensions</span>: [<span class="string">&quot;.ts&quot;</span>, <span class="string">&quot;.js&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-创建ts配置文件"><a href="#3-创建ts配置文件" class="headerlink" title="(3).创建ts配置文件"></a>(3).创建ts配置文件</h3><ul>
<li>在项目根目录中创建一个 <code>tsconfig.json</code> 文件</li>
<li>根据以下内容配置：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ES2015&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-修改package-json文件"><a href="#4-修改package-json文件" class="headerlink" title="(4).修改package.json文件"></a>(4).修改package.json文件</h3><ul>
<li>在 <code>scripts</code> 字段中添加 <code>build</code> 字段</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="5-自动生成HTML网页"><a href="#5-自动生成HTML网页" class="headerlink" title="(5)自动生成HTML网页"></a>(5)自动生成HTML网页</h3><ul>
<li>在项目根目录的命令行中执行 <code>npm i -D html-webpack-plugin</code> </li>
<li>在 <code>webpack.config.js</code> 中引入并配置：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 配置webpack插件</span></span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&quot;这里可以自定义标题&quot;</span>,</span><br><span class="line">            <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span></span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-Webpack开发服务器"><a href="#6-Webpack开发服务器" class="headerlink" title="(6)Webpack开发服务器"></a>(6)Webpack开发服务器</h3><ul>
<li>在项目根目录的命令行中执行 <code>npm i -D webpack-dev-server</code> </li>
<li>在 <code>package.json</code> 中的 <code>scripts</code> 字段中配置如下：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack serve --open chrome.exe&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：可以实时更新，即可以监控 ts 文件是否修改然后重新编译</li>
</ul>
<h3 id="7-编译时删除旧编译文件"><a href="#7-编译时删除旧编译文件" class="headerlink" title="(7).编译时删除旧编译文件"></a>(7).编译时删除旧编译文件</h3><ul>
<li>在项目根目录的命令行中执行 <code>npm i -D clean-webpack-plugin</code></li>
<li>在 <code>webpack.config.js</code> 中引入并配置：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&quot;clean-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h1><h2 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h2><ul>
<li></li>
</ul>
<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><ul>
<li>构造函数会在对象创建的时候调用，在实例方法中，this就表示当前的实例</li>
<li>因此可以通过 this 向新建的对象中添加属性</li>
</ul>
<h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h2><ul>
<li>通过继承可以将多个类中共同的代码写在一个父类中，所有的子类将拥有父类中的属性和方法</li>
<li>如果在子类中写了构造函数，则必须对父类的构造函数进行调用，即使用 <code>super()</code> </li>
</ul>
<h2 id="4-抽象类"><a href="#4-抽象类" class="headerlink" title="4.抽象类"></a>4.抽象类</h2><ul>
<li>以 abstract 开头的类是抽象类，抽象类不能用于创建对象，所以抽象类是专门用来做继承的</li>
<li>在抽象类中可以定义抽象方法，抽象方法使用 abstract 开头且没有方法体，子类必须对抽象方法进行重写</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">sabstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">abstract</span> sayHello(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;喵喵喵&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-接口"><a href="#5-接口" class="headerlink" title="5.接口"></a>5.接口</h2><ul>
<li>接口用来定义一个类的结构，用来定义一个类中应该含有哪些属性和方法</li>
<li>接口也可以当做类型声明去使用</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> myInterface&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口可以在定义类的时候去限制类的结构，且接口中所有的属性都不能有实际的值，接口中的方法都是抽象方法</li>
<li>定义类时，可以实现一个接口：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="title">implements</span> <span class="title">myInterface</span></span>&#123;</span><br><span class="line">	xxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-属性的封装"><a href="#6-属性的封装" class="headerlink" title="6.属性的封装"></a>6.属性的封装</h2><ul>
<li>类的修饰符有三种：<ul>
<li>public：公有属性，可以在任意地方访问与修改</li>
<li>private：私有属性，只能在类内部进行访问修改</li>
<li>protected：受保护的属性，只能在当前类和当前类的子类中使用</li>
</ul>
</li>
<li>类中定义的属性与方法，如果不加以限制会被外界随意读取与修改，这并不是合规的，所以我们需要对属性进行相关的封装</li>
</ul>
<h3 id="1-js中属性的封装"><a href="#1-js中属性的封装" class="headerlink" title="(1).js中属性的封装"></a>(1).js中属性的封装</h3><ul>
<li>在 js 中我们需要设置属性的修饰符为 <code>private</code></li>
<li>然后使用属性的<strong>存取器</strong>来进行读取和设置：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    private name: string;</span><br><span class="line">    private age: number;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: string, age: number</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">setName</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>);</span><br><span class="line">p.setName(<span class="string">&quot;猪八戒&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.getName());</span><br></pre></td></tr></table></figure>

<h3 id="2-ts中属性的封装"><a href="#2-ts中属性的封装" class="headerlink" title="(2).ts中属性的封装"></a>(2).ts中属性的封装</h3><ul>
<li>在 ts 中我们需要设置属性的修饰符为 <code>private</code></li>
<li>ts 中简化了操作，设置 getter 与 setter 的方法如下：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animall</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> _name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">private</span> _age: <span class="built_in">number</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>._name = name;</span><br><span class="line">        <span class="built_in">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">name</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>._name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Animall(<span class="string">&quot;小狗&quot;</span>, <span class="number">3</span>);</span><br><span class="line">a.name = <span class="string">&quot;小猫&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br></pre></td></tr></table></figure>

<ul>
<li>在 ts 中我们可以直接使用 <code>对象.属性</code> 的方式来读取或者修改属性值</li>
</ul>
<h2 id="7-泛型"><a href="#7-泛型" class="headerlink" title="7.泛型"></a>7.泛型</h2><ul>
<li>在定义函数或类时，如果遇到类型不明确时就可以使用<strong>泛型</strong></li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>&lt;<span class="title">T</span>&gt;(<span class="params">a: T</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">10</span>);                 <span class="comment">// 不指定泛型，TS可以自动进行类型推断</span></span><br><span class="line">fn&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hello&quot;</span>);    <span class="comment">// 指定泛型</span></span><br></pre></td></tr></table></figure>

<ul>
<li>泛型也可以指定多个</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>&lt;<span class="title">T</span>, <span class="title">K</span>&gt;(<span class="params">a: T, b: K</span>): <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">fn2&lt;<span class="built_in">number</span>, <span class="built_in">string</span>&gt;(<span class="number">123</span>, <span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型可以实现接口</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Inter&#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Inter</span>&gt;(<span class="params">a: T</span>): <span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型可以自动识别类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="attr">name</span>: T;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: T</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mc = <span class="keyword">new</span> MyClass&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;孙悟空&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h1><h2 id="错误1："><a href="#错误1：" class="headerlink" title="错误1："></a>错误1：</h2><p><strong>报错信息</strong>：<code>String does not match the pattern of &quot;^(?:@[a-z0-9-*~][a-z0-9-*._~]*/)?[a-z0-9-~][a-z0-9-._~]*$&quot;.</code></p>
<p><strong>报错原因</strong>：package.json 文件中的名字必须全为小写</p>
<h2 id="错误2："><a href="#错误2：" class="headerlink" title="错误2："></a>错误2：</h2><p><strong>报错信息</strong>：<code>Property &#39;value&#39; does not exist on type &#39;EventTarget&#39;</code></p>
<p><strong>报错原因</strong>：出现此报错大概率是在获取 <code>event.target.value</code> 时遇到的，在 js 中很明显它是正常的，但是在 ts 中就显得不太正常了，因为并不是所有的 HTMLEmelent 上都含有 <code>target</code> 属性，所以才会出现报错</p>
<p><strong>解决办法</strong>：为你的 HTML 元素执行明确的类型断言，例如：<code>(e.target as HTMLButtonElement).value</code> </p>
<h2 id="错误3："><a href="#错误3：" class="headerlink" title="错误3："></a>错误3：</h2><p><strong>报错信息</strong>：<code>Parsing error: Unexpected token. Did you mean &#123;&#39;&gt;&#39;&#125; or &amp;gt;?</code></p>
<p><strong>报错原因</strong>：在该行代码处使用了标签形式的类型声明，而 ESlint 在检测的时候误以为 HTML 标签：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里的&lt;number&gt;</span></span><br><span class="line"><span class="built_in">this</span>.corpusMaxNum = &lt;<span class="built_in">number</span>&gt;res.paramList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id === <span class="string">&#x27;Titan.Model.Corpus.MaxNum&#x27;</span>)[<span class="number">0</span>].value;</span><br></pre></td></tr></table></figure>

<p><strong>解决办法</strong>：使用 <code>as</code> 进行类型断言即可</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.corpusMaxNum = res.paramList.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.id === <span class="string">&#x27;Titan.Model.Corpus.MaxNum&#x27;</span>)[<span class="number">0</span>].value <span class="keyword">as</span> <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<h2 id="错误4：Timer单位"><a href="#错误4：Timer单位" class="headerlink" title="错误4：Timer单位"></a>错误4：Timer单位</h2><p>在 ts 文件中如果想要使用定时器，需要给定时器设置一个类型，虽然定时器返回的是 number 类型，但是如果按 number 类型定义时会出错，所以需要借用 NodeJS.Timer 来进行定义</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Timer = NodeJS.Timer;</span><br><span class="line"><span class="keyword">private</span> timer: Timer;</span><br></pre></td></tr></table></figure>

<p>这时会出现报错 <code>&#39;NodeJS&#39; is not defined.eslint</code></p>
<p>解决办法参考该 <a href="https://github.com/Chatie/eslint-config/issues/45">issue</a></p>
<h2 id="错误5：WheelEvent问题"><a href="#错误5：WheelEvent问题" class="headerlink" title="错误5：WheelEvent问题"></a>错误5：WheelEvent问题</h2><p><strong>报错信息</strong>：<code>TS2339:Property &#39;wheelDelta&#39; does not exist on type &#39;WheelEvent</code> </p>
<p><strong>报错场景</strong>：需要监控鼠标滚轮事件时，通过 <code>event.wheelDelta</code> 属性的正负来判断鼠标滚轮滚动的方向</p>
<p><strong>报错原因</strong>：通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WheelEvent">MDN文档</a> 查看该属性被标注为 <code>Deprecated/Non-standard</code> ，发现该属性已被弃用</p>
<p><strong>解决办法</strong>：现在可以使用 <code>deltaY</code> 属性来替代 <code>wheelDelta</code> 属性，但需要注意的是，该属性的判断值刚好和 <code>wheelDelta</code> 属性相反，即当 <code>event.deltaY &lt; 0</code> 时代表向上滚动，当 <code>event.deltaY &gt; 0</code> 时代表向下滚动</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：Git（尚硅谷）</title>
    <url>/Learn-Git.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 Git 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h1><ul>
<li>可前往 <a href="https://learngitbranching.js.org/?locale=zh_CN%25EF%25BF%25BC">这里</a> 练习 Git 相关练习</li>
<li>可前往 <a href="https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf">这里</a> 查看廖雪峰总结的相关 git 命令</li>
</ul>
<h2 id="1-版本控制"><a href="#1-版本控制" class="headerlink" title="1.版本控制"></a>1.版本控制</h2><ul>
<li>定义：是一种记录一个或若干文件内容变化，以便于将来查阅特定版本修订情况的系统</li>
<li>优点：<ul>
<li>便于回滚版本</li>
<li>便于分工开发</li>
</ul>
</li>
<li>缺点：<ul>
<li>所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，程序代码等等，而对于二进制文件是无法跟踪的</li>
</ul>
</li>
</ul>
<h3 id="1-集中化的版本控制系统"><a href="#1-集中化的版本控制系统" class="headerlink" title="(1).集中化的版本控制系统"></a>(1).集中化的版本控制系统</h3><ul>
<li>例子：SVN、CVS、Subversion、Perforce</li>
<li>优点：<ul>
<li>代码存放在单一的服务器上，便于项目的管理</li>
</ul>
</li>
<li>缺点：<ul>
<li>服务器宕机：员工写的代码得不到保障</li>
<li>服务器炸了：整个项目的历史记录都会丢失</li>
</ul>
</li>
</ul>
<h3 id="2-分布式的版本控制系统"><a href="#2-分布式的版本控制系统" class="headerlink" title="(2).分布式的版本控制系统"></a>(2).分布式的版本控制系统</h3><ul>
<li>客户端并不只提取最新版本的文件快照，而是把代码仓库完成的镜像下来</li>
<li>例子：Git、BitKeeper</li>
<li>优点：<ul>
<li>回滚速度快（因为每次存的都是项目的完整快照）</li>
<li>完全的分布式</li>
</ul>
</li>
<li>缺点：<ul>
<li>占用空间相对大一些</li>
</ul>
</li>
</ul>
<h2 id="2-安装与配置"><a href="#2-安装与配置" class="headerlink" title="2.安装与配置"></a>2.安装与配置</h2><ul>
<li><p>官网点击<a href="https://git-scm.com/">这里</a></p>
</li>
<li><p>一般在新系统上需要配置一下自己的 Git 工作环境</p>
</li>
<li><p>Git 提供了一个叫做 <code>git config</code> 的命令来配置或者读取相应的工作环境变量，这些变量存放在以下三个不同的地方：</p>
<ul>
<li><code>etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置，若使用该命令添加 <code>--system</code> 选项是读写的就是这个文件</li>
<li><code>~/ .gitconfig</code> 文件：用户目录下的配置文件只适用于该用户，若使用该命令添加 <code>--global</code> 选项是读写的就是这个文件</li>
<li><code>.git/config</code> 文件：当前项目的 Git 目录中的配置文件（也就是工作目录中的那个文件），若使用该命令不添加任何选项是读写的就是这个文件</li>
</ul>
</li>
<li><p>配置方法：</p>
<ul>
<li>我们一般只需要配置用户文件即可，需要配置自己的用户名和邮件地址，用来作为标识</li>
<li>使用 <code>git config --global user.name &quot;用户名&quot;</code> 命令来设置自己的用户名</li>
<li>使用 <code>git config --global user.email 邮箱</code> 命令来设置自己的邮箱</li>
</ul>
</li>
<li><p>检查配置方法：</p>
<ul>
<li>使用 <code>git config --list</code> 命令来检查自己的配置</li>
</ul>
</li>
</ul>
<h2 id="3-概念"><a href="#3-概念" class="headerlink" title="3.概念"></a>3.概念</h2><h3 id="1-区域"><a href="#1-区域" class="headerlink" title="(1).区域"></a>(1).区域</h3><ul>
<li>工作区</li>
<li>暂存区</li>
<li>版本库</li>
</ul>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="(2).对象"></a>(2).对象</h3><ul>
<li>Git对象<ul>
<li>Git 的核心是键值对数据库</li>
</ul>
</li>
<li>树对象</li>
<li>提交对象</li>
</ul>
<h3 id="3-文件状态"><a href="#3-文件状态" class="headerlink" title="(3).文件状态"></a>(3).文件状态</h3><ul>
<li>工作目录下的所有文件有两种状态：<strong style="color:red;">未跟踪</strong> 与 <strong style="color:red;">已跟踪</strong></li>
<li>已跟踪分为如下三种：<ul>
<li>已暂存：当文件被提交到暂存区时就变为已暂存状态，颜色为绿色</li>
<li>已修改：当文件被修改时，为已修改但未暂存状态，颜色为红色</li>
<li>已提交：当文件被提交到版本库时就变为已提交状态</li>
</ul>
</li>
<li>图示如下：<br><img src="https://z3.ax1x.com/2021/07/26/WhSUk6.png" alt="git01.png"></li>
</ul>
<h2 id="4-底层命令"><a href="#4-底层命令" class="headerlink" title="4.底层命令"></a>4.底层命令</h2><h3 id="1-Git对象"><a href="#1-Git对象" class="headerlink" title="(1).Git对象"></a>(1).Git对象</h3><ul>
<li><code>echo &quot;test&quot; | git hash-object -w --stdin</code>：向数据库写入内容并返回对应键值（-w表示存储数据对象，-stdin表示从标准输入中读取内容）</li>
<li><code>git hash-object -w 文件路径</code>：生成文件的键值</li>
<li><code>git has-object 文件路径</code>：读取文件的键值</li>
<li><code>find .git/objects -type f</code>：查看 git 存储的数据，文件夹为哈希值的前面位，文件名为哈希值的剩余位</li>
<li><code>git cat-file -p 哈希值</code>：根据键值来查看数据内容</li>
<li><code>git cat-file -t 哈希值</code>：查看存储的数据类型</li>
</ul>
<h3 id="2-树对象"><a href="#2-树对象" class="headerlink" title="(2).树对象"></a>(2).树对象</h3><ul>
<li><code>git update-index --add --cacheinfo 100644 哈希值 文件名</code>：向暂存区中添加一条记录（让Git对象对应文件名）</li>
<li><code>git write-tree</code>：生成树对象</li>
</ul>
<h3 id="3-提交对象"><a href="#3-提交对象" class="headerlink" title="(3).提交对象"></a>(3).提交对象</h3><ul>
<li><code>echo &quot;注释&quot; | git commit-tree 树对象的哈希值</code>：生成提交对象</li>
</ul>
<h3 id="4-查看暂存区"><a href="#4-查看暂存区" class="headerlink" title="(4).查看暂存区"></a>(4).查看暂存区</h3><ul>
<li><code>git ls-files -s</code></li>
</ul>
<h2 id="5-高层命令"><a href="#5-高层命令" class="headerlink" title="5.高层命令"></a>5.高层命令</h2><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="(1).初始化"></a>(1).初始化</h3><ul>
<li>要对现有的某个项目开始用 Git 管理，需要到此项目的目录中执行初始化操作</li>
<li>命令：<code>git init</code> </li>
<li>初始化后有如下目录结构：<ul>
<li>hooks：包含客户端或服务端的钩子脚本</li>
<li>info：包含一个全局性排除文件</li>
<li>logs：保存日志信息</li>
<li>objects：存储所有数据内容</li>
<li>refs：存储指向数据（分支）的提交对象的指针</li>
<li>config：文件，包含项目特有的配置选项</li>
<li>description：文件，显示对仓库的描述信息</li>
<li>HEAD：文件，指示目前被检出的分支</li>
<li>index：文件，保存暂存区信息</li>
</ul>
</li>
</ul>
<h3 id="2-添加"><a href="#2-添加" class="headerlink" title="(2).添加"></a>(2).添加</h3><ul>
<li>作用：将当前工作目录中的文件添加到暂存区（即使文件被跟踪）</li>
<li>命令：<code>git add 路径</code> </li>
<li>以上命令涉及到底层以下两个命令：<ul>
<li><code>git hash-object -w 文件名</code></li>
<li><code>git update-index</code> </li>
</ul>
</li>
</ul>
<h3 id="3-提交"><a href="#3-提交" class="headerlink" title="(3).提交"></a>(3).提交</h3><ul>
<li>作用：将暂存区中的文件提交到版本库</li>
<li>命令如下：<ul>
<li><code>git commit</code>：进入 vim 界面书写较长的注释文字并将暂存区中的文件提交到版本库</li>
<li><code>git commit -m &quot;注释&quot;</code>：将暂存区中的文件提交到版本库</li>
<li><code>git commit -a</code>：进入 vim 界面书写较长的注释文字并将工作目录中已被跟踪的文件提交到版本库（跳过添加到暂存区）</li>
<li><code>git commit -a -m &quot;注释&quot;</code>：将工作目录中已被跟踪的文件提交到版本库</li>
</ul>
</li>
<li>以上命令涉及到底层以下两个命令：<ul>
<li><code>git write-tree</code></li>
<li><code>git commit-tree</code> </li>
</ul>
</li>
</ul>
<h3 id="4-删除"><a href="#4-删除" class="headerlink" title="(4).删除"></a>(4).删除</h3><ul>
<li>作用：删除工作目录中的文件（并不会删除该文件的相关git对象）</li>
<li>命令：<code>git rm 文件名</code></li>
<li>以上命令涉及到以下两个命令：<ul>
<li><code>rm 原文件名</code></li>
<li><code>git add 路径</code></li>
</ul>
</li>
</ul>
<h3 id="5-改名"><a href="#5-改名" class="headerlink" title="(5).改名"></a>(5).改名</h3><ul>
<li>作用：对当前文件进行改名操作</li>
<li>命令：<code>git mv 原文件名 新文件名</code></li>
<li>以上命令涉及到以下三个命令：<ul>
<li><code>mv 原文件名 新文件名</code></li>
<li><code>git rm 原文件名</code></li>
<li><code>git add 路径</code></li>
</ul>
</li>
</ul>
<h3 id="6-查看状态"><a href="#6-查看状态" class="headerlink" title="(6).查看状态"></a>(6).查看状态</h3><p>作用：可以查看到文件的相关状态</p>
<p>命令：</p>
<ul>
<li><code>git status</code>：查看当前文件的状态</li>
<li><code>git diff</code>：查看哪些修改过的文件还没有被暂存</li>
<li><code>git diff --staged/--cached</code>：查看哪些修改过的文件已经被暂存但没有被提交</li>
</ul>
<h3 id="7-查看历史记录"><a href="#7-查看历史记录" class="headerlink" title="(7).查看历史记录"></a>(7).查看历史记录</h3><p>作用：可以看到整个项目的提交历史记录</p>
<p>命令：</p>
<ul>
<li><code>git log</code>：正常显示log</li>
<li><code>git log --pretty=oneline</code>：单行显示log，hash值正常显示</li>
<li><code>git log --oneline</code>：单行显示log，hash值简写</li>
<li><code>git reflog</code>：查看 HEAD 发生变化时的历史记录</li>
</ul>
<h3 id="8-回退"><a href="#8-回退" class="headerlink" title="(8).回退"></a>(8).回退</h3><p>作用：可以回退到上一版本</p>
<p>命令：</p>
<ul>
<li><code>git reset --soft 哈希值/~</code> 只修改HEAD（带着分支）</li>
<li><code>git reset [--mixed] 哈希值/~</code> 同时修改HEAD（带着分支）和暂存区</li>
<li><code>git reset --hard 哈希值/~</code> 同时修改HEAD（带着分支）、暂存区和工作区</li>
</ul>
<h3 id="9-撤销修改"><a href="#9-撤销修改" class="headerlink" title="(9).撤销修改"></a>(9).撤销修改</h3><p><code>git checkout -- 文件名</code>：把文件在工作区的修改全部撤销</p>
<ul>
<li>修改后文件未放入暂存区：回到版本库一模一样的状态</li>
<li>已入暂存区又进行了修改：回到添加到暂存区中的状态</li>
</ul>
<p><code>git reset HEAD 文件名</code>：可以把暂存区的修改撤销掉（unstage），重新放回工作区</p>
<p><code>git commit --amend</code>：</p>
<ul>
<li>可以重新编写上一次提交的提交信息</li>
<li>当发现工作区有内容忘记暂存，可以先使用 <code>git add 文件名</code>，然后再执行该命令，可以将两次提交合为一次提交</li>
</ul>
<h4 id="如何撤销远程-commit-？"><a href="#如何撤销远程-commit-？" class="headerlink" title="如何撤销远程 commit ？"></a>如何撤销远程 commit ？</h4><p>确保你在你想要撤销的分支上且该分支工作区干净</p>
<ul>
<li>本地使用 <code>get reset --hard 哈希值</code>，切换到特定的commit</li>
<li>使用 –force推送到远程分支（如果报错需要前往仓库设置中允许 force 操作）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --hard cedc856</span><br><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-数据恢复"><a href="#10-数据恢复" class="headerlink" title="(10).数据恢复"></a>(10).数据恢复</h3><p><code>git branch recover-branch 哈希值</code>：当硬重置到某个提交时，如果想要回去，可以使用该命令创建一个新的分支来进行开发</p>
<p><code>git reflog &amp;&amp; git reset --hard 最后一次提交的哈希值</code>：当硬重置到某个提交时，如果想要回去，也可以使用该命令硬重置回去，但一般不推荐，因为此时 HEAD 会形成相应的修改记录</p>
<h2 id="6-分支命令"><a href="#6-分支命令" class="headerlink" title="6.分支命令"></a>6.分支命令</h2><ul>
<li>分支的本质：是指向提交对象的<strong style="color:red;">可变指针HEAD</strong></li>
<li>HEAD：<ul>
<li>是一个指针，默认指向 Master 分支，切换分支时就是让 HEAD 指向不同的分支</li>
<li>每次有新的提交时，HEAD 都会带着当前指向的分支一起往前移动</li>
</ul>
</li>
<li>分支的模式：<ul>
<li>长期分支：一般指 master 和 develop 分支</li>
<li>特性分支：一般指每一个功能的分支</li>
</ul>
</li>
<li>分支的原理：<ul>
<li><code>.git/refs</code> 保存了分支及其对应的提交对象 hash 值</li>
<li><code>HEAD引用</code> 是一个符号引用，指向目前所在的分支</li>
</ul>
</li>
</ul>
<h3 id="1-创建"><a href="#1-创建" class="headerlink" title="(1).创建"></a>(1).创建</h3><ul>
<li>作用：给当前的提交对象创建一个分支<ul>
<li>命令：<code>git branch 分支名</code></li>
</ul>
</li>
<li>作用：给指定的提交对象创建一个分支（可以达成版本回滚操作）<ul>
<li>命令：<code>git branch 分支名 指定的hash值</code></li>
</ul>
</li>
</ul>
<h3 id="2-切换"><a href="#2-切换" class="headerlink" title="(2).切换"></a>(2).切换</h3><ul>
<li>作用：切换到指定分支<ul>
<li>命令：<code>git checkout 分支名</code></li>
</ul>
</li>
<li>作用：新建分支并切换到该分支上<ul>
<li>命令：<code>git checkout -b 分支名</code></li>
</ul>
</li>
<li>缺点：在切换分支时，如果当前分支上有未暂存的修改（第一次）或者有未提交的暂存（第一次）时，分支可以切换成功但会污染其他分支</li>
<li>注意：切换分支会动 <strong style="color:red;">HEAD、暂存区、工作目录</strong> 这三个地方，<strong style="color:red;">因此每次切换分支前，一定要提交一次当前分支！</strong></li>
<li>撤销修改与切换分支的命令很类似，所以最新版本的 Git 中提供了以下命令来切换到该分区<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git switch -c dev	// 新建并切换分区</span><br><span class="line">git switch master	// 切换到现有分区</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-合并"><a href="#3-合并" class="headerlink" title="(3).合并"></a>(3).合并</h3><h4 id="1-快进合并"><a href="#1-快进合并" class="headerlink" title="1).快进合并"></a>1).快进合并</h4><ul>
<li>适用于：当需要合并的分支在主分支的后边且在一条线上时，可以直接进行快进合并</li>
<li>方法：<ul>
<li>先提交当前分支的内容</li>
<li>切换到主分支上</li>
<li>使用 <code>git merge 需要合并到主分支上的分支名</code></li>
<li>删除已合并的分支名即可</li>
</ul>
</li>
</ul>
<h4 id="2-典型合并"><a href="#2-典型合并" class="headerlink" title="2).典型合并"></a>2).典型合并</h4><ul>
<li>适用于：当需要合并的分支在主分支的历史进行了分叉，即当前分支不是最新的主分支代码，可能会与主分支同时修改到同一文件</li>
<li>方法：<ul>
<li>先提交当前分支的内容</li>
<li>切换到主分支上</li>
<li>使用 <code>git merge 需要合并到主分支上的分支名</code></li>
<li>此时会提示哪个文件产生冲突，进入该文件解决冲突</li>
<li>同时可以使用 <code>git status</code> 来查看哪些因包含合并冲突而处于未合并状态</li>
<li>当解决完后提交当前代码就可以成功合并了</li>
<li>删除已合并的分支名即可</li>
</ul>
</li>
</ul>
<h3 id="4-查看"><a href="#4-查看" class="headerlink" title="(4).查看"></a>(4).查看</h3><ul>
<li><p>作用：查看项目分叉历史</p>
<ul>
<li>命令：<code>git log --oneline --decorate --graph --all</code> 或 <code>git log --graph --pretty=oneline --abbrev-commit</code></li>
</ul>
</li>
<li><p>作用：查看分支列表</p>
<ul>
<li>命令：<code>git branch</code></li>
</ul>
</li>
<li><p>作用：查看每一个分支的最后一次提交</p>
<ul>
<li>命令：<code>git branch -v</code> </li>
</ul>
</li>
<li><p>作用：查看每一个分支的最后一次提交以及跟踪的远程分支</p>
<ul>
<li>命令：<code>git branch -vv</code> </li>
</ul>
</li>
<li><p>作用：查看哪些分支已经合并到当前分支</p>
<ul>
<li>命令：<code>git branch -merged</code></li>
</ul>
</li>
<li><p>作用：查看所有包含未合并工作的分支</p>
<ul>
<li>命令：<code>git branch --no-merged</code></li>
</ul>
</li>
</ul>
<h3 id="5-删除"><a href="#5-删除" class="headerlink" title="(5).删除"></a>(5).删除</h3><ul>
<li><strong style="color:red;">注意：删除分支时必须切换到主分支，不然无法自己删自己</strong></li>
<li>作用：删除某已合并或空的分支<ul>
<li>命令：<code>git branch -d 分支名</code></li>
</ul>
</li>
<li>作用：删除未合并的分支<ul>
<li>命令：<code>git branch -D 分支名</code></li>
</ul>
</li>
</ul>
<h3 id="6-修改"><a href="#6-修改" class="headerlink" title="(6).修改"></a>(6).修改</h3><p><strong>作用</strong>：可以修改当前分支名</p>
<p><strong>命令</strong>：<code>git branch -m oldName newName</code> </p>
<h2 id="7-分支引申"><a href="#7-分支引申" class="headerlink" title="7.分支引申"></a>7.分支引申</h2><ul>
<li>禁用Fast Forward：<ul>
<li>可以禁用 “快速合并模式” 来在合并分支时生成新的 commit，这样从分支历史上就可以看出分支信息</li>
<li>只要在合并时使用 <code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code> 即可禁用该模式</li>
</ul>
</li>
<li>分支策略：<ul>
<li><code>master</code> 分支是非常稳定的，仅用来发布新版本</li>
<li><code>dev</code> 分支是不稳定的，等版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本</li>
<li>每个人都在 <code>dev</code> 分支上干活且都有自己的分支，时不时地往 <code>dev</code> 分支上合并就可</li>
<li>团队图：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900005860592480">这里</a></li>
</ul>
</li>
</ul>
<h3 id="0-删除远程分支"><a href="#0-删除远程分支" class="headerlink" title="(0).删除远程分支"></a>(0).删除远程分支</h3><ul>
<li>先查看所有的分支，使用 <code>git branch -a</code> 可以看到本地和远程的所有的分支</li>
<li>然后使用 <code>git push origin --delete 远程分支名</code> 即可删除远程分支</li>
</ul>
<h3 id="1-临时处理Bug"><a href="#1-临时处理Bug" class="headerlink" title="(1).临时处理Bug"></a>(1).临时处理Bug</h3><ul>
<li>可以使用 <code>git stash</code> 将当前的工作现场临时存储起来</li>
<li>然后处理相应 Bug</li>
<li>然后合并 Bug 分支到主分支上</li>
<li>切换到当前工作分支</li>
<li>使用 <code>git stash list</code> 查看所有被存储的工作区</li>
<li>恢复工作区：<ul>
<li>先使用 <code>git stash apply</code> 恢复，然后使用 <code>git stash drop</code> 删除 stash 内容</li>
<li>直接使用 <code>git stash pop</code> 恢复，且同时把 stash 呢日荣删除</li>
</ul>
</li>
</ul>
<h3 id="2-在子分支修复主分支同样的bug"><a href="#2-在子分支修复主分支同样的bug" class="headerlink" title="(2).在子分支修复主分支同样的bug"></a>(2).在子分支修复主分支同样的bug</h3><ul>
<li>可以使用 <code>git stash</code> 将当前的工作现场临时存储起来</li>
<li>然后处理相应 Bug</li>
<li>然后合并 Bug 分支到主分支上</li>
<li>切换到当前工作分支</li>
<li>使用 <code>git stash list</code> 查看所有被存储的工作区</li>
<li>使用 <code>git cherry-pick &lt;bug修复的哈希值&gt;</code> 命令把 bug 提交的修改“复制”到当前分支</li>
<li>恢复工作区：<ul>
<li>先使用 <code>git stash apply</code> 恢复，然后使用 <code>git stash drop</code> 删除 stash 内容</li>
<li>直接使用 <code>git stash pop</code> 恢复，且同时把 stash 呢日荣删除</li>
</ul>
</li>
</ul>
<h3 id="3-多人协作"><a href="#3-多人协作" class="headerlink" title="(3).多人协作"></a>(3).多人协作</h3><ul>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并<ul>
<li>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code></li>
</ul>
</li>
<li>如果合并有冲突，则解决冲突，并在本地提交</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功</li>
</ul>
<h2 id="8-存储命令"><a href="#8-存储命令" class="headerlink" title="8.存储命令"></a>8.存储命令</h2><p>使用 <code>git stash</code> 可以将当前分支上未提交的修改暂存在栈中</p>
<p>使用 <code>git stash apply</code> 可以应用暂存在栈顶的修改，并不会删除该暂存</p>
<p>使用 <code>git stash list</code> 可以查看当前暂存的修改 </p>
<p>使用 <code>git stash drop &#123;暂存编号&#125;</code> 可以删除指定编号的暂存</p>
<p>使用 <code>git stash pop</code> 可以应用暂存在栈顶的修改，并删除该暂存</p>
<h2 id="9-远程仓库"><a href="#9-远程仓库" class="headerlink" title="9.远程仓库"></a>9.远程仓库</h2><h3 id="1-创建-1"><a href="#1-创建-1" class="headerlink" title="(1).创建"></a>(1).创建</h3><ul>
<li>创建 SSH Key</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建好后可以去用户主目录中查看是否含有 <code>.ssh</code> 文件夹，在该文件夹里存放着两个文件<ul>
<li><code>id_rsa</code> 为私钥，只能自己使用</li>
<li><code>id_rsa.pub</code> 为公钥，可以给其他人使用</li>
</ul>
</li>
<li>登录 GitHub 或者 GitLab 中，在设置中找到 <code>SSH Keys</code> 字段添加一个 key，在其中输入公钥</li>
</ul>
<h3 id="2-拉取远程仓库项目"><a href="#2-拉取远程仓库项目" class="headerlink" title="(2).拉取远程仓库项目"></a>(2).拉取远程仓库项目</h3><ul>
<li><code>git clone git@192.168.129.110:zhangyangeng/test.git</code> 命令可以拉取指定仓库</li>
<li><code>cd test</code> 进入到项目目录中</li>
<li><code>touch README.md</code> 创建一个文件</li>
<li><code>git add README.md</code> 将修改提交到暂存区</li>
<li><code>git commit -m &quot;add README&quot;</code> 将暂存区中的文件提交到版本库</li>
<li><code>git push -u origin master</code> 将当前版本库中的内容推送到远程仓库</li>
</ul>
<h3 id="3-推送已有项目到远程仓库"><a href="#3-推送已有项目到远程仓库" class="headerlink" title="(3).推送已有项目到远程仓库"></a>(3).推送已有项目到远程仓库</h3><ul>
<li><code>git remote add origin git@192.168.129.110:zhangyangeng/test.git</code> 将远程仓库与当前项目目录进行关联<ul>
<li>origin 为远程仓库的名字，默认为其</li>
<li>后面的内容是自己仓库的链接，自行修改</li>
</ul>
</li>
<li><code>git push -u origin master</code> 将当前版本库中的内容推送到远程仓库</li>
<li><code>git push origin master</code> 之后只要本地做了提交，就可以通过命令把本地 <code>master</code> 分支的最新修改推送至远程仓库了</li>
</ul>
<h3 id="4-查看远程仓库"><a href="#4-查看远程仓库" class="headerlink" title="(4).查看远程仓库"></a>(4).查看远程仓库</h3><ul>
<li><code>git remote -v</code> 可以查看到当前所有的远程仓库</li>
<li>一般会含有两行内容，分别代表抓取和推送的 <code>origin</code> 地址</li>
</ul>
<h3 id="5-删除远程仓库"><a href="#5-删除远程仓库" class="headerlink" title="(5).删除远程仓库"></a>(5).删除远程仓库</h3><ul>
<li><code>git remote rm origin</code> 注意：这里并不是直接删除了远程仓库，而是解除了本地与远程仓库的连接，删除还需要去网站后台进行删除</li>
</ul>
<h3 id="6-修改远程仓库"><a href="#6-修改远程仓库" class="headerlink" title="(6).修改远程仓库"></a>(6).修改远程仓库</h3><p>直接修改：</p>
<ul>
<li><code>git remot set-url &lt;name&gt; &lt;newUrl&gt;</code> 将指定远程链接名的 URL 修改为新的 URL</li>
</ul>
<p>先删除再添加：</p>
<ul>
<li><code>git remote remove &lt;name&gt;</code> 删除指定远程链接名</li>
<li><code>git remote add &lt;name&gt; &lt;newurl&gt;</code> 新增远程仓库</li>
</ul>
<h2 id="10-远程分支"><a href="#10-远程分支" class="headerlink" title="10.远程分支"></a>10.远程分支</h2><p>当本地想要新建一个分支来开发远程指定分支上的代码时，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git checkout -b dev upstream/dev 或 git checkout --track upstream/dev</span><br></pre></td></tr></table></figure>

<p>当本地已有分支想要跟踪远程分支代码时，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch upstream</span><br><span class="line">git checkout -u upstream/dev</span><br></pre></td></tr></table></figure>

<h1 id="二、Rebase"><a href="#二、Rebase" class="headerlink" title="二、Rebase"></a>二、Rebase</h1><ul>
<li>看不懂</li>
</ul>
<h1 id="三、Tag"><a href="#三、Tag" class="headerlink" title="三、Tag"></a>三、Tag</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本<br>所以，标签也是版本库的一个快照</p>
<h2 id="1-创建标签"><a href="#1-创建标签" class="headerlink" title="1.创建标签"></a>1.创建标签</h2><p><code>git tag &lt;name&gt;</code> 切换到需要打标签的分支上执行该命令来创建标签</p>
<p><code>git tag &lt;name&gt; 哈希值</code> 给对应的 commit 打标签</p>
<p><code>git tag -a &lt;name&gt; -m &quot;提示文字&quot;</code> 创建带有说明的标签</p>
<h2 id="2-查看标签"><a href="#2-查看标签" class="headerlink" title="2.查看标签"></a>2.查看标签</h2><p><code>git tag</code> 查看标签（标签默认是按字母顺序排序的）</p>
<p><code>git show &lt;name&gt;</code> 查看标签的具体信息</p>
<h2 id="3-推送标签"><a href="#3-推送标签" class="headerlink" title="3.推送标签"></a>3.推送标签</h2><p><code>git push origin &lt;name&gt;</code> 推送某个标签到远程</p>
<p><code>git push origin --tags</code> 一次性推送全部尚未推送到远程的本地标签</p>
<h2 id="4-删除标签"><a href="#4-删除标签" class="headerlink" title="4.删除标签"></a>4.删除标签</h2><p><code>git tag -d &lt;name&gt;</code> 删除本地标签</p>
<p><code>git tag -d &lt;name&gt;</code> 然后 <code>git push origin :refs/tags/v0.9</code> 删除已经推送到远程的标签</p>
<h2 id="5-检出标签"><a href="#5-检出标签" class="headerlink" title="5.检出标签"></a>5.检出标签</h2><p><code>git checkout &lt;name&gt;</code> 切换到标签所在处，但此时会出现 HEAD 和分支分离的情况，所以<strong style="color:red;">不推荐使用</strong></p>
<p><code>git checkout -b &lt;name&gt;</code> 切换到标签所在处，并新建一个分支，<strong style="color:red;">推荐使用</strong></p>
<h1 id="四、自定义Git"><a href="#四、自定义Git" class="headerlink" title="四、自定义Git"></a>四、自定义Git</h1><h2 id="1-忽略特殊文件"><a href="#1-忽略特殊文件" class="headerlink" title="1.忽略特殊文件"></a>1.忽略特殊文件</h2><ul>
<li>在 Git 工作区的根目录下创建一个特殊的 <code>.gitignore</code> 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件</li>
<li>不需要从头写<code>.gitignore</code>文件，GitHub 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></li>
<li>忽略文件的原则：<ul>
<li>忽略操作系统自动生成的文件，比如缩略图等</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件</li>
</ul>
</li>
<li>当某个自己想要上传的文件被忽略时我们可以使用 <code>-f</code> 参数来强制添加到 Git</li>
<li><code>git check-ignore -v 文件名</code> 来检查哪个规则有问题</li>
<li>忽略文件中的例外规则：可以不排除指定文件，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 排除所有.开头的隐藏文件:</span><br><span class="line">.*</span><br><span class="line"># 排除所有.class文件:</span><br><span class="line">*.class</span><br><span class="line"># 不排除.gitignore和App.class:</span><br><span class="line">!.gitignore</span><br><span class="line">!App.class</span><br></pre></td></tr></table></figure>

<h2 id="2-配置别名"><a href="#2-配置别名" class="headerlink" title="2.配置别名"></a>2.配置别名</h2><ul>
<li>Git 并不会在输入部分命令时自动判断需要输入的命令，所以可以通过 config 文件来给长命令设置一个别名</li>
<li>使用如下：<ul>
<li><code>git config --global alias.co checkout</code>，当需要该命令时直接输入 <code>git co</code> 即可</li>
<li><code>git config --global alias.br branch</code>，当需要该命令时直接输入 <code>git br</code> 即可</li>
</ul>
</li>
</ul>
<h2 id="3-搭建Git服务器"><a href="#3-搭建Git服务器" class="headerlink" title="3.搭建Git服务器"></a>3.搭建Git服务器</h2><ul>
<li>点击 <a href="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">查看</a></li>
</ul>
<h1 id="五、Git-Fork流操作"><a href="#五、Git-Fork流操作" class="headerlink" title="五、Git Fork流操作"></a>五、Git Fork流操作</h1><ol>
<li>从远程仓库A fork到自己仓库B</li>
<li>从自己仓库clone到本地 </li>
<li>git remote add upstream <a href="https://gitlab.xxxx.com/A/project%EF%BC%88%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AAupstream%E6%8C%87%E5%90%91%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%89">https://gitLab.XXXX.com/A/project（添加一个upstream指向远程仓库）</a></li>
<li>git fetch upstream（获取A上的所有分支到你本地)</li>
<li>git merge upstream/master（将远程的master分支的内容同步到本地的master上），此时你的项目与远程一致了，这是时候在本地进行修改后正常 add ，commit，push之前要确定你这次提交之前与你最后一次拉代码的时候没有人提交，这时候需要再拉一次代码</li>
<li>git git fetch upstream （将远程分支同步到本地）</li>
<li>git merge upstream/master （合并分支，每次将远程仓库项目同步到本地project需要6，7操作，/后可以是你想同步的任意分支）</li>
<li>git pull（同步到本地）</li>
<li>git push origin master(将内容推到你的仓库B)</li>
<li>然后请求合并到远程仓库A</li>
</ol>
<h1 id="六、Git配置问题"><a href="#六、Git配置问题" class="headerlink" title="六、Git配置问题"></a>六、Git配置问题</h1><h2 id="1-执行-git-push-出错"><a href="#1-执行-git-push-出错" class="headerlink" title="1.执行 git push 出错"></a>1.执行 git push 出错</h2><ul>
<li>错误代码：<code>git@github.com: Permission denied (publickey). fatal: Could not read from remote repository.</code></li>
<li>解决方法1：检查是否成功在远程仓库中添加了本机对应的 SSH Key，如果没有，添加后再次执行</li>
<li>解决方法2：检查本地Git仓库是否和该SSH key关联，即执行 <code>ssh-add &quot;你的 id-rsa 文件地址&quot;</code></li>
</ul>
<h2 id="2-执行-ssh-add-出错"><a href="#2-执行-ssh-add-出错" class="headerlink" title="2.执行 ssh-add 出错"></a>2.执行 ssh-add 出错</h2><ul>
<li>错误代码：<code>Could not open a connection to your authentication agent</code></li>
<li>解决方法：执行 <code>ssh-agent bash</code> ，然后再执行 <code>ssh-add </code></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>学习</tag>
        <tag>代码管理</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：ECMAScript教程（尚硅谷）</title>
    <url>/Learn-ECMA.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 ECMAScript 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、ECMA"><a href="#一、ECMA" class="headerlink" title="一、ECMA"></a>一、ECMA</h1><ul>
<li>ECMA-262 历史版本点击<a href="https://www.ecma-international.org/publications-and-standards/standards/ecma-262/">这里</a>查看</li>
<li>ES6 兼容性点击<a href="http://kangax.github.io/compat-table/es6/">这里</a>查看</li>
</ul>
<h1 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h1><h2 id="1-let"><a href="#1-let" class="headerlink" title="1.let"></a>1.let</h2><ul>
<li><p>变量不能重复声明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &quot;wrysmile&quot;</span><br><span class="line">let name = &quot;Wrysmile&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>块级作用域</p>
<ul>
<li>在ES5中只有全局、函数、eval（严格模式下才有）作用域</li>
<li>ES6新增块级作用域，let 声明的变量只能作用在块级作用域中</li>
<li>if、else、while、for、花括号都属于块级作用域</li>
</ul>
</li>
<li><p>不存在变量提升</p>
</li>
<li><p>不影响作用域链</p>
</li>
</ul>
<h3 id="案例：遍历绑定事件时使用不使用this"><a href="#案例：遍历绑定事件时使用不使用this" class="headerlink" title="!案例：遍历绑定事件时使用不使用this"></a>!案例：遍历绑定事件时使用不使用this</h3><ul>
<li>在遍历绑定事件时<ul>
<li>如果使用 var 声明，不使用 this 时会因为全局作用域中的变量导致事件找不到当前下标</li>
<li>如果使用 let 声明，因为其声明的变量只在其块级作用域中有效，所以事件可以找到当前下标</li>
</ul>
</li>
<li>案例如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;点击切换颜色&lt;/h1&gt;</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">	&lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	let items = document.getElementsByClassName(&quot;item&quot;);</span><br><span class="line">	for (let i = 0; i &lt; items.length; i++)&#123;</span><br><span class="line">		items[i].onclick = function ()&#123;</span><br><span class="line">			items[i].style.background = &quot;red&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-const"><a href="#2-const" class="headerlink" title="2.const"></a>2.const</h2><ul>
<li>作用：用来声明一个常量</li>
<li>一定要赋初始值</li>
<li>一般常量使用大写</li>
<li>常量的值不能修改</li>
<li>块级作用域</li>
<li>对于数组和对象的元素修改，不算做常量的修改，不会报错</li>
</ul>
<h2 id="3-变量解构赋值"><a href="#3-变量解构赋值" class="headerlink" title="3.变量解构赋值"></a>3.变量解构赋值</h2><ul>
<li><p>ES6 允许按照一定模式从数组和对象中提取值，对变量进行赋值，称为解构赋值</p>
</li>
<li><p>数组的解构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [&quot;小明&quot;,&quot;小张&quot;,&quot;小王&quot;,&quot;小李&quot;];</span><br><span class="line">let [a,b,c,d] = arr;</span><br><span class="line">console.log(a,b,c,d);</span><br></pre></td></tr></table></figure></li>
<li><p>对象的解构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">	name: &quot;Wrysmile&quot;,</span><br><span class="line">	age: 25,</span><br><span class="line">	eat: function ()&#123;</span><br><span class="line">		console.log(&quot;我爱吃西瓜&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let &#123;name, age , eat&#125; = obj;</span><br><span class="line">console.log(name,age,eat);</span><br><span class="line">eat();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-模板字符串"><a href="#4-模板字符串" class="headerlink" title="4.模板字符串"></a>4.模板字符串</h2><ul>
<li><p>概念：ES6 中引入了新的声明字符串的方式</p>
</li>
<li><p>内容中可以直接出现换行符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = `你好</span><br><span class="line">你好</span><br><span class="line">你好`;</span><br><span class="line">console.log(str);</span><br></pre></td></tr></table></figure></li>
<li><p>支持变量拼接，只需要使用 <code>$&#123;&#125;</code> 即可进行拼接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str1 = &quot;陈奕迅&quot;;</span><br><span class="line">let str2 = `$&#123;str1&#125;是我最喜欢的歌手`;</span><br><span class="line">console.log(str2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-简化对象写法"><a href="#5-简化对象写法" class="headerlink" title="5.简化对象写法"></a>5.简化对象写法</h2><ul>
<li>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let name = &quot;Wrysmile&quot;;</span><br><span class="line">let age = 25;</span><br><span class="line">let change = function ()&#123;</span><br><span class="line">	console.log(&quot;改变&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const person = &#123;</span><br><span class="line">	name,</span><br><span class="line">	age,</span><br><span class="line">	change,</span><br><span class="line">	improve()&#123;</span><br><span class="line">		console.log(&quot;提高&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-箭头函数"><a href="#6-箭头函数" class="headerlink" title="6.箭头函数"></a>6.箭头函数</h2><ul>
<li><p>ES6 中允许使用<strong>箭头</strong>来定义函数</p>
</li>
<li><p>特性：</p>
<ul>
<li>this 是静态的，this 始终指向函数声明时所在作用域下的 this 的值</li>
<li>不能作为构造函数来实例化对象</li>
<li>不能使用 arguments 变量</li>
</ul>
</li>
<li><p>简写：</p>
<ul>
<li>省略小括号：当形参有且只有一个的时候</li>
<li>省略花括号：当代码体只有一条语句的时候，此时代码体的 return 必须省略，因为语句的执行结果就是函数的返回值</li>
</ul>
</li>
<li><p>适合：</p>
<ul>
<li>与 this 无关的回调，如定时器，数组的方法回调</li>
</ul>
</li>
<li><p>不适合：</p>
<ul>
<li>与 this 有关的回调，如事件回调，对象的方法</li>
</ul>
</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li><p>通过静态this来修改元素属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ad = document.getElementById(&quot;ad&quot;);</span><br><span class="line">ad.addEventListener(&quot;click&quot;, function ()&#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		this.style.background = &quot;pink&quot;;</span><br><span class="line">	&#125;,2000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>从数组中返回偶数的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1,4,6,7,58,63,100];</span><br><span class="line">const newArr = arr.filter(function (item)&#123;</span><br><span class="line">	return item % 2 === 0;</span><br><span class="line">&#125;)</span><br><span class="line">const newArr2 = arr.filter(item =&gt; item %2 === 0);</span><br><span class="line">console.log(newArr, newArr2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-函数参数的默认值"><a href="#7-函数参数的默认值" class="headerlink" title="7.函数参数的默认值"></a>7.函数参数的默认值</h2><ul>
<li>ES6 允许给函数参数赋值初始值</li>
<li>特性：<ul>
<li>形参初始值，具有默认值的参数，一般位置要靠后</li>
<li>可以与解构赋值结合</li>
</ul>
</li>
<li>与解构赋值结合可以省略一部分重复代码，如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function connect(options)&#123;</span><br><span class="line">	console.log(options.host, options.username, options.password, options.port);</span><br><span class="line">&#125;</span><br><span class="line">function connect(&#123;host=&quot;127.0.0.1&quot;, username, password, port&#125;)&#123;</span><br><span class="line">	console.log(host, username, password, port);</span><br><span class="line">&#125;</span><br><span class="line">connect(&#123;</span><br><span class="line">	host: &quot;www.wrysmile.cn&quot;,</span><br><span class="line">	username: &quot;admin&quot;,</span><br><span class="line">	password: &quot;admin&quot;,</span><br><span class="line">	port: 3306</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-rest-参数"><a href="#8-rest-参数" class="headerlink" title="8.rest 参数"></a>8.rest 参数</h2><ul>
<li><p>ES6 可以使用 rest 参数来获取函数的实参，用来代替 arguments</p>
</li>
<li><p>语法：<code>...args</code>，即在标识符前加三个点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function date(...args)&#123;</span><br><span class="line">	console.log(args);</span><br><span class="line">&#125;</span><br><span class="line">function date(a, b, ...args)&#123;</span><br><span class="line">	console.log(args)</span><br><span class="line">&#125;</span><br><span class="line">date(1, 2, 3, 9);</span><br></pre></td></tr></table></figure></li>
<li><p>与 arguments 的区别：</p>
<ul>
<li>arguments 返回的是对象</li>
<li>rest 参数返回的是数组</li>
</ul>
</li>
</ul>
<h2 id="9-扩展运算符"><a href="#9-扩展运算符" class="headerlink" title="9.扩展运算符"></a>9.扩展运算符</h2><ul>
<li><p><code>...</code> 能将<strong>数组</strong>转换为逗号分割的<strong>参数序列</strong>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const tfboys = [&quot;易烊千玺&quot;, &quot;王源&quot;, &quot;王俊凯&quot;];</span><br><span class="line">function chunwan()&#123;</span><br><span class="line">	console.log(arguments);</span><br><span class="line">&#125;</span><br><span class="line">chunwan(tfboys);</span><br><span class="line">chunwan(...tfboys);</span><br></pre></td></tr></table></figure></li>
<li><p>两个函数执行结果对比如下：<br><img src="https://z3.ax1x.com/2021/07/16/WQeqtH.png" alt="es01.png"></p>
</li>
<li><p>应用：</p>
<ul>
<li>数组的合并</li>
<li>数组的克隆</li>
<li>伪数组转为真正的数组</li>
</ul>
</li>
<li><p>应用案例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 数组的合并</span><br><span class="line">const kuaizi = [&quot;王太利&quot;, &quot;肖央&quot;];</span><br><span class="line">const fenghuangchuanqi = [&quot;曾毅&quot;, &quot;玲花&quot;];</span><br><span class="line">const songer = [...kuaizi, ...fenghuangchuanqi];</span><br><span class="line">console.log(songer);</span><br><span class="line">// 数组的克隆</span><br><span class="line">const sanzhihua = [&quot;E&quot;,&quot;G&quot;,&quot;M&quot;];</span><br><span class="line">const sanyecao = [...sanzhihua];</span><br><span class="line">console.log(sanyecao);</span><br><span class="line">// 将伪数组转为真正的数组</span><br><span class="line">const divs = document.querySelectorAll(&quot;div&quot;);</span><br><span class="line">const divArr = [...divs]</span><br><span class="line">console.log(divs);</span><br><span class="line">console.log(divArr);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-Symbol"><a href="#10-Symbol" class="headerlink" title="10.Symbol"></a>10.Symbol</h2><ul>
<li>ES6 中引入了一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值</li>
<li>它是 JS 的第七种数据类型，也是一种类似于字符串的数据类型</li>
<li>特点：<ul>
<li>Symbol 的值是唯一的，用来解决命名冲突的问题</li>
<li>Symbol 的值不能与其他数据进行运算</li>
<li>Symbol 定义的对象属性不能使用 <code>for...in</code> 循环遍历，但是可以使用 <code>Reflect.ownKeys</code> 来获取对象的所有键名</li>
</ul>
</li>
</ul>
<h3 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="(1).基础使用"></a>(1).基础使用</h3><ul>
<li><p>普通创建 Symbol：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s = Symbol();</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>Symbol.for()</code> 来创建 Symbol：（可以通过描述字符串来找到唯一的Symbol值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s1 = Symbol.for(&quot;s1&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>使用描述字符串来标识一个 Symbol：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s2 = Symbol(&quot;s2&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-创建对象属性"><a href="#2-创建对象属性" class="headerlink" title="(2).创建对象属性"></a>(2).创建对象属性</h3><ul>
<li>当向某个对象中添加方法时，为了避免重名的问题，可以使用 Symbol 来唯一标识<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let game = &#123;</span><br><span class="line">	name: &quot;俄罗斯方块&quot;,</span><br><span class="line">	up: function ()&#123;</span><br><span class="line">		console.log(&quot;向上&quot;);</span><br><span class="line">	&#125;,</span><br><span class="line">	down: function ()&#123;</span><br><span class="line">		console.log(&quot;向下&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let methods = &#123;</span><br><span class="line">	up: Symbol(),</span><br><span class="line">	down: Symbol()</span><br><span class="line">&#125;</span><br><span class="line">game[methods.up] = function ()&#123;</span><br><span class="line">	console.log(&quot;唯一的向上&quot;);</span><br><span class="line">&#125;</span><br><span class="line">game[methods.down] = function ()&#123;</span><br><span class="line">	console.log(&quot;唯一的向下&quot;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(game);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Symbol-内置值"><a href="#3-Symbol-内置值" class="headerlink" title="(3).Symbol 内置值"></a>(3).Symbol 内置值</h3><ul>
<li>除了定义自己使用的 Symbol 值以外，ES 6还提供了11个内置的 Symbol 值，指向语言内部使用的方法</li>
<li>视频链接点<a href="https://www.bilibili.com/video/BV1uK411H7on?p=17&spm_id_from=pageDriver">这里</a>的p17</li>
</ul>
<h2 id="11-迭代器"><a href="#11-迭代器" class="headerlink" title="11.迭代器"></a>11.迭代器</h2><ul>
<li>迭代器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署了 Iterator 接口就可以完成遍历操作</li>
<li>ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，而迭代器主要供 <code>for...of</code> 消费<ul>
<li><code>for...in</code> 循环是获取到了属性名</li>
<li><code>fro...of</code> 循环是获取到了属性值</li>
</ul>
</li>
<li>原生具备 Iterator 接口的数据，即可以使用 <code>for...of</code> 循环的有：Array、Arguments、Set、Map、String、TypedArray、NodeList</li>
<li>工作原理：<ul>
<li>创建一个指针对象，指向当前数据结构的起始位置</li>
<li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</li>
<li>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</li>
<li>每调用 next 方法返回一个包含 value 和 done 属性的对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const xiyou = [&#x27;唐僧&#x27;,&#x27;孙悟空&#x27;,&#x27;猪八戒&#x27;,&#x27;沙僧&#x27;];</span><br><span class="line">let iterator = xiyou[Symbol.iterator]();</span><br><span class="line">console.log(iterator.next());</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong style="color:red;">注意：需要自定义遍历数据的时候，要想到迭代器</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 自定义迭代器 —— 遍历得出对象中数组的每个值</span><br><span class="line">const classNum = &#123;</span><br><span class="line">	name: &quot;云计算一班&quot;,</span><br><span class="line">	stus: [</span><br><span class="line">			&#x27;小明&#x27;,</span><br><span class="line">			&#x27;小黄&#x27;,</span><br><span class="line">			&#x27;小红&#x27;</span><br><span class="line">	],</span><br><span class="line">	[Symbol.iterator]()&#123;</span><br><span class="line">		// 索引变量</span><br><span class="line">		let index = 0;</span><br><span class="line">		// 保存this</span><br><span class="line">		let _this = this;</span><br><span class="line">		return &#123;</span><br><span class="line">			next: function ()&#123;</span><br><span class="line">				if(index &lt; _this.stus.length)&#123;</span><br><span class="line">					const result = &#123;</span><br><span class="line">						value: _this.stus[index],</span><br><span class="line">						done: false</span><br><span class="line">					&#125;</span><br><span class="line">					// 下标自增</span><br><span class="line">					index ++;</span><br><span class="line">					// 返回结果</span><br><span class="line">					return result;</span><br><span class="line">				&#125;else &#123;</span><br><span class="line">					return &#123;</span><br><span class="line">						value: undefined,</span><br><span class="line">						done: true</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (let v of classNum)&#123;</span><br><span class="line">	console.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-生成器"><a href="#12-生成器" class="headerlink" title="12.生成器"></a>12.生成器</h2><ul>
<li><p>ES6 提供了一种异步编程的解决方案 —— 生成器函数</p>
</li>
<li><p>异步编程指纯回调函数，例如：Node中的fs模块、ajax、MongoDB等</p>
</li>
<li><p>创建生成器：在函数名前面加一个星号，返回的是迭代器对象，所以需要使用 <code>next()</code> 方法来执行其中的语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function * gen()&#123;</span><br><span class="line">	console.log(&quot;hello&quot;);</span><br><span class="line">&#125;</span><br><span class="line">let iterator = gen();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure></li>
<li><p>代码分割：在该函数中可以使用 <code>yield</code> 来进行代码分割，执行 <code>next()</code> 方法时就会按分割的区域顺序执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function * gen()&#123;</span><br><span class="line">	console.log(&quot;111&quot;);</span><br><span class="line">	yield &quot;第一条分割线&quot;;</span><br><span class="line">	console.log(&quot;222&quot;);</span><br><span class="line">	yield &quot;第二条分割线&quot;;</span><br><span class="line">	console.log(&quot;333&quot;);</span><br><span class="line">	yield &quot;第三条分割线&quot;;</span><br><span class="line">	console.log(&quot;444&quot;);</span><br><span class="line">&#125;</span><br><span class="line">let iterator = gen();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.next();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure></li>
<li><p>函数传参：在 <code>next()</code> 方法中可以传入实参，该实参将作为上一次 yield 语句的返回值来进行展示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function * gen2(arg)&#123;</span><br><span class="line">	console.log(arg);</span><br><span class="line">	let one = yield 111;</span><br><span class="line">	console.log(one);</span><br><span class="line">	let two = yield 222;</span><br><span class="line">	console.log(two);</span><br><span class="line">	let three = yield 333;</span><br><span class="line">	console.log(three);</span><br><span class="line">&#125;</span><br><span class="line">let iterator2 = gen2(&quot;AAA&quot;);</span><br><span class="line">console.log(iterator2.next());</span><br><span class="line">console.log(iterator2.next(&quot;BBB&quot;));</span><br><span class="line">console.log(iterator2.next(&quot;CCC&quot;));</span><br><span class="line">console.log(iterator2.next(&quot;DDD&quot;));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><ul>
<li><p>1秒后输出111，2秒后输出222，3秒后输出333</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function one()&#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		console.log(&quot;111&quot;);</span><br><span class="line">		iterator.next();</span><br><span class="line">	&#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">function two()&#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		console.log(&quot;222&quot;);</span><br><span class="line">		iterator.next();</span><br><span class="line">	&#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line">function three()&#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		console.log(&quot;333&quot;);</span><br><span class="line">		iterator.next();</span><br><span class="line">	&#125;, 3000)</span><br><span class="line">&#125;</span><br><span class="line">function * gen()&#123;</span><br><span class="line">	yield one();</span><br><span class="line">	yield two();</span><br><span class="line">	yield three();</span><br><span class="line">&#125;</span><br><span class="line">let iterator = gen();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure></li>
<li><p>模拟获取用户数据、订单数据、商品数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getUser()&#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		let data = &quot;用户数据&quot;;</span><br><span class="line">		iterator.next(data);</span><br><span class="line">	&#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">function getOrder()&#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		let data = &quot;订单数据&quot;;</span><br><span class="line">		iterator.next(data);</span><br><span class="line">	&#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">function getGoods()&#123;</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		let data = &quot;商品数据&quot;;</span><br><span class="line">		iterator.next(data);</span><br><span class="line">	&#125;, 1000)</span><br><span class="line">&#125;</span><br><span class="line">function * gen()&#123;</span><br><span class="line">	let user = yield getUser();</span><br><span class="line">	console.log(user);</span><br><span class="line">	let order = yield getOrder();</span><br><span class="line">	console.log(order);</span><br><span class="line">	let goods = yield getGoods();</span><br><span class="line">	console.log(goods);</span><br><span class="line">&#125;</span><br><span class="line">let iterator = gen();</span><br><span class="line">iterator.next();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-Promise"><a href="#13-Promise" class="headerlink" title="13.Promise"></a>13.Promise</h2><ul>
<li><p>ES6 引入的一种新的异步编程解决方案，是一个构造函数</p>
</li>
<li><p>作用：封装异步操作并可以获取其成功或失败的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const p = new Promise(function (resolve, reject)&#123;</span><br><span class="line">	let data = &quot;数据库中的数据&quot;;</span><br><span class="line">	// resolve(data);</span><br><span class="line">	let err = &quot;错误的数据&quot;;</span><br><span class="line">	reject(err);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(function (value)&#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;, function (reason)&#123;</span><br><span class="line">	console.log(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p><code>then()</code> 方法：该方法的返回结构是 Promise 对象，对象状态由回调函数的执行结构来决定</p>
<ul>
<li>如果回调函数中返回的结构是<strong style="color:red;">非 Promise 类型</strong>的属性，返回状态为成功，返回值为对象的成功的值</li>
<li>如果回调函数中返回的结构是 <strong style="color:red;">Promise 类型</strong>的属性，返回状态是成功则成功，失败则失败</li>
<li>如果回调函数中返回的结构是<strong style="color:red;">抛出错误</strong>，返回状态为失败</li>
<li><strong style="color:red;">所以，<code>then()</code> 方法可以链式调用</strong></li>
</ul>
</li>
<li><p><code>catch()</code> 方法：是 <code>then()</code> 方法的语法糖，具体同上</p>
</li>
</ul>
<h3 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h3><ul>
<li><p>使用 Promise 读取一个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line">// 普通读取一个文件</span><br><span class="line">fs.readFile(&quot;./file/test.md&quot;, (err,data) =&gt; &#123;</span><br><span class="line">	if (err) throw err;</span><br><span class="line">	console.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">// Promise读取一个文件</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	fs.readFile(&quot;./file/test.md&quot;, (err, data) =&gt; &#123;</span><br><span class="line">		if(err) reject(err);</span><br><span class="line">		resolve(data);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then((value) =&gt; &#123;</span><br><span class="line">	console.log(value.toString());</span><br><span class="line">&#125;, (reason) =&gt; &#123;</span><br><span class="line">	console.log(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Promise 封装 AJAX：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	const xhr = new XMLHttpRequest();</span><br><span class="line">	xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:9000/data&quot;);</span><br><span class="line">	xhr.send();</span><br><span class="line">	xhr.onreadystatechange = function ()&#123;</span><br><span class="line">		if (xhr.readyState === 4)&#123;</span><br><span class="line">			if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;</span><br><span class="line">				resolve(xhr.response);</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">				reject(xhr.response);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value =&gt; &#123;</span><br><span class="line">	console.log(value);</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">	console.error(reason);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 Promise 读取多个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 普通读取多个文件</span><br><span class="line">fs.readFile(&quot;./file/test1.md&quot;,(err,data1) =&gt; &#123;</span><br><span class="line">	fs.readFile(&quot;./file/test2.md&quot;, (err,data2) =&gt; &#123;</span><br><span class="line">		console.log(data1 + &quot;\r\n&quot; + data2);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">// Promise读取多个文件</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	fs.readFile(&quot;./file/test1.md&quot;, (err,data) =&gt; &#123;</span><br><span class="line">		resolve(data);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(value =&gt; &#123;</span><br><span class="line">	return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		fs.readFile(&quot;./file/test2.md&quot;, (err,data) =&gt; &#123;</span><br><span class="line">			resolve([value, data]);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;).then(value =&gt; &#123;</span><br><span class="line">	console.log(value.join(&quot;\r\n&quot;));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-Set"><a href="#14-Set" class="headerlink" title="14.Set"></a>14.Set</h2><ul>
<li><p>ES6 提供了新的数据结构 —— Set（集合），类似于数组但成员的值都是唯一的，数据类型是对象</p>
</li>
<li><p>集合实现了 Iterator 接口，所以可以使用 <code>扩展运算符</code> 和 <code>for...of</code> 来进行遍历</p>
</li>
<li><p>声明一个 set，同时在传入值的时候还可以达到<strong style="color:red;">数组去重的效果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const s1 = new Set();</span><br><span class="line">console.log(s1);</span><br><span class="line">const s2 = new Set([1,2,3,4,3,2,1]);</span><br><span class="line">console.log(s2)</span><br></pre></td></tr></table></figure></li>
<li><p>集合的属性和方法：</p>
<ul>
<li><code>s.size()</code>：返回集合的元素个数</li>
<li><code>s.add()</code>：增加一个新元素，返回当前集合</li>
<li><code>s.delete()</code>：删除一各元素，返回布尔值</li>
<li><code>s.has()</code>：检测集合中是否包含某个元素，返回布尔值</li>
<li><code>s.clear()</code>：清空当前集合</li>
</ul>
</li>
</ul>
<h3 id="案例：-2"><a href="#案例：-2" class="headerlink" title="案例："></a>案例：</h3><ul>
<li><p>数组去重：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = [1, 2, 4, 6, 4, 1];</span><br><span class="line">const s = new Set(arr);</span><br><span class="line">console.log([...s]);</span><br></pre></td></tr></table></figure></li>
<li><p>两数组的交集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [1, 2, 4, 6, 4, 1];</span><br><span class="line">const arr2 = [5, 6, 6, 5];</span><br><span class="line">const sArr1 = new Set(arr1);</span><br><span class="line">const sArr2 = new Set(arr2);</span><br><span class="line">const result = [...sArr1].filter(item =&gt; &#123;</span><br><span class="line">	if (sArr2.has(item))&#123;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line">const result1 = [...sArr1].filter(item =&gt; sArr2.has(item));</span><br><span class="line">console.log(result, result1);</span><br></pre></td></tr></table></figure></li>
<li><p>两数组的并集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [1, 2, 4, 6, 4, 1];</span><br><span class="line">const arr2 = [5, 6, 6, 5];</span><br><span class="line">const result = [...new Set([...arr1,...arr2])];</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure></li>
<li><p>两数组的差值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr1 = [1, 2, 4, 6, 4, 1];</span><br><span class="line">const arr2 = [5, 6, 6, 5];</span><br><span class="line">const sArr1 = new Set(arr1);</span><br><span class="line">const sArr2 = new Set(arr2);</span><br><span class="line">const se = [...sArr1].filter(item =&gt; !(sArr2.has(item)));</span><br><span class="line">const desc = [...sArr2].filter(item =&gt; !(sArr1.has(item)));</span><br><span class="line">console.log(se, desc);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="15-Map"><a href="#15-Map" class="headerlink" title="15.Map"></a>15.Map</h2><p>ES6 提供了 Map 数据结构，类似于对象，是键值对的集合，但键不限于字符串，各种类型的值（包括对象）都可以当做键</p>
<p>Map 也实现了 Iterator 接口，所以可以使用 <code>扩展运算符</code> 和 <code>for...of</code> 来进行遍历</p>
<p>声明一个 Map：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const m = new Map();</span><br><span class="line">m.set(&quot;name&quot;,&quot;Wrysmile&quot;);</span><br><span class="line">console.log(m);</span><br></pre></td></tr></table></figure>

<p>Map 的属性和方法：</p>
<ul>
<li><code>m.size()</code>：返回 Map 的元素个数</li>
<li><code>m.set()</code>：增加一个新元素，返回当前 Map</li>
<li><code>m.get()</code>：返回键名对象的键值</li>
<li><code>m.has()</code>：检测 Map 中是否包含某个元素，返回布尔值</li>
<li><code>m.clear()</code>：清空集合，返回 undefined</li>
</ul>
<h2 id="16-Class"><a href="#16-Class" class="headerlink" title="16.Class"></a>16.Class</h2><ul>
<li>通过 class 关键字可以定义类，可以看做一个语法糖</li>
</ul>
<h3 id="1-声明类"><a href="#1-声明类" class="headerlink" title="(1).声明类"></a>(1).声明类</h3><ul>
<li>如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Phone&#123;</span><br><span class="line">	// 构造方法，语法固定不可修改</span><br><span class="line">	constructor(phone, price) &#123;</span><br><span class="line">		this.phone = phone;</span><br><span class="line">		this.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	// 不能使用 ES5 的对象完整形式</span><br><span class="line">	call()&#123;</span><br><span class="line">		console.log(&quot;我可以打电话&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const onePlus = new Phone(&quot;一加&quot;,2999);</span><br><span class="line">console.log(onePlus);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-静态成员"><a href="#2-静态成员" class="headerlink" title="(2).静态成员"></a>(2).静态成员</h3><ul>
<li>通过 <code>static</code> 关键字设置的属性为静态属性，是不能被实例对象所引用的。就类似于 <code>Phone.name</code> 设置的属性</li>
<li>而不通过 <code>static</code> 关键字设置的属性是可以被实例对象所调用的。就类似于 <code>Phone.prototype.name</code> 设置的属性</li>
</ul>
<h3 id="3-继承"><a href="#3-继承" class="headerlink" title="(3).继承"></a>(3).继承</h3><ul>
<li><p>ES5 中的对象继承：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父类</span><br><span class="line">function Phone(brand, price)&#123;</span><br><span class="line">	this.brand = brand;</span><br><span class="line">	this.price = price;</span><br><span class="line">&#125;</span><br><span class="line">Phone.prototype.call = function ()&#123;</span><br><span class="line">	console.log(&quot;我可以打电话&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">function SmartPhone(brand, price, color, size)&#123;</span><br><span class="line">	Phone.call(this, brand, price);</span><br><span class="line">	this.color = color;</span><br><span class="line">	this.size = size;</span><br><span class="line">&#125;</span><br><span class="line">// 设置子类构造函数的原型</span><br><span class="line">SmartPhone.prototype = new Phone;</span><br><span class="line">SmartPhone.prototype.constructor = SmartPhone;</span><br><span class="line">// 声明子类的方法</span><br><span class="line">SmartPhone.prototype.photo = function ()&#123;</span><br><span class="line">	console.log(&quot;我可以拍照片&quot;);</span><br><span class="line">&#125;</span><br><span class="line">const onePlus = new SmartPhone(&quot;一加&quot;, 2999, &quot;黑色&quot;, &quot;6.6inch&quot;);</span><br><span class="line">console.log(onePlus);</span><br></pre></td></tr></table></figure></li>
<li><p>ES6 中的对象继承：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Phone&#123;</span><br><span class="line">	constructor(brand, price) &#123;</span><br><span class="line">		this.brand = brand;</span><br><span class="line">		this.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	call()&#123;</span><br><span class="line">		console.log(&quot;我可以打电话&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class SmartPhone extends Phone&#123;</span><br><span class="line">	constructor(brand, price, color, size) &#123;</span><br><span class="line">		// 继承父类的属性</span><br><span class="line">		super(brand, price);</span><br><span class="line">		this.color = color;</span><br><span class="line">		this.size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	photo()&#123;</span><br><span class="line">		console.log(&quot;我可以拍照片&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const onePlus = new SmartPhone(&quot;一加&quot;, 2999, &quot;黑色&quot;, &quot;6.6inch&quot;);</span><br><span class="line">console.log(onePlus);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-重写"><a href="#4-重写" class="headerlink" title="(4).重写"></a>(4).重写</h3><ul>
<li>我们可以在子类中重写父类的同名方法，同时也可以使用 <code>super.方法名()</code> 来调用父类的方法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父类</span><br><span class="line">class Phone&#123;</span><br><span class="line">	constructor(brand, price) &#123;</span><br><span class="line">		this.brand = brand;</span><br><span class="line">		this.price = price;</span><br><span class="line">	&#125;</span><br><span class="line">	call()&#123;</span><br><span class="line">		console.log(&quot;我可以打电话&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子类</span><br><span class="line">class SmartPhone extends Phone&#123;</span><br><span class="line">	constructor(brand, price, color, size) &#123;</span><br><span class="line">		// 继承父类的属性</span><br><span class="line">		super(brand, price);</span><br><span class="line">		this.color = color;</span><br><span class="line">		this.size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	call()&#123;</span><br><span class="line">		super.call();</span><br><span class="line">		console.log(&quot;我是子类的打电话&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	photo()&#123;</span><br><span class="line">		console.log(&quot;我可以拍照片&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const onePlus = new SmartPhone(&quot;一加&quot;, 2999, &quot;黑色&quot;, &quot;6.6inch&quot;);</span><br><span class="line">console.log(onePlus);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-get与set"><a href="#5-get与set" class="headerlink" title="(5).get与set"></a>(5).get与set</h3><ul>
<li><p>在 Class 中可以使用 <code>get</code> 来读取类中的方法，同时还可以读取到返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Phone&#123;</span><br><span class="line">	get call()&#123;</span><br><span class="line">		console.log(&quot;call方法被调用了&quot;);</span><br><span class="line">		return &quot;get到的&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const p = new Phone();</span><br><span class="line">console.log(p.call);</span><br></pre></td></tr></table></figure></li>
<li><p>在 Class 中给方法赋值时就会调用 <code>set</code> 中的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Phone&#123;</span><br><span class="line">	set call(arg)&#123;</span><br><span class="line">		console.log(&quot;set中的方法被调用了&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">const p = new Phone();</span><br><span class="line">p.call = &quot;flag&quot;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="17-数值扩展"><a href="#17-数值扩展" class="headerlink" title="17.数值扩展"></a>17.数值扩展</h2><ul>
<li><code>Number.EPSILON</code>：JS 中表示的最小精度，其值接近于 <code>2.22*10(-16方)</code></li>
<li>进制数定义：<ul>
<li>二进制：<code>0b1010</code></li>
<li>八进制：<code>0o777</code></li>
<li>十进制：<code>100</code></li>
<li>十六进制：<code>0xff</code></li>
</ul>
</li>
<li><code>Number.isFinite</code>：检测一个数值是否为有限数</li>
<li><code>Number.isNaN</code>：检测一个数值是否为 NaN</li>
<li><code>Number.parseInt/Float</code>：将字符串转为整数/浮点数</li>
<li><code>Number.isInteger</code>：判断一个数是否为整数</li>
<li><code>Math.trunc</code>：将数字的小数部分抹掉</li>
<li><code>Math.sign</code>：判断一个数到底为整数、负数还是零</li>
</ul>
<h2 id="18-对象方法扩展"><a href="#18-对象方法扩展" class="headerlink" title="18.对象方法扩展"></a>18.对象方法扩展</h2><ul>
<li><code>Object.is</code>：判断两个值是否完全相等</li>
<li><code>Object.assign(oldObject, newObject)</code>：对象的合并，当旧对象中有新对象中没有的时候，会进行合并，否则会直接覆盖</li>
<li><code>Object.setPrototypeOf</code>：设置原型对象（不推荐使用）</li>
<li><code>Object.getPrototypeOf</code>：获取原型对象（不推荐使用）</li>
</ul>
<h2 id="19-模块化"><a href="#19-模块化" class="headerlink" title="19.模块化"></a>19.模块化</h2><ul>
<li>是指将一个大的程序文件拆成许多小的文件，然后进行组合</li>
<li>优势：<ul>
<li>防止命名冲突</li>
<li>代码复用</li>
<li>高维护性</li>
</ul>
</li>
<li>模块化规范产品：<ul>
<li>CommonJS：NodeJS、Browserify</li>
<li>AMD：requireJS</li>
<li>CMD：seaJS</li>
</ul>
</li>
</ul>
<h3 id="1-暴露与引入"><a href="#1-暴露与引入" class="headerlink" title="(1).暴露与引入"></a>(1).暴露与引入</h3><ul>
<li>暴露模块内容的方法：<ul>
<li>在每一个需要暴露的变量或方法前面都加一个 <code>export</code> </li>
<li>也可以暴露一个对象，将需要暴露的变量或方法都放入对象中</li>
<li>也可以使用 <code>export default xxx</code> 来进行默认暴露的设置</li>
</ul>
</li>
<li>通过 <code>&lt;script&gt;</code> 标签来引入模块的方法：<ul>
<li>通用的引入：<code>import * as xxx from &quot;./test.js&quot;</code></li>
<li>解构赋值的引入，以下三个分别对应暴露模块的三种形式：<ul>
<li><code>import &#123;school&#125; from &quot;./test.js&quot;</code></li>
<li><code>import &#123;school as guigu&#125; from &quot;./test.js&quot;</code></li>
<li><code>import &#123;default as a&#125; from &quot;./test.js&quot;</code></li>
</ul>
</li>
<li>简便形式的引入，只针对于默认暴露的方法：<code>import b from &quot;./test.js&quot;</code></li>
</ul>
</li>
<li>通过 <code>&lt;script&gt;</code> 标签的 src 属性来引入：<ul>
<li>在 src 中引入某个js文件</li>
<li>然后在该 js 文件中直接使用上面语句进行引入</li>
</ul>
</li>
</ul>
<h3 id="2-babel代码转换"><a href="#2-babel代码转换" class="headerlink" title="(2).babel代码转换"></a>(2).babel代码转换</h3><ul>
<li>通过使用 babel 可以将 ES6语法转换为 ES5语法，方便不同浏览器的使用，官网点击<a href="https://www.babeljs.cn/">这里</a></li>
<li>使用方法：<ul>
<li>使用 <code>npm init --yes</code> 进行初始化</li>
<li>使用 <code>npm i babel-cli babel-preset-env browserify -D</code> 命令来安装相关的开发依赖，会安装babel-cli（命令行工具）、babel-preset-env（预设包，进行转换）、browserify（打包工具）这三个工具</li>
<li>使用 <code>npx babel 原始路径 -d 新路径</code> 命令来进行转换</li>
<li>使用 <code>npm browserify 新路径下的配置文件 -o 新路径配置文件</code> 命令来进行打包</li>
<li>网页中只要引用最后打包好的文件即可 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：Promise（尚硅谷）</title>
    <url>/Learn-Promise.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 Promise 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-实例对象与函数对象"><a href="#1-实例对象与函数对象" class="headerlink" title="1.实例对象与函数对象"></a>1.实例对象与函数对象</h2><ul>
<li>实例对象：new 函数产生的对象，称为实例对象，简称为对象</li>
<li>函数对象：将函数作为对象使用时，简称为函数对象</li>
</ul>
<h2 id="2-回调函数"><a href="#2-回调函数" class="headerlink" title="2.回调函数"></a>2.回调函数</h2><ul>
<li>同步回调：<ul>
<li>理解：立即执行，完全执行完了才结束，不会放入回调队列中</li>
<li>例子：数组遍历相关的函数、Promise 的 excutor 函数</li>
</ul>
</li>
<li>异步回调：<ul>
<li>理解：不会立即执行，会放入回调队列中将来执行</li>
<li>例子：定时器调用、ajax 回调、Promise 的成功/失败回调</li>
</ul>
</li>
</ul>
<h2 id="3-JS中的错误"><a href="#3-JS中的错误" class="headerlink" title="3.JS中的错误"></a>3.JS中的错误</h2><ul>
<li>具体可看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error">MDN</a> 中的解释</li>
</ul>
<h3 id="1-错误的类型"><a href="#1-错误的类型" class="headerlink" title="(1).错误的类型"></a>(1).错误的类型</h3><ul>
<li><code>Error</code>：所有错误的父类型</li>
<li><code>ReferenceError</code>：引用错误，引用的变量不存在</li>
<li><code>TypeError</code>：类型错误，数据类型不正确</li>
<li><code>RangeError</code>：范围错误，数据值不在其所允许的范围内</li>
<li><code>SyntaxError</code>：语法错误</li>
</ul>
<h3 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="(2).错误处理"></a>(2).错误处理</h3><ul>
<li><p>捕获错误：使用 <code>try...catch</code> 来捕获</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	let a;</span><br><span class="line">	console.log(a.xxx)</span><br><span class="line">&#125; catch (error)&#123;</span><br><span class="line">	console.log(error.message);</span><br><span class="line">	console.log(error.stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>抛出错误：使用 <code>throw error</code> 来抛出，error 中传一个 message</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function something() &#123;</span><br><span class="line">	if(Date.now() % 2 === 1)&#123;</span><br><span class="line">		console.log(&quot;当前时间为奇数，可以继续执行&quot;);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		throw new Error(&quot;当前时间为偶数，无法继续执行&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">	something();</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">	alert(error.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-错误对象"><a href="#3-错误对象" class="headerlink" title="(3).错误对象"></a>(3).错误对象</h3><ul>
<li>message 属性：错误相关信息</li>
<li>stack 属性：函数调用栈记录信息</li>
</ul>
<h1 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h1><h2 id="1-理解"><a href="#1-理解" class="headerlink" title="1.理解"></a>1.理解</h2><ul>
<li>抽象表达：<ul>
<li>Promise 是 JS 中进行异步编程的新方案</li>
<li><strong style="color:red;">注意：旧方案为纯回调</strong></li>
</ul>
</li>
<li>具体表达：<ul>
<li>从语法上来说：Promise 是一个构造函数</li>
<li>从功能上来说：Promise 对象用来封装一个异步操作并可以获取其结果</li>
</ul>
</li>
</ul>
<h2 id="2-状态"><a href="#2-状态" class="headerlink" title="2.状态"></a>2.状态</h2><p>Promise 一共有三种状态：pending、resolved、rejected</p>
<p>状态改变：</p>
<ul>
<li>pending -&gt; resolved，结果数据为 value</li>
<li>pending -&gt; rejected，结果数据为 reason</li>
</ul>
<p>一个 Promise 对象只能改变一次，无论变为成功还是失败，都会有一个结果数据</p>
<h2 id="3-流程"><a href="#3-流程" class="headerlink" title="3.流程"></a>3.流程</h2><ul>
<li>基本运行流程如下：<br><img src="https://z3.ax1x.com/2021/07/15/WnyxeS.png" alt="promise01.png"></li>
</ul>
<h2 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h2><ul>
<li>基本使用方法如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个新的Promise对象</span><br><span class="line">const p = new Promise((resolve, reject) =&gt; &#123;// 执行器函数（同步回调）</span><br><span class="line">	// 执行异步操作任务</span><br><span class="line">	setTimeout(() =&gt; &#123;</span><br><span class="line">		const time = Date.now();</span><br><span class="line">		if (time % 2 === 0)&#123;</span><br><span class="line">			// 成功，调用 resolve</span><br><span class="line">			resolve(&quot;当前时间为偶数&quot;+time+&quot;成功&quot;);</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">			// 失败，调用 reject</span><br><span class="line">			reject(&quot;当前时间为奇数&quot;+time+&quot;失败&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(</span><br><span class="line">	value =&gt; &#123;</span><br><span class="line">		console.log(&quot;成功的回调&quot;+value);</span><br><span class="line">	&#125;,</span><br><span class="line">	reason =&gt; &#123;</span><br><span class="line">		console.log(&quot;失败的回调&quot;+reason);</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-优点"><a href="#5-优点" class="headerlink" title="5.优点"></a>5.优点</h2><ul>
<li>指定回调函数的方式更加灵活：<ul>
<li>旧方法：必须在启动任务前指定</li>
<li>Promise：启动异步任务 =&gt; 返回promise对象 =&gt; 给promise对象绑定回调函数（甚至可以在异步任务结束后指定）</li>
</ul>
</li>
<li>支持链式调用，可以解决回调地狱问题</li>
</ul>
<h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="!回调地狱"></a>!回调地狱</h3><ul>
<li><p>回调函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数执行的条件</p>
</li>
<li><p>缺点：不便于阅读、不便于异常处理</p>
</li>
<li><p>初级解决方案：promise 链式调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">	.then(function (result)&#123;</span><br><span class="line">		return doSomethingElse(result)</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(function (newResult)&#123;</span><br><span class="line">		return doThirdThing(newResult)</span><br><span class="line">	&#125;)</span><br><span class="line">	.then(function (finalResult)&#123;</span><br><span class="line">		console.log(&quot;Get the final result&quot; + finalResult)</span><br><span class="line">	&#125;)</span><br><span class="line">	.catch(failureCallback)</span><br></pre></td></tr></table></figure></li>
<li><p>终极解决方案：async / await</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function request()&#123;</span><br><span class="line">	try&#123;</span><br><span class="line">		const result = await doSomething()</span><br><span class="line">		const newResult = await doSomethingElse(result)</span><br><span class="line">		const finalResult = await doThirdThing(newResult)</span><br><span class="line">		console.log(&quot;Get the final result&quot; + finalResult)</span><br><span class="line">	&#125;catch (error)&#123;</span><br><span class="line">		failureCallback(error)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-API"><a href="#6-API" class="headerlink" title="6.API"></a>6.API</h2><ul>
<li>Promise构造函数：<code>Promise(excutor)&#123;&#125;</code><ul>
<li>excutor函数：同步执行 <code>(resolve, reject) =&gt; &#123;&#125;</code> <ul>
<li>resolve函数：内部定义成功时我们调用的函数 <code>value =&gt; &#123;&#125;</code></li>
<li>reject函数：内部定义失败时我们调用的函数 <code>reason =&gt; &#123;&#125;</code></li>
</ul>
</li>
<li>说明：excutor 会在 Promise 内部立即同步回调，异步操作在执行器中执行</li>
</ul>
</li>
<li>Promise.prototype.then方法：<code>(onResolved, onRejected) =&gt; &#123;&#125;</code><ul>
<li>onResolved函数：成功的回调函数 <code>(value) =&gt; &#123;&#125;</code></li>
<li>onRejeced函数：失败的回调函数 <code>(reason) =&gt; &#123;&#125;</code></li>
<li>说明：指定用于得到成功value的成功回调和用于得到失败reason的失败回调，返回一个新的 promise 对象</li>
</ul>
</li>
<li>Promise.prototype.catch方法：<code>(onRejectde) =&gt; &#123;&#125;</code><ul>
<li>onRejeced函数：失败的回调函数 <code>(reason) =&gt; &#123;&#125;</code></li>
<li>说明：<code>then()</code> 的语法糖，相当于 <code>then(undefined, onRejected)</code></li>
</ul>
</li>
<li>Promise.resolve方法：<code>(value) =&gt; &#123;&#125;</code><ul>
<li>value：成功的数据或promise对象</li>
<li>说明：返回一个成功/失败的promise对象</li>
</ul>
</li>
<li>Promise.reject方法：<code>(reason) =&gt; &#123;&#125;</code><ul>
<li>reason：失败的原因</li>
<li>说明：返回一个失败的promise对象</li>
</ul>
</li>
<li>Promise.all方法：<code>(Promises) =&gt; &#123;&#125;</code><ul>
<li>promises：包含n个promise数组</li>
<li>说明：返回一个新的promise，只有所有的promise都成功才成功，只要有一个失败就直接失败</li>
</ul>
</li>
<li>Promise.race方法：<code>(promises) =&gt; &#123;&#125;</code><ul>
<li>promises：包含n个promise数组</li>
<li>说明：返回一个新的promise，第一个完成的promise的结果状态就是最终的结果状态</li>
</ul>
</li>
</ul>
<h1 id="三、Promise问题"><a href="#三、Promise问题" class="headerlink" title="三、Promise问题"></a>三、Promise问题</h1><h2 id="1-如何改变Promise状态？"><a href="#1-如何改变Promise状态？" class="headerlink" title="1.如何改变Promise状态？"></a>1.如何改变Promise状态？</h2><ul>
<li>调用 <code>resolve(value)</code>：如果当前是pending就会变成resolved</li>
<li>调用 <code>reject(reason)</code>：如果当前是pending就会变成rejected</li>
<li>抛出异常：如果当前是pending就会变成rejected</li>
</ul>
<h2 id="2-一个Promise指定多个成功-失败回调函数，都会调用吗？"><a href="#2-一个Promise指定多个成功-失败回调函数，都会调用吗？" class="headerlink" title="2.一个Promise指定多个成功/失败回调函数，都会调用吗？"></a>2.一个Promise指定多个成功/失败回调函数，都会调用吗？</h2><ul>
<li>当 promise 改变为对应状态时都会调用</li>
</ul>
<h2 id="3-改变Promise状态和指定回调函数谁先谁后？"><a href="#3-改变Promise状态和指定回调函数谁先谁后？" class="headerlink" title="3.改变Promise状态和指定回调函数谁先谁后？"></a>3.改变Promise状态和指定回调函数谁先谁后？</h2><ul>
<li>都有可能，正常情况下是先指定回调再改变状态，但也可以先改状态在指定回调</li>
</ul>
<h3 id="1-如何先改状态再指定回调？"><a href="#1-如何先改状态再指定回调？" class="headerlink" title="(1).如何先改状态再指定回调？"></a>(1).如何先改状态再指定回调？</h3><ul>
<li>在执行器中直接调用 <code>resolve()/reject()</code> </li>
<li>延迟更长时间再调用 <code>then()</code></li>
</ul>
<h3 id="2-什么时候才能得到数据？"><a href="#2-什么时候才能得到数据？" class="headerlink" title="(2).什么时候才能得到数据？"></a>(2).什么时候才能得到数据？</h3><ul>
<li>如果先指定回调，那当状态发生改变时，回调函数就会调用，得到数据</li>
<li>如果先改变状态，那当指定回调时，回调函数就会调用，得到数据</li>
</ul>
<h2 id="4-then-方法返回的新promise的结果状态由什么决定？"><a href="#4-then-方法返回的新promise的结果状态由什么决定？" class="headerlink" title="4.then()方法返回的新promise的结果状态由什么决定？"></a>4.then()方法返回的新promise的结果状态由什么决定？</h2><ul>
<li>简单表达：由 <code>then()</code> 指定的回调函数执行的结果决定</li>
<li>详细表达：<ul>
<li>如果抛出异常，新 promise 变为 rejected，reason 为抛出的异常</li>
<li>如果返回的是非 promise 的任意值，新 promise 变为 resolved，value 为返回的值</li>
<li>如果返回的是另一个新 promise，此 promise 的结果就会变成新 promise 的结果</li>
</ul>
</li>
</ul>
<h2 id="5-promise如何串联多个操作任务？"><a href="#5-promise如何串联多个操作任务？" class="headerlink" title="5.promise如何串联多个操作任务？"></a>5.promise如何串联多个操作任务？</h2><ul>
<li>promise 的 <code>then()</code> 返回一个新的 promise，可以看成 <code>then()</code> 的链式调用</li>
<li>通过 <code>then()</code> 的链式调用串联多个同步/异步任务 </li>
</ul>
<h2 id="6-promise异常传-穿透是什么？"><a href="#6-promise异常传-穿透是什么？" class="headerlink" title="6.promise异常传/穿透是什么？"></a>6.promise异常传/穿透是什么？</h2><ul>
<li>当使用 promise 的 <code>then()</code> 链式调用时，可以在最后指定失败的回调，前面任何操作出了异常，都会传到最后失败的回调中处理</li>
<li>因为在中间的传递中，默认执行如下语句：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reason =&gt; &#123;</span><br><span class="line">	throw reason;</span><br><span class="line">&#125;</span><br><span class="line">等同于：</span><br><span class="line">reason =&gt; Promise.rejected(reason);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-如何中断promise链？"><a href="#7-如何中断promise链？" class="headerlink" title="7.如何中断promise链？"></a>7.如何中断promise链？</h2><ul>
<li>定义：当使用 promise 的 <code>then()</code> 链式调用时，在中间中断，不再调用后面的回调函数</li>
<li>方法：在回调函数中返回一个 pending 状态的 promise 对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return new Promise(() =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、自定义Promise"><a href="#四、自定义Promise" class="headerlink" title="四、自定义Promise"></a>四、自定义Promise</h1><ul>
<li><strong style="color:red;">重复观看！！！</strong></li>
</ul>
<h1 id="五、async与await"><a href="#五、async与await" class="headerlink" title="五、async与await"></a>五、async与await</h1><ul>
<li>MDN文档点 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">async</a>/<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></li>
</ul>
<h2 id="1-async函数"><a href="#1-async函数" class="headerlink" title="1.async函数"></a>1.async函数</h2><ul>
<li>函数的返回值为 promise 对象</li>
<li>promise 对象的结构由 async 函数执行的返回值决定</li>
</ul>
<h2 id="2-await表达式"><a href="#2-await表达式" class="headerlink" title="2.await表达式"></a>2.await表达式</h2><ul>
<li>await 右侧的表达式一般为 promise 对象，但也可以是其他的值<ul>
<li>如果表达式是 promise 对象，await 返回的是 promise 成功的值</li>
<li>如果表达式时其他值，直接将此值作为 await 的返回值</li>
<li>如果 await 的 promise 失败了，就会抛出异常，需要通过 <code>try...catch</code> 来捕获处理</li>
</ul>
</li>
<li><strong style="color:red;">注意：await 必须写在 async 函数中，但 async 函数中可以没有 await</strong></li>
</ul>
<h1 id="六、JS异步之两种队列"><a href="#六、JS异步之两种队列" class="headerlink" title="六、JS异步之两种队列"></a>六、JS异步之两种队列</h1><ul>
<li><p>JS 中用来存储待执行回调函数的队列包含两个不同特定的队列：</p>
<ul>
<li>宏队列：用来保存待执行的宏任务（回调）。如：定时器回调、DOM 事件回调、ajax 回调</li>
<li>微队列：用来保存待执行的微任务（回调）。如：Promise 回调、MutationObserve 回调</li>
</ul>
</li>
<li><p>原理图如下：<br><img src="https://z3.ax1x.com/2021/07/19/WJro38.png" alt="promise02.png"></p>
</li>
<li><p>JS 执行时会区别这两个队列：</p>
<ul>
<li>JS 引擎首先必须先执行所有的初始化同步任务代码</li>
<li>每次准备取出第一个红任务执行前，都要将所有的微任务一个一个取出来执行</li>
</ul>
</li>
</ul>
<h1 id="七、面试题"><a href="#七、面试题" class="headerlink" title="七、面试题"></a>七、面试题</h1><h2 id="1-题一"><a href="#1-题一" class="headerlink" title="1.题一"></a>1.题一</h2><ul>
<li><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">	console.log(1)</span><br><span class="line">&#125;,0)</span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">	console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">	console.log(3)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(4)</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果为：4 2 3 1</p>
</li>
</ul>
<h2 id="2-题二"><a href="#2-题二" class="headerlink" title="2.题二"></a>2.题二</h2><ul>
<li><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">	console.log(1)</span><br><span class="line">&#125;,0)</span><br><span class="line">new Promise((resolve) =&gt; &#123;</span><br><span class="line">	console.log(2)</span><br><span class="line">	resolve()</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">	console.log(3)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">	console.log(4)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(5)</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果为：2 5 3 4 1</p>
</li>
<li><p>研究：</p>
<ul>
<li>首先，Promise 的执行器函数是同步执行的，所以2先打印，之后同步执行5</li>
<li>其次，放入微队列中的是3，宏队列中的是1，且在4处时 promise 状态还为 pending，所以其待定</li>
<li>然后，微队列中的3打印输出，此时状态更改为，resolved，4进入微队列</li>
<li>最后，微队列中的4打印输出，宏队列中的1打印输出</li>
</ul>
</li>
</ul>
<h2 id="3-题三"><a href="#3-题三" class="headerlink" title="3.题三"></a>3.题三</h2><ul>
<li><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const first = () =&gt; (</span><br><span class="line">	new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		console.log(3)</span><br><span class="line">		let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			console.log(7)</span><br><span class="line">			setTimeout(() =&gt; &#123;</span><br><span class="line">				console.log(5)</span><br><span class="line">				resolve(6)</span><br><span class="line">			&#125;,0)</span><br><span class="line">			resolve(1)</span><br><span class="line">		&#125;)</span><br><span class="line">		resolve(2)</span><br><span class="line">		p.then((arg) =&gt; &#123;</span><br><span class="line">			console.log(arg)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">)</span><br><span class="line">first().then((arg) =&gt; &#123;</span><br><span class="line">	console.log(arg)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(4)</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果为：3 7 4 1 2 5</p>
</li>
</ul>
<h2 id="4-题四"><a href="#4-题四" class="headerlink" title="4.题四"></a>4.题四</h2><ul>
<li><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">	console.log(0)</span><br><span class="line">&#125;,0)</span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	console.log(1)</span><br><span class="line">	resolve()</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">	console.log(2)</span><br><span class="line">	new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		console.log(3)</span><br><span class="line">		resolve()</span><br><span class="line">	&#125;).then(() =&gt; &#123;</span><br><span class="line">		console.log(4)</span><br><span class="line">	&#125;).then(() =&gt; &#123;</span><br><span class="line">		console.log(5)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">	console.log(6)</span><br><span class="line">&#125;)</span><br><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">	console.log(7)</span><br><span class="line">	resolve()</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">	console.log(8)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果为：</p>
</li>
<li><p>研究：</p>
<ul>
<li>首先根据代码执行顺序可以判断出当前同步执行的有[1 7]，宏队列有[0]，微队列有[2 8]</li>
<li>然后输出[1 7 2]，当2执行过后3为同步，所以输出为[1 7 2 3]，此时宏队列有[0]，微队列中有[8 4 6]，因为2所在的代码块中返回值为 undefined，所以6已经入队列了</li>
<li>然后输出[1 7 2 3 8 4]，当4执行完后5为promise对象的回调，此时宏队列有[0]，微队列中有[6 5]</li>
<li>然后输出[1 7 2 3 8 4 6]，此时宏队列有[0]，微队列中有[5 8]</li>
<li>最后输出[1 7 2 3 8 4 6 5 0]</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：AJAX（尚硅谷）</title>
    <url>/Learn-AJAX.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 AJAX 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础内容"><a href="#一、基础内容" class="headerlink" title="一、基础内容"></a>一、基础内容</h1><h2 id="1-AJAX"><a href="#1-AJAX" class="headerlink" title="1.AJAX"></a>1.AJAX</h2><p>AJAX 是异步的 JS 和 XML，通过 AJAX 可以在浏览器中向服务器中发送异步请求<br>优点：</p>
<ul>
<li>可以无需刷新页面与服务器进行通信</li>
<li>允许根据用户时间来更新部分页面内容</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有浏览历史，不能回退</li>
<li>存在跨域问题（同源）</li>
<li>SEO 不太好</li>
</ul>
<h2 id="2-XML"><a href="#2-XML" class="headerlink" title="2.XML"></a>2.XML</h2><p>XML 被设计用来传输和存储数据<br>xml 与 html 的区别：</p>
<ul>
<li>前者没有预定义标签，全是自定义标签，用来表示一些数据</li>
<li>后者都是预定义标签<br>目前已被 JSON 取代</li>
</ul>
<h2 id="3-HTTP"><a href="#3-HTTP" class="headerlink" title="3.HTTP"></a>3.HTTP</h2><ul>
<li>超文本传输协议，详细规定了浏览器和万维网服务器之间互相通信的规则</li>
</ul>
<h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="(1).请求报文"></a>(1).请求报文</h3><ul>
<li>请求行：GET或POST / url / HTTP协议版本</li>
<li>请求头：格式为<strong style="color:red;">键值对</strong><ul>
<li>Host：xxxx</li>
<li>Cookie：name=wrysmile</li>
</ul>
</li>
<li>请求空行：固定的</li>
<li>请求体：<ul>
<li>如果请求行是 GET 请求，请求体就为空</li>
<li>如果请求行是 POST 请求，请求体可以不为空</li>
</ul>
</li>
</ul>
<h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="(2).响应报文"></a>(2).响应报文</h3><ul>
<li>响应行：HTTP协议版本 / 响应状态码 / 响应状态字符串<ul>
<li>1xx：信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2xx：成功，操作被成功接收并处理</li>
<li>3xx：重定向，需要进一步的操作以完成请求</li>
<li>4xx：客户端错误，请求包含语法错误或无法完成请求</li>
<li>5xx：服务器错误，服务器在处理请求的过程中发生了错误</li>
<li>具体状态码可以看<a href="https://www.runoob.com/http/http-status-codes.html">这里</a></li>
</ul>
</li>
<li>响应头：<ul>
<li>Content-Type：text/html;charset=utf-8</li>
</ul>
</li>
<li>响应空行：固定必须有</li>
<li>响应体：html中的所有内容</li>
</ul>
<h2 id="4-Express"><a href="#4-Express" class="headerlink" title="4.Express"></a>4.Express</h2><ul>
<li><p>安装 express</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i express</span><br></pre></td></tr></table></figure></li>
<li><p>引入 express</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const express = require(&quot;express&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>创建应用对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const app = express();</span><br></pre></td></tr></table></figure></li>
<li><p>创建路由规则：request 是对请求报文的封装，response 是对响应报文的封装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// get请求</span><br><span class="line">app.get(&#x27;/server&#x27;, (request,response) =&gt; &#123;</span><br><span class="line">    // 设置响应头，允许跨域</span><br><span class="line">    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &quot;*&quot;)</span><br><span class="line">    // 设置响应</span><br><span class="line">    response.send(&quot;你好&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">// post请求</span><br><span class="line">app.post(&quot;/server&quot;, (request, response) =&gt; &#123;</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">    response.send(&quot;你好&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>监听端口启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.listen(8000, () =&gt; &#123;</span><br><span class="line">    console.log(&quot;服务已经启动，8000端口监听中&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-nodemon"><a href="#5-nodemon" class="headerlink" title="5.nodemon"></a>5.nodemon</h2><ul>
<li><p>官网点<a href="https://www.npmjs.com/package/nodemon">这里</a></p>
</li>
<li><p>作用：在修改了 NodeJS 中的代码时可以自动重启服务</p>
</li>
<li><p>安装：执行下面的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure></li>
<li><p>启用：执行下面的指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nodemon test.js</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二、AJAX操作"><a href="#二、AJAX操作" class="headerlink" title="二、AJAX操作"></a>二、AJAX操作</h1><h2 id="1-GET请求"><a href="#1-GET请求" class="headerlink" title="1.GET请求"></a>1.GET请求</h2><ul>
<li><p>创建对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure></li>
<li><p>初始化，设置请求方法和 URL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>发送</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></li>
<li><p>事件绑定：处理服务端返回的结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = function ()&#123;</span><br><span class="line">	// readystate 是xhr对象中的属性，表示状态，共有0,1,2,3,4 五种状态</span><br><span class="line">	// 0表示未初始化、1表示open已经调用完毕，2表示send已经调用完毕，3表示服务器返回了一部分的机结果，4表示服务器返回了所有的结果</span><br><span class="line">	if(xhr.readyState === 4)&#123;</span><br><span class="line">		if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;</span><br><span class="line">			// 响应行中的状态码</span><br><span class="line">			console.log(xhr.status)</span><br><span class="line">			// 响应行中的状态字符串</span><br><span class="line">			console.log(xhr.statusText)</span><br><span class="line">			// 所有的响应头</span><br><span class="line">			console.log(xhr.getAllResponseHeaders())</span><br><span class="line">			// 响应体</span><br><span class="line">			console.log(xhr.response)</span><br><span class="line">		&#125;else &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-xhr的属性"><a href="#1-xhr的属性" class="headerlink" title="(1).xhr的属性"></a>(1).xhr的属性</h3><ul>
<li><code>xhr.readyState()</code>：表示状态</li>
<li><code>xhr.status</code>：表示响应状态码</li>
<li><code>xhr.statusText</code>：表示响应状态字符串</li>
<li><code>xhr.getAllResponseHeaders()</code>：表示获取所有的响应头</li>
<li><code>xhr.response</code>：表示响应体</li>
</ul>
<h3 id="2-AJAX请求参数"><a href="#2-AJAX请求参数" class="headerlink" title="(2).AJAX请求参数"></a>(2).AJAX请求参数</h3><ul>
<li>只需要在url后面跟上需要传的参数即可</li>
<li>使用 <code>?a=100&amp;b=200</code> 的方式来传递</li>
</ul>
<h2 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2.POST请求"></a>2.POST请求</h2><ul>
<li><p>只需要修改相应的请求方式即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;POST&quot;, &quot;http://127.0.0.1:8000/server&quot;);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = function ()&#123;</span><br><span class="line">	if(xhr.readyState === 4)&#123;</span><br><span class="line">		if(xhr.status &gt;= 200 &amp; xhr.status &lt; 300)&#123;</span><br><span class="line">			result.innerHTML = xhr.response;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>设置请求体：只需要在send()方法中设置即可，格式灵活多变，只需要服务端可以处理该格式即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.send(&quot;a=100&amp;b=222&quot;);</span><br><span class="line">xhr.send(&quot;a:100&amp;b:200&quot;);</span><br><span class="line">xhr.send(&quot;12332112345&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>设置请求头：只需要在open()方法下面执行以下语句即可（注意：一般发送的都是预定义的内容）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-响应JSON数据"><a href="#3-响应JSON数据" class="headerlink" title="3.响应JSON数据"></a>3.响应JSON数据</h2><h3 id="1-手动响应"><a href="#1-手动响应" class="headerlink" title="(1).手动响应"></a>(1).手动响应</h3><ul>
<li>调用 JSON 的方法手动对数据进行转化<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/json-server&quot;);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = function ()&#123;</span><br><span class="line">	if(xhr.readyState === 4)&#123;</span><br><span class="line">		if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;</span><br><span class="line">			let data = JSON.parse(xhr.response);</span><br><span class="line">			result.innerHTML = data.name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-自动响应"><a href="#2-自动响应" class="headerlink" title="(2).自动响应"></a>(2).自动响应</h3><ul>
<li>设置响应体的数据类型即可自动对数据进行转化<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">// 设置响应体数据类型</span><br><span class="line">xhr.responseType = &quot;json&quot;;</span><br><span class="line">xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/json-server&quot;);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = function ()&#123;</span><br><span class="line">	if(xhr.readyState === 4)&#123;</span><br><span class="line">		if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;</span><br><span class="line">			// 自动转化</span><br><span class="line">			result.innerHTML = xhr.response.name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-IE缓存问题解决"><a href="#4-IE缓存问题解决" class="headerlink" title="4.IE缓存问题解决"></a>4.IE缓存问题解决</h2><ul>
<li>在 IE 浏览器中通过 AJAX 获取到的数据是会自动缓存到本地的，当再次获取时是获取的本地缓存，所以需要处理本地缓存问题</li>
<li>只需要在open()方法中传入一个时间戳即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/ie?t=&quot; + Date.now());</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-请求超时与网络异常"><a href="#5-请求超时与网络异常" class="headerlink" title="5.请求超时与网络异常"></a>5.请求超时与网络异常</h2><ul>
<li><p>当用户请求超过一定时间时如果还没有获取到相应的内容，可以通过以下方法来给用户进行一些提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 超时设置 2s</span><br><span class="line">xhr.timeout = 2000;</span><br><span class="line">// 超时回调</span><br><span class="line">xhr.ontimeout = function ()&#123;</span><br><span class="line">	alert(&quot;请求超时&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当网络出现异常时也可以进行一些提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 异常回调</span><br><span class="line">xhr.onerror = function ()&#123;</span><br><span class="line">	alert(&quot;网络异常&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-手动取消请求"><a href="#6-手动取消请求" class="headerlink" title="6.手动取消请求"></a>6.手动取消请求</h2><ul>
<li>使用 <code>xhr.abort()</code> 方法可以手动取消请求<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;点击发送&lt;/button&gt;</span><br><span class="line">&lt;button&gt;点击取消&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	const btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">	let xhr = null;</span><br><span class="line">	btns[0].onclick = function ()&#123;</span><br><span class="line">		xhr = new XMLHttpRequest();</span><br><span class="line">		xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/dely&quot;);</span><br><span class="line">		xhr.send();</span><br><span class="line">	&#125;</span><br><span class="line">	btns[1].onclick = function ()&#123;</span><br><span class="line">		xhr.abort();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-重复发送请求"><a href="#7-重复发送请求" class="headerlink" title="7.重复发送请求"></a>7.重复发送请求</h2><ul>
<li>当用户重复发送请求时，会占用很大的服务器资源，所以我们需要在发送请求前判断是否有上一次的请求存在<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;点击发送&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	const btns = document.querySelectorAll(&quot;button&quot;);</span><br><span class="line">	// 判断是否正在发送请求</span><br><span class="line">	let isSending = false;</span><br><span class="line">	let xhr = null;</span><br><span class="line">	btns[0].onclick = function ()&#123;</span><br><span class="line">		// 如果标识为true表示正在发送请求，关闭上次请求</span><br><span class="line">		if (isSending)  xhr.abort();</span><br><span class="line">		xhr = new XMLHttpRequest();</span><br><span class="line">		// 正在发送请求，更改标识</span><br><span class="line">		isSending = true;</span><br><span class="line">		xhr.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/dely&quot;);</span><br><span class="line">		xhr.send();</span><br><span class="line">		xhr.onreadystatechange = function ()&#123;</span><br><span class="line">			if(xhr.readyState === 4)&#123;</span><br><span class="line">				// 请求发送完毕，更改标识</span><br><span class="line">				isSending = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、JQuery操作"><a href="#三、JQuery操作" class="headerlink" title="三、JQuery操作"></a>三、JQuery操作</h1><h2 id="1-发送AJAX请求"><a href="#1-发送AJAX请求" class="headerlink" title="1.发送AJAX请求"></a>1.发送AJAX请求</h2><ul>
<li><p>发送请求时总共有四个参数：</p>
<ul>
<li>url：请求的url地址</li>
<li>data：请求携带的参数（为对象）</li>
<li>callback：回调函数</li>
<li>type：设置返回内容的格式（xml、html、script、json、text、_default）</li>
</ul>
</li>
<li><p>GET 请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).eq(0).click(function ()&#123;</span><br><span class="line">	$.get(&quot;http://127.0.0.1:8000/jquery-server&quot;, &#123;a:100,b:200&#125;, function (data)&#123;</span><br><span class="line">		// data参数为响应体</span><br><span class="line">		console.log(data)</span><br><span class="line">	&#125;, &quot;json&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>POST 请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;button&quot;).eq(1).click(function ()&#123;</span><br><span class="line">	$.post(&quot;http://127.0.0.1:8000/jquery-server&quot;, &#123;a:100,b:200&#125;, function (data)&#123;</span><br><span class="line">		// data参数为响应体</span><br><span class="line">		console.log(data)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>通用型发送请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	// url</span><br><span class="line">	url: &quot;http://127.0.0.1:8000/json-server&quot;,</span><br><span class="line">	// 参数</span><br><span class="line">	data: &#123;a:100, b:200&#125;,</span><br><span class="line">	// 请求类型</span><br><span class="line">	type: &quot;GET&quot;,</span><br><span class="line">	// 响应体结果</span><br><span class="line">	dataType: &quot;json&quot;,</span><br><span class="line">	// 成功的回调</span><br><span class="line">	success: function (data)&#123;</span><br><span class="line">		console.log(data)</span><br><span class="line">	&#125;,</span><br><span class="line">	// 超时时间</span><br><span class="line">	timeout: 2000,</span><br><span class="line">	// 失败的回调</span><br><span class="line">	error: function ()&#123;</span><br><span class="line">		console.log(&quot;出错了&quot;);</span><br><span class="line">	&#125;,</span><br><span class="line">	// 头信息</span><br><span class="line">	header: &#123;</span><br><span class="line">		c: 300,</span><br><span class="line">		d: 400</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、Axios操作"><a href="#四、Axios操作" class="headerlink" title="四、Axios操作"></a>四、Axios操作</h1><ul>
<li><p>GET 请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.get(&quot;http://127.0.0.1:8000/axios-server&quot;, &#123;</span><br><span class="line">	// url参数信息</span><br><span class="line">	params: &#123;</span><br><span class="line">		id: 100,</span><br><span class="line">		vip: 7</span><br><span class="line">	&#125;,</span><br><span class="line">	// 请求头信息</span><br><span class="line">	headers: &#123;</span><br><span class="line">		name: &quot;Wrysmile&quot;,</span><br><span class="line">		age: 25</span><br><span class="line">	&#125;,</span><br><span class="line">	// 请求体</span><br><span class="line">	data: &#123;</span><br><span class="line">		username: &quot;wrysmile&quot;,</span><br><span class="line">		password: &quot;123456789&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>POST 请求如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios.post(&quot;http://127.0.0.1:8000/axios-server&quot;, &#123;</span><br><span class="line">	username: &quot;wrysmile&quot;,</span><br><span class="line">	password: &quot;123456789&quot;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	// url参数信息</span><br><span class="line">	params: &#123;</span><br><span class="line">		id: 100,</span><br><span class="line">		vip: 7</span><br><span class="line">	&#125;,</span><br><span class="line">	// 请求头信息</span><br><span class="line">	headers: &#123;</span><br><span class="line">		name: &quot;Wrysmile&quot;,</span><br><span class="line">		age: 25</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>通用型请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">	// 请求方法</span><br><span class="line">	method: &quot;POST&quot;,</span><br><span class="line">	// url</span><br><span class="line">	url: &quot;http://127.0.0.1:8000/axios-server&quot;,</span><br><span class="line">	// url参数</span><br><span class="line">	params: &#123;</span><br><span class="line">		id: 300,</span><br><span class="line">		vip: 10</span><br><span class="line">	&#125;,</span><br><span class="line">	// 头信息</span><br><span class="line">	headers: &#123;</span><br><span class="line">		a: 100,</span><br><span class="line">		b:200</span><br><span class="line">	&#125;,</span><br><span class="line">	// 请求体参数</span><br><span class="line">	data: &#123;</span><br><span class="line">		username: &quot;wrysmile&quot;,</span><br><span class="line">		password: &quot;123456789&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、fetch操作"><a href="#五、fetch操作" class="headerlink" title="五、fetch操作"></a>五、fetch操作</h1><ul>
<li>fetch 是全局对象中的一个函数，返回的是一个 Promise 对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fetch(&quot;http://localhost:8000/fetch-server&quot;, &#123;</span><br><span class="line">	// 请求方法</span><br><span class="line">	method: &quot;POST&quot;,</span><br><span class="line">	// 请求头</span><br><span class="line">	headers: &#123;</span><br><span class="line">		name: &quot;Wrysmile&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	// 请求体</span><br><span class="line">	body: &quot;username=admin&quot;</span><br><span class="line">&#125;).then(response =&gt; &#123;</span><br><span class="line">	console.log(response);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、跨域"><a href="#六、跨域" class="headerlink" title="六、跨域"></a>六、跨域</h1><h2 id="1-同源策略"><a href="#1-同源策略" class="headerlink" title="1.同源策略"></a>1.同源策略</h2><ul>
<li>最早由 Netscape 公司提出，是浏览器的一种安全策略</li>
<li>该策略要求<strong style="color:red;">协议、域名、端口号</strong>必须完全相同</li>
<li><strong style="color:red;">跨域</strong>：违背同源策略就是跨域</li>
</ul>
<h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h2><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="(1).JSONP"></a>(1).JSONP</h3><ul>
<li>介绍：是一个非官方的跨域解决方案，只支持get请求</li>
<li>原理：利用 <code>&lt;script&gt;</code> 标签的跨域能力来发送请求</li>
<li>原生使用方法：<ul>
<li>动态的创建一个 <code>&lt;script&gt;</code> 标签</li>
<li>设置 <code>&lt;script&gt;</code> 标签的 src 属性</li>
</ul>
</li>
</ul>
<h4 id="原生Demo：检测用户名是否存在"><a href="#原生Demo：检测用户名是否存在" class="headerlink" title="原生Demo：检测用户名是否存在"></a>原生Demo：检测用户名是否存在</h4><ul>
<li><p>页面代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;text&quot; /&gt;</span><br><span class="line">&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	const input = document.querySelector(&quot;input&quot;);</span><br><span class="line">	const p = document.querySelector(&quot;p&quot;);</span><br><span class="line">	// 声明 handle 函数</span><br><span class="line">	function handle(data)&#123;</span><br><span class="line">		// 修改输入框的边框</span><br><span class="line">		input.style.border = &quot;1px solid #f00&quot;</span><br><span class="line">		// 给p元素设置文字</span><br><span class="line">		p.innerHTML = data.msg;</span><br><span class="line">	&#125;</span><br><span class="line">	input.onblur = function ()&#123;</span><br><span class="line">		// 获取用户的输入</span><br><span class="line">		let username = this.value;</span><br><span class="line">		// 向服务器发送请求，检测用户是否存在</span><br><span class="line">		// 1.创建 script 标签</span><br><span class="line">		const script = document.createElement(&quot;script&quot;);</span><br><span class="line">		// 2.设置 script 的src属性</span><br><span class="line">		script.src = &quot;http://127.0.0.1:8000/jsonp-username&quot;;</span><br><span class="line">		// 3.将 script 标签添加到文档中</span><br><span class="line">		document.body.append(script);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>express 服务端代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入express</span><br><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">// 创建应用对象</span><br><span class="line">const app = express();</span><br><span class="line">// 创建路由规则</span><br><span class="line">app.all(&quot;/jsonp-username&quot;, (request,response) =&gt; &#123;</span><br><span class="line">    const data = &#123;</span><br><span class="line">        exist: 1,</span><br><span class="line">        msg: &quot;该用户名已存在&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 将数据转换为字符串</span><br><span class="line">    let str = JSON.stringify(data);</span><br><span class="line">    response.end(`handle($&#123;str&#125;)`);</span><br><span class="line">&#125;)</span><br><span class="line">// 监听端口启动服务</span><br><span class="line">app.listen(8000, () =&gt; &#123;</span><br><span class="line">    console.log(&quot;服务已经启动，8000端口监听中&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>JQuery使用方法：</p>
<ul>
<li>调用 JQuery 的 <code>getJSON()</code> 方法即可</li>
<li>注意该方法的url中需要传 <code>?callback=?</code> 参数，然后在服务端直接获取到该参数的值作为函数即可使用</li>
</ul>
</li>
</ul>
<h4 id="JQuery-Demo：获取用户数据"><a href="#JQuery-Demo：获取用户数据" class="headerlink" title="JQuery Demo：获取用户数据"></a>JQuery Demo：获取用户数据</h4><ul>
<li><p>页面代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;点击发送 jsonp 请求&lt;/button&gt;</span><br><span class="line">&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	$(&quot;button&quot;).eq(0).click(function ()&#123;</span><br><span class="line">		$.getJSON(&quot;http://127.0.0.1:8000/jsonp-jquery?callback=?&quot;, function (data)&#123;</span><br><span class="line">			$(&quot;#result&quot;).html(`</span><br><span class="line">				名称: $&#123;data.name&#125;&lt;br&gt;</span><br><span class="line">				城市: $&#123;data.city&#125;</span><br><span class="line">			`)</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>express 服务端代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入express</span><br><span class="line">const express = require(&quot;express&quot;);</span><br><span class="line">// 创建应用对象</span><br><span class="line">const app = express();</span><br><span class="line">// 创建路由规则</span><br><span class="line">app.all(&quot;/jsonp-jquery&quot;, (request,response) =&gt; &#123;</span><br><span class="line">    const data = &#123;</span><br><span class="line">        name: &quot;Wrysmile&quot;,</span><br><span class="line">        city: [&quot;上海&quot;,&quot;北京&quot;,&quot;广东&quot;]</span><br><span class="line">    &#125;;</span><br><span class="line">    // 将数据转换为字符串</span><br><span class="line">    let str = JSON.stringify(data);</span><br><span class="line">    // 接收callback参数</span><br><span class="line">    let cb = request.query.callback;</span><br><span class="line">    response.end(`$&#123;cb&#125;($&#123;str&#125;)`);</span><br><span class="line">&#125;)</span><br><span class="line">// 监听端口启动服务</span><br><span class="line">app.listen(8000, () =&gt; &#123;</span><br><span class="line">    console.log(&quot;服务已经启动，8000端口监听中&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="(2).CORS"></a>(2).CORS</h3><ul>
<li>介绍：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">CORS</a>（Cross-Origin Resource Sharing）是一个官方的跨域解决方案，支持 get 和 post 请求</li>
<li>特点：不需要在客户端做任何特殊的操作，完全在服务器中进行处理</li>
<li>方法：服务器端设置一个响应头来告诉浏览器请求允许跨域<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.get(&#x27;/jsonp-cors&#x27;, (request,response) =&gt; &#123;</span><br><span class="line">    // 设置响应头，允许跨域</span><br><span class="line">    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &quot;*&quot;)</span><br><span class="line">    // 允许自定义头信息</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">    // 允许设置请求方法</span><br><span class="line">    response.setHeader(&quot;Access-Control-Allow-Method&quot;, &quot;*&quot;);</span><br><span class="line">    // 设置响应</span><br><span class="line">    response.send(&quot;你好&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：MongoDB（尚硅谷）</title>
    <url>/Learn-MongoDB.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 MongoDB 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础内容"><a href="#一、基础内容" class="headerlink" title="一、基础内容"></a>一、基础内容</h1><h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h2><h3 id="1-关系型数据库"><a href="#1-关系型数据库" class="headerlink" title="(1).关系型数据库"></a>(1).关系型数据库</h3><ul>
<li>关系型数据库（RDBMS）中全都是表</li>
<li>例如：MySQL、Oracle、DB2、SQL Server</li>
</ul>
<h3 id="2-非关系型数据库"><a href="#2-非关系型数据库" class="headerlink" title="(2).非关系型数据库"></a>(2).非关系型数据库</h3><ul>
<li>非关系型数据库（NoSQL、Not Only SQL）分为好多种类，主要有：</li>
<li>键值对数据库：Redis</li>
<li>文档数据库：MongoDB</li>
</ul>
<h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h2><ul>
<li>MongoDB 的数据模型是面向文档的，即类似于 JSON 的结构（又名BSON）</li>
<li>主要概念如下：<ul>
<li>数据库（database）：一个仓库，可以存放集合</li>
<li>集合（collection）：类似于数组，可以存放文档</li>
<li>文档（document）：文档数据库中的最小单位，存储和操作的内容都是文档</li>
</ul>
</li>
</ul>
<h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3.安装"></a>3.安装</h2><ul>
<li>可以去<a href="https://www.mongodb.com/">官网</a>下载最新版，也可以去<a href="https://www.mongodb.org/dl/win32/">这里</a>下载，下载社区版即可（3.2版本之后不支持32位系统，且最新版安装无需配置 data 目录，会自动生成）</li>
<li>配置环境变量：<ul>
<li>打开 MongoDB 安装目录下的 <code>bin</code> 文件夹，将该路径添加到系统的环境变量中</li>
</ul>
</li>
<li>打开 cmd 窗口，直接输入 <code>mongo</code> 命令即可连接到 MongoDB 数据库</li>
<li>可通过以下命令更改默认数据库位置和端口号<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongod --dbpath 数据库路径 --port 端口号		// 端口号一般介于1000-65535之间</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-指令"><a href="#4-指令" class="headerlink" title="4.指令"></a>4.指令</h2><h3 id="1-基本"><a href="#1-基本" class="headerlink" title="(1).基本"></a>(1).基本</h3><ul>
<li><code>show dbs/datebases</code>：显示当前的所有数据库</li>
<li><code>use 数据库名</code>：进入到指定的数据库中</li>
<li><code>db</code>：显示当前所处的数据库</li>
<li><code>show collections</code>：显示数据库中所有集合</li>
</ul>
<h3 id="2-CRUD"><a href="#2-CRUD" class="headerlink" title="(2).CRUD"></a>(2).CRUD</h3><ul>
<li>插入：<ul>
<li><code>db.&lt;集合名&gt;.insert(doc)</code>：向集合中插入文档（可一个可多个）</li>
<li><code>db.&lt;集合名&gt;.insertOne(doc)</code>：向集合中插入一个文档</li>
<li><code>db.&lt;集合名&gt;.insertMany(doc)</code>：向集合中插入多个文档</li>
</ul>
</li>
<li>查询：<ul>
<li><code>db.&lt;集合名&gt;.find()</code>：查询集合中的所有文档，返回的是一个数组</li>
<li><code>db.&lt;集合名&gt;.find().count()</code>：查询集合中所有文档的数量</li>
<li><code>db.&lt;集合名&gt;.find(&#123;属性:值&#125;)</code>：查询集合中属性是指定值的文档，若需要查询指定的属性，需要使用“查询操作符”来完成查询<ul>
<li><code>$gt</code>：大于指定属性的值</li>
<li><code>$lt</code>：小雨指定属性的值</li>
</ul>
</li>
<li><code>db.&lt;集合名&gt;.findOne()</code>：查询集合中符合条件的第一个文档，返回的是一个对象</li>
<li><code>db.&lt;集合名&gt;.find().limit(10)</code>：设置显示数据的上限</li>
<li><code>db.&lt;集合名&gt;.find().skip(10).limit(10)</code>：跳过前10条数据<ul>
<li>skip((页码 -1 ) * 每页显示的条数)</li>
<li>limit(每页显示的条数)</li>
</ul>
</li>
</ul>
</li>
<li>修改：<ul>
<li><code>db.&lt;集合名&gt;.update(&#123;查询条件&#125;,&#123;新对象&#125;)</code>：默认情况会使用新对象覆盖旧对象，若需要修改指定的属性，需要使用“修改操作符”来完成修改<ul>
<li><code>$set</code>：修改文档中的指定属性</li>
<li><code>$unset</code>：删除文档中的指定属性</li>
<li><code>$push/$addToSet</code>：向数组中添加一个新的元素（后者如果数组中已存在该元素，则不会添加）</li>
<li><code>$inc</code>：进行自增操作</li>
</ul>
</li>
<li><code>db.&lt;集合名&gt;.updateMany()</code>：同时修改多个符合条件的文档</li>
<li><code>db.&lt;集合名&gt;.updateOne()</code>：修改一个符合条件的文档</li>
<li><code>db.&lt;集合名&gt;.replaceOne()</code>：替换一个文档</li>
</ul>
</li>
<li>删除：<ul>
<li><code>db.&lt;集合名&gt;.remove()</code>：删除符合条件的所有文档（默认情况下会删除多个，但第二个参数传true时只会删除一个）</li>
<li><code>db.&lt;集合名&gt;.remove(&#123;&#125;)</code>：删除集合中的所有文档</li>
<li><code>db.&lt;集合名&gt;.deleteOne()</code>：删除符合条件的一个文档</li>
<li><code>db.&lt;集合名&gt;.deleteMany()</code>：删除符合条件的多个文档</li>
<li><code>db.&lt;集合名&gt;.drop()</code>：删除集合</li>
<li><code>db.dropDatabase()</code>：删除数据库</li>
<li><strong style="color:red;">!注意：一般数据库中的数据都不会删除，一般会在数据中添加一个字段，来表示数据是否被删除</strong></li>
</ul>
</li>
</ul>
<h2 id="5-注意"><a href="#5-注意" class="headerlink" title="5.注意"></a>5.注意</h2><ul>
<li>在 MongoDB 中当一个文档的属性值是一个文档时，这个文档为内嵌文档</li>
<li>在 MongoDB 中支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档则可通过 <code>.</code> 的形式来匹配，<strong style="color:red;">但此时的属性名必须使用引号</strong></li>
</ul>
<h1 id="二、进阶内容"><a href="#二、进阶内容" class="headerlink" title="二、进阶内容"></a>二、进阶内容</h1><h2 id="1-文档之间的联系"><a href="#1-文档之间的联系" class="headerlink" title="1.文档之间的联系"></a>1.文档之间的联系</h2><ul>
<li>一对一<ul>
<li>例子：夫妻</li>
<li>可以通过内嵌文档的形式来体现出一对一的关系</li>
</ul>
</li>
<li>一对多<ul>
<li>例子：父母 - 孩子、用户 - 订单、文章 - 评论、</li>
<li>可以通过内嵌文档来映射一对多的关系</li>
</ul>
</li>
<li>多对多<ul>
<li>例子：分类 - 商品、老师 - 学生</li>
</ul>
</li>
</ul>
<h2 id="2-排序和投影"><a href="#2-排序和投影" class="headerlink" title="2.排序和投影"></a>2.排序和投影</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="(1).排序"></a>(1).排序</h3><ul>
<li>在使用 <code>find()</code> 查询文档时，默认是按照 <code>_id</code> 的值进行升序排序的</li>
<li>我们可以使用 <code>sort()</code> 来指定文档的排序规则，且需要传递一个对象来指定排序规则<ul>
<li>1 表示升序</li>
<li>-1 表示降序</li>
</ul>
</li>
<li>当在 <code>sort()</code> 中输入第二个参数时，表示先以第一个参数排序，当第一个参数相等时按第二个参数排序</li>
</ul>
<h3 id="2-投影"><a href="#2-投影" class="headerlink" title="(2).投影"></a>(2).投影</h3><ul>
<li>当我们只想要获取某个文档中的某个字段时可以使用 <strong>投影</strong></li>
<li>在查询时，可以在第二个参数的位置来设置查询结果的投影<ul>
<li>1 表示显示</li>
<li>0 表示不显示</li>
<li>默认显示 <code>_id</code> </li>
</ul>
</li>
</ul>
<h2 id="3-Mongoose"><a href="#3-Mongoose" class="headerlink" title="3.Mongoose"></a>3.Mongoose</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="(1).简介"></a>(1).简介</h3><ul>
<li>官网：点击<a href="https://mongoosejs.com/">这里</a></li>
<li>Mongoose 是一个对象文档模型（ODM）库，对 Node 原生的 MongoDB 模块进一步的优化封装并提供了更多的功能</li>
<li>Mongoose 的好处：<ul>
<li>可以为文档创建一个模式结构（Schema）</li>
<li>可以对模型中的对象/文档进行验证</li>
<li>数据可以通过类型转换转换为对象模型</li>
<li>可以使用中间件来应用业务逻辑挂钩</li>
<li>比 Node 原生的 MongoDB 驱动更容易</li>
</ul>
</li>
<li>Mongoose 新对象：<ul>
<li>Schema（模式对象）：约束数据库中的文档结构</li>
<li>Model：作为集合中的所有文档的标识，相当于数据库中的集合 Collection</li>
<li>Document：表示集合中的具体文档</li>
</ul>
</li>
</ul>
<h3 id="2-连接数据库"><a href="#2-连接数据库" class="headerlink" title="(2).连接数据库"></a>(2).连接数据库</h3><ul>
<li><p>在当前项目路径的终端中进行安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i mongoose --save</span><br></pre></td></tr></table></figure></li>
<li><p>在当前项目中引入 Mongoose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mongoose = require(&quot;mongoose&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>连接 MongoDB 数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongoose.connect(&quot;mongodb://数据库的ip地址:端口号/数据库名&quot;, &#123;useNewUrlParser: true, useUnifiedTopology: true&#125;);</span><br><span class="line">mongoose.connect(&quot;mongodb://localhost:27017/mongoose_test&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>断开 MongoDB 数据库（一般不调用，连接一次后除非项目停止、服务器关闭，否则连接一般不会断开）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongoose.disconnect()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="！监听数据库的连接状态"><a href="#！监听数据库的连接状态" class="headerlink" title="！监听数据库的连接状态"></a>！监听数据库的连接状态</h4><ul>
<li><p>在 Mongoose 对象中，有一个属性叫做 connection，该对象表示的就是数据库连接，通过监视该对象的状态就可以监听数据库的连接与断开</p>
</li>
<li><p>数据库连接成功的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongoose.connection.once(&quot;open&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;数据库连接成功&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>数据库连接断开的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mongoose.connection.once(&quot;close&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;数据库连接断开&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-创建Schema"><a href="#3-创建Schema" class="headerlink" title="(3).创建Schema"></a>(3).创建Schema</h3><ul>
<li><p>通过创建 Schema 对象来进行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Schema = mongoose.Schema;</span><br><span class="line">const stuSchema = new Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: Number,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &quot;male&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>如果想要设置默认值，可以通过以下方式进行设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gender: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;male&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-创建Model"><a href="#4-创建Model" class="headerlink" title="(4).创建Model"></a>(4).创建Model</h3><ul>
<li>可通过以下命令来创建 Model，参数一为要映射的集合名，参数二为创建好的 Schema 对象</li>
<li>mongoose 会自动将集合名变为复数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const StuModel = mongoose.model(&quot;students&quot;, stuSchema);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-Module的方法"><a href="#5-Module的方法" class="headerlink" title="(5).Module的方法"></a>(5).Module的方法</h3><h4 id="1-插入文档"><a href="#1-插入文档" class="headerlink" title="1).插入文档"></a>1).插入文档</h4><ul>
<li>使用以下命令来插入文档，参数一为需要插入的文档内容，参数二为回调函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StuModel.create(&#123;</span><br><span class="line">    name: &quot;孙悟空&quot;,</span><br><span class="line">    age: 18</span><br><span class="line">&#125;, function (err)&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(&quot;插入成功！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-查询文档"><a href="#2-查询文档" class="headerlink" title="2).查询文档"></a>2).查询文档</h4><ul>
<li><code>Module.find()</code>：查询所有符合条件的文档</li>
<li><code>Module.findOne()</code>：查询符合条件的第一个文档</li>
<li><code>Module.findById()</code>：根据文档id属性查询文档</li>
<li>参数有：<ul>
<li>condition：查询的条件（对象）</li>
<li>projection：投影（可以使用传统方式，也可以传入一个对象 <code>&quot;name age -_id&quot;</code> 来投影）</li>
<li>options：查询选项（skip、limit）</li>
<li>callback：回调函数，必传否则不会查询</li>
</ul>
</li>
</ul>
<h4 id="3-修改文档"><a href="#3-修改文档" class="headerlink" title="3).修改文档"></a>3).修改文档</h4><ul>
<li><code>Module.update()</code></li>
<li><code>Module.updateMany()</code></li>
<li><code>Module.updateOne()</code></li>
<li><code>Module.replaceOne()</code></li>
<li>参数有：<ul>
<li>condition：查询条件</li>
<li>doc：修改后的对象</li>
<li>options：配置参数</li>
<li>callback：回调函数</li>
</ul>
</li>
</ul>
<h4 id="4-删除文档"><a href="#4-删除文档" class="headerlink" title="4).删除文档"></a>4).删除文档</h4><ul>
<li><code>Module.remove()</code></li>
<li><code>Module.deleteOne()</code></li>
<li><code>Module.deleteMany()</code></li>
<li>参数有：<ul>
<li>conditions：查询条件</li>
<li>callback：回调函数</li>
</ul>
</li>
</ul>
<h4 id="5-统计文档"><a href="#5-统计文档" class="headerlink" title="5).统计文档"></a>5).统计文档</h4><ul>
<li><code>Module.count(conditions, callback)</code>：统计文档的数量</li>
</ul>
<h3 id="6-Document的方法"><a href="#6-Document的方法" class="headerlink" title="(6).Document的方法"></a>(6).Document的方法</h3><ul>
<li>Document 是 Module 的实例，和集合中的文档一一对应</li>
<li><code>document.save()</code>：保存到数据库</li>
<li><code>document.update()</code>：修改对象</li>
<li><code>document.remove()</code>：删除对象</li>
<li><code>document.get()</code>：获取文档中的指定属性值</li>
<li><code>document.set()</code>：设置文档中的指定属性值</li>
<li><code>document.id()</code>：获取文档的 _id 属性值</li>
<li><code>document.toJSON()</code>：转换为一个 JSON 对象</li>
<li><code>document.toObject()</code>：转换为一个 Object 对象，转换之后所有的 Document 对象的方法或属性都不能使用</li>
</ul>
<h3 id="7-模块化"><a href="#7-模块化" class="headerlink" title="(7).模块化"></a>(7).模块化</h3><ul>
<li><p>把连接数据库的代码封装到一个工具文件中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;-- conn_mongodb.js --&gt;</span><br><span class="line">const mongoose = require(&quot;mongoose&quot;);</span><br><span class="line">mongoose.connect(&quot;mongodb://127.0.0.1:27017/mongoose_test&quot;);</span><br><span class="line">mongoose.connection.once(&quot;open&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;数据库连接成功&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">mongoose.connection.once(&quot;close&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;数据库连接关闭&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>把创建 Schema 和 Model 的代码封装到专门存放Model对象的文件夹中，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;-- student.js --&gt;</span><br><span class="line">const mongoose = require(&quot;mongoose&quot;)</span><br><span class="line">const Schema = mongoose.Schema;</span><br><span class="line">const stuSchema = new Schema(&#123;</span><br><span class="line">    name: String,</span><br><span class="line">    age: Number,</span><br><span class="line">    gender: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        default: &quot;male&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const StuModel = mongoose.model(&quot;student&quot;, stuSchema);</span><br><span class="line">module.exports = StuModel;</span><br></pre></td></tr></table></figure></li>
<li><p>最后在所需的文件中直接引入这两个内容即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;-- model.js --&gt;</span><br><span class="line">require(&quot;./tools/conn_mongodb&quot;);</span><br><span class="line">const student = require(&quot;./modules/student&quot;);</span><br><span class="line">student.find(&#123;&#125;, function (err, docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="三、案例分析"><a href="#三、案例分析" class="headerlink" title="三、案例分析"></a>三、案例分析</h1><h2 id="1-向数据库中添加20000条数据"><a href="#1-向数据库中添加20000条数据" class="headerlink" title="1.向数据库中添加20000条数据"></a>1.向数据库中添加20000条数据</h2><h3 id="1-普通方法"><a href="#1-普通方法" class="headerlink" title="(1).普通方法"></a>(1).普通方法</h3><ul>
<li>将数据库插入操作放入循环中，<strong style="color:red;">性能极差，耗时长</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(let i = 1; i &lt;= 20000; i++)&#123;</span><br><span class="line">	db.numbers.insert(&#123;num:i&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-优化方法"><a href="#2-优化方法" class="headerlink" title="(2).优化方法"></a>(2).优化方法</h3><ul>
<li>先循环将20000条数据添加到数组中，再将这个数组插入到数据库的集合中，<strong style="color:red;">性能好，耗时短，推荐</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [];</span><br><span class="line">for(let i = 1; i &lt;= 20000; i++)&#123;</span><br><span class="line">	arr.push(&#123;num : i&#125;)</span><br><span class="line">&#125;</span><br><span class="line">db.numbers.insert(arr);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：NodeJS（尚硅谷）</title>
    <url>/Learn-NodeJS.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 Node.js 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础内容"><a href="#一、基础内容" class="headerlink" title="一、基础内容"></a>一、基础内容</h1><h2 id="1-命令行"><a href="#1-命令行" class="headerlink" title="1.命令行"></a>1.命令行</h2><h3 id="1-命令"><a href="#1-命令" class="headerlink" title="(1).命令"></a>(1).命令</h3><ul>
<li><code>dir</code>：列出当前目录下的所有文件</li>
<li><code>cd 目录名</code>：进入指定目录</li>
<li><code>md 目录名</code>：新建文件夹</li>
<li><code>rd 目录名</code>：删除文件夹</li>
<li><code>a.txt</code>：直接打开当前目录下的文件</li>
</ul>
<h3 id="2-目录"><a href="#2-目录" class="headerlink" title="(2).目录"></a>(2).目录</h3><ul>
<li><code>.</code>：当前目录</li>
<li><code>..</code>：上一级目录</li>
</ul>
<h3 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="(3).环境变量"></a>(3).环境变量</h3><ul>
<li>当我们在命令行窗口打开一个文件或调用一个程序时</li>
<li>系统会首先在当前目录下寻找文件程序<ul>
<li>如果找到了则直接打开</li>
<li>如果没有找到则会依次到环境变量 path 的路径中寻找<ul>
<li>如果找到了则会直接执行</li>
<li>如果没有找到则报错</li>
</ul>
</li>
</ul>
</li>
<li>可以将一些常用的文件或程序的路径添加到 path 下，这样我们就可以在任意位置来访问这些文件了</li>
</ul>
<h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2.简介"></a>2.简介</h2><ul>
<li>中文网站：<a href="http://nodejs.cn/">点击这里</a></li>
<li>Node.js 是一个能够在服务器端运行 JavaScript 的开放源代码、跨平台 JavaScript 运行环境</li>
<li>Node 采用 Google 开发的 V8 引擎运行 js 代码，使用<strong style="color:red;">事件驱动、非阻塞和异步I/O模型</strong>等技术来提高性能，可优化应用程序的传输量和规模</li>
<li>Node 大部分基本模块都用 JavaScript 编写。在 Node 出现之前，JS 通常作为客户端程序设计语言使用，以 JS 写出的程序常在用户的浏览器上运行</li>
<li>Node 是事件驱动的，开发者可以在不使用线程的情况下开发出一个能够承载高并发的服务器。其他服务器端语言难以开发高并发应用，而且即使开发出来，性能也不尽人意</li>
<li>Node.js 允许通过 JS 和一系列模块来编写服务器端应用和网络相关的应用<ul>
<li>核心模块包括文件系统 I/O、网络（HTTP、TCP、UDP、DNS、YLS/SSL等）、二进制数据流、加密算法、数据流等等</li>
<li>Node 模块的 API 形式简单，降低了编程的复杂度</li>
</ul>
</li>
<li>Node.js 之父：<strong>瑞安·达尔（Ryan Dahl）</strong></li>
</ul>
<h2 id="3-图示"><a href="#3-图示" class="headerlink" title="3.图示"></a>3.图示</h2><ul>
<li>一个网页需要经过如下几个步骤：<ul>
<li>用户访问网页并发送请求给网站服务器</li>
<li>服务器分出线程来处理该条请求，如果需要进行I/O操作时，会自动分出一条I/O线程</li>
<li>处理完I/O操作后，服务器将网页响应返回给用户</li>
</ul>
</li>
<li>在如上的步骤中，第一和第三项可以做到优化，唯独无法优化的就是I/O请求</li>
<li>所以为了防止服务器多条进程造成阻塞现象，服务器端只能是单进程，这样才不会形成阻塞</li>
<li>示例图如下：<br><img src="https://z3.ax1x.com/2021/04/11/c0PjAg.png" alt="njs01.png"></li>
</ul>
<h2 id="4-历史"><a href="#4-历史" class="headerlink" title="4.历史"></a>4.历史</h2><ul>
<li>Node.js 的历史发展如下图所示：<br><img src="https://z3.ax1x.com/2021/04/11/c0FAMt.png" alt="njs02.png"></li>
</ul>
<h2 id="5-用途"><a href="#5-用途" class="headerlink" title="5.用途"></a>5.用途</h2><ul>
<li>Web 服务 API，比如 REST</li>
<li>实时多人游戏</li>
<li>后端的 Web 服务，例如跨域、服务器端的请求</li>
<li>基于 Web 的应用</li>
<li>多客户端的通信，如即时通信</li>
</ul>
<h2 id="6-更新"><a href="#6-更新" class="headerlink" title="6.更新"></a>6.更新</h2><h3 id="1-Windows下"><a href="#1-Windows下" class="headerlink" title="(1).Windows下"></a>(1).Windows下</h3><ul>
<li>去官网下载最新版本的 <code>.msi</code> 文件并安装，就完成了 Node 版本更新</li>
<li>npm 是随 Node.js 一起发布的包管理工具，默认采用的并不一定是最新版本，如需升级在命令行使用以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -g install npm ( 官方最新稳定版 )</span><br><span class="line">npm -g install npm@6.1.0 ( 自己需要的版本 )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-Linux下"><a href="#2-Linux下" class="headerlink" title="(2).Linux下"></a>(2).Linux下</h3><ul>
<li><p>先查看本机 Node.js 版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure></li>
<li><p>清除 Node.js 的 cache</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm cache clean -f</span><br></pre></td></tr></table></figure></li>
<li><p>安装 Node 版本管理工具，工具的名字有点奇葩，叫做 n</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install -g n</span><br></pre></td></tr></table></figure></li>
<li><p>安装最新版本的 Node.js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo n stable</span><br></pre></td></tr></table></figure></li>
<li><p>再次查看本机的 Node.js 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure></li>
<li><p>更新 npm 到最新版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install -g npm</span><br></pre></td></tr></table></figure></li>
<li><p>验证版本是否升级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-执行js"><a href="#7-执行js" class="headerlink" title="7.执行js"></a>7.执行js</h2><ul>
<li>在命令行中进入js文件所在目录</li>
<li>然后使用 <code>node hello.js</code> 命令来执行该js文件</li>
</ul>
<h1 id="二、CommonJS规范"><a href="#二、CommonJS规范" class="headerlink" title="二、CommonJS规范"></a>二、CommonJS规范</h1><ul>
<li>目的：弥补当前 JavaScript 没有标准的缺陷</li>
<li>愿景：希望JS能够在任何地方运行</li>
<li>定义：模块引用、模块定义、模块标识</li>
</ul>
<h2 id="1-模块标识"><a href="#1-模块标识" class="headerlink" title="1.模块标识"></a>1.模块标识</h2><ul>
<li>引入外部模块时，使用即为模块标识，可以通过模块标识来找到指定的模块</li>
<li>模块分为两大类：<ul>
<li>核心模块：由Node引擎提供的模块，标识即为模块的名字</li>
<li>文件模块：由用户自己创建的模块，标识即为文件的路径（绝对、相对路径）</li>
</ul>
</li>
</ul>
<h2 id="2-模块化"><a href="#2-模块化" class="headerlink" title="2.模块化"></a>2.模块化</h2><ul>
<li>在Node中，一个JS文件就是一个模块</li>
<li>在Node中，每一个JS文件中的JS代码都是独立运行在一个函数中的，而不是全局作用域</li>
</ul>
<h3 id="1-引入模块"><a href="#1-引入模块" class="headerlink" title="(1).引入模块"></a>(1).引入模块</h3><ul>
<li><p>在Node中，通过 <code>require()</code> 函数来引入外部的模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let md = require(&quot;./module&quot;);</span><br><span class="line">或</span><br><span class="line">let md = require(&quot;./module.js&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>路径如果使用相对路径，必须以 <code>./</code> 或 <code>../</code> 来开头</p>
</li>
<li><p>使用 <code>require()</code> 引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块</p>
</li>
</ul>
<h3 id="2-暴露变量或方法"><a href="#2-暴露变量或方法" class="headerlink" title="(2).暴露变量或方法"></a>(2).暴露变量或方法</h3><ul>
<li>在Node中，通过 <code>exports</code> 来向外部暴露变量和方法，只需要将需要暴露给外部的变量或方法设置为 <code>exports</code> 的属性即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exports.x = &quot;暴露的x&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-调用变量或方法"><a href="#3-调用变量或方法" class="headerlink" title="(3).调用变量或方法"></a>(3).调用变量或方法</h3><ul>
<li>通过引入模块时定义的变量来调用暴露的变量或方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">md.x;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-全局对象"><a href="#3-全局对象" class="headerlink" title="3.全局对象"></a>3.全局对象</h2><ul>
<li><p>在 Node 中有一个全局对象 global，它的作用和网页中 Window 类似</p>
<ul>
<li>在全局中创建的变量都会作为 global 的属性保存</li>
<li>在全局中创建的函数都会作为 global 的方法保存</li>
</ul>
</li>
<li><p>当 Node 在执行模块中的代码时，它会在代码的外部添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">	模块中的代码</span><br><span class="line">	console.log(arguments.callee + &quot;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实际上模块中的代码都是包装在一个函数中执行的并且在函数执行时，同时传递进了如下5个实参：</p>
<ul>
<li>exports：用来将变量或函数暴露到外部</li>
<li>require：函数，用来引入外部的模块</li>
<li>module：代表的是当前模块本身，exports就是它的属性</li>
<li>__filename：当前模块的完 整路径</li>
<li>__dirname：当前模块所在文件夹的完整路径</li>
</ul>
</li>
</ul>
<h3 id="exports与module-exports的区别"><a href="#exports与module-exports的区别" class="headerlink" title="exports与module.exports的区别"></a>exports与module.exports的区别</h3><ul>
<li><p>前者只能通过 <code>exports.xxx</code> 的方式来向外暴露内部变量，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exports.xxx = xxx;</span><br></pre></td></tr></table></figure></li>
<li><p>后者既可以通过 <code>module.exports.xxx</code> 的方式，也可以通过直接赋值来向外暴露内部变量，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports.xxx = xxx;</span><br><span class="line">module.exports = &#123;&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>赋值的区分方法：前者是直接修改了变量，而后者是修改了变量的属性（通过画引用数据类型的内存空间图来理解）</p>
</li>
</ul>
<h2 id="4-包"><a href="#4-包" class="headerlink" title="4.包"></a>4.包</h2><ul>
<li>规范允许我们将一组相关的模块组合到一起，形成一组完整的工具</li>
<li><strong>包规范</strong>由<strong style="color:red;">包结构</strong>和<strong style="color:red;">包描述文件</strong>两个部分组成<ul>
<li>包结构：用于组织包中的各种文件</li>
<li>包描述文件：描述包的相关信息，以供外部读取分析</li>
</ul>
</li>
</ul>
<h3 id="1-包结构"><a href="#1-包结构" class="headerlink" title="(1).包结构"></a>(1).包结构</h3><ul>
<li>包实际上就是一个压缩文件，解压以后还原为目录，包含如下：<ul>
<li><code>package.json</code>：描述文件<strong style="color:red;">（必须的）</strong></li>
<li><code>bin</code>：目录，存放可执行二进制文件</li>
<li><code>lib</code>：目录，存放js代码</li>
<li><code>doc</code>：目录，存放文档</li>
<li><code>test</code>：目录，存放单元测试文件</li>
</ul>
</li>
</ul>
<h3 id="2-包描述文件"><a href="#2-包描述文件" class="headerlink" title="(2).包描述文件"></a>(2).包描述文件</h3><ul>
<li>用于表达非代码相关的信息，是一个JSON格式的文件，位于包的根目录下，是包的重要组成部分</li>
<li><code>package.json</code> 主要含有：name、description、version、keywords、maintainers、contributors、bugs、licenses、repositories、dependencies 等</li>
<li><strong style="color:red;">注意：任何JSON文件中都不可以写注释</strong></li>
</ul>
<h3 id="3-NPM"><a href="#3-NPM" class="headerlink" title="(3).NPM"></a>(3).NPM</h3><ul>
<li>npm 可实现第三方模块的发布、安装和依赖等</li>
<li>npm 命令：<ul>
<li><code>npm -v</code>：查看 npm 的版本</li>
<li><code>npm version</code>：查看所有模块的版本</li>
<li><code>npm init -y</code>：初始化 npm 且跳过手动设置（如需手动设置需去除-y）</li>
<li><code>npm search 包名</code>：搜索包</li>
<li><code>npm install/i 包名</code>：安装包</li>
<li><code>npm remove/r 包名</code>：删除包</li>
<li><code>npm install 包名 --save</code>：安装包并添加到依赖中</li>
<li><code>npm install</code>：下载当前项目所依赖的包</li>
<li><code>npm install 包名 -g</code>：全局安装包（一般都是一些工具）</li>
</ul>
</li>
<li>在安装包的时候，可能发现文件夹中并没有新增文件夹，可能是因为缺少了 <code>package.json</code> 文件，可通过初始化命令添加</li>
</ul>
<h3 id="4-CNPM"><a href="#4-CNPM" class="headerlink" title="(4).CNPM"></a>(4).CNPM</h3><ul>
<li>即为淘宝提供的 npm 镜像<a href="http://npm.taobao.org/">网站</a></li>
<li>作用：解决 npm 下载缓慢问题</li>
</ul>
<h3 id="5-寻找包流程"><a href="#5-寻找包流程" class="headerlink" title="(5).寻找包流程"></a>(5).寻找包流程</h3><ul>
<li>node 在使用模块名字来引入模块时，会首先在当前目录的 <code>node_modules</code> 中寻找是否含有该模块<ul>
<li>如果有则直接使用，如果没有则去上一层目录的 <code>node_modules</code> 中寻找</li>
<li>如果有则直接使用，如果没有则再去上一层目录的 <code>node_modules</code> 中寻找，直到找到为止</li>
<li>如果找到磁盘的根目录依然没有，则报错</li>
</ul>
</li>
</ul>
<h1 id="三、Buffer（缓冲区）"><a href="#三、Buffer（缓冲区）" class="headerlink" title="三、Buffer（缓冲区）"></a>三、Buffer（缓冲区）</h1><ul>
<li>简介：从结构上看 Buffer 非常像一个数组，其元素为16进制的两位数，每个元素表示内存中的一个字节，因此可以直接通过 Buffer 来创建内存中的空间<ul>
<li>每个元素的范围是从 00 - ff 的</li>
</ul>
</li>
<li>作用：专门用来<strong style="color:red;">存储二进制数据</strong>（区别于数组）</li>
</ul>
<h2 id="1-length的区别"><a href="#1-length的区别" class="headerlink" title="1.length的区别"></a>1.length的区别</h2><ul>
<li><code>buf.length</code>：计算的是占用内存的大小</li>
<li><code>str.length</code>：计算的是字符串的长度</li>
<li>区别：两个有时会相同有时不同，不同是因为一个汉字占内存空间中的3个字节，而长度只有1</li>
</ul>
<h2 id="2-相关方法"><a href="#2-相关方法" class="headerlink" title="2.相关方法"></a>2.相关方法</h2><ul>
<li><p><code>Buffer.from(&quot;字符串&quot;)</code>：将一个字符串转换为 buffer</p>
</li>
<li><p><code>Buffer.alloc(size)</code>：创建一个指定大小的 buffer</p>
</li>
<li><p><code>Buffer.allocUnsafe(size)</code>：创建一个指定大小的 buffer，但是 buffer 中可能含有敏感数据（会残留当前内存区之前的数据）</p>
</li>
<li><p><code>buf[2]</code>：操作buf对象中的第3个元素，<strong style="color:red;">若数字在控制台或页面中输出一定是十进制</strong></p>
<ul>
<li>可使用 toString() 方法来转换显示的进制<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buf2[1].toString(2);	// 转换为二进制显示</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>buf.toString()</code>：将缓冲区中的数据转换为字符串</p>
</li>
</ul>
<h1 id="四、fs（文件系统）"><a href="#四、fs（文件系统）" class="headerlink" title="四、fs（文件系统）"></a>四、fs（文件系统）</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li>文件系统（File System）是通过 Node 中的 <code>fs</code> 模块来操作系统中的文件</li>
<li>该模块提供了一些标准文件访问 API 来打开、读取、写入文件，以及与其交互</li>
<li>该模块中的所有的操作都有<strong style="color:red;">同步</strong>和<strong style="color:red;">异步</strong>两种形式<ul>
<li>同步：会阻塞程序的执行（带Sync）</li>
<li>异步：不会阻塞程序的执行，通过回调函数将结果返回（不带Sync）</li>
</ul>
</li>
<li>该模块是核心模块，直接引入无需下载：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fs = require(&quot;fs&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-文件写入"><a href="#2-文件写入" class="headerlink" title="2.文件写入"></a>2.文件写入</h2><h3 id="1-普通写入"><a href="#1-普通写入" class="headerlink" title="(1).普通写入"></a>(1).普通写入</h3><h4 id="a-同步使用"><a href="#a-同步使用" class="headerlink" title="a).同步使用"></a>a).同步使用</h4><ul>
<li><p>使用 <code>fs.openSync()</code> 来<strong style="color:red;">打开文件</strong>（该方法会返回一个文件的描述符作为结果，可以通过该描述符来对文件进行各种操作），参数为：</p>
<ul>
<li>path：文件路径</li>
<li>flags：操作的类型（w，r）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let fd = fs.openSync(&quot;./file/test1.txt&quot;, &quot;w&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用 <code>fs.writeSync()</code> 来<strong style="color:red;">写入文件</strong>，参数为：</p>
<ul>
<li>fd：文件描述符</li>
<li>string：要写入的内容</li>
<li>position：写入的起始位置<strong style="color:red;">（可选）</strong></li>
<li>encoding：写入的编码，默认为 utf-8<strong style="color:red;">（可选）</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.writeSync(fd, &quot;测试文件的第一行文字&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用 <code>fs.closeSync()</code> 来<strong style="color:red;">关闭文件</strong>，参数为：</p>
<ul>
<li>fd：文件描述符<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.closeSync(fd);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="b-异步使用"><a href="#b-异步使用" class="headerlink" title="b).异步使用"></a>b).异步使用</h4><ul>
<li>使用异步 API 时，只需要在同步的基础上增加回调函数即可，回调函数需要通过参数来返回相应的值，参数通常有：<ul>
<li>err：错误对象，若没有错误即为 null</li>
<li>fd：文件描述符</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 打开文件</span><br><span class="line">fs.open(&quot;./file/test2.txt&quot;, &quot;w&quot;, function (err, fd)&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        // 写入内容</span><br><span class="line">        fs.write(fd, &quot;异步操作的第一行文字&quot;, function (err)&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                console.log(&quot;成功添加内容&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 关闭文件</span><br><span class="line">            fs.close(fd, function (err)&#123;</span><br><span class="line">                console.log(err);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-简单写入"><a href="#2-简单写入" class="headerlink" title="(2).简单写入"></a>(2).简单写入</h3><h4 id="a-同步使用-1"><a href="#a-同步使用-1" class="headerlink" title="a).同步使用"></a>a).同步使用</h4><ul>
<li><p>使用 <code>fs.writeFileSync()</code> 来写入，参数为：</p>
<ul>
<li><p>path：文件路径</p>
</li>
<li><p>data：要写入的内容</p>
</li>
<li><p>options：<strong style="color:red;">可选</strong>，可以对写入进行一些设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.writeFileSync(&quot;./file/test4.txt&quot;, &quot;通过简单文件同步写入的内容&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="b-异步使用-1"><a href="#b-异步使用-1" class="headerlink" title="b).异步使用"></a>b).异步使用</h4><ul>
<li>使用 <code>fs.writeFile()</code> 来写入，参数比同步多一个回调函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.writeFile(&quot;./file/test3.txt&quot;, &quot;通过简单文件异步写入的内容&quot;, function (err)&#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(&quot;写入成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-flag状态"><a href="#c-flag状态" class="headerlink" title="c).flag状态"></a>c).flag状态</h4><ul>
<li>打开文件的状态如下图：<br><img src="https://z3.ax1x.com/2021/06/25/R3aDeI.png" alt="njs03.png"></li>
</ul>
<h3 id="3-流式写入"><a href="#3-流式写入" class="headerlink" title="(3).流式写入"></a>(3).流式写入</h3><blockquote>
<p>以上两种写入方法都不适合大文件的写入，性能较差，容易导致内存溢出，因此推荐使用流式写入方法</p>
</blockquote>
<ul>
<li><p>使用 <code>fs.createWriteStream()</code> 来创建一个可写流，参数为：</p>
<ul>
<li>path：文件路径</li>
<li>options：配置的参数，<strong style="color:red;">可选</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let ws = fs.createWriteStream(&quot;./file/test5.txt&quot;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>使用 <code>ws.write()</code> 来向文件中输入内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ws.write(&quot;第一次写入&quot;);</span><br><span class="line">ws.write(&quot;第二次写入&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>ws.close()/ws.end()</code> 来关闭该可写流（前者在低版本Node中会出现一些错误）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ws.close();</span><br><span class="line">ws.end();</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>ws.once()</code> 可以为对象绑定一个一次性的事件来监听可写流的关闭与否：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ws.once(&quot;open&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;可写流打开了~~&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">ws.once(&quot;close&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;可写流关闭了~~&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-文件读取"><a href="#3-文件读取" class="headerlink" title="3.文件读取"></a>3.文件读取</h2><h3 id="1-普通读取"><a href="#1-普通读取" class="headerlink" title="(1).普通读取"></a>(1).普通读取</h3><ul>
<li></li>
</ul>
<h3 id="2-简单读取"><a href="#2-简单读取" class="headerlink" title="(2).简单读取"></a>(2).简单读取</h3><h4 id="a-同步使用-2"><a href="#a-同步使用-2" class="headerlink" title="a).同步使用"></a>a).同步使用</h4><ul>
<li></li>
</ul>
<h4 id="b-异步使用-2"><a href="#b-异步使用-2" class="headerlink" title="b).异步使用"></a>b).异步使用</h4><ul>
<li><p>使用 <code>fs.readFile()</code> 来读取，参数比同步多一个回调函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.readFile(&quot;./file/test1.txt&quot;, function (err, data)&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>若读取与写入同时使用时，可以达到复制的效果，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs.readFile(&quot;./file/1.jpg&quot;, function (err, data)&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        console.log(data);</span><br><span class="line">        fs.writeFile(&quot;./file/1_copy.jpg&quot;, data, function (err)&#123;</span><br><span class="line">            if (!err)&#123;</span><br><span class="line">                console.log(&quot;写入成功~~~&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-流式读取"><a href="#3-流式读取" class="headerlink" title="(3).流式读取"></a>(3).流式读取</h3><h4 id="a-常规读取-写入"><a href="#a-常规读取-写入" class="headerlink" title="a).常规读取+写入"></a>a).常规读取+写入</h4><ul>
<li>读取可读流中的数据，需要为可读流绑定一个 data 事件，事件绑定完毕会自动开始读取数据（读取到的数据都在回调函数的参数中）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个可读流</span><br><span class="line">let rs = fs.createReadStream(&quot;./file/test1.txt&quot;);</span><br><span class="line">// 创建一个可写流</span><br><span class="line">let ws = fs.createWriteStream(&quot;./file/test1_copy.txt&quot;);</span><br><span class="line">// 监听是否开始关闭</span><br><span class="line">rs.once(&quot;open&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;可读流打开了&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">rs.once(&quot;close&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;可读流关闭了&quot;);</span><br><span class="line">    ws.end();</span><br><span class="line">&#125;)</span><br><span class="line">// 读取可读流的数据</span><br><span class="line">rs.on(&quot;data&quot;, function (data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">    // 写入可写流中</span><br><span class="line">    ws.write(data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-简便读取-写入"><a href="#b-简便读取-写入" class="headerlink" title="b).简便读取+写入"></a>b).简便读取+写入</h4><ul>
<li>无需绑定 data 事件，只需使用可写流的 <code>rs.pipe()</code> 方法即可将可读流中的内容直接输出到可写流中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个可写流</span><br><span class="line">let rs = fs.createReadStream(&quot;./file/那些花儿.mp3&quot;);</span><br><span class="line">// 创建一个可写流</span><br><span class="line">let ws = fs.createWriteStream(&quot;./file/那些花儿_copy.mp3&quot;);</span><br><span class="line">// 监听是否开始关闭</span><br><span class="line">rs.once(&quot;open&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;可读流打开了&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">rs.once(&quot;close&quot;, function ()&#123;</span><br><span class="line">    console.log(&quot;可读流关闭了&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">rs.pipe(ws);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-其他方法"><a href="#4-其他方法" class="headerlink" title="4.其他方法"></a>4.其他方法</h2><ul>
<li><code>fs.existsSync(path)</code>：检查一个文件是否存在</li>
<li><code>fs.stat(path,callback)/fs.statSync(path)</code>：获取文件的状态</li>
<li><code>fs.unlink(path,callback)/fs.unlinkSync(path)</code>：删除文件</li>
<li><code>fs.readdir(path[,options],callback)/fs.readdirSync(path[,options])</code>：读取一个目录的目录结构</li>
<li><code>fs.truncate(path,len,callback) / fs.truncateSync(path,len)</code>：截断文件，将文件修改为指定的大小</li>
<li><code>fs.mkdir(path,[options],callback) / fs.mkdirSync(path,[options])</code>：创建一个目录</li>
<li><code>fs.rmdir(path,callback) / fs.rmdirSync(path)</code>：删除一个目录</li>
<li><code>fs.rename(oldPath,newPath,callback) / fs.renameSync(oldPath,newPath)</code>：对文件进行重命名，同时可以实现移动的效果</li>
<li><code>fs.watchFire(filename[,options],listener)</code>：监视文件的修改</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：jQuery（尚硅谷）</title>
    <url>/Learn-jQuery.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 jQuery 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><ul>
<li>官网地址：<a href="https://jquery.com/">点击这里</a></li>
<li>jQuery 是一个优秀的 JS 函数库，封装了 BOM、DOM 等相关操作（CRUD）</li>
<li>特性：HTML元素选取（选择器）、HTML元素操作、CSS操作、HTML事件处理、JS动画效果、<strong style="color:red;">链式调用</strong>、<strong style="color:red;">读写合一</strong>、<strong style="color:red;">隐式遍历（迭代）</strong>、浏览器兼容、易扩展插件、ajax封装</li>
</ul>
<h2 id="1-版本之间的区别"><a href="#1-版本之间的区别" class="headerlink" title="1.版本之间的区别"></a>1.版本之间的区别</h2><ul>
<li><code>1.x</code>：兼容老版本IE、文件更大</li>
<li><code>2.x</code>：部分IE8及以下不支持，文件小，执行效率更高</li>
<li><code>3.x</code>：完全不再支持IE8及以下版本，提供了一些新的API，提供不包含ajax/动画API的版本</li>
</ul>
<h2 id="2-原生JS和jQuery的区别"><a href="#2-原生JS和jQuery的区别" class="headerlink" title="2.原生JS和jQuery的区别"></a>2.原生JS和jQuery的区别</h2><ul>
<li>这里主要谈 <code>window.onload</code> 与 <code>$(document).ready() / $(function()&#123;&#125;)</code></li>
<li><code>window.onload</code>：<ul>
<li>包括页面的图片加载完后才会回调（晚）</li>
<li>只能有一个监听回调（其余的会覆盖）</li>
</ul>
</li>
<li><code>$(document).ready()</code>：<ul>
<li>等同于: <code>$(function()&#123;&#125;)</code></li>
<li>页面加载完就回调（早）</li>
<li>可以有多个监听回调</li>
</ul>
</li>
</ul>
<h2 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3.基本操作"></a>3.基本操作</h2><h3 id="1-引入-jQuery-库"><a href="#1-引入-jQuery-库" class="headerlink" title="(1).引入 jQuery 库"></a>(1).引入 jQuery 库</h3><ul>
<li>可选如下两种方式：</li>
</ul>
<h4 id="1-服务器本地库"><a href="#1-服务器本地库" class="headerlink" title="1).服务器本地库"></a>1).服务器本地库</h4><ul>
<li>使用 <code>&lt;script&gt;</code> 标签从本地引入</li>
</ul>
<h4 id="2-CDN-远程库"><a href="#2-CDN-远程库" class="headerlink" title="2).CDN 远程库"></a>2).CDN 远程库</h4><ul>
<li>项目上线时，一般使用比较靠谱的CDN资源库，用来减轻服务器压力</li>
<li>BootCDN：<a href="https://www.bootcdn.cn/">查看链接</a></li>
</ul>
<h3 id="2-使用-jQuery"><a href="#2-使用-jQuery" class="headerlink" title="(2).使用 jQuery"></a>(2).使用 jQuery</h3><ul>
<li>我们需要使用 jQuery 核心函数和 jQuery 核心对象<ul>
<li><strong>jQuery 核心函数</strong>：向外直接暴露的 $/jQuery</li>
<li><strong>jQuery 核心对象</strong>：执行jQuery函数返回的对象，我们一般在对象名前加 <code>$</code> 符号来标明</li>
</ul>
</li>
<li>案例文本请点击 <a href="/demo/JSex/jQuery01.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h1 id="二、核心函数"><a href="#二、核心函数" class="headerlink" title="二、核心函数"></a>二、核心函数</h1><h2 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1.使用方式"></a>1.使用方式</h2><h3 id="1-作为一般函数调用"><a href="#1-作为一般函数调用" class="headerlink" title="(1).作为一般函数调用"></a>(1).作为一般函数调用</h3><ul>
<li>语法：<code>$(param)</code></li>
<li>参数为函数：当DOM加载完成后，执行此回调函数（文档加载完成的监听）</li>
<li>参数为选择器字符串: 查找所有匹配的标签，并将它们封装成jQuery对象</li>
<li>参数为DOM对象: 将dom对象封装成jQuery对象</li>
<li>参数为html标签字符串(用得少): 创建标签对象并封装成jQuery对象</li>
</ul>
<h3 id="2-作为对象使用"><a href="#2-作为对象使用" class="headerlink" title="(2).作为对象使用"></a>(2).作为对象使用</h3><ul>
<li>语法：<code>$.xxx()</code></li>
<li><code>$.each()</code>: 隐式遍历对象/数组</li>
<li><code>$.trim()</code>: 去除两端的空格</li>
</ul>
<h2 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2.选择器"></a>2.选择器</h2><ul>
<li>选择器本身只是一个有特定语法规则的字符串，没有实质用处</li>
<li>它的基本语法规则使用的就是CSS的选择器语法，并对其进行了扩展</li>
<li>只有调用<code>$()</code>, 并将选择器作为参数传入才能起作用</li>
<li><code>$(selector)</code>作用：根据选择器规则在整个文档中查找所有匹配的标签的数组, 并封装成jQuery对象返回</li>
</ul>
<h3 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="(1).基本选择器"></a>(1).基本选择器</h3><ul>
<li><p><code>#id</code>：id选择器</p>
</li>
<li><p><code>element</code>：元素选择器</p>
</li>
<li><p><code>.class</code>：属性选择器</p>
</li>
<li><p><code>*</code>：任意标签</p>
</li>
<li><p><code>selector1,selector2,selectorN</code>：取多个选择器的并集(组合选择器)</p>
</li>
<li><p><code>selector1selector2selectorN</code>：取多个选择器的交集(相交选择器)</p>
</li>
</ul>
<h3 id="2-层次选择器"><a href="#2-层次选择器" class="headerlink" title="(2).层次选择器"></a>(2).层次选择器</h3><ul>
<li><code>ancestor descendant</code>：在给定的祖先元素下匹配所有的后代元素</li>
<li><code>parent&gt;child</code>：在给定的父元素下匹配所有的子元素</li>
<li><code>prev+next</code>：匹配所有紧接在 prev 元素后的 next 元素</li>
<li><code>prev~siblings</code>：匹配 prev 元素之后的所有 siblings 元素</li>
</ul>
<h3 id="3-过滤选择器"><a href="#3-过滤选择器" class="headerlink" title="(3).过滤选择器"></a>(3).过滤选择器</h3><ul>
<li>在原有选择器匹配的元素中进一步进行过滤的选择器</li>
<li>多个过滤选择器不是同时执行的，而是依次过滤的</li>
</ul>
<h4 id="a-基本"><a href="#a-基本" class="headerlink" title="a).基本"></a>a).基本</h4><ul>
<li><code>:first</code>：获取匹配的第一个元素</li>
<li><code>:last</code>：获取匹配的最后一个元素</li>
<li><code>:not(selector)</code>：去除所有与给定选择器匹配的元素</li>
<li><code>:lt/gt(index)</code>：匹配所有小于/大于给定索引值的元素</li>
</ul>
<h4 id="b-内容"><a href="#b-内容" class="headerlink" title="b).内容"></a>b).内容</h4><ul>
<li><code>:contains(text)</code>：匹配包含给定文本的元素</li>
</ul>
<h4 id="c-可见性"><a href="#c-可见性" class="headerlink" title="c).可见性"></a>c).可见性</h4><ul>
<li><code>:hidden</code>：匹配所有不可见元素，或者type为hidden的元素</li>
</ul>
<h4 id="d-属性"><a href="#d-属性" class="headerlink" title="d).属性"></a>d).属性</h4><ul>
<li><code>[attribute]</code>：匹配包含给定属性的元素</li>
<li><code>[attribute=value]</code>：匹配给定的属性是某个特定值的元素</li>
</ul>
<h3 id="4-表单选择器"><a href="#4-表单选择器" class="headerlink" title="(4).表单选择器"></a>(4).表单选择器</h3><h4 id="a-表单"><a href="#a-表单" class="headerlink" title="a).表单"></a>a).表单</h4><ul>
<li><code>:input</code>：匹配所有 input, textarea, select 和 button 元素</li>
<li><code>:text</code>：匹配所有的单行文本框</li>
<li><code>:checkbox</code>：匹配所有复选框</li>
<li><code>:submit</code>：匹配所有提交按钮</li>
</ul>
<h4 id="b-表单对象属性"><a href="#b-表单对象属性" class="headerlink" title="b).表单对象属性"></a>b).表单对象属性</h4><ul>
<li><code>:enabled</code>：匹配所有可用元素</li>
<li><code>:disabled</code>：匹配所有不可用元素</li>
<li><code>:checked</code>：匹配所有选中的被选中元素(复选框、单选框等，不包括select中的option)</li>
<li><code>:selected</code>：匹配所有选中的option元素</li>
</ul>
<h2 id="3-工具"><a href="#3-工具" class="headerlink" title="3.工具"></a>3.工具</h2><ul>
<li><code>$.each()</code>：遍历数组或对象中的数据</li>
<li><code>$.trim()</code>：去除字符串两边的空格</li>
<li><code>$.type(obj)</code>：得到数据的类型</li>
<li><code>$.isarray(obj)</code>：判断是否是数组</li>
<li><code>$.isFunction(obj)</code>：判断是否是函数</li>
<li><code>$.parseJSON(json)</code>: 解析json字符串转换为js对象/数组</li>
</ul>
<h1 id="三、核心对象"><a href="#三、核心对象" class="headerlink" title="三、核心对象"></a>三、核心对象</h1><ul>
<li>即执行 jQuery 核心函数返回的对象</li>
<li>jQuery 对象内部包含的是 DOM元素对象的伪数组（可能只有一个元素）</li>
<li>jQuery 对象拥有很多有用的属性和方法，让程序员能方便的操作 DOM</li>
<li>特点：<ul>
<li>链式调用：调用 jQuery 对象的任何方法后返回的还是当前 jQuery 对象</li>
<li>读写合一：读内部第一个 dom 元素、写内部所有的 dom 元素</li>
</ul>
</li>
</ul>
<h2 id="0-伪数组"><a href="#0-伪数组" class="headerlink" title="0.伪数组"></a>0.伪数组</h2><ul>
<li>是一个Object对象</li>
<li>有length属性、数值下标属性</li>
<li>没有数组特别的方法：forEach()、push()、pop()、splice()</li>
<li>自定义伪数组如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let weiArr = &#123;&#125;;</span><br><span class="line">weiArr.length = 0;</span><br><span class="line">weiArr[0] = &#x27;wrysmile&#x27;;</span><br><span class="line">weiArr.length = 1;</span><br><span class="line">weiArr[1] = 980378775;</span><br><span class="line">weiArr.length = 2;</span><br><span class="line">for(let i = 0; i &lt; weiArr.length; i++)&#123;</span><br><span class="line">	let obj = weiArr[i];</span><br><span class="line">	console.log(i,obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-基本行为"><a href="#1-基本行为" class="headerlink" title="1.基本行为"></a>1.基本行为</h2><ul>
<li><del>size()</del>/length: 包含的 DOM 元素个数<strong style="color:red;">（注意：size()在jQuery1.8已废弃）</strong></li>
<li>[index]/get(index): 得到对应位置的DOM元素</li>
<li>each(): 遍历包含的所有DOM元素</li>
<li>index(): 得到在所在兄弟元素中的下标</li>
</ul>
<h2 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h2><h3 id="1-操作任意属性"><a href="#1-操作任意属性" class="headerlink" title="(1).操作任意属性"></a>(1).操作任意属性</h3><ul>
<li><code>attr()</code>：设置或返回被选元素的属性值</li>
<li><code>removeAttr()</code>：从每一个匹配的元素中删除一个属性</li>
<li><code>prop()</code>：获取在匹配的元素集中的第一个元素的属性值</li>
</ul>
<h4 id="引申：attr和prop的区别"><a href="#引申：attr和prop的区别" class="headerlink" title=" 引申：attr和prop的区别"></a><strong style="color:red;"> 引申：attr和prop的区别</strong></h4><ul>
<li>attr() 操作属性值为非布尔值的属性</li>
<li>prop() 操作属性值为布尔值的属性，如 checked, selected 或者 disabled</li>
</ul>
<h3 id="2-操作class属性"><a href="#2-操作class属性" class="headerlink" title="(2).操作class属性"></a>(2).操作class属性</h3><ul>
<li><code>addClass()</code>：为每个匹配的元素添加指定的类名</li>
<li><code>removeClass()</code>：从所有匹配的元素中删除全部或者指定的类</li>
</ul>
<h3 id="3-操作HTML代码-文本-值"><a href="#3-操作HTML代码-文本-值" class="headerlink" title="(3).操作HTML代码/文本/值"></a>(3).操作HTML代码/文本/值</h3><ul>
<li><code>html()</code>：取得第一个匹配元素的html内容</li>
<li><code>val()</code>：获得匹配元素的当前值</li>
</ul>
<h2 id="3-CSS"><a href="#3-CSS" class="headerlink" title="3.CSS"></a>3.CSS</h2><h3 id="1-读取-设置css样式"><a href="#1-读取-设置css样式" class="headerlink" title="(1).读取/设置css样式"></a>(1).读取/设置css样式</h3><ul>
<li><code>css()</code>：设置css样式/读取css值</li>
<li>设置多个样式时，应当封装为一个对象</li>
<li><strong style="color:red;">注意：当设置CSS样式中的宽高时，可以不写 px 单位</strong></li>
</ul>
<h3 id="2-读取-设置标签的位置"><a href="#2-读取-设置标签的位置" class="headerlink" title="(2).读取/设置标签的位置"></a>(2).读取/设置标签的位置</h3><ul>
<li><code>offset()</code>：相对页面左上角的坐标</li>
<li><code>position()</code>：相对于父元素左上角的坐标</li>
<li><code>scrollTop()</code>：获取匹配元素相对滚动条顶部的偏移<ul>
<li>得到页面滚动条的坐标：<code>$(document.body).scrollTop()+$(document.documentElement).scrollTop()</code></li>
<li>设置滚动条的新坐标：<code>$(&#39;body,html&#39;).scrollTop(60)</code></li>
</ul>
</li>
<li><code>scrollLeft()</code>：获取匹配元素相对滚动条左侧的偏移</li>
</ul>
<h3 id="3-读取-设置标签的尺寸"><a href="#3-读取-设置标签的尺寸" class="headerlink" title="(3).读取/设置标签的尺寸"></a>(3).读取/设置标签的尺寸</h3><ul>
<li><code>heigh()/width()</code>：只计算内容尺寸</li>
<li><code>innerHeight()/innerWidth()</code>：计算内部尺寸（height/width + padding）</li>
<li><code>outerHeight()/outerWidth()</code>：计算外部尺寸（height/width + padding + border）</li>
<li><code>outerHeight(true)/outerWidth(true)</code>：计算外部尺寸（height/width + padding + border + margin）</li>
</ul>
<h2 id="4-筛选"><a href="#4-筛选" class="headerlink" title="4.筛选"></a>4.筛选</h2><h3 id="1-过滤"><a href="#1-过滤" class="headerlink" title="(1).过滤"></a>(1).过滤</h3><ul>
<li>作用：在 jQuery 对象中的元素对象数组中过滤出一部分元素来，并封装成新的 jQuery 对象返回</li>
<li>下面中前三个是通过下标来过滤，后三个是根据选择器来过滤<ul>
<li><code>first()</code>：获取第一个元素</li>
<li><code>last()</code>：获取最后一个元素</li>
<li><code>eq(index|-index)</code>：获取第N个元素</li>
<li><code>filter(selector)</code>：筛选出与指定表达式匹配的元素集合</li>
<li><code>not(selector)</code>：删除与指定表达式匹配的元素</li>
<li><code>has(selector)</code>：保留包含特定后代的元素，去掉那些不含有指定后代的元素</li>
</ul>
</li>
</ul>
<h3 id="2-查找"><a href="#2-查找" class="headerlink" title="(2).查找"></a>(2).查找</h3><ul>
<li>作用：在已经匹配出的元素集合中根据选择器查找孩子/父母/兄弟标签<ul>
<li><code>children()</code>：查找当前元素的子标签中符合条件的元素</li>
<li><code>find()</code>：查找当前元素的后代标签中符合条件的元素</li>
<li><code>parent()</code>：查找当前元素的父元素</li>
<li><code>prevAll()</code>：查找当前元素之前所有的同辈元素</li>
<li><code>nextAll()</code>：查找当前元素之后所有的同辈元素</li>
<li><code>siblings()</code>：查找当前元素前后所有的兄弟元素</li>
</ul>
</li>
</ul>
<h2 id="5-文档"><a href="#5-文档" class="headerlink" title="5.文档"></a>5.文档</h2><h3 id="1-添加节点"><a href="#1-添加节点" class="headerlink" title="(1).添加节点"></a>(1).添加节点</h3><ul>
<li><code>append(content)</code>：向当前匹配的所有元素内部的最后插入指定内容</li>
<li><code>prepend(content)</code>：向当前匹配的所有元素内部的最前面插入指定内容</li>
<li><code>before(content)</code>：将指定内容插入到当前所有匹配元素的前面</li>
<li><code>after(content)</code>：将指定内容插入到当前所有匹配元素的后面</li>
</ul>
<h3 id="2-替换节点"><a href="#2-替换节点" class="headerlink" title="(2).替换节点"></a>(2).替换节点</h3><ul>
<li><code>replaceWith(content)</code>：用指定内容替换所有匹配的标签</li>
<li><code>replaceAll(selector)</code>：用匹配的元素替换掉所有 selector 匹配到的元素</li>
</ul>
<h3 id="3-删除节点"><a href="#3-删除节点" class="headerlink" title="(3).删除节点"></a>(3).删除节点</h3><ul>
<li><code>empty()</code>：删除所有匹配元素的子元素</li>
<li><code>remove()</code>：删除所有匹配的元素</li>
</ul>
<h2 id="6-事件"><a href="#6-事件" class="headerlink" title="6.事件"></a>6.事件</h2><h3 id="1-事件处理"><a href="#1-事件处理" class="headerlink" title="(1).事件处理"></a>(1).事件处理</h3><ul>
<li><code>on()</code>：在选择元素上绑定一个或多个事件的事件处理函数</li>
<li><code>off()</code>：在选择元素上移除一个或多个事件的事件处理函数</li>
<li><code>click()</code>：触发每一个匹配元素的click事件</li>
<li><code>mouseenter()</code>：当鼠标指针穿过元素时，会发生 mouseenter 事件</li>
<li><code>mouseleave()</code>：当鼠标指针离开元素时，会发生 mouseleave 事件</li>
</ul>
<h3 id="2-事件切换"><a href="#2-事件切换" class="headerlink" title="(2).事件切换"></a>(2).事件切换</h3><ul>
<li><code>hover()</code>：同时绑定鼠标移入和移出监听，它只需要接收两个回调函数</li>
</ul>
<h3 id="3-事件委派-委托"><a href="#3-事件委派-委托" class="headerlink" title="(3).事件委派(委托)"></a>(3).事件委派(委托)</h3><h4 id="a-简介"><a href="#a-简介" class="headerlink" title="a).简介"></a>a).简介</h4><ul>
<li>将多个子元素的事件监听委托给父辈元素处理，并且将监听回调加在了父辈元素上</li>
<li>当操作任何一个子元素时，事件会冒泡到父辈元素上面去</li>
<li><strong style="color:red;">父辈元素不会直接处理事件，而是根据 event.target 得到发生事件的子元素，通过这个子元素调用事件回调函数</strong></li>
<li>优势：新增的元素没有事件监听、减少监听的数量</li>
</ul>
<h4 id="b-委派方法"><a href="#b-委派方法" class="headerlink" title="b).委派方法"></a>b).委派方法</h4><ul>
<li><code>delegate()</code>：设置事件委托，参数为(childrenSelector, eventName, callback)</li>
<li><code>undelegate()</code>：移除事件委托</li>
</ul>
<h3 id="4-事件对象"><a href="#4-事件对象" class="headerlink" title="(4).事件对象"></a>(4).事件对象</h3><ul>
<li><code>event.clientX/Y</code>：事件坐标，相对视口左上角</li>
<li><code>event.pageX/Y</code>：事件坐标，相对页面左上角</li>
<li><code>event.offsetX/Y</code>：事件坐标，相对元素左上角</li>
<li><code>event.stopPropagation()</code>：阻止事件冒泡</li>
<li><code>event.preventDefault()</code>：取消事件的默认行为</li>
</ul>
<h3 id="引申：区别-mouseover-与-mouseenter"><a href="#引申：区别-mouseover-与-mouseenter" class="headerlink" title=" 引申：区别 mouseover 与 mouseenter"></a><strong style="color:red;"> 引申：区别 mouseover 与 mouseenter</strong></h3><ul>
<li>mouseover: 在移入子元素时也会触发，对应 mouseout</li>
<li>mouseenter: 只在移入当前元素时才触发，对应 mouseleave<ul>
<li>hover() 使用的就是 mouseenter() 和 mouseleave()</li>
</ul>
</li>
</ul>
<h3 id="引申：区别-on-‘xxx’-fun-与-xxx-fun"><a href="#引申：区别-on-‘xxx’-fun-与-xxx-fun" class="headerlink" title=" 引申：区别 on(‘xxx’,fun) 与 xxx(fun)"></a><strong style="color:red;"> 引申：区别 on(‘xxx’,fun) 与 xxx(fun)</strong></h3><ul>
<li>前者通用但编码麻烦</li>
<li>后者编码简单，但有的事件没有对应的方法</li>
</ul>
<h2 id="7-效果"><a href="#7-效果" class="headerlink" title="7.效果"></a>7.效果</h2><ul>
<li>以下效果都可以不传参数（代表默认值），也可以传数字、字符串、回调函数<ul>
<li>数字：动画效果时长</li>
<li>字符串：需要传入固定字符串 —— slow、normal、fast</li>
<li>回调函数：动画执行完毕的回调</li>
</ul>
</li>
</ul>
<h3 id="1-淡入淡出动画"><a href="#1-淡入淡出动画" class="headerlink" title="(1).淡入淡出动画"></a>(1).淡入淡出动画</h3><ul>
<li>不断改变元素的透明度来实现的</li>
<li><code>fadeIn()</code>：实现所有匹配元素的淡入效果，并在动画完成后可选地触发一个回调函数</li>
<li><code>fadeOut()</code>：实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数</li>
<li><code>fadeToggle()</code>：开关所有匹配元素的淡入和淡出效果，并在动画完成后可选地触发一个回调函数</li>
</ul>
<h3 id="2-上下滑动动画"><a href="#2-上下滑动动画" class="headerlink" title="(2).上下滑动动画"></a>(2).上下滑动动画</h3><ul>
<li>不断改变元素的高度来实现的</li>
<li><code>slideUp()</code>：动态地隐藏所有匹配的元素，在隐藏完成后可选地触发一个回调函数</li>
<li><code>slideDown()</code>：动态地显示所有匹配的元素，在显示完成后可选地触发一个回调函数</li>
<li><code>slideToggle()</code>：切换所有匹配元素的可见性，并在切换完成后可选地触发一个回调函数</li>
</ul>
<h3 id="3-显示隐藏动画"><a href="#3-显示隐藏动画" class="headerlink" title="(3).显示隐藏动画"></a>(3).显示隐藏动画</h3><ul>
<li>不断改变元素的尺寸和透明度来实现</li>
<li><code>show()</code>：(不)带动画的显示隐藏的匹配元素</li>
<li><code>hide()</code>：(不)带动画的隐藏显示的元素</li>
<li><code>toggle()</code>：(不)带动画的切换显示/隐藏</li>
</ul>
<h3 id="4-自定义动画"><a href="#4-自定义动画" class="headerlink" title="(4).自定义动画"></a>(4).自定义动画</h3><ul>
<li><code>animate()</code>：自定义动画效果的动画，里面可以传一个对象用来设置动画结束时的样式，这里不需要设置单位</li>
<li><code>stop()</code>：停止动画</li>
</ul>
<h1 id="四、多库共存"><a href="#四、多库共存" class="headerlink" title="四、多库共存"></a>四、多库共存</h1><ul>
<li>如果我们的项目中需要引入多个库且其中都使用到了 <code>$</code> 来进行调用，就会存在冲突，导致其余库和jQuery库无法执行</li>
<li>jQuery 库中可以使用相应的 API 来释放 <code>$</code> 的使用权，让另一个库可以正常使用，此时 jQuery 库就只能使用 jQuery 来进行调用了</li>
<li><code>jQuery.noConflict()</code> ：释放使用权</li>
</ul>
<h1 id="五、jQuery插件"><a href="#五、jQuery插件" class="headerlink" title="五、jQuery插件"></a>五、jQuery插件</h1><h2 id="1-扩展插件"><a href="#1-扩展插件" class="headerlink" title="1.扩展插件"></a>1.扩展插件</h2><ul>
<li><p>扩展jQuery的工具方法：<code>jQuery.extend(object)</code></p>
</li>
<li><p>扩展jQuery对象的方法：<code>jQuery.fn.extend(object)</code></p>
</li>
<li><p>案例：将全选、全不选、反选封装到扩展插件中供别人使用</p>
<ul>
<li>请点击 <a href="/demo/JSex/jQuery09.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
</li>
</ul>
<h2 id="2-jQuery插件"><a href="#2-jQuery插件" class="headerlink" title="2.jQuery插件"></a>2.jQuery插件</h2><ul>
<li>是基于 jQuery 编写的扩展库，官方插件地址请点击 <a href="https://plugins.jquery.com/">这里</a></li>
</ul>
<h3 id="1-jquery-validation"><a href="#1-jquery-validation" class="headerlink" title="(1).jquery-validation"></a>(1).jquery-validation</h3><ul>
<li>功能：是一款表单验证插件<ul>
<li>一种声明式验证：程序员只需要声明各种验证规则。可以自定义验证错误信息</li>
</ul>
</li>
<li>可参考 <a href="https://www.runoob.com/jquery/jquery-plugin-validate.html">菜鸟教程</a> 进行学习</li>
</ul>
<h4 id="插件使用方法"><a href="#插件使用方法" class="headerlink" title="!插件使用方法"></a>!插件使用方法</h4><ul>
<li><p>去<a href="https://github.com/jquery-validation/jquery-validation">Github</a>下载该插件最新版<strong style="color:red;">（jQuery官网已不再更新该插件了，所以需要自行去Github上下载）</strong></p>
</li>
<li><p>将如下3个 js文件引入到自己的项目里</p>
<ul>
<li><code>jquery-1.xx.x.js</code>：jQuery的js库</li>
<li><code>jquery.validate.js</code>：验证的js库</li>
<li><code>messages_zh.js</code>：错误信息的中文提示库</li>
</ul>
</li>
<li><p>可以对照该插件的 demo 直接在标签中设置相应的属性</p>
</li>
<li><p>设置好后需要调用一下该插件才可以正常运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&#x27;form的id&#x27;).validate();</span><br></pre></td></tr></table></figure></li>
<li><p>也可以在以上的代码中传入一个对象，在对象中设置规则或者错误信息提示规则等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&#x27;#form&#x27;).validate(&#123;</span><br><span class="line">	messages: &#123;</span><br><span class="line">		username: &#123;</span><br><span class="line">			required: &#x27;必须的哈哈哈&#x27;,</span><br><span class="line">			minlength: &#x27;你不够长&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-jquery-UI"><a href="#2-jquery-UI" class="headerlink" title="(2).jquery UI"></a>(2).jquery UI</h3><ul>
<li>功能：可以构建精选的用户界面交互，效果，小部件和主题等</li>
<li>请点击<a href="https://jqueryui.com/">这里</a>进行相应主题的下载</li>
<li>将如下3个 js文件引入到自己的项目里<ul>
<li><code>jquery-1.xx.x.js</code>：jQuery的js库</li>
<li><code>jquery-ui.js</code>：该插件的js库</li>
<li><code>jquery-ui.css</code>：该插件的css文件</li>
</ul>
</li>
<li>想要用哪个UI组件，就去刚刚下载的插件中去直接复制然后自行修改样式<ul>
<li>例如：Accordion为手风琴式效果，主要用来实现导航的切换</li>
</ul>
</li>
<li>然后使用 jQuery 对象调用相应方法即可</li>
</ul>
<h2 id="3-原生js插件"><a href="#3-原生js插件" class="headerlink" title="3.原生js插件"></a>3.原生js插件</h2><h3 id="1-layDate"><a href="#1-layDate" class="headerlink" title="(1).layDate"></a>(1).layDate</h3><ul>
<li>功能：一款被广泛使用的高级 Web 日历组件</li>
<li>请点击<a href="https://www.layui.com/laydate/?alone">这里</a>进行下载</li>
<li>将 layDate 下的所有文件全都复制到自己的项目中</li>
<li>将 <code>laydate.js</code> 引入到自己的项目中</li>
<li>创建一个表单元素并给其绑定一个id</li>
<li>使用如下语法进行调用：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">laydate.render(&#123;</span><br><span class="line">	elem: &#x27;id选择器&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="六、案例分析"><a href="#六、案例分析" class="headerlink" title="六、案例分析"></a>六、案例分析</h1><h2 id="1-多Tab切换功能"><a href="#1-多Tab切换功能" class="headerlink" title="1.多Tab切换功能"></a>1.多Tab切换功能</h2><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="(1).思路"></a>(1).思路</h3><h4 id="a-Tab实现"><a href="#a-Tab实现" class="headerlink" title="a).Tab实现"></a>a).Tab实现</h4><ul>
<li>将Tab放入多级列表中，将Tab对应的内容放在盒子容器中</li>
<li>使用定位使两个内容连接在一起</li>
<li>使用 <code>display</code> 属性来控制内容的显示与否</li>
</ul>
<h4 id="b-切换Tab实现"><a href="#b-切换Tab实现" class="headerlink" title="b).切换Tab实现"></a>b).切换Tab实现</h4><ul>
<li>先给3个li添加点击监听</li>
<li>隐藏当前已显示的内容</li>
<li>显示对应内容的div，得到当前点击的li在兄弟中的下标</li>
<li>找到对应内容的div并修改 <code>display</code> 属性</li>
</ul>
<h3 id="2-代码"><a href="#2-代码" class="headerlink" title="(2).代码"></a>(2).代码</h3><ul>
<li>请点击 <a href="/demo/JSex/jQuery02.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="2-回到顶部功能"><a href="#2-回到顶部功能" class="headerlink" title="2.回到顶部功能"></a>2.回到顶部功能</h2><ul>
<li>瞬间滚动到顶部只需要将 scrollTop 值设置为0即可，以下主要说的是平滑滚动到顶部</li>
</ul>
<h3 id="1-思路-1"><a href="#1-思路-1" class="headerlink" title="(1).思路"></a>(1).思路</h3><ul>
<li>获取到总距离、总时间、间隔时间、间隔距离等数据</li>
<li>使用循环定时器不断滚动</li>
<li>当到达顶部时，停止定时器</li>
</ul>
<h3 id="2-代码-1"><a href="#2-代码-1" class="headerlink" title="(2).代码"></a>(2).代码</h3><ul>
<li>请点击 <a href="/demo/JSex/jQuery03.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="3-爱好选择功能"><a href="#3-爱好选择功能" class="headerlink" title="3.爱好选择功能"></a>3.爱好选择功能</h2><h3 id="1-思路-2"><a href="#1-思路-2" class="headerlink" title="(1).思路"></a>(1).思路</h3><ul>
<li>点击’全选’: 选中所有爱好，并勾选’全选/全不选’</li>
<li>点击’全不选’: 所有爱好都不勾选，并取消勾选’全选/全不选’</li>
<li>点击’反选’: 改变所有爱好的勾选状态，并更新’全选/全不选’的选中状态</li>
<li>点击’全选/全不选’: 选中所有爱好, 或者全不选中</li>
<li>点击某个爱好时，必要时更新’全选/全不选’的选中状态</li>
<li>点击’提交’: 提示所有勾选的爱好</li>
</ul>
<h3 id="2-代码-2"><a href="#2-代码-2" class="headerlink" title="(2).代码"></a>(2).代码</h3><ul>
<li>请点击 <a href="/demo/JSex/jQuery04.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="4-表单的添加删除功能"><a href="#4-表单的添加删除功能" class="headerlink" title="4.表单的添加删除功能"></a>4.表单的添加删除功能</h2><h3 id="1-思路-3"><a href="#1-思路-3" class="headerlink" title="(1).思路"></a>(1).思路</h3><ul>
<li>添加功能：<ul>
<li>先收集表单中需要填写的数据</li>
<li>生成对应的<code>&lt;tr&gt;</code>标签结构，并插入到表单的的<code>&lt;tbody&gt;</code>中</li>
<li>给新添加的<code>&lt;tr&gt;</code>标签中的超链接设置点击事件，并传入删除的回调函数</li>
<li>清除表单输入框中的内容</li>
</ul>
</li>
<li>删除功能：<ul>
<li>找到表单后代中所有的超链接元素</li>
<li>为这些超链接元素绑定点击事件，并传入删除的回调函数</li>
</ul>
</li>
<li>删除的回调函数：<ul>
<li>使用 confirm() 方法来提示用户是否删除</li>
<li>取消默认行为</li>
<li>将删除功能中的回调函数单独封装出来，用来供添加功能使用</li>
</ul>
</li>
</ul>
<h3 id="2-代码-3"><a href="#2-代码-3" class="headerlink" title="(2).代码"></a>(2).代码</h3><ul>
<li>请点击 <a href="/demo/JSex/jQuery05.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h3 id="3-代码优化"><a href="#3-代码优化" class="headerlink" title="(3).代码优化"></a>(3).代码优化</h3><ul>
<li>以上的思路是将点击事件绑定给了当前元素，在新增元素时，需要额外的代码去将点击事件绑定给新加元素</li>
<li>可以使用事件委派来优化代码，将点击事件绑定给其父元素，优化后的页面代码如下：</li>
<li>请点击 <a href="/demo/JSex/jQuery06.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="5-轮播图自动切换功能"><a href="#5-轮播图自动切换功能" class="headerlink" title="5.轮播图自动切换功能"></a>5.轮播图自动切换功能</h2><ul>
<li>轮播图虽然展示出来可能比较单调，就是一直轮播，但是其中的小逻辑也很多，我们可以分步骤来逐步实现</li>
<li>前端的HTML、CSS相关编写不赘述，主要讲述JS逻辑</li>
</ul>
<h3 id="1-思路-4"><a href="#1-思路-4" class="headerlink" title="(1).思路"></a>(1).思路</h3><ul>
<li>我们一般将相关功能放入匿名函数中，使其在页面加载完成以后才会加载</li>
<li>在实现功能前，我们最好先在全局中定义好我们需要的全局变量</li>
<li>首先先给轮播图左右的按钮绑定点击事件，使其平滑切换到下(上)一页</li>
<li>其次实现无限循环切换，即第一页的上一页为最后页，最后一页的下一页是第一页<ul>
<li>这里主要是在结构中单独在将最后一张图片复制到第一位，把第一张图片复制到最后一位，在到达这一位置时，迅速切换图片下标，做到无缝切换</li>
</ul>
</li>
<li>一般轮播图都会自动进行切换，这时就需要用定时器来使其自动切换</li>
<li>但是在其自动切换时当用户的鼠标进入图片区域时，自动切换就会停止；当鼠标离开后，又开始自动切换</li>
<li>切换图片的时候下面的导航点也需要跟随图片进行切换，这里就需要使导航点的下标和图片的下标保持一致</li>
<li>导航点不仅会自动切换，还会跟随用户的点击切换到相应的图片，这里就需要对上面的逻辑进行一定程度的修改</li>
<li>最后我们需要对功能进行一定程度的测试，发现快速点击左右按钮时会出现半个图片，这里我们只需要设置个状态来判断是否点击即可</li>
</ul>
<h3 id="2-代码-4"><a href="#2-代码-4" class="headerlink" title="(2).代码"></a>(2).代码</h3><ul>
<li>请点击 <a href="/demo/JSex/jQuery07.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="6-导航栏显示折叠功能"><a href="#6-导航栏显示折叠功能" class="headerlink" title="6.导航栏显示折叠功能"></a>6.导航栏显示折叠功能</h2><h3 id="1-思路-5"><a href="#1-思路-5" class="headerlink" title="(1).思路"></a>(1).思路</h3><ul>
<li>只要找到需要显示或折叠的多级列表</li>
<li>给这个多级列表绑定hover()事件</li>
<li>在移入移出时调用上下滑动动画即可（为了功能的完美体验，应该在每次动画前都停止到之前的所有动画）</li>
</ul>
<h3 id="2-代码-5"><a href="#2-代码-5" class="headerlink" title="(2).代码"></a>(2).代码</h3><ul>
<li>请点击 <a href="/demo/JSex/jQuery08.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="7-京东商品详情页综合案例"><a href="#7-京东商品详情页综合案例" class="headerlink" title="7.京东商品详情页综合案例"></a>7.京东商品详情页综合案例</h2>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：Android</title>
    <url>/Angular-Basics.html</url>
    <content><![CDATA[<center>本篇是 Android 开发中需要掌握的基础内容</center>

<span id="more"></span>

<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-开发方向"><a href="#1-开发方向" class="headerlink" title="1.开发方向"></a>1.开发方向</h2><h3 id="1-传统Windows开发"><a href="#1-传统Windows开发" class="headerlink" title="(1).传统Windows开发"></a>(1).传统Windows开发</h3><ul>
<li>SDK、DDK、C++、C#（.Net Framework、.Net Core）</li>
</ul>
<h3 id="2-移动开发"><a href="#2-移动开发" class="headerlink" title="(2).移动开发"></a>(2).移动开发</h3><ul>
<li>HTML+CSS、AJAX、JS、XML（XPath）、图形图像</li>
<li>基于 ARM 架构</li>
<li>SOC</li>
</ul>
<h3 id="3-Web开发"><a href="#3-Web开发" class="headerlink" title="(3).Web开发"></a>(3).Web开发</h3><ul>
<li>CoM</li>
<li>前端：HTML+CSS、AJAX、JS、图形图像</li>
<li>后台：CGI+DB，PHP，ASP.NET、JSP</li>
</ul>
<h3 id="4-嵌入式开发"><a href="#4-嵌入式开发" class="headerlink" title="(4).嵌入式开发"></a>(4).嵌入式开发</h3><h2 id="2-学习内容"><a href="#2-学习内容" class="headerlink" title="2.学习内容"></a>2.学习内容</h2><ul>
<li>算法（数据结构）</li>
<li>接口</li>
<li>方法论</li>
</ul>
<h1 id="二、基础内容"><a href="#二、基础内容" class="headerlink" title="二、基础内容"></a>二、基础内容</h1><h2 id="1-零碎"><a href="#1-零碎" class="headerlink" title="1.零碎"></a>1.零碎</h2><ul>
<li>Android 讲究逻辑设视图分离 —— 在布局文件中编写界面，然后在活动中引入进来</li>
<li>在 <code>res</code> 文件夹下最后自己再创建 <code>drawable-hdpi、drawable-xhdpi、drawable-xxhdpi</code> 等文件夹，用来存放不同分辨率的图片</li>
</ul>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2.环境搭建"></a>2.环境搭建</h2><ul>
<li>关于软件下载，可以去<a href="https://www.androiddevtools.cn/">这个</a>网站</li>
<li>关于安卓信息，可以去<a href="https://developer.android.google.cn/">这个</a>网站了解</li>
</ul>
<h3 id="1-ADT"><a href="#1-ADT" class="headerlink" title="(1).ADT"></a>(1).ADT</h3><ul>
<li>关于ADT版本和SDK Tools的对应版本可以查看<a href="https://developer.android.com/studio/intro">这里</a>，里面详细说明了不同版本的ADT所对应的JDK版本要求，eclipse版本要求及SDK Tools版本要求。</li>
</ul>
<h3 id="2-Android-Studio"><a href="#2-Android-Studio" class="headerlink" title="(2).Android Studio"></a>(2).Android Studio</h3><ul>
<li>关于其概述，可以查看<a href="https://developer.android.com/studio/intro">这里</a></li>
<li>安装教程查看<a href="https://zhuanlan.zhihu.com/p/80051318">这里</a></li>
</ul>
<h2 id="3-日志工具"><a href="#3-日志工具" class="headerlink" title="3.日志工具"></a>3.日志工具</h2><ul>
<li>Android 中的日志工具类是 Log，该类中提供了以下五个方法：<br>Log.v()：对应级别verbose，打印所有日志信息<br>Log.d()：对应级别debug，打印调试信息<br>Log.i()：对应级别info，打印比较重要的数据<br>Log.w()：对应级别warn，打印警告信息<br>Log.e()：对应级别error，打印错误信息</li>
<li>该方法中需要两个字符串参数：<br>tag：用于对打印信息进行过滤<br>msg：想要打印的具体内容</li>
</ul>
<h1 id="三、活动（Activity）"><a href="#三、活动（Activity）" class="headerlink" title="三、活动（Activity）"></a>三、活动（Activity）</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h2><ul>
<li>项目中的任何活动都应该重写 Activity 的 onCreate() 方法</li>
</ul>
<h2 id="2-简单编写"><a href="#2-简单编写" class="headerlink" title="2.简单编写"></a>2.简单编写</h2><h3 id="1-创建活动"><a href="#1-创建活动" class="headerlink" title="(1).创建活动"></a>(1).创建活动</h3><ul>
<li>在项目的 <code>app/src/main/java</code> 下的包中右键新建 Empty Activity</li>
</ul>
<h3 id="2-创建布局文件"><a href="#2-创建布局文件" class="headerlink" title="(2).创建布局文件"></a>(2).创建布局文件</h3><ul>
<li>在项目的 <code>app/src/main/res</code> 下右键新建一个Directory，并将其命名为</li>
</ul>
<h3 id="3-设计布局文件"><a href="#3-设计布局文件" class="headerlink" title="(3).设计布局文件"></a>(3).设计布局文件</h3><h3 id="4-加载布局文件"><a href="#4-加载布局文件" class="headerlink" title="(4).加载布局文件"></a>(4).加载布局文件</h3><ul>
<li>使用 setContentView() 方法，一般需要传入一个布局文件的id</li>
</ul>
<h3 id="5-注册活动"><a href="#5-注册活动" class="headerlink" title="(5).注册活动"></a>(5).注册活动</h3><ul>
<li>将活动在 AndroidManifest.xml 文件中注册</li>
<li>活动的注册声明要放在 <code>&lt;application&gt;</code> 标签内，通过 <code>&lt;activity&gt;</code> 标签来对活动进行注册</li>
<li>在 <code>&lt;activity&gt;</code> 标签中使用 <code>android:name</code> 来指定具体注册哪一个活动，因为前面包名已经指定，所以只需要写 <code>.活动名</code> 即可</li>
</ul>
<h3 id="6-配置主活动"><a href="#6-配置主活动" class="headerlink" title="(6).配置主活动"></a>(6).配置主活动</h3><ul>
<li>在 <code>&lt;activity&gt;</code> 标签内部加入 <code>&lt;intent-filter&gt;</code> 标签，并在标签中写入如下内容：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;activity android:name=&quot;.FirstActivity&quot;</span><br><span class="line">	android:label=&quot;FirstActivity&quot;&gt;  &lt;!--指定活动中标题栏内容，并且成为应用名--&gt;</span><br><span class="line">	&lt;intent-filter&gt;</span><br><span class="line">		&lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">		&lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">	&lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-销毁活动"><a href="#7-销毁活动" class="headerlink" title="(7).销毁活动"></a>(7).销毁活动</h3><ul>
<li>第一种：按下Back键就可以销毁当前的活动</li>
<li>第二种：调用Activity类中的finish() 方法<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onClick(View v)&#123;</span><br><span class="line">	finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-Toast"><a href="#3-Toast" class="headerlink" title="3.Toast"></a>3.Toast</h2><ul>
<li><p>通过静态方法 <code>makeText()</code> 创建出一个 Toast 对象，然后调用 <code>show()</code> 将 Toast 显示出来就可以了</p>
</li>
<li><p>该方法需要传入3个参数：<br>Context：Toast要求的上下文<br>Text：Toast显示的文本内容<br>Time：Toast显示的时长，可选值为：Toast.LENGTH_SHORT与Toast.LENGTH_LONG</p>
</li>
<li><p>如下就是通过点击一个按钮来使其显示 Toast</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">	super.onCreate(savedInstanceState);</span><br><span class="line">	setContentView(R.layout.first_layout);</span><br><span class="line">	// 获取到在布局文件中定义的元素并返回View对象</span><br><span class="line">	Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">	// 为按钮注册一个监听器</span><br><span class="line">	button1.setOnClickListener(new View.OnClickListener()&#123;</span><br><span class="line">		// 为按钮添加单击响应事件</span><br><span class="line">		@Override</span><br><span class="line">		public void onClick(View v)&#123;</span><br><span class="line">			Toast.makeText(FirstActivity.this,&quot;You clicked Button 1&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-Menu"><a href="#4-Menu" class="headerlink" title="4.Menu"></a>4.Menu</h2><ul>
<li></li>
</ul>
<h2 id="5-Intent"><a href="#5-Intent" class="headerlink" title="5.Intent"></a>5.Intent</h2><ul>
<li></li>
</ul>
<h2 id="6-生命周期"><a href="#6-生命周期" class="headerlink" title="6.生命周期"></a>6.生命周期</h2><ul>
<li></li>
</ul>
<h2 id="7-启动模式"><a href="#7-启动模式" class="headerlink" title="7.启动模式"></a>7.启动模式</h2><h3 id="1-standard"><a href="#1-standard" class="headerlink" title="(1).standard"></a>(1).standard</h3><ul>
<li></li>
</ul>
<h3 id="2-singleTop"><a href="#2-singleTop" class="headerlink" title="(2).singleTop"></a>(2).singleTop</h3><ul>
<li></li>
</ul>
<h3 id="3-singleTask"><a href="#3-singleTask" class="headerlink" title="(3).singleTask"></a>(3).singleTask</h3><ul>
<li></li>
</ul>
<h3 id="4-singleInstance"><a href="#4-singleInstance" class="headerlink" title="(4).singleInstance"></a>(4).singleInstance</h3><ul>
<li></li>
</ul>
<h2 id="8-活动的最佳实践"><a href="#8-活动的最佳实践" class="headerlink" title="8.活动的最佳实践"></a>8.活动的最佳实践</h2><h3 id="1-知晓当前在哪一个活动"><a href="#1-知晓当前在哪一个活动" class="headerlink" title="(1).知晓当前在哪一个活动"></a>(1).知晓当前在哪一个活动</h3><ul>
<li></li>
</ul>
<h3 id="2-随时随地退出程序"><a href="#2-随时随地退出程序" class="headerlink" title="(2).随时随地退出程序"></a>(2).随时随地退出程序</h3><ul>
<li></li>
</ul>
<h3 id="3-启动活动的最佳写法"><a href="#3-启动活动的最佳写法" class="headerlink" title="(3).启动活动的最佳写法"></a>(3).启动活动的最佳写法</h3><ul>
<li></li>
</ul>
<h1 id="四、UI-设计"><a href="#四、UI-设计" class="headerlink" title="四、UI 设计"></a>四、UI 设计</h1><h2 id="1-视图（View）"><a href="#1-视图（View）" class="headerlink" title="1.视图（View）"></a>1.视图（View）</h2><ul>
<li>任何可视化控件都需要从 <code>android.view.View</code> 类中继承，而任何继承自该类的类都称为视图</li>
<li>View 可以分为三种：布局（layout）、视图容器类（View Container）、视图类（Button、TextView、EditText等）</li>
<li>视图的继承关系如下图：<br><img src="https://s3.ax1x.com/2020/11/16/DAw0aT.png" alt="Android02.png"></li>
</ul>
<h2 id="2-视图之视图类"><a href="#2-视图之视图类" class="headerlink" title="2.视图之视图类"></a>2.视图之视图类</h2><h3 id="1-TextView"><a href="#1-TextView" class="headerlink" title="(1).TextView"></a>(1).TextView</h3><ul>
<li>主要用于在界面上显示一段文本信息</li>
</ul>
<h3 id="2-Button"><a href="#2-Button" class="headerlink" title="(2).Button"></a>(2).Button</h3><ul>
<li><p>主要用于在界面上显示一个按钮</p>
</li>
<li><p>在布局文件中设置的文字有小写，但实际会转为大写，可以添加如下文件来禁用这一默认特性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">	android:id=&quot;@+id/button&quot;</span><br><span class="line">	android:layout_width=&quot;match_parent&quot;</span><br><span class="line">	android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">	android:textAllCaps=&quot;false&quot;			//禁用默认特性</span><br><span class="line">	android:text=&quot;Button&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>绑定点击事件之匿名类注册监听器，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">	@Override</span><br><span class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		Button button = (Button) findViewById(R.id.button);</span><br><span class="line">		button.setOnClickListener(new View.OnClickListener()&#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void onClick(View v)&#123;</span><br><span class="line">				//此处写逻辑</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>绑定点击事件之实现接口注册监听器，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123;</span><br><span class="line">	@Override</span><br><span class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		Button button = (Button) findViewById(R.id.button);</span><br><span class="line">		// 实现接口方式注册监听器</span><br><span class="line">		button.setOnClickListener(this);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void onClick(View v)&#123;</span><br><span class="line">		switch(v.getId())&#123;</span><br><span class="line">			case R.id.button:</span><br><span class="line">				//此处写逻辑</span><br><span class="line">				break;</span><br><span class="line">			default:</span><br><span class="line">				break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-EditText"><a href="#3-EditText" class="headerlink" title="(3).EditText"></a>(3).EditText</h3><ul>
<li>主要用于在控件里输入和编辑内容，并可以在程序中对这些内容进行处理</li>
</ul>
<h3 id="4-ImageView"><a href="#4-ImageView" class="headerlink" title="(4).ImageView"></a>(4).ImageView</h3><ul>
<li>主要用于引入图片并进行相关操作</li>
<li>在引入之前最后自己在 res 目录下自己新建一个 <code>drawable-xhdpi</code> 的文件夹并将图片放入其中</li>
</ul>
<h3 id="5-ProgressBar"><a href="#5-ProgressBar" class="headerlink" title="(5).ProgressBar"></a>(5).ProgressBar</h3><ul>
<li>主要用于在界面上显示一个进度条，表示程序正在加载一些数据</li>
<li>如果想要更改进度条的样式，可以如下设置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ProgressBar</span><br><span class="line">	android:id=&quot;@+id/progress_bar&quot;</span><br><span class="line">	android:layout_width=&quot;match_parent&quot;</span><br><span class="line">	android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">	// 更改进度条样式并设置最大值</span><br><span class="line">	style=&quot;?android:attr/progressBarStyleHorizontal&quot;</span><br><span class="line">	android:max=&quot;100&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-AlertDialog"><a href="#6-AlertDialog" class="headerlink" title="(6).AlertDialog"></a>(6).AlertDialog</h3><ul>
<li>可以在当前界面弹出一个对话框，且置顶于所有界面元素之上的</li>
<li>具体实现如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 点击按钮弹出一个对话框</span><br><span class="line">@Override</span><br><span class="line">public void onClick(View v)&#123;</span><br><span class="line">	switch (v.getId())&#123;</span><br><span class="line">		case R.id.button:</span><br><span class="line">			AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);</span><br><span class="line">			dialog.setTitle(&quot;This is Dialog&quot;);</span><br><span class="line">			dialog.setMessage(&quot;这很重要，你确定要删除吗？&quot;);</span><br><span class="line">			// 设置可以用返回键来关闭对话框</span><br><span class="line">			dialog.setCancelable(false);</span><br><span class="line">			dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			dialog.setNegativeButton(&quot;Cancle&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			// 显示对话框</span><br><span class="line">			dialog.show();</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-ProgressDialog"><a href="#7-ProgressDialog" class="headerlink" title="(7).ProgressDialog"></a>(7).ProgressDialog</h3><ul>
<li>可以在当前界面弹出一个对话框，且置顶于所有界面元素之上的，区别于上面的是，该对话框可以显示进度条，一般用于表示当前操作比较耗时</li>
<li>具体实现如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 点击按钮弹出对话框且显示进度条</span><br><span class="line">@Override</span><br><span class="line">public void onClick(View v)&#123;</span><br><span class="line">	switch (v.getId())&#123;</span><br><span class="line">		case R.id.button:</span><br><span class="line">			ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);</span><br><span class="line">			progressDialog.setTitle(&quot;This is ProgressDialog&quot;);</span><br><span class="line">			progressDialog.setMessage(&quot;Loading....&quot;);</span><br><span class="line">			progressDialog.setCancelable(true);</span><br><span class="line">			progressDialog.show();</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-相关属性"><a href="#8-相关属性" class="headerlink" title="(8).相关属性"></a>(8).相关属性</h3><h4 id="a-android-id-属性"><a href="#a-android-id-属性" class="headerlink" title="a).android:id 属性"></a>a).android:id 属性</h4><ul>
<li>语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android:id=&quot;@+id/user&quot;</span><br></pre></td></tr></table></figure>

<h4 id="b-android-background-属性"><a href="#b-android-background-属性" class="headerlink" title="b).android:background 属性"></a>b).android:background 属性</h4><ul>
<li>语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android:background=&quot;@mipmap/bg&quot;</span><br><span class="line">android:background=&quot;#bfa&quot;</span><br></pre></td></tr></table></figure>

<h4 id="c-android-padding-属性"><a href="#c-android-padding-属性" class="headerlink" title="c).android:padding 属性"></a>c).android:padding 属性</h4><ul>
<li>语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android:padding=&quot;@dimen/activity_margin&quot;</span><br><span class="line">android:padding=&quot;16dp&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>还包括如下四个：<br>android:paddingLeft<br>android:paddingTop<br>android:paddingRight<br>android:paddingBottom</li>
<li>API 17新增加：<br>android:paddingStart<br>android:paddingEnd</li>
</ul>
<h4 id="d-android-gravity-属性"><a href="#d-android-gravity-属性" class="headerlink" title="d).android:gravity 属性"></a>d).android:gravity 属性</h4><ul>
<li>用于指定文字的对齐方式，可选值有：top/bottom/left/right/center，也可以用 <code>|</code> 来指定多个值</li>
</ul>
<h4 id="e-android-textSize-属性"><a href="#e-android-textSize-属性" class="headerlink" title="e).android:textSize 属性"></a>e).android:textSize 属性</h4><ul>
<li>用于设置文字的大小，在Android中字体大小时使用 sp 作为单位的</li>
</ul>
<h4 id="f-android-hint-属性"><a href="#f-android-hint-属性" class="headerlink" title="f).android:hint 属性"></a>f).android:hint 属性</h4><ul>
<li>常在EditText中使用，可以指定一段提示性文字</li>
</ul>
<h4 id="g-android-maxLines-属性"><a href="#g-android-maxLines-属性" class="headerlink" title="g).android:maxLines 属性"></a>g).android:maxLines 属性</h4><ul>
<li>常在EditText中使用，可以设置最大行数</li>
</ul>
<h4 id="h-android-visibility-属性"><a href="#h-android-visibility-属性" class="headerlink" title="h).android:visibility 属性"></a>h).android:visibility 属性</h4><ul>
<li><p>所有控件都可以使用，用于设置控件的可见属性</p>
</li>
<li><p>可选值如下：<br>visible：可见的，默认值<br>invisible：不可见的，但仍占据空间<br>gone：不可见的，且不占据任何空间</p>
</li>
<li><p>也可以使用代码设置控件的可见性，使用 <code>setVisibility()</code> 方法，可以传入 <code>View.VISIBLE View.INVISIBLE View.GONE</code> 三个值</p>
</li>
</ul>
<h2 id="3-视图之布局"><a href="#3-视图之布局" class="headerlink" title="3.视图之布局"></a>3.视图之布局</h2><ul>
<li>布局是一种可用于放置很多控件的容器，可以按照一定规律调整内部控件的位置</li>
</ul>
<h3 id="1-线性布局（LinearLayout）"><a href="#1-线性布局（LinearLayout）" class="headerlink" title="(1).线性布局（LinearLayout）"></a>(1).线性布局（LinearLayout）</h3><ul>
<li>在线性布局中，vertical下，高度就不可以指定为match；horizontal下，宽度就不可以指定为match</li>
<li>相关属性请看下面的 <code>ab</code></li>
</ul>
<h3 id="2-相对布局（RelativeLayout）"><a href="#2-相对布局（RelativeLayout）" class="headerlink" title="(2).相对布局（RelativeLayout）"></a>(2).相对布局（RelativeLayout）</h3><ul>
<li>可以通过相对定位的方式让控件出现在布局的任何位置</li>
<li>相关属性请看下面的 <code>c~g</code></li>
</ul>
<h3 id="3-帧布局（FrameLayout）"><a href="#3-帧布局（FrameLayout）" class="headerlink" title="(3).帧布局（FrameLayout）"></a>(3).帧布局（FrameLayout）</h3><ul>
<li>所有的控件都会默认摆放在布局的左上角</li>
<li>相关属性请看下面的 <code>a</code></li>
</ul>
<h3 id="4-百分比布局"><a href="#4-百分比布局" class="headerlink" title="(4).百分比布局"></a>(4).百分比布局</h3><ul>
<li>该布局只是作为相对布局和帧布局的拓展，分别为：PercentFrameLayout 和 PercentRelativeLayout</li>
<li>只需要在项目的 build.gradle 中添加百分比布局库的依赖即可在所有系统版本上的兼容性了，打开 app/build.gradle ，在 dependencies 闭包中添加如下内容的最后一行，然后点击 <code>Sync Now</code> 即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	implementation &#x27;androidx.appcompat:appcompat:1.2.0&#x27;</span><br><span class="line">	implementation &#x27;com.google.android.material:material:1.2.1&#x27;</span><br><span class="line">	implementation &#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span><br><span class="line">	testImplementation &#x27;junit:junit:4.+&#x27;</span><br><span class="line">	androidTestImplementation &#x27;androidx.test.ext:junit:1.1.2&#x27;</span><br><span class="line">	androidTestImplementation &#x27;androidx.test.espresso:espresso-core:3.3.0&#x27;</span><br><span class="line">	implementation &#x27;com.android.support:percent:24.2.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-相关属性"><a href="#5-相关属性" class="headerlink" title="(5).相关属性"></a>(5).相关属性</h3><h4 id="a-android-layout-gravity-属性"><a href="#a-android-layout-gravity-属性" class="headerlink" title="a).android:layout_gravity 属性"></a>a).android:layout_gravity 属性</h4><ul>
<li>用于指定控件在布局中的对齐方式</li>
</ul>
<h4 id="b-android-layout-weight-属性"><a href="#b-android-layout-weight-属性" class="headerlink" title="b).android:layout_weight 属性"></a>b).android:layout_weight 属性</h4><ul>
<li>用于使用比例的方式来指定控件的大小</li>
<li>使用该属性时，可以将宽度修改为 <code>0dp</code> ，然后将该属性设置为1，则可以实现控件自动平分宽度</li>
<li>在同一方向上也可以指定部分控件的该属性，使其自动适配</li>
</ul>
<h4 id="c-android-layout-alignParentXxx-属性"><a href="#c-android-layout-alignParentXxx-属性" class="headerlink" title="c).android:layout_alignParentXxx 属性"></a>c).android:layout_alignParentXxx 属性</h4><ul>
<li>其中XXX包含Left、Right、Top、Bottom</li>
<li>使其相对于父元素定位</li>
</ul>
<h4 id="d-android-layout-centerInParent-属性"><a href="#d-android-layout-centerInParent-属性" class="headerlink" title="d).android:layout_centerInParent 属性"></a>d).android:layout_centerInParent 属性</h4><ul>
<li>使其相对于父元素居中</li>
</ul>
<h4 id="e-android-layout-above-below-属性"><a href="#e-android-layout-above-below-属性" class="headerlink" title="e).android:layout_above/below 属性"></a>e).android:layout_above/below 属性</h4><ul>
<li>可以让一个控件位于另一个控件的上方/下方</li>
<li>使用该属性时作为参照物的控件需要写在最上边</li>
</ul>
<h4 id="f-android-layout-toLeftOf-toRightOf-属性"><a href="#f-android-layout-toLeftOf-toRightOf-属性" class="headerlink" title="f).android:layout_toLeftOf/toRightOf 属性"></a>f).android:layout_toLeftOf/toRightOf 属性</h4><ul>
<li>可以让一个控件位于另一个控件的左侧/右侧</li>
<li>使用该属性时作为参照物的控件需要写在最上边</li>
</ul>
<h4 id="g-android-layout-alignXXX-属性"><a href="#g-android-layout-alignXXX-属性" class="headerlink" title="g).android:layout_alignXXX 属性"></a>g).android:layout_alignXXX 属性</h4><ul>
<li>其中XXX包含Left、Right、Top、Bottom</li>
<li>可以让一个控件的左/右/上/下边缘与另一个控件的边缘对齐</li>
</ul>
<h3 id="6-引入布局或自定义控件"><a href="#6-引入布局或自定义控件" class="headerlink" title="(6).引入布局或自定义控件"></a>(6).引入布局或自定义控件</h3><ul>
<li>通过引用布局，可以减少重复代码的编写</li>
<li>当引入的布局中有些需要绑定点击事件时，就需要自定义控件来解决该问题了</li>
</ul>
<h4 id="a-引入布局"><a href="#a-引入布局" class="headerlink" title="a).引入布局"></a>a).引入布局</h4><ul>
<li><p>新建一个布局文件并编写好，在 <code>activity_main.xml</code> 中使用以下语法来引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;include layout=&quot;@layout/title&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>如果需要去除系统自带的标题栏，则需要在 <code>MainActivity.java</code> 文件中这样编写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ActionBar actionbar = getSupportActionBar();</span><br><span class="line">if(actionbar != null)&#123;</span><br><span class="line">	actionbar.hide();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-自定义控件"><a href="#b-自定义控件" class="headerlink" title="b).自定义控件"></a>b).自定义控件</h4><ul>
<li><p>新建一个java文件来继承自 <code>LinearLayout</code> ，并重写其构造函数，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class TitleLayout extends LinearLayout &#123;</span><br><span class="line">	public TitleLayout(Context context, AttributeSet attrs)&#123;</span><br><span class="line">		super(context,attrs);</span><br><span class="line">		LayoutInflater.from(context).inflate(R.layout.title,this);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在布局文件中添加该自定义控件，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">	android:layout_width=&quot;match_parent&quot;</span><br><span class="line">	android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">	&lt;!-- 引入自定义控件 --&gt;</span><br><span class="line">	&lt;com.wrysmile.uilayouttest.TitleLayout</span><br><span class="line">		android:layout_width=&quot;match_parent&quot;</span><br><span class="line">		android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在自定义控件中编写适当的点击事件即可</p>
</li>
</ul>
<h2 id="4-视图之视图容器类"><a href="#4-视图之视图容器类" class="headerlink" title="4.视图之视图容器类"></a>4.视图之视图容器类</h2><h3 id="1-ListView"><a href="#1-ListView" class="headerlink" title="(1).ListView"></a>(1).ListView</h3><ul>
<li>当程序有大量数据时，使用该空间可以将屏幕外的数据滚入，屏幕内的数据滚出</li>
</ul>
<h4 id="b-点击事件"><a href="#b-点击事件" class="headerlink" title="b).点击事件"></a>b).点击事件</h4><ul>
<li>我们需要使用 <code>setOnItemClickListener()</code> 方法为ListView注册一个监听器，当执行点击事件时，就会回调 <code>onItemClick()</code> 方法</li>
<li>在该方法中通过 position 来判断点击的是哪一个子项，然后执行相应的操作，可看下方：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;Fruit&gt; fruitList = new ArrayList&lt;&gt;();</span><br><span class="line">	@Override</span><br><span class="line">	protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">		super.onCreate(savedInstanceState);</span><br><span class="line">		setContentView(R.layout.activity_main);</span><br><span class="line">		// 初始化水果数据</span><br><span class="line">		initFruits();</span><br><span class="line">		FruitAdapter adapter = new FruitAdapter(MainActivity.this,R.layout.fruit_item,fruitList);</span><br><span class="line">		ListView listView = (ListView) findViewById(R.id.list_view);</span><br><span class="line">		listView.setAdapter(adapter);</span><br><span class="line">		// 点击事件</span><br><span class="line">		listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id)&#123;</span><br><span class="line">				Fruit fruit = fruitList.get(position);</span><br><span class="line">				Toast.makeText(MainActivity.this,fruit.getName(),Toast.LENGTH_SHORT).show();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-RecyclerView"><a href="#2-RecyclerView" class="headerlink" title="(2).RecyclerView"></a>(2).RecyclerView</h3><ul>
<li><p>增强版的 ListView，具有同样的效果，还优化了性能问题</p>
</li>
<li><p>和百分比布局类似，它也属于新增的控件，需要在项目的 build.gradle 中的 dependencies 闭包中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">implementation &#x27;androidx.recyclerview:recyclerview:1.1.0&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>然后在 activity_main.xml 文件中这样编写即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">	android:layout_width=&quot;match_parent&quot;</span><br><span class="line">	android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">	&lt;androidx.recyclerview.widget.RecyclerView</span><br><span class="line">		android:id=&quot;@+id/recycler_view&quot;</span><br><span class="line">		android:layout_width=&quot;match_parent&quot;</span><br><span class="line">		android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="a-点击事件"><a href="#a-点击事件" class="headerlink" title="a).点击事件"></a>a).点击事件</h4><h2 id="5-制作-Nine-Patch-图片"><a href="#5-制作-Nine-Patch-图片" class="headerlink" title="5.制作 Nine-Patch 图片"></a>5.制作 Nine-Patch 图片</h2><ul>
<li>Nine-Patch 图片可以让某一图片动态的跟随内容变换其长度和高度，而不是单纯的让图片平铺在背景上，主要用于实现类似于聊天框的效果</li>
<li>将图片导入到项目中的 <code>drawable-xhdpi</code> 文件夹中，右击该图片，找到 <code>Create 9-patch file</code> 按钮，点击就进入了制作界面</li>
<li>类似于 PS 的画笔功能，可以在四边用鼠标进行绘画一条直线，上边和左边是控制哪部分拉伸的，下边和右边是控制文本在哪里显示的</li>
<li>修改好后右边可以看到效果图，满意保存替换源文件即可</li>
</ul>
<h2 id="2-ViewGroup-类"><a href="#2-ViewGroup-类" class="headerlink" title="2.ViewGroup 类"></a>2.ViewGroup 类</h2><ul>
<li>它是一个抽象类，一般使用其子类来实现</li>
<li>该类控制其子组件分布时依赖如下两个内部类：</li>
</ul>
<h3 id="1-ViewGroup-LayoutParams-类"><a href="#1-ViewGroup-LayoutParams-类" class="headerlink" title="(1).ViewGroup.LayoutParams 类"></a>(1).ViewGroup.LayoutParams 类</h3><ul>
<li><p>该类主要控制布局的位置、高度和宽度的</p>
</li>
<li><p>通常使用以下两个属性：<br>android:layout_height：设置布局高度<br>android:layout_width：设置布局宽度</p>
</li>
<li><p>这两个属性有如下属性值：<br>fill_parent：与父容器形同（API8以下使用）<br>match_parent：与父容器相同<br>wrap_content：包裹其自身的内容</p>
</li>
</ul>
<h3 id="2-ViewGroup-MarginLayoutParams-类"><a href="#2-ViewGroup-MarginLayoutParams-类" class="headerlink" title="(2).ViewGroup.MarginLayoutParams 类"></a>(2).ViewGroup.MarginLayoutParams 类</h3><ul>
<li>主要用于控制子组件的外边距</li>
<li>通常包括四个属性：<br>android:layout_marginLeft<br>android:layout_marginTop<br>android:layout_marginRight<br>android:layout_marginBottom</li>
<li>API 17新增加：<br>android:paddingStart<br>android:paddingEnd</li>
</ul>
<h2 id="3-UI组件的层次结构"><a href="#3-UI组件的层次结构" class="headerlink" title="3.UI组件的层次结构"></a>3.UI组件的层次结构</h2><ul>
<li>如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zbYFJ.png" alt="Android01.png"></li>
</ul>
<h2 id="4-控制UI界面的方法"><a href="#4-控制UI界面的方法" class="headerlink" title="4.控制UI界面的方法"></a>4.控制UI界面的方法</h2><h3 id="1-使用XML布局文件控制UI界面"><a href="#1-使用XML布局文件控制UI界面" class="headerlink" title="(1).使用XML布局文件控制UI界面"></a>(1).使用XML布局文件控制UI界面</h3><ul>
<li>在 <code>res/layout</code> 目录下编写XML布局文件</li>
<li>在 Activity 中使用以下Java代码来显示XML文件中布局的内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setContentView(R.layout.activity_main);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-在Java代码中控制UI界面"><a href="#2-在Java代码中控制UI界面" class="headerlink" title="(2).在Java代码中控制UI界面"></a>(2).在Java代码中控制UI界面</h3><ul>
<li>新建的 MainActivity 类应该继承自 AppCompatActivity 类</li>
<li>然后重写 onCreate 方法，且所有代码都得写在 <code>super.onCreate(savedInstanceState);</code> 语句的后面</li>
<li>中间代码设置背景等样式</li>
<li>还可以为按钮绑定单击响应事件</li>
<li>最后需要将写好的内容通过以下代码加入 View 中——<code>frameLayout.addView(text1);</code> </li>
</ul>
<h3 id="3-使用XML和Java混合控制UI界面"><a href="#3-使用XML和Java混合控制UI界面" class="headerlink" title="(3).使用XML和Java混合控制UI界面"></a>(3).使用XML和Java混合控制UI界面</h3><h3 id="4-开发自定义的View"><a href="#4-开发自定义的View" class="headerlink" title="(4).开发自定义的View"></a>(4).开发自定义的View</h3><h1 id="五、碎片（手机平板的兼容）"><a href="#五、碎片（手机平板的兼容）" class="headerlink" title="五、碎片（手机平板的兼容）"></a>五、碎片（手机平板的兼容）</h1><h2 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="1.基础"></a>1.基础</h2><ul>
<li>碎片是一种可以嵌入在活动当中的 UI 片段，一般用于平板视图中</li>
</ul>
<h2 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2.使用方式"></a>2.使用方式</h2><h3 id="1-简单用法"><a href="#1-简单用法" class="headerlink" title="(1).简单用法"></a>(1).简单用法</h3><ul>
<li>写一左一右两个布局文件</li>
<li>新建一左一右两个类并让其继承自 <code>Fragment</code> 类，并在这两个类中通过 LayoutInflater 的 inflate() 方法将刚才定义的布局加载进来</li>
<li>在 activity_main.xml 中使用 <code>&lt;fragment&gt;</code> 标签添加碎片</li>
<li><font color=#F00>注意：这里需要通过 android:name 属性来显示指明要添加的碎片类名</font></li>
</ul>
<h3 id="2-动态添加碎片"><a href="#2-动态添加碎片" class="headerlink" title="(2).动态添加碎片"></a>(2).动态添加碎片</h3><h4 id="a-方法"><a href="#a-方法" class="headerlink" title="a).方法"></a>a).方法</h4><ul>
<li>创建待添加的碎片实例</li>
<li>获取 FragmentManager，在活动中可以直接调用 getSupportFragmentManager() 方法得到</li>
<li>开启一个事务，通过调用 beginTransaction() 方法开启</li>
<li>向容器内添加或替换碎片，一般使用 replace() 方法实现，需要传入容器的id和待添加的碎片实例</li>
<li>提交事务，调用 commit() 方法来完成</li>
</ul>
<h4 id="b-引申"><a href="#b-引申" class="headerlink" title="b).引申"></a>b).引申</h4><ul>
<li>这里在 activity_main.xml 中加载布局可以使用 <code>&lt;FrameLayout&gt;&lt;/FrameLayout&gt;</code> 布局来写</li>
</ul>
<h3 id="3-在碎片中返回栈"><a href="#3-在碎片中返回栈" class="headerlink" title="(3).在碎片中返回栈"></a>(3).在碎片中返回栈</h3><ul>
<li>作用：使碎片像活动一样有返回栈，按 Back键时会回到上一个页面</li>
<li>FragmentTransaction 中提供了一个 addToBackStack() 方法，可以用于将一个事务添加到返回栈中，一般传 null 即可，如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transaction.addToBackStack(null);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-碎片和活动的通信"><a href="#4-碎片和活动的通信" class="headerlink" title="(4).碎片和活动的通信"></a>(4).碎片和活动的通信</h3><ul>
<li><p>从布局文件中获取碎片的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RightFragment rightFragment = (RightFragment) getSupportFragmentManager().findFragmentById(R.id.right_fragment);</span><br></pre></td></tr></table></figure></li>
<li><p>从碎片中调用活动的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MainActivity activity = (MainActivity) getActivity();</span><br></pre></td></tr></table></figure></li>
<li><p>引申：<font color=#F00>碎片与碎片之间的通信</font>可以先在一个碎片总得到与它相关联的活动，然后再通过这个活动去获取另外一个碎片的实例</p>
</li>
<li><p>引申：当碎片需要使用 Context 对象时，也可以使用 getActivity() 方法</p>
</li>
</ul>
<h2 id="3-生命周期"><a href="#3-生命周期" class="headerlink" title="3.生命周期"></a>3.生命周期</h2><ul>
<li>生命周期示意图如下：</li>
</ul>
<h3 id="1-运行状态"><a href="#1-运行状态" class="headerlink" title="(1).运行状态"></a>(1).运行状态</h3><ul>
<li>碎片可见，且与之关联的活动正处于运行状态</li>
</ul>
<h3 id="2-暂停状态"><a href="#2-暂停状态" class="headerlink" title="(2).暂停状态"></a>(2).暂停状态</h3><ul>
<li>某一活动进入暂停状态，与之相关联的碎片也会处于暂停状态</li>
</ul>
<h3 id="3-停止状态"><a href="#3-停止状态" class="headerlink" title="(3).停止状态"></a>(3).停止状态</h3><ul>
<li>某一活动进入停止状态，与之相关联的碎片也会处于停止状态</li>
<li>通过调用 FragmentTransaction 的 remove()和replace() 方法将碎片从活动中移除，但在事务提交前调用 addToBackStack() 方法，也会处于停止状态</li>
</ul>
<h3 id="4-销毁状态"><a href="#4-销毁状态" class="headerlink" title="(4).销毁状态"></a>(4).销毁状态</h3><ul>
<li>某一活动被销毁时，与之相关联的碎片就会进入销毁状态</li>
<li>通过调用 FragmentTransaction 的 remove()和replace() 方法将碎片从活动中移除，但在事务提交前没有调用 addToBackStack() 方法，也会处于销毁状态</li>
</ul>
<h3 id="5-附加回调方法"><a href="#5-附加回调方法" class="headerlink" title="(5).附加回调方法"></a>(5).附加回调方法</h3><ul>
<li>onAttach()：碎片和活动建立关联时调用</li>
<li>onCreateView()：为碎片创建视图（加载布局）时调用</li>
<li>onActivityCreated()：确保与碎片相关联的活动一定已经创建完毕时调用</li>
<li>onDestroyView()：当与碎片相关联的视图被移除时调用</li>
<li>onDetach()：当碎片和活动解除关联时调用</li>
</ul>
<h1 id="六、广播接收器"><a href="#六、广播接收器" class="headerlink" title="六、广播接收器"></a>六、广播接收器</h1><h2 id="1-基础-2"><a href="#1-基础-2" class="headerlink" title="1.基础"></a>1.基础</h2><ul>
<li>发送广播使用 Intent，而接收广播使用 Broadcast Receiver（广播接收器）</li>
<li>广播类型分为：<br>标准广播：一种完全异步执行的广播，广播发出以后，所有的广播接收器几乎在同一时刻接收到这条广播信息<br>有序广播：一种同步执行的广播，广播发出以后，同一时刻只有一个广播接收器能收到这条广播信息，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递</li>
</ul>
<h2 id="2-接收系统广播"><a href="#2-接收系统广播" class="headerlink" title="2.接收系统广播"></a>2.接收系统广播</h2><h3 id="1-动态注册"><a href="#1-动态注册" class="headerlink" title="(1).动态注册"></a>(1).动态注册</h3><ul>
<li>广播接收器想要监听什么广播，就使用 intentFilter 添加相应的 action 即可</li>
<li>动态注册的广播接收器一定要取消注册才行，可以在 onDestroy() 方法中调用 unregisterReceiver() 方法来实现</li>
<li><font color=#F00>注意 Android 系统为了保护用户设备的安全和隐私，做了严格的规定</font>：如果程序需要进行一些对用户来说比较敏感的操作，就必须在配置文件中声明权限才可以，否则程序会直接崩溃</li>
</ul>
<h1 id="附、问题集合"><a href="#附、问题集合" class="headerlink" title="附、问题集合"></a>附、问题集合</h1><h2 id="1-Android-Studio启动后gradle下载太慢"><a href="#1-Android-Studio启动后gradle下载太慢" class="headerlink" title="1.Android Studio启动后gradle下载太慢"></a>1.Android Studio启动后gradle下载太慢</h2><ul>
<li>在尝试进行第一次编译程序时，发现gradle下载很慢，即使挂梯子也下载很慢，于是在网上找到需要的压缩包进行自行配置，需要的可以点击<a href="https://pan.baidu.com/s/1APiyo22_EKd3Y9SKYpwl7A">这里</a>（提取码：m33b）直接进行下载</li>
<li>将 <code>gradlegradle-6.1.1-all.zip（或者其他版本名字）</code> 下载完成之后放着待用</li>
<li>在你的c盘中找到该路径 <code>C:\Users\你的用户名\.gradle\wrapper\dists\gradle-6.1.1-all（或者其他版本名字）\cfmwm155h49vnt3hynmlrsdst</code></li>
<li>将其中的文件全部删除，再把刚刚下载好的文件粘贴进去</li>
<li>重启 Android Studio，此时会自动跳过下载并开始解压i</li>
</ul>
<h2 id="2-给-Button-添加背景之后不显示"><a href="#2-给-Button-添加背景之后不显示" class="headerlink" title="2.给 Button 添加背景之后不显示"></a>2.给 Button 添加背景之后不显示</h2><ul>
<li><p>添加背景后依然显示默认颜色，此时需要给布局处加入以下这一行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>然后在按钮的设置处加入以下这行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app:backgroundTint=&quot;@null&quot; </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-如何修改AS的模拟器位置"><a href="#3-如何修改AS的模拟器位置" class="headerlink" title="3.如何修改AS的模拟器位置"></a>3.如何修改AS的模拟器位置</h2><ul>
<li><p>在 <code>C:\user\用户名\.android\avd</code> 或 <code>C:\Android\.android\avd</code> 中找到模拟器文件夹，一个文件夹对应一个配置文件</p>
</li>
<li><p>将模拟器文件夹移动到你所需要移动到的位置，我这里移动到了这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D:\Android\avd\Pixel_3a_API_30_x86.avd</span><br></pre></td></tr></table></figure></li>
<li><p>修改C盘的配置文件中的path字段即可，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">avd.ini.encoding=UTF-8</span><br><span class="line">path=D:\Android\avd\Pixel_3a_API_30_x86.avd</span><br><span class="line">path.rel=avd\Pixel_3a_API_30_x86.avd</span><br><span class="line">target=android-30</span><br></pre></td></tr></table></figure></li>
<li><p>打开AS测试模拟器是否可以正常运行</p>
</li>
</ul>
<h2 id="4-如何修改Android项目的包名"><a href="#4-如何修改Android项目的包名" class="headerlink" title="4.如何修改Android项目的包名"></a>4.如何修改Android项目的包名</h2><blockquote>
<p>当你引用别人的项目时，会发现包名是别人的包名，想要修改成为自己的包名按以下操作即可</p>
</blockquote>
<ul>
<li>建议在Project格式下，找到 <code>app/src/main/java</code> 路径，在这之下就是项目的包名，点击右上角的齿轮图标，如下图：<br><img src="https://s3.ax1x.com/2020/12/14/rnIKnx.png" alt="Android03.png"></li>
<li>将 <strong>Compact Middle Packages</strong> 选项取消勾选，更改后如下图：<br><img src="https://s3.ax1x.com/2020/12/14/rnIY3d.png" alt="Android04.png"></li>
<li>点击你需要更改的包名，按快捷键 <strong>shift + F6</strong> 进行重命名操作，并选择 <strong>Rename package</strong>，如下图：<br><img src="https://s3.ax1x.com/2020/12/14/rnIBE8.png" alt="Android05.png"></li>
<li>填好包名后点击 <strong>Refactor</strong>，此时下方会弹出小框提示哪些文件需要一并修改，这里AS会自动检测并帮我们自动修改，点击 <strong>Do Refactor</strong>，如下图：<br><img src="https://s3.ax1x.com/2020/12/14/rnIfbV.png" alt="Android06.png"></li>
<li>完成后修改 app 目录下的 <code>build.gradle</code> 文件中的 applicationId 字样，成功后点击 <strong>Sync now</strong> 修改完成，如下图：<br><img src="https://s3.ax1x.com/2020/12/14/rnI78J.png" alt="Android07.png"></li>
<li><a href="https://www.jianshu.com/p/14d92eecfada">https://www.jianshu.com/p/14d92eecfada</a></li>
<li>双击返回键退出应用：<a href="https://blog.csdn.net/qq_23179075/article/details/60587202">https://blog.csdn.net/qq_23179075/article/details/60587202</a></li>
<li>实现沉浸式状态栏：<a href="https://blog.csdn.net/weixin_43796132/article/details/102250632">https://blog.csdn.net/weixin_43796132/article/details/102250632</a></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>玩机：巧妙备份并转换输入法词库</title>
    <url>/Input.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>很多时候，使用一个输入法久了以后再换另一个输入法时，长久积攒的词库备份是一个很大的问题</li>
<li>而在 GitHub 上的一个开源项目 —— 深蓝词库转换可以很好的解决该问题<span id="more"></span></li>
</ul>
<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ul>
<li>为了解决不同词库之间的格式转换，推荐使用 GitHub 上的一个开源项目 —— <a href="https://github.com/studyzy/imewlconverter">深蓝词库转换</a></li>
<li><strong>深蓝词库转换</strong> 是一款功能强大的词库转换工具，目前支持QQ，搜狗，微软，百度，必应，手心等20多款主流输入法的词库的相互转换</li>
<li>完整支持的输入法列表：<br>搜狗拼音（文本词库、Bin格式备份词库和scel格式细胞词库）<br>QQ拼音（文本词库和qpyd格式分类词库）<br>百度PC拼音（文本词库、bdict格式）<br>微软拼音2010/Win10微软拼音<br>拼音加加/手心输入法/必应输入法/谷歌拼音/新浪拼音<br>紫光拼音（文本词库和uwl格式分类词库）<br>libpinyin(Linux)/Chinese-pyim(Linux)<br>QQ五笔/搜狗五笔/小鸭五笔/极点五笔/Win10微软五笔<br>极点郑码/小小输入法（拼音、五笔、郑码、二笔）<br>FIT输入法(Mac)/MacOS自带简体拼音<br>Rime输入法(Linux中州韻、Windows小狼毫、Mac OS鼠鬚管)<br>雅虎奇摩输入法（注音）/灵格斯词库ld2/仓颉平台</li>
</ul>
<h1 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h1><ul>
<li>这里主要以搜狗输入法为例。首先搜狗的词库主要包括基础词库和细胞字库，其中基础词库除了自带的本地词库外最重要的是包含了日积月累的自动学习的词汇，也就是符合个人组词习惯/词语频率的词库，可以说这是极具个人特点的词库，也是备份和转换时的重点，至于细胞词库则是搜狗公开可以下载的词库，这个在官网上可以随便下载</li>
<li>在搜狗输入法的属性设置中，切换至词库选项，勾选基础词库导出备份</li>
<li>打开深蓝字库转换器，打开保存好的.bin词库备份文件，点击转换即可</li>
<li>转换成功后导入在其他输入法中即可</li>
</ul>
<h2 id="三、说明"><a href="#三、说明" class="headerlink" title="三、说明"></a>三、说明</h2><ul>
<li>有些输入法的自学习词汇库不能超过2W个词条，因此转换之前可以先在高级设置中通过设置词条长度、词频等过滤条件来控制词条数量</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>玩机技巧</tag>
        <tag>输入法</tag>
        <tag>词库</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器：破解网页复制与粘贴限制</title>
    <url>/copy-paste.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>平时上网一定遇到过网站禁止复制文字或者粘贴文字的情况</li>
<li>本篇主要总结了一些比较实用的小技巧来解决这些情况<span id="more"></span></li>
</ul>
<h1 id="一、复制问题"><a href="#一、复制问题" class="headerlink" title="一、复制问题"></a>一、复制问题</h1><h2 id="1-插件"><a href="#1-插件" class="headerlink" title="1.插件"></a>1.插件</h2><ul>
<li>目前网上有很多油猴插件、浏览器插件可以解决这些办法</li>
<li>目前本篇没有收录，可以自行搜索</li>
</ul>
<h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2.代码"></a>2.代码</h2><ul>
<li><p>将下面这串代码保存成书签或者鼠标选中后拖放在浏览器书签栏</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:!function e(t)&#123;function n()&#123;&#125;function o(e)&#123;e[i].removeChild(e)&#125;function r(e)&#123;return[].slice.call(t.querySelectorAll(e))&#125;function c(t)&#123;function n()&#123;s(function()&#123;if(!o)try&#123;var n=t.contentDocument;n.body.childNodes.length&amp;&amp;(o=1,e(n))&#125;catch(e)&#123;o=0&#125;&#125;,100)&#125;a[l](function(e)&#123;t[&#x27;on&#x27;+e]=null&#125;);var o;n(),t.onload=n&#125;for(var i=&#x27;parentNode&#x27;,l=&#x27;forEach&#x27;,a=&#x27;contextmenu dragstart selectstart select copy beforecopy mouseup mousedown&#x27;.split(&#x27; &#x27;),u=setTimeout(n,0);u&gt;=0;u--)clearTimeout(u);for(u=setInterval(n,1e8);u&gt;=0;u--)clearInterval(u);var s=setTimeout;setTimeout=setInterval=n,r(&#x27;script&#x27;)[l](o);var m=[];r(&#x27;iframe,frame&#x27;)[l](function(e)&#123;m.push(e),e[i].replaceChild(t.createElement(&#x27;script&#x27;),e)&#125;);var f=t.documentElement.innerHTML;t.open(),t.write(&#x27;&lt;!DOCTYPE html&gt;&#x27;),t.close(),t.documentElement.innerHTML=f,r(&#x27;script&#x27;)[l](function(e)&#123;e[i].replaceChild(m.shift(),e)&#125;),r(&#x27;*&#x27;)[l](c),c(t),a[l](function(e)&#123;t.addEventListener(e,function(e)&#123;e.stopPropagation()&#125;,!0)&#125;);var p=t.createElement(&#x27;style&#x27;);p.innerHTML=&#x27;*&#123;-webkit-user-select:text!important;-moz-user-select:text!important;user-select:text!important;&#125;&#x27;,t.body.appendChild(p)&#125;(document);</span><br></pre></td></tr></table></figure></li>
<li><p>在禁止复制的页面上点击这个书签刷新页面就可以复制了</p>
</li>
<li><p>这串代码基本能破解98%的限制，包括文字、图片复制以及屏蔽页面右键菜单，将其保存到书签里使用起来相当的方便</p>
</li>
</ul>
<h2 id="3-开发者工具"><a href="#3-开发者工具" class="headerlink" title="3.开发者工具"></a>3.开发者工具</h2><ul>
<li>浏览器按下快捷键 F12 调出开发者工具找到需要复制的文字即可直接复制</li>
<li>或者直接右键查看元素，定位到要复制的文字内容直接复制即可</li>
</ul>
<h1 id="二、粘贴问题"><a href="#二、粘贴问题" class="headerlink" title="二、粘贴问题"></a>二、粘贴问题</h1><h2 id="1-输入框中无法粘贴"><a href="#1-输入框中无法粘贴" class="headerlink" title="1.输入框中无法粘贴"></a>1.输入框中无法粘贴</h2><ul>
<li>在该页面按下键盘的 F12，点击 <code>Console</code> ，按键盘的 F1 调出 Settings 界面，将 <code>Disable JavaScript</code> 和 <code>Color-code resource types</code>前面打上对勾</li>
<li>然后关闭 Settings，保留 Console 界面，这时就可以往输入框中粘贴东西了。</li>
<li>粘贴完毕以后，记得将上面的两个选项去掉对勾，以免造成不必要的损失</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>干货</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器：解决无法进入Github网站</title>
    <url>/enter-github.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本篇文章中的方法可以有效的解决电脑无法进入 Github 网站</li>
</ul>
<span id="more"></span>


<h1 id="一、方法"><a href="#一、方法" class="headerlink" title="一、方法"></a>一、方法</h1><h2 id="1-确定Github网站的ip"><a href="#1-确定Github网站的ip" class="headerlink" title="1.确定Github网站的ip"></a>1.确定Github网站的ip</h2><ul>
<li><p>打开该 <a href="https://github.com.ipaddress.com/">网址</a></p>
</li>
<li><p>在里面找到 <code>IP Address</code> 字段，如下：<br><img src="https://s1.ax1x.com/2020/10/20/BSQ7E6.png" alt="Github01.png"></p>
</li>
<li><p>然后打开记事本，按如下填写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.114.4	github.com</span><br></pre></td></tr></table></figure></li>
<li><p>如果有两个ip地址就都写上</p>
</li>
</ul>
<h2 id="2-确定域名ip"><a href="#2-确定域名ip" class="headerlink" title="2.确定域名ip"></a>2.确定域名ip</h2><ul>
<li><p>打开该 <a href="https://fastly.net.ipaddress.com/github.global.ssl.fastly.net">网址</a></p>
</li>
<li><p>在里面找到 <code>IP Address</code> 字段，如下：<br><img src="https://s1.ax1x.com/2020/10/20/BSQHUK.png" alt="Github02.png"></p>
</li>
<li><p>在记事本中继续添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.114.4	 github.com</span><br><span class="line">199.232.69.194   github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-确定静态资源ip"><a href="#3-确定静态资源ip" class="headerlink" title="3.确定静态资源ip"></a>3.确定静态资源ip</h2><ul>
<li><p>打开该 <a href="https://github.com.ipaddress.com/assets-cdn.github.com">网址</a></p>
</li>
<li><p>在里面找到 <code>IP Address</code> 字段，这里没有显示 ip 地址，就往下找找，如下：<br><img src="https://s1.ax1x.com/2020/10/20/BSQLCD.png" alt="Github03.png"></p>
</li>
<li><p>在记事本中继续添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">140.82.114.4	   github.com</span><br><span class="line">199.232.69.194     github.global.ssl.fastly.net</span><br><span class="line">185.199.108.153    assets-cdn.github.com</span><br><span class="line">185.199.109.153	   assets-cdn.github.com</span><br><span class="line">185.199.110.153	   assets-cdn.github.com</span><br><span class="line">185.199.111.153    assets-cdn.github.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-修改hosts文件"><a href="#4-修改hosts文件" class="headerlink" title="4.修改hosts文件"></a>4.修改hosts文件</h2><ul>
<li>在 <code>C:\Windows\System32\drivers\etc</code> 该路径下找到 hosts 文件</li>
<li>右键以记事本打开，将之前填写好的ip地址复制到最后面保存，如下：<br><img src="https://s1.ax1x.com/2020/10/20/BSQb4O.png" alt="Github04.png"></li>
</ul>
<h2 id="5-使hosts文件更新"><a href="#5-使hosts文件更新" class="headerlink" title="5.使hosts文件更新"></a>5.使hosts文件更新</h2><ul>
<li>可以关闭当前网络再重新开启，也可以重新启动电脑</li>
<li>这样就使hosts文件更新了，且Github也可以正常进入了</li>
</ul>
<h1 id="二、注意"><a href="#二、注意" class="headerlink" title="二、注意"></a>二、注意</h1><ul>
<li>因为服务器的变换原因，有时候ip地址一变换就导致再一次进入不了 Github（<font color=#F00><strong>我之前就是使用的网上的hosts文件，然后突然有一天不能用了</strong></font>） </li>
<li>只要自己再次进入上述网站更新下hosts文件即可</li>
</ul>
<h1 id="三、引申"><a href="#三、引申" class="headerlink" title="三、引申"></a>三、引申</h1><ul>
<li>该方法理论上可以解决其他访问速度慢的外网</li>
<li>只要在 <a href="https://www.ipaddress.com/">这个</a> 网站查询到需要进入的网站的ip地址并进行更新hosts即可</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>干货</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：JavaScript（尚硅谷）</title>
    <url>/Learn-JS.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 JavaScript 课程时的一些笔记</li>
<li>在线手册点击 <a href="https://www.w3schools.com/">这里</a></li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li><strong>JavaScript</strong> 主要用于处理网页中的前端验证</li>
<li><strong>ECMAScript</strong> 是如今 JavaScript 都遵循的一个标准<ul>
<li>缺陷：没有模块系统、标准库较少、没有标准接口、缺乏管理系统</li>
</ul>
</li>
<li>JS 的组成：<br><img src="https://s1.ax1x.com/2020/10/18/0j0btI.png" alt="js01.png"></li>
</ul>
<h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h2><ul>
<li>解释型语言</li>
<li>类似于 C 和 Java 的语法结构</li>
<li>动态语言</li>
<li>基于原型的面向对象</li>
</ul>
<h2 id="3-JS-编写位置"><a href="#3-JS-编写位置" class="headerlink" title="3.JS 编写位置"></a>3.JS 编写位置</h2><h3 id="1-内联样式"><a href="#1-内联样式" class="headerlink" title="(1).内联样式"></a>(1).内联样式</h3><ul>
<li><p>直接将 js  代码编写到标签的 onclick 的属性中去</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;讨厌，你点我干嘛&#x27;);&quot;</span>&gt;</span>点我一下<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>也可以直接将 js 代码编写到超链接的 href 属性中，这样点击的时候就会执行 js 代码了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(&#x27;让你点就点!&#x27;);&quot;</span>&gt;</span>你也点我一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>这样属于结构与行为耦合，不推荐使用</p>
</li>
</ul>
<h3 id="2-内部样式"><a href="#2-内部样式" class="headerlink" title="(2).内部样式"></a>(2).内部样式</h3><ul>
<li>使用 <code>&lt;script&gt;</code> 标签来编写 js 代码<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	alert(<span class="string">&quot;我是script中的代码&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-外部样式"><a href="#3-外部样式" class="headerlink" title="(3).外部样式"></a>(3).外部样式</h3><ul>
<li><p>使用 <code>&lt;script&gt;</code> 标签来引入外部的 js 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./js/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>该标签一旦用于引入外部文件，就不能在编写代码了，如果需要可以重新创建一个 <code>&lt;script&gt;</code> 标签</p>
</li>
</ul>
<h2 id="4-基本语法"><a href="#4-基本语法" class="headerlink" title="4.基本语法"></a>4.基本语法</h2><ul>
<li>JS 中严格区分大小写</li>
<li>JS 中每一条语句都以 <code>;</code> 结尾</li>
<li>JS 中会忽略多个空格和换行</li>
</ul>
<h2 id="5-常量和变量"><a href="#5-常量和变量" class="headerlink" title="5.常量和变量"></a>5.常量和变量</h2><h3 id="1-字面量（常量）"><a href="#1-字面量（常量）" class="headerlink" title="(1).字面量（常量）"></a>(1).字面量（常量）</h3><ul>
<li>都是一些不可改变的值</li>
<li>字面量都是可以直接使用的，但一般不直接使用</li>
</ul>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="(2).变量"></a>(2).变量</h3><ul>
<li><p>变量可以用来保存字面量，而且变量的值是可以任意改变的，故开发中都是通过变量去保存一个字面量的，很少直接使用字面量</p>
</li>
<li><p><font color=#F00>声明变量的方法：</font>在 JS 中使用 var 关键字来声明一个变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line">简写为：<span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure></li>
<li><p>可以通过遍历对字面量进行描述</p>
</li>
<li><p><font color=#F00>注意：使用 var 关键字声明的变量，会在所有的代码执行之前被声明但是不会赋值</font></p>
</li>
</ul>
<h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="(3).数据类型"></a>(3).数据类型</h3><ul>
<li><p>数据类型就是字面量的类型，在 JS 中一共有6种数据类型，如下：<br>String：字符串<br>Number：数值<br>Boolean：布尔值<br>Null：空值<br>Undefined：未定义<br>Object：对象</p>
</li>
<li><p>前面5个是基本（值）数据类型，最后一个是对象（引用）数据类型</p>
</li>
</ul>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a><font color=#32CD32>String</font></h4><ul>
<li>在 JS 中字符串需要使用引号引起来</li>
<li>引号不能嵌套，可以外单内双，外双内单</li>
<li>在字符串中可以使用 <code>\</code> 作为转义字符，表示特殊符号时可以使用转义字符来转义</li>
</ul>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a><font color=#32CD32>Number</font></h4><ul>
<li><p>在 JS 中所有的数值都是 Number 类型，包括整数和浮点数</p>
</li>
<li><p>可以使用一个运算符 typeof 来检查一个变量的类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a);</span><br></pre></td></tr></table></figure></li>
<li><p>JS 中可以表示数字的最大值，即 <code>Number.MAX_VALUE</code> ；如果使用 Number 表示的数字超过最大值，则会返回一个 Infinity ，表示正无穷（如：Number.MAX_VALUE * Number.MAX_VALUE）；而加个负号，则会返回一个 -Infinity，表示负无穷</p>
</li>
<li><p><strong>Infinity</strong> 就是一个字面量</p>
</li>
<li><p><strong>NaN</strong> 是一个特殊的数字，表示 Not A Number</p>
</li>
<li><p>JS 中可以表示数字的最小值，即 <code>Number.MIN_VALUE</code>，<font color=#F00>注意：这表示一个0以上的最小值</font></p>
</li>
<li><p>在 JS 中整数的运算基本可以保证精确，而浮点数的运算可能得到一个不精确的结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a><font color=#32CD32>Boolean</font></h4><ul>
<li><p>布尔值只有两个，真与假</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 typeof 检查一个布尔值时，显示 boolean</p>
</li>
</ul>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a><font color=#32CD32>Null</font></h4><ul>
<li>Null 类型的值只有一个，就是 null，专门用来表示一个为空的对象</li>
<li>使用 typeof 检查一个 Null 时，显示 object</li>
</ul>
<h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a><font color=#32CD32>Undefined</font></h4><ul>
<li>Undefined 类型的值只有一个，就是 undefined</li>
<li>当声明一个变量，但是先不给变量赋值时，它的值就是 undefined<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a><font color=#32CD32>Object</font></h4><ul>
<li>引用数据类型</li>
<li>含有两个特别的对象——Function和Array</li>
</ul>
<h3 id="4-强制数据类型转换"><a href="#4-强制数据类型转换" class="headerlink" title="(4).强制数据类型转换"></a>(4).强制数据类型转换</h3><ul>
<li>指将一个数据类型强制转换为其他的数据类型，主要是将其他的数据类型转换为 String、Number、Boolean</li>
</ul>
<h4 id="转换为-String"><a href="#转换为-String" class="headerlink" title="转换为 String"></a><font color=#32CD32>转换为 String</font></h4><ul>
<li><p>方式一：调用被转换数据类型的 toString() 方法，该方法不会影响到原变量。<font color=#F00>注意：null 和 undefined 这两个值没有 toString() 方法</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line"><span class="comment">//调用a的toString()方法</span></span><br><span class="line"><span class="keyword">var</span> b = a.toString();</span><br><span class="line">或：</span><br><span class="line"><span class="keyword">var</span> a = a.toString();</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：调用 String() 函数并将被转换的数据作为参数传递给函数。对于 Number 和 Boolean 实际上就是调用的 toString() 方法；而对于 null 和 undefined ，它会直接转换为字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</span><br><span class="line">a = <span class="built_in">String</span>(a);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="转换为-Number"><a href="#转换为-Number" class="headerlink" title="转换为 Number"></a><font color=#32CD32>转换为 Number</font></h4><ul>
<li><p>方式一：使用 Number() 函数来将 a 转换为 Number类型</p>
</li>
<li><p>字符串 - &gt; 数字：</p>
<ul>
<li>若是纯数字的字符串，则转换为数字</li>
<li>若字符串中有非数字的内容，则转换为 NaN</li>
<li>若字符串是空串或是一个全是空格的字符串，则转换为0</li>
</ul>
</li>
<li><p>布尔 - &gt; 数字：</p>
<ul>
<li>true 转成1，false 转成0</li>
</ul>
</li>
<li><p>Null - &gt; 数字：为0</p>
</li>
<li><p>Undefined - &gt; 数字：为NaN</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123 &quot;</span>;</span><br><span class="line">a = <span class="built_in">Number</span>(a);</span><br></pre></td></tr></table></figure></li>
<li><p>方式二：使用 parseInt() 函数来将一个字符串转换为一个整数；使用 parseFloat() 函数来将一个字符串转换为一个浮点数</p>
</li>
<li><p>对于非 String 类型使用以上两个函数会先将其转换为 String 类型，然后再操作（因此，该方式只适用于字符串类型）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;123px &quot;</span>;</span><br><span class="line">b = <span class="string">&quot;123.456 &quot;</span>;</span><br><span class="line">a = <span class="built_in">parseInt</span>(a);</span><br><span class="line">b = <span class="built_in">parseFloat</span>(b);</span><br></pre></td></tr></table></figure></li>
<li><p>为了避免有些浏览器将字符串 070 转数字时当8进制解析，可以在 parseInt() 中传递第二个参数，来制定数字的进制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;070&quot;</span>;</span><br><span class="line">a = <span class="built_in">parseInt</span>(a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="转换为-Boolean"><a href="#转换为-Boolean" class="headerlink" title="转换为 Boolean"></a><font color=#32CD32>转换为 Boolean</font></h4><ul>
<li>使用 Boolean() 函数来将其他数据类型转换为 Boolean</li>
<li>数字 - &gt; 布尔：除了 0 和 NaN，其余的都是 true</li>
<li>字符串 - &gt; 布尔：除了空串，其余的都是 true</li>
<li>Null和Undefined - &gt; 布尔：都是 false</li>
<li>对象 - &gt; 布尔：为 true</li>
</ul>
<h3 id="5-隐式的数据类型转换"><a href="#5-隐式的数据类型转换" class="headerlink" title="(5).隐式的数据类型转换"></a>(5).隐式的数据类型转换</h3><ul>
<li>将任意的数据类型转换为字符串可以在该数据类型后面加一个空串，实际上也是调用了 String() 函数</li>
<li>将任意的数据类型转换为数字可以在该数据类型后面 -0 或 *1 或 /1，实际上也是调用了 Number() 函数</li>
<li>将任意的数据类型转换为数字还可以使用一元运算符的 <code>+</code>  ，原理和 Number() 函数一样</li>
<li>将任意的数据类型转换为布尔值可以对该数据类型取两次反，原理和 Boolean() 函数一样</li>
</ul>
<h3 id="6-其他进制的数字表示"><a href="#6-其他进制的数字表示" class="headerlink" title="(6).其他进制的数字表示"></a>(6).其他进制的数字表示</h3><ul>
<li>在 JS 中表示16进制的数字，则需要以 0x 开头</li>
<li>在 JS 中表示8进制的数字，则需要以0开头</li>
<li>在 JS 中表示2进制的数字，则需要以 0b 开头，但有些浏览器并不支持</li>
</ul>
<h2 id="6-标识符"><a href="#6-标识符" class="headerlink" title="6.标识符"></a>6.标识符</h2><p>在 JS 中所有可以由我们自主命令的都为标识符，如：变量名，函数名，属性名</p>
<p>标识符规则：</p>
<ol>
<li>标识符可以含有 <code>字母、数字、_、$</code></li>
<li>标识符不能以数字开头</li>
<li>标识符不能是 ES 中的关键字或保留字</li>
<li>标识符一般采用驼峰命名法（首字母小写，每个单词开头大写）</li>
</ol>
<p>JS 中的关键字或保留字有：<br><img src="https://s1.ax1x.com/2020/10/18/0j0HAA.png" alt="js02.png"></p>
<p>JS 中其他不建议使用的标识符<br><img src="https://s1.ax1x.com/2020/10/18/0j0qht.png" alt="js03.png"></p>
<p>JS 底层保存标识符时实际上是采用的 Unicode 编码的方式</p>
<h2 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7.运算符"></a>7.运算符</h2><ul>
<li>运算符都会返回一个结果的</li>
<li>typeof 可以获得一个值的类型，将该值的类型以字符串的形式返回</li>
</ul>
<h3 id="1-算术运算符："><a href="#1-算术运算符：" class="headerlink" title="(1).算术运算符：+ - * / %"></a>(1).算术运算符：+ - * / %</h3><ul>
<li>当对非 Number 类型的值进行运算时，都会将这些值转为 Number 再进行计算 </li>
<li>任何值和 NaN 做运算，都是 NaN<br>如果对两个字符串进行加法运算，则会进行拼串操作</li>
<li>任何的值和字符串做加法运算时，都会先转换为字符串，然后再执行拼串操作</li>
<li>任何值做 - * / 运算时都会自动转换为 Number</li>
</ul>
<h3 id="2-一元运算符"><a href="#2-一元运算符" class="headerlink" title="(2).一元运算符"></a>(2).一元运算符</h3><ul>
<li>+：正号，结果不变</li>
<li>-：负号，用于取反</li>
</ul>
<h3 id="3-自增自减运算符"><a href="#3-自增自减运算符" class="headerlink" title="(3).自增自减运算符"></a>(3).自增自减运算符</h3><ul>
<li>无论 a++ 还是 ++a 都会使原变量的值自增1</li>
<li>a++ 是指原值，而 ++a 是指 a+1 的值</li>
</ul>
<h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="(4).逻辑运算符"></a>(4).逻辑运算符</h3><h4 id="非"><a href="#非" class="headerlink" title="非"></a>非</h4><ul>
<li>用 <code>!</code> 表示，即为取反操作</li>
<li>若对非布尔值进行取反，则将其转换为布尔值，再取反</li>
</ul>
<h4 id="与"><a href="#与" class="headerlink" title="与"></a>与</h4><ul>
<li>用 <code>&amp;&amp;</code> 表示，JS 中的与是短路与</li>
<li>若对非布尔值进行与运算时，会先将其转换为布尔值，然后再运算，并且返回原值</li>
<li>如果两个值都为 true ，则返回后边的</li>
<li>如果两个值中有 false，则返回靠前的 false</li>
</ul>
<h4 id="或"><a href="#或" class="headerlink" title="或"></a>或</h4><ul>
<li>用 <code>||</code>表示，JS 中的或是短路或</li>
<li>若对非布尔值进行或运算时，会先将其转换为布尔值，然后再运算，并且返回原值</li>
<li>如果第一个值为 true，则直接返回第一个值</li>
<li>如果第一个值为 false，则直接返回第二个值</li>
</ul>
<h3 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="(5).赋值运算符"></a>(5).赋值运算符</h3><ul>
<li><code>=</code> 、<code>+=</code> 、<code>-=</code> 、<code>*=</code>、<code>/=</code>、<code>%=</code></li>
</ul>
<h3 id="6-关系运算符"><a href="#6-关系运算符" class="headerlink" title="(6).关系运算符"></a>(6).关系运算符</h3><ul>
<li>通过关系运算符可以比较两个值之间的大小关系，成立返回 true，不成立返回 false</li>
<li><code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></li>
<li>非数值的情况下：</li>
<li>会将非数值转换为数值，然后再比较</li>
<li>任何值和 NaN 做任何比较都是 false</li>
<li>如果符号两端的值都是字符串时，不会将其转换为数值，而是分别比较字符串中字符的 Unicode 编码，比较时是一位一位进行比较，如果两位一样，则比较下一位（比较中文时没有意义）</li>
<li><font color=#f00>注意：比较两个字符串型的数字时，一定一定要转型</font></li>
</ul>
<h3 id="7-相等运算符"><a href="#7-相等运算符" class="headerlink" title="(7).相等运算符"></a>(7).相等运算符</h3><ul>
<li><p>通过相等运算符可以比较两个值是否相等，相等返回 true，不相等返回 false</p>
</li>
<li><p><code>==</code> 与 <code>!=</code> </p>
</li>
<li><p>如果值的类型不同，则会自动进行类型转换，将其转换为相同的类型，然后再比较</p>
</li>
<li><p><font color=#f00>注意：</font></p>
</li>
<li><p>Undefined 衍生自 Null，所以这两个值进行相等判断时，会返回 true</p>
</li>
<li><p>NaN 不和任何值相等，包括本身，因此 JS 中可以通过isNaN() 函数来判断一个值是否是 NaN</p>
</li>
<li><p><code>===</code> 为全等，用来判断两个值是否全等，和相等类似，但它不会自动进行类型转换</p>
</li>
<li><p><code>!==</code> 为不全等，用来判断两个值是否不全等，和不等类似，但它不会自动进行类型转换</p>
</li>
</ul>
<h3 id="8-条件-三元-运算符"><a href="#8-条件-三元-运算符" class="headerlink" title="(8).条件(三元)运算符"></a>(8).条件(三元)运算符</h3><ul>
<li>语法：<code>条件表达式?语句1:语句2;</code></li>
<li>流程：先对条件表达式进行求值，若该值为 true ，则执行语句1，反之语句2</li>
<li>可以嵌套来判断3个值中的最大值，但不推荐使用</li>
<li>如果条件表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算</li>
</ul>
<h3 id="9-逗号运算符"><a href="#9-逗号运算符" class="headerlink" title="(9).逗号运算符"></a>(9).逗号运算符</h3><ul>
<li>使用 <code>,</code> 可以分割多个语句，一般在声明多个变量时使用</li>
</ul>
<h3 id="10-in-运算符"><a href="#10-in-运算符" class="headerlink" title="(10).in 运算符"></a>(10).in 运算符</h3><ul>
<li>通过该运算符可以检查一个对象中是否含有指定的属性，如果有则返回 true，没有则返回 false</li>
<li>语法：”属性名” in 对象</li>
</ul>
<h3 id="11-运算符的优先级"><a href="#11-运算符的优先级" class="headerlink" title="(11).运算符的优先级"></a>(11).运算符的优先级</h3><ul>
<li>具体可以看如下图：<br><img src="https://s1.ax1x.com/2020/10/18/0j0T7d.png" alt="js04.png"></li>
</ul>
<h2 id="8-Unicode编码表"><a href="#8-Unicode编码表" class="headerlink" title="8.Unicode编码表"></a>8.Unicode编码表</h2><ul>
<li>在 JS 中需要在字符串中使用转义字符输出 Unicode 编码，即 <code>\u四位编码</code></li>
<li>在网页中使用转义字符输出 Unicode 编码，即 <code>&amp;#编码</code>（这里的编码是10进制的） </li>
</ul>
<h2 id="9-代码块"><a href="#9-代码块" class="headerlink" title="9.代码块"></a>9.代码块</h2><ul>
<li>在 JS 中可以使用 <code>&#123;&#125;</code> 来为语句进行分组，同一个大括号中的语句为一组语句，要么都执行，要么都不执行</li>
<li>代码块的后面不需要分号</li>
<li>JS 中的代码块只具有分组的作用</li>
</ul>
<h2 id="10-垃圾回收-GC"><a href="#10-垃圾回收-GC" class="headerlink" title="10.垃圾回收(GC)"></a>10.垃圾回收(GC)</h2><ul>
<li>当一个对象没有任何的变量或属性对它进行引用时，我们将永远无法操作该对象，此时这种对象就是垃圾，垃圾过多会占用大量的内存空间，导致程序运行变慢，所以垃圾必须清理</li>
<li>在 JS 中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁</li>
<li>我们只需要将不再使用的对象设置为 null 即可 <code>obj = null;</code> </li>
</ul>
<h1 id="二、流程控制语句"><a href="#二、流程控制语句" class="headerlink" title="二、流程控制语句"></a>二、流程控制语句</h1><h2 id="1-if-——-条件判断语句"><a href="#1-if-——-条件判断语句" class="headerlink" title="1.if —— 条件判断语句"></a>1.if —— 条件判断语句</h2><ul>
<li><p>语法1: <code>if(条件表达式) 语句</code> ，多条执行语句用代码块包含（单条执行语句也建议使用）</p>
</li>
<li><p>语法2: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	语句</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>语法3:可以多个 else if，该语法一旦有一个语句执行成功，剩余的语句都不会执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	语句</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">	语句</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color=#F00>注意：一般需要对非法数值进行处理，可以在 <code>if···else</code> 再嵌套 <code>if···else</code> 来进行处理</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(grade &gt; <span class="number">100</span> || grade &lt; <span class="number">0</span> || <span class="built_in">isNaN</span>(grade))&#123;</span><br><span class="line">	alert(<span class="string">&quot;输入非法数值！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(grade &lt; <span class="number">60</span>)&#123;</span><br><span class="line">		alert(<span class="string">&quot;很遗憾，没有任何奖励！&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(grade &lt; <span class="number">80</span>)&#123;</span><br><span class="line">		alert(<span class="string">&quot;奖励一本参考书&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(grade &lt; <span class="number">99</span>)&#123;</span><br><span class="line">		alert(<span class="string">&quot;奖励一台ipad&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		alert(<span class="string">&quot;奖励一台宝马&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-switch-——-条件分支语句"><a href="#2-switch-——-条件分支语句" class="headerlink" title="2.switch —— 条件分支语句"></a>2.switch —— 条件分支语句</h2><ul>
<li>该语句会依次将 switch 后的条件表达式和 case 后的条件表达式进行全等比较</li>
<li>语法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(条件表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 表达式：</span><br><span class="line">		语句</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 表达式：</span><br><span class="line">		语句</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 表达式：</span><br><span class="line">		语句</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 表达式：</span><br><span class="line">		语句</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3.循环语句"></a>3.循环语句</h2><h3 id="1-while"><a href="#1-while" class="headerlink" title="(1).while"></a>(1).while</h3><ul>
<li>用法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)&#123;</span><br><span class="line">	语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-do···while"><a href="#2-do···while" class="headerlink" title="(2).do···while"></a>(2).do···while</h3><ul>
<li>用法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-for"><a href="#3-for" class="headerlink" title="(3).for"></a>(3).for</h3><ul>
<li>用法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式;条件表达式;更新表达式)&#123;</span><br><span class="line">	语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>for 循环中的三个部分都可以省略，也可以写在外部；若不写任何表达式，只写两个分号，则为死循环</li>
</ul>
<h4 id="！质数练习中的思维："><a href="#！质数练习中的思维：" class="headerlink" title="！质数练习中的思维："></a>！质数练习中的思维：</h4><ul>
<li>如果无法通过余数不为0来进行判断，那么可以逆向思维，用余数为0来判断。可以使用中间变量来取出所需要的值 </li>
<li>为了提高性能，可以适当的使用 break </li>
<li>实际上，内层循环有一部分的运算是毫无意义的，当检验到一个数的开方处时，后面的数值其实已经都进行过判断了，所以内层循环就不需要一直运算到i，只要运算到i的开方即可，即：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">2</span>;j&lt;=<span class="built_in">Math</span>.sqrt(i);j++)&#123;</span><br><span class="line">	代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="！九九乘法表中的思维："><a href="#！九九乘法表中的思维：" class="headerlink" title="！九九乘法表中的思维："></a>！九九乘法表中的思维：</h4><ul>
<li>在使用for循环实现九九乘法表时，发现虽然在每个式子中间加了空格，但其实在前几行是上下不对齐的，这样并不美观</li>
<li>解决方法就是，在 document 函数中前后用双引号与加号填入 <code>&lt;span&gt;</code> 标签，然后对 <code>&lt;span&gt;</code> 标签进行相应的css设置，如下：<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-break-amp-continue"><a href="#4-break-amp-continue" class="headerlink" title="4.break &amp; continue"></a>4.break &amp; continue</h2><h3 id="1-break"><a href="#1-break" class="headerlink" title="(1).break"></a>(1).break</h3><ul>
<li>用于退出 switch 和循环语句，他会立即终止离他最近的那个循环语句</li>
<li>可以为循环语句创建一个 label，来标识当前的循环，语法为：<code>label: 循环语句</code> ，使用 break 语句时，在 break 后跟上 label，这样 break 会结束指定的循环，而不是最近的</li>
<li>灵活使用 break 可以提高性能</li>
</ul>
<h3 id="2-continue"><a href="#2-continue" class="headerlink" title="(2).continue"></a>(2).continue</h3><ul>
<li>用于跳过当次循环，默认只会对离他最近的循环起作用</li>
<li>跳过指定循环与 break 类似，使用 label</li>
</ul>
<h1 id="三、对象"><a href="#三、对象" class="headerlink" title="三、对象"></a>三、对象</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h2><ul>
<li>即 Object，为引用数据类型，之前的都为基本数据类型，基本数据类型都是单一的值，值和值之间没有任何的联系</li>
<li>对象属于一种复合的数据类型，可以<font color=#F00><strong>保存多个不同的数据类型</strong></font>的属性</li>
<li>一个对象代表现实中的一个事物</li>
<li>对象由属性和方法（属性值是函数）组成</li>
</ul>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><h3 id="1-内建对象"><a href="#1-内建对象" class="headerlink" title="(1).内建对象"></a>(1).内建对象</h3><ul>
<li>由ES标准中定义的对象，在任何的ES的实现中都可以使用，如：Math、String、Number、Function、Object</li>
</ul>
<h3 id="2-宿主对象"><a href="#2-宿主对象" class="headerlink" title="(2).宿主对象"></a>(2).宿主对象</h3><ul>
<li>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象，如：BOM、DOM</li>
</ul>
<h3 id="3-自定义对象"><a href="#3-自定义对象" class="headerlink" title="(3).自定义对象"></a>(3).自定义对象</h3><ul>
<li>由开发人员自己创建的对象</li>
</ul>
<h2 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3.基本操作"></a>3.基本操作</h2><h3 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="(1).创建对象"></a>(1).创建对象</h3><ul>
<li>使用 new 关键字调用构造函数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-向对象添加属性"><a href="#2-向对象添加属性" class="headerlink" title="(2).向对象添加属性"></a>(2).向对象添加属性</h3><ul>
<li>对象中保存的值为属性</li>
<li>语法：对象.属性名 = 属性值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.name = <span class="string">&quot;孙悟空&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-读取对象的属性"><a href="#3-读取对象的属性" class="headerlink" title="(3).读取对象的属性"></a>(3).读取对象的属性</h3><ul>
<li>语法：对象.属性名</li>
<li><font color=#F00>注意：如果读取对象中没有的属性，不会报错但会返回 undefined</font></li>
</ul>
<h3 id="4-修改对象的属性值"><a href="#4-修改对象的属性值" class="headerlink" title="(4).修改对象的属性值"></a>(4).修改对象的属性值</h3><ul>
<li>语法：对象.属性名 = 属性值</li>
</ul>
<h3 id="5-删除对象的属性"><a href="#5-删除对象的属性" class="headerlink" title="(5).删除对象的属性"></a>(5).删除对象的属性</h3><ul>
<li>语法：delete 对象.属性名</li>
</ul>
<h2 id="4-属性名和属性值"><a href="#4-属性名和属性值" class="headerlink" title="4.属性名和属性值"></a>4.属性名和属性值</h2><ul>
<li><p>对象的属性名不强制要求遵循标识符的规范，尽量避免</p>
</li>
<li><p>如果使用特殊的属性名，不能采用点的方式，需要使用该方法 —— 语法为：对象[“属性名”] = 属性值；读取时也使用该方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj[<span class="string">&quot;123&quot;</span>] = <span class="number">456</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">&quot;123&quot;</span>]);</span><br></pre></td></tr></table></figure></li>
<li><p>JS 中的属性值可以是任意的数据类型，包括对象与函数</p>
</li>
<li><p>使用 in 运算符检查是否含有指定属性，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&quot;孙悟空&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> obj);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-基本与引用数据类型"><a href="#5-基本与引用数据类型" class="headerlink" title="5.基本与引用数据类型"></a>5.基本与引用数据类型</h2><ul>
<li><p>基本数据类型的值是直接在栈内存中存储的，值与值之间是独立存在的</p>
</li>
<li><p>引用数据类型中的对象是保存到堆内存中，每创建一个对象，就会在堆内存中开辟一个新的空间，用来保存属性名与属性值，在栈内存中变量存的是对象的名字，值保存的是对象的内存地址，如下：<br><img src="https://s1.ax1x.com/2020/10/18/0j0o0H.png" alt="js05"></p>
</li>
<li><p>当比较两个引用数据类型时，比较的是地址的值！！！</p>
</li>
</ul>
<h2 id="6-对象字面量"><a href="#6-对象字面量" class="headerlink" title="6.对象字面量"></a>6.对象字面量</h2><ul>
<li>使用对象字面量可以在创建对象的时候，直接指定对象中的属性</li>
<li>语法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;属性名:属性值,属性名:属性值....&#125;;	<span class="comment">//可以有无数个，最后一个不加逗号</span></span><br><span class="line">格式美化如下：</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;猪八戒&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">18</span>,</span><br><span class="line">	<span class="attr">gender</span>:<span class="string">&quot;男&quot;</span>,</span><br><span class="line">	<span class="attr">test</span>:&#123;</span><br><span class="line">		<span class="attr">name</span>:<span class="string">&quot;沙和尚&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>对象字面量的属性名可以加引号也可以不加，如果要使用一些特殊的名字，则必须加引号</li>
</ul>
<h2 id="7-函数作为对象的属性"><a href="#7-函数作为对象的属性" class="headerlink" title="7.函数作为对象的属性"></a>7.函数作为对象的属性</h2><ul>
<li>如果一个函数作为一个对象的属性保存，则称为该对象的方法</li>
<li>调用这个函数即为调用对象的方法</li>
</ul>
<h2 id="8-枚举对象中的属性"><a href="#8-枚举对象中的属性" class="headerlink" title="8.枚举对象中的属性"></a>8.枚举对象中的属性</h2><ul>
<li><p>使用 <code>for in</code> 语句，语法为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> 变量n <span class="keyword">in</span> 对象)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>每次执行时，会将对象中的一个属性的名字赋值给变量，所以取对象的属性与属性值可以如下操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> n <span class="keyword">in</span> obj)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(n);			<span class="comment">//取对象的属性</span></span><br><span class="line">	<span class="built_in">console</span>.log(obj[n]);	<span class="comment">//取对象的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、内建对象"><a href="#四、内建对象" class="headerlink" title="四、内建对象"></a>四、内建对象</h1><h2 id="1-函数对象"><a href="#1-函数对象" class="headerlink" title="1.函数对象"></a>1.函数对象</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="(1).简介"></a>(1).简介</h3><ul>
<li>函数也是个对象，函数中可以封装一些功能，在需要时可以执行这些功能</li>
</ul>
<h4 id="1-使用构造函数创建函数对象"><a href="#1-使用构造函数创建函数对象" class="headerlink" title="1).使用构造函数创建函数对象"></a>1).使用构造函数创建函数对象</h4><ul>
<li><p>创建一个函数对象，语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;代码&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>将要封装的代码以字符串的形式传递给构造函数</p>
</li>
<li><p>调用函数的语法：<code>函数对象()</code>，如：fun()</p>
</li>
<li><p><font color=#F00>！注意：开发中不常用</font></p>
</li>
</ul>
<h4 id="2-使用函数声明来创建函数"><a href="#2-使用函数声明来创建函数" class="headerlink" title="2).使用函数声明来创建函数"></a>2).使用函数声明来创建函数</h4><ul>
<li><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">[形参<span class="number">1</span>,形参<span class="number">2</span>,形参....]</span>)</span>&#123;		<span class="comment">//这里中括号是可选的意思，实际开发中不写</span></span><br><span class="line">	语句...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用方法：<code>函数名()</code></p>
</li>
<li><p><font color=#F00>注意：使用该方式创建的函数会在所有的代码执行之前就被创建</font></p>
</li>
</ul>
<h4 id="3-使用函数表达式创建函数"><a href="#3-使用函数表达式创建函数" class="headerlink" title="3).使用函数表达式创建函数"></a>3).使用函数表达式创建函数</h4><ul>
<li>声明匿名函数然后赋值给了变量，语法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 函数名 = <span class="function"><span class="keyword">function</span>(<span class="params">[形参<span class="number">1</span>,形参<span class="number">2</span>,形参....]</span>)</span>&#123;		<span class="comment">//这里中括号是可选的意思，实际开发中不写</span></span><br><span class="line">	语句...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-函数的参数"><a href="#2-函数的参数" class="headerlink" title="(2).函数的参数"></a>(2).函数的参数</h3><ul>
<li><p>可以在函数的()中指定一个或多个形参，之间使用 <code>,</code> 隔开</p>
</li>
<li><p>在调用函数时，可以在()中指定实参，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>调用函数解析器时不会检查实参的类型，因此可能会接收到非法的参数</p>
</li>
</ul>
<h4 id="！对象也可以作为函数的实参"><a href="#！对象也可以作为函数的实参" class="headerlink" title="！对象也可以作为函数的实参"></a>！对象也可以作为函数的实参</h4><ul>
<li>当需要传入多个参数时，可以使用对象来进行封装，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;我是&quot;</span>+o.name+<span class="string">&quot;，我今年&quot;</span>+o.age+<span class="string">&quot;岁了，我住在&quot;</span>+o.address+<span class="string">&quot;。&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;张砚耕&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">	<span class="attr">address</span>:<span class="string">&quot;大同大学&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">sayHello(obj);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="！函数也可以作为函数的实参"><a href="#！函数也可以作为函数的实参" class="headerlink" title="！函数也可以作为函数的实参"></a>！函数也可以作为函数的实参</h4><ul>
<li><code>fun(mianji(10));</code> ：调用函数，相当于使用的函数的返回值</li>
<li><code>fun(mianji);</code> ：函数对象，相当于直接使用函数对象</li>
</ul>
<h3 id="3-返回值"><a href="#3-返回值" class="headerlink" title="(3).返回值"></a>(3).返回值</h3><ul>
<li>可以使用 return 来设置函数的返回值，且其后的语句不会执行</li>
<li>return 后的值会作为函数的执行结果返回，可以定义一个变量来接收该结果，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> d = a + b + c;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-立即执行函数（IIFE）"><a href="#4-立即执行函数（IIFE）" class="headerlink" title="(4).立即执行函数（IIFE）"></a>(4).立即执行函数（IIFE）</h3><ul>
<li>函数定义完以后，立即被调用，称为立即执行函数</li>
<li>将匿名函数放在括号中，就不会出现报错，最后再加一个括号，就变成了立即执行函数：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;我是匿名函数！&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-作用域"><a href="#5-作用域" class="headerlink" title="(5).作用域"></a>(5).作用域</h3><ul>
<li>指一个变量的作用的范围</li>
<li>JS 中分为全局作用域和函数作用域</li>
</ul>
<h4 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1).全局作用域"></a>1).全局作用域</h4><ul>
<li>直接编写在 <code>&lt;script&gt;</code> 标签中的JS代码，都在全局作用域中</li>
<li>在页面打开时创建，在页面关闭时销毁</li>
<li>在该作用域中有一个全局对象 window ，代表浏览器的窗口</li>
<li>在该作用域中，创建的变量都会作为 window 对象的属性保存，而创建的函数都会作为方法保存</li>
</ul>
<h4 id="2-函数作用域"><a href="#2-函数作用域" class="headerlink" title="2).函数作用域"></a>2).函数作用域</h4><ul>
<li>在函数调用时创建，在函数执行完毕时销毁</li>
<li>每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的</li>
<li>要在函数中调用全局变量可以使用 window 对象</li>
<li>在函数作用域中也有声明提前的特性</li>
<li>在函数中不使用 var 声明的变量都是全局变量</li>
<li>定义形参就相当于在函数作用域中声明了变量，所以此时无法访问全局变量下的同名变量</li>
</ul>
<h3 id="6-两个隐含参数"><a href="#6-两个隐含参数" class="headerlink" title="(6).两个隐含参数"></a>(6).两个隐含参数</h3><h4 id="1-this"><a href="#1-this" class="headerlink" title="1).this"></a>1).this</h4><ul>
<li>浏览器在调用函数时每次都会向函数内部传递进两个隐含的参数，其中一个是 this</li>
<li>this 指向的是一个对象，这个对象为函数执行的 <strong>上下文对象</strong></li>
<li>根据函数的调用方式的不同，this 会指向不同的对象<br>以函数的形式调用时，this永远都是window<br>以方法的形式调用时，this就是调用方法的那个对象<br>（在事件的相应函数中，响应函数是给谁绑定的，this就是谁）<br>以构造函数的形式调用时，this就是新创建的那个对象<br>以call()和apply()方法调用时，this就是指定的那个对象</li>
</ul>
<h4 id="2-arguments"><a href="#2-arguments" class="headerlink" title="2).arguments"></a>2).arguments</h4><ul>
<li>浏览器在调用函数时每次都会向函数内部传递进两个隐含的参数，其中一个是 arguments</li>
<li>arguments 是一个 <strong>类数组对象</strong>，它也可以通过索引来操作数据，也可以获取长度</li>
<li>在调用函数时，我们所传递的实参都会在 arguments 中保存</li>
<li>我们即使不定义形参，也可以通过 arguments 来使用实参，只不过比较麻烦。比如：arguments[0]表示第一个实参，arguments[1]表示第二个实参</li>
<li>在它里边还有一个属性叫做 callee，这个属性对应一个函数对象，就是当前正在指向的函数的对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee);</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-创建对象"><a href="#7-创建对象" class="headerlink" title="(7).创建对象"></a>(7).创建对象</h3><h4 id="1-使用工厂方法创建对象"><a href="#1-使用工厂方法创建对象" class="headerlink" title="1).使用工厂方法创建对象"></a>1).使用工厂方法创建对象</h4><ul>
<li>通过该方法可以大批量的创建对象</li>
<li>该方法主要思想是创建一个对象及属性的容器，然后在需要调用时直接传入相应的参数即可，具体如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatPerson</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//创建一个新的对象</span></span><br><span class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">	<span class="comment">//向对象中添加属性</span></span><br><span class="line">	obj.name = name;</span><br><span class="line">	obj.age = age;</span><br><span class="line">	obj.gender = gender;</span><br><span class="line">	obj.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = creatPerson(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> obj2 = creatPerson(<span class="string">&quot;猪八戒&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">obj1.sayName();</span><br></pre></td></tr></table></figure>

<ul>
<li>在创建的函数中需要将自己创建的对象返回</li>
<li><font color=#F00>缺点：使用的构造函数都是 Object，所以创建的对象都是 Object，导致无法区分出多种不同类型的对象</font></li>
</ul>
<h4 id="2-使用构造函数创建对象"><a href="#2-使用构造函数创建对象" class="headerlink" title="2).使用构造函数创建对象"></a>2).使用构造函数创建对象</h4><p>构造函数在创建方式上和普通函数没有任何区别，不同的是构造函数习惯上首字母大写</p>
<p>区别：普通函数直接调用，构造函数使用new关键字来调用</p>
<p>构造函数的执行流程：</p>
<ol>
<li>立刻创建一个新的对象</li>
<li>将新建的对象设置为函数中的 this，在构造函数中可以使用 this 来引用新建的对象</li>
<li>逐行执行函数中的代码</li>
<li>将新建的对象作为返回值返回</li>
</ol>
<p>构造函数称为类，而其创建的对象称为一类对象，通过一个构造函数创建的对象称之为该类的实例</p>
<h5 id="基础法创建："><a href="#基础法创建：" class="headerlink" title="基础法创建："></a>基础法创建：</h5><ul>
<li><p>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">	<span class="built_in">this</span>.gender = gender;</span><br><span class="line">	<span class="comment">//向对象中添加一个方法</span></span><br><span class="line">	<span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per);</span><br></pre></td></tr></table></figure></li>
<li><p>缺点：该方法中的函数每执行一次就会创建一个新的方法，完全可以使所有的对象共享同一个方法</p>
</li>
</ul>
<h5 id="进阶法创建："><a href="#进阶法创建：" class="headerlink" title="进阶法创建："></a>进阶法创建：</h5><ul>
<li><p>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">	<span class="built_in">this</span>.gender = gender;</span><br><span class="line">	<span class="comment">//向对象中添加一个方法</span></span><br><span class="line">	<span class="built_in">this</span>.sayName = fun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将sayName方法在全局作用域中定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per);</span><br></pre></td></tr></table></figure></li>
<li><p>缺点：将函数定义在全局作用域中，污染了全局作用域的命名空间，而且很不安全</p>
</li>
</ul>
<h5 id="原型法创建-完美！-："><a href="#原型法创建-完美！-：" class="headerlink" title="原型法创建(完美！)："></a>原型法创建(完美！)：</h5><ul>
<li>原型相关内容可以看第8点，代码如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">	<span class="built_in">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向原型中添加sayName方法</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> per = <span class="keyword">new</span> Person(<span class="string">&quot;孙悟空&quot;</span>,<span class="number">18</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per);</span><br><span class="line">per.sayName();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-原型（prototype）"><a href="#8-原型（prototype）" class="headerlink" title="(8).原型（prototype）"></a>(8).原型（prototype）</h3><h4 id="1-基础内容"><a href="#1-基础内容" class="headerlink" title="1).基础内容"></a>1).基础内容</h4><ul>
<li><p>我们所创建的每一个函数，解析器都会向函数中添加一个属性 prototype，这个属性对应着一个对象，这个对象就是<strong>原型对象</strong></p>
</li>
<li><p>如果函数作为普通函数调用时，prototype 没有任何作用；如果函数以构造函数形式调用时，它所创建的对象中都会有一个隐含的属性，指向该构造函数的原型对象，可以通过 <code>__proto__</code> 来访问该属性（两个下划线）</p>
</li>
<li><p>原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，所以向这个原型对象中添加属性即 <code>MyClass.prototype.a = 123;</code><br><img src="https://s1.ax1x.com/2020/10/18/0j0O9P.png" alt="js06.png"></p>
</li>
<li><p>当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用；如果没有则会去原型对象中寻找，如果有则直接使用；如果没有则去原型的原型中寻找，直到找到 Object 对象的原型（它没有原型），如果在 Object 的原型中依然没有找到，则返回 <code>undefined</code> </p>
</li>
<li><p><font color=#F00>总结：以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，就可以使每个对象都具有这些属性和方法了</font></p>
</li>
</ul>
<h4 id="2-检查非原型对象中的属性"><a href="#2-检查非原型对象中的属性" class="headerlink" title="2).检查非原型对象中的属性"></a>2).检查非原型对象中的属性</h4><ul>
<li>使用in运算符可以检查到对象中含有某个原型对象的属性，但实际是要检查该对象中有没有属性，所以可以使用对象的 <code>hasOwnProperty()</code> 来检查对象自身是否含有该属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(per.hasOwnProperty(<span class="string">&quot;name&quot;</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-原型对象的toString-方法"><a href="#3-原型对象的toString-方法" class="headerlink" title="3).原型对象的toString()方法"></a>3).原型对象的toString()方法</h4><ul>
<li><p>当我们直接在页面中打印一个对象时，实际上是输出对象的 toString() 方法的返回值</p>
</li>
<li><p>如果我们希望在输出对象时不输出 [object Object] ，可以为原型对象添加一个 toString() 方法，且方法中需要填写返回值</p>
</li>
<li><p>如果想要输出对象内容，即 Person[name=孙悟空,age=18,gender=男] 这样的格式，如下操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Person.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Person[name=&quot;</span>+<span class="built_in">this</span>.name+<span class="string">&quot;,age=&quot;</span>+<span class="built_in">this</span>.age+<span class="string">&quot;,gender=&quot;</span>+<span class="built_in">this</span>.gender+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color=#F00>注意：谷歌浏览器不会输出 toString() 方法，而是会直接输出对象中的内容</font></p>
</li>
</ul>
<h3 id="9-常见函数"><a href="#9-常见函数" class="headerlink" title="(9).常见函数"></a>(9).常见函数</h3><h4 id="1-alert"><a href="#1-alert" class="headerlink" title="1).alert()"></a>1).alert()</h4><ul>
<li>alert() 函数可以控制浏览器弹出一个警告框</li>
<li>语法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">&quot;这是第一条函数&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-confirm"><a href="#2-confirm" class="headerlink" title="2).confirm()"></a>2).confirm()</h4><ul>
<li>用于弹出一个带有确认和取消按钮的提示框</li>
<li>需要一个字符串作为参数，该字符串将会作为提示文字显示出来</li>
<li>如果用户点击确认则返回true，反之返回false</li>
</ul>
<h4 id="3-document-write"><a href="#3-document-write" class="headerlink" title="3).document.write()"></a>3).document.write()</h4><ul>
<li><p>document.write() 函数可以在页面中输出一个内容</p>
</li>
<li><p>语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;页面中的内容&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>因为该语句是在网页的 <code>&lt;body&gt;</code> 中显示的，所以如果要在这里面换行的话，是需要使用换行标签的，而不是 <code>\n</code> </p>
</li>
</ul>
<h4 id="4-console-log"><a href="#4-console-log" class="headerlink" title="4).console.log()"></a>4).console.log()</h4><ul>
<li>console.log() 函数可以在控制台中输出一个内容</li>
<li>语法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;控制台中的内容&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-console-time"><a href="#5-console-time" class="headerlink" title="5).console.time()"></a>5).console.time()</h4><ul>
<li>console.time() 函数可以开启一个计时器，它需要一个字符串作为参数，这个字符串会作为计时器的标识</li>
<li>该函数与 console.timeEnd() 函数一起使用</li>
<li>语法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">中间代码</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-prompt"><a href="#6-prompt" class="headerlink" title="6).prompt()"></a>6).prompt()</h4><ul>
<li><p>prompt() 函数可以弹出一个提示框，且提示框中会带有文本框</p>
</li>
<li><p>该函数需要一个字符串作为参数，该字符串将会作为提示框的提示文字</p>
</li>
<li><p>用户输入的内容将会作为函数的返回值返回，所以需要定义一个变量来接收该内容</p>
</li>
<li><p>语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> test = prompt(<span class="string">&quot;请输入数字：&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><font color=#F00>注意：该函数的返回值是 String 类型的，如果想要转换为数值类型的，则需要在其前面加一个 + 号</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = +prompt(<span class="string">&quot;请输入变量1：&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-parseInt"><a href="#7-parseInt" class="headerlink" title="7).parseInt()"></a>7).parseInt()</h4><ul>
<li>可以对值进行取整</li>
</ul>
<h4 id="8-Math-sqrt"><a href="#8-Math-sqrt" class="headerlink" title="8).Math.sqrt()"></a>8).Math.sqrt()</h4><ul>
<li>可以对一个数值进行开方</li>
</ul>
<h3 id="10-函数的方法"><a href="#10-函数的方法" class="headerlink" title="(10).函数的方法"></a>(10).函数的方法</h3><h4 id="1-call-和apply"><a href="#1-call-和apply" class="headerlink" title="1).call()和apply()"></a>1).call()和apply()</h4><ul>
<li><p>这两个是函数对象的方法，需要通过函数对象来调用（即没有括号）</p>
</li>
<li><p>可以让一个函数成为指定任意对象的方法进行调用</p>
</li>
<li><p>当对函数调用 call() 和 apply() 都会调用函数执行，在调用 call() 和 apply() 时可以将一个对象指定为第一个参数，此时这个对象将会成为函数执行时的 this</p>
</li>
<li><p>call() 方法可以将实参在对象之后依次传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a = &quot;</span>+a);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;b = &quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">	<span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">fun.call(obj,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>apply() 方法需要将实参封装到一个数组中统一传递</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;a = &quot;</span>+a);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&quot;b = &quot;</span>+b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">	<span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">fun.apply(obj,[<span class="number">3</span>,<span class="number">4</span>]);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-bind"><a href="#2-bind" class="headerlink" title="2).bind()"></a>2).bind()</h4><ul>
<li>该方法主要将函数绑定到某个对象中，可以解决 this 相关问题</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>).<span class="title">bind</span>(<span class="params"><span class="built_in">this</span></span>)</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="built_in">this</span>.function()</span><br></pre></td></tr></table></figure>

<h2 id="2-数组对象"><a href="#2-数组对象" class="headerlink" title="2.数组对象"></a>2.数组对象</h2><h3 id="1-简介-2"><a href="#1-简介-2" class="headerlink" title="(1).简介"></a>(1).简介</h3><ul>
<li>数组也是对象，也是用来存储一些值，不同的是，普通对象是使用字符串作为属性名的，而数组是使用数字来作为索引操作元素</li>
<li>作用：数组的存储性能比普通对象好，开发中常用</li>
</ul>
<h3 id="2-操作"><a href="#2-操作" class="headerlink" title="(2).操作"></a>(2).操作</h3><ul>
<li>创建数组对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();		<span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);		<span class="comment">//创建时直接指定数组中元素</span></span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);		<span class="comment">//当只传入一个整数时代表创建一个长度为10的数组</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>向数组中添加元素，语法：<code>数组[索引] = 值</code> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>读取数组中的元素，语法：<code>数组[索引]</code> 。如果读取不存在的索引，不会报错反而会返回 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li>
<li><p>获取数组的长度，可以使用 length 属性来获取数组的长度，语法：<code>数组.length</code></p>
<ul>
<li>对于连续的数组，使用 length 可以获取到数组的长度（元素的个数）；对于非连续的数组，使用 length 会获取到数组的最大的索引+1<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.length);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>修改length。如果修改的length大于原长度，则多出部分会空出来；如果修改的length小于原长度，则多出部分会被删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.length = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>向数组的最后一个位置添加元素，语法：<code>数组[数组.length] = 值;</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[arr.length] = <span class="number">70</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-数组字面量"><a href="#3-数组字面量" class="headerlink" title="(3).数组字面量"></a>(3).数组字面量</h3><ul>
<li><p>使用字面量创建数组，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];		<span class="comment">//创建时直接指定数组中元素</span></span><br><span class="line">arr = [<span class="number">10</span>];					<span class="comment">//当只传入一个整数时代表创建一个数组只有一个元素10</span></span><br></pre></td></tr></table></figure></li>
<li><p>数组中的元素可以是任意的数据类型，即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr = [<span class="string">&quot;hello&quot;</span>,<span class="number">1</span>,<span class="literal">true</span>,<span class="literal">null</span>,<span class="literal">undefined</span>];</span><br><span class="line"><span class="comment">//可以是对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;孙悟空&quot;</span>&#125;;</span><br><span class="line">arr[arr.length] = obj;</span><br><span class="line">arr = [&#123;<span class="attr">name</span>:<span class="string">&quot;孙悟空&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;猪八戒&quot;</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&quot;沙和尚&quot;</span>&#125;];</span><br><span class="line"><span class="comment">//可以是函数</span></span><br><span class="line">arr = [<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;];</span><br><span class="line"><span class="comment">//可以是数组，即二维数组</span></span><br><span class="line">arr = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]];</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-数组的方法"><a href="#4-数组的方法" class="headerlink" title="(4).数组的方法"></a>(4).数组的方法</h3><h4 id="1-push"><a href="#1-push" class="headerlink" title="1).push()"></a>1).push()</h4><ul>
<li>向数组的末尾添加一个或多个元素，并返回数组的新长度</li>
<li>可以将要添加的元素作为方法的参数传递，这样这些元素将会自动添加到数组的末尾<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line">arr.push(<span class="string">&quot;小D&quot;</span>,<span class="string">&quot;小E&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-pop"><a href="#2-pop" class="headerlink" title="2).pop()"></a>2).pop()</h4><ul>
<li>删除数组的最后一个元素，并将删除的元素作为返回值返回<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line">arr.pop();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-unshift"><a href="#3-unshift" class="headerlink" title="3).unshift()"></a>3).unshift()</h4><ul>
<li>向数组的开头添加一个或多个元素，并返回新的数组长度</li>
<li>向前边插入元素以后，其他的元素索引会依次调整<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line">arr.unshift(<span class="string">&quot;小D&quot;</span>,<span class="string">&quot;小E&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-shift"><a href="#4-shift" class="headerlink" title="4).shift()"></a>4).shift()</h4><ul>
<li>删除数组的第一个元素，并将删除的元素作为返回值返回<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line">arr.shift();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-slice"><a href="#5-slice" class="headerlink" title="5).slice()"></a>5).slice()</h4><ul>
<li><p>可以用来从数组中提取指定元素，该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回</p>
</li>
<li><p>该方法总共有两个参数：<br>第一个参数：截取开始的位置的索引，包含开始索引（左闭）<br>第二个参数：截取结束的位置的索引，不包含结束索引（右开）</p>
</li>
<li><p>以上参数中的索引也可以传递一个负值，就会从后往前计算，-1为倒数第一个，-2为倒数第二个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-splice"><a href="#6-splice" class="headerlink" title="6).splice()"></a>6).splice()</h4><ul>
<li><p>可以用于删除数组中的指定元素并在相应位置插入需要的元素，该方法会影响到原数组，会将指定元素从原数组中删除并将被删除的元素作为返回值返回</p>
</li>
<li><p>该方法固定参数有两个，剩余参数由具体情况而定<br>第一个参数：表示开始位置的索引<br>第二个参数：表示删除的数量<br>第三个及以后参数：可以传递一些新的元素，这些元素将会自动插入到开始位置索引的前边</p>
</li>
<li><p>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.splice(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&quot;小AA&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-concat"><a href="#7-concat" class="headerlink" title="7).concat()"></a>7).concat()</h4><ul>
<li>可以连接两个或多个数组，并将新的数组返回</li>
<li>该方法不会对原数组产生影响<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&quot;小D&quot;</span>,<span class="string">&quot;小E&quot;</span>,<span class="string">&quot;小F&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.concat(arr1,arr2,<span class="string">&quot;小G&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="8-join"><a href="#8-join" class="headerlink" title="8).join()"></a>8).join()</h4><ul>
<li>可以将数组转换为一个字符串</li>
<li>该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回</li>
<li>在join()中可以指定一个字符串作为参数，这个字符串将会成为元素的连接符，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.join(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">输出如下：</span><br><span class="line">小A-小B-小C</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="9-reverse"><a href="#9-reverse" class="headerlink" title="9).reverse()"></a>9).reverse()</h4><ul>
<li>可以用来反转数组</li>
<li>该方法会直接修改原数组<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;小A&quot;</span>,<span class="string">&quot;小B&quot;</span>,<span class="string">&quot;小C&quot;</span>];</span><br><span class="line">arr.reverse();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="10-sort"><a href="#10-sort" class="headerlink" title="10).sort()"></a>10).sort()</h4><ul>
<li><p>可以用来对数组中的元素进行排序</p>
</li>
<li><p>该方法会影响原数组，默认按照 Unicode 编码进行排序</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;C&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;A&quot;</span>];</span><br><span class="line">arr.sort();</span><br></pre></td></tr></table></figure></li>
<li><p>及时对于纯数字的数组，使用该方法排序时，也会按照 Unicode 编码进行排序，所以对于数字进行排序时，可能会得到错误的结果</p>
</li>
</ul>
<h5 id="！自行指定排序规则"><a href="#！自行指定排序规则" class="headerlink" title="！自行指定排序规则"></a>！自行指定排序规则</h5><ul>
<li><p>在 sort() 中添加一个回调函数来指定排序规则，该回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数，即根据相邻元素，第一个一定在第二个的前边</p>
</li>
<li><p>浏览器会根据回调函数的返回值来决定元素的位置<br>返回一个大于0的值，元素交换位置<br>返回一个小于0的值，元素位置不变<br>返回0，两元素相等，元素位置不变</p>
</li>
<li><p>升序排列时，直接返回 a-b ；降序排列时，直接返回 b-a</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//升序排列</span></span><br><span class="line">	<span class="keyword">return</span> a-b;</span><br><span class="line">	<span class="comment">//降序排列</span></span><br><span class="line">	<span class="keyword">return</span> b-a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="11-forEach"><a href="#11-forEach" class="headerlink" title="11).forEach()"></a>11).forEach()</h4><ul>
<li>用来遍历数组，且该方法只支持IE8以上的浏览器</li>
<li>该方法需要一个函数作为参数，像这种函数，由我们创建但是不由我们调用的称为 <strong>回调函数</strong> </li>
<li>数组中有几个元素函数就会执行几次，每次执行时，浏览器会将遍历到的元素以实参的形式传递进来，我们可以定义形参来读取这些内容</li>
<li>浏览器会在回调函数中传递三个函数：<br>第一个参数，是当前正在遍历的元素<br>第二个参数，是当前正在遍历的元素的索引<br>第三个参数，是正在遍历的数组</li>
<li>具体方法使用看下面的遍历部分</li>
</ul>
<h4 id="12-indexOf"><a href="#12-indexOf" class="headerlink" title="12).indexOf"></a>12).indexOf</h4><ul>
<li>数组的 indexOf() 方法和字符串的类似，点击 <a href="#indexOf">这里查看</a></li>
</ul>
<h3 id="5-数组的遍历"><a href="#5-数组的遍历" class="headerlink" title="(5).数组的遍历"></a>(5).数组的遍历</h3><ul>
<li><p>使用for循环</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用forEach()方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value,index,obj</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-Date对象"><a href="#3-Date对象" class="headerlink" title="3.Date对象"></a>3.Date对象</h2><h3 id="1-简介-3"><a href="#1-简介-3" class="headerlink" title="(1).简介"></a>(1).简介</h3><ul>
<li>在 JS 中使用 Date 对象来表示一个时间</li>
</ul>
<h3 id="2-操作-1"><a href="#2-操作-1" class="headerlink" title="(2).操作"></a>(2).操作</h3><h4 id="1-创建一个Date对象"><a href="#1-创建一个Date对象" class="headerlink" title="1).创建一个Date对象"></a>1).创建一个Date对象</h4><ul>
<li>直接使用构造函数创建一个 Date 对象，则会封装为当前代码执行得时间<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-创建一个指定时间的时间对象"><a href="#2-创建一个指定时间的时间对象" class="headerlink" title="2).创建一个指定时间的时间对象"></a>2).创建一个指定时间的时间对象</h4><ul>
<li>需要在构造函数中传递一个表示时间的字符串作为参数</li>
<li>日期的格式为：<code>月份/日/年 时:分:秒</code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;07/07/2020 07:07:07&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(d1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Date的方法"><a href="#3-Date的方法" class="headerlink" title="(3).Date的方法"></a>(3).Date的方法</h3><h4 id="1-getDate"><a href="#1-getDate" class="headerlink" title="1).getDate()"></a>1).getDate()</h4><ul>
<li>获取当前日期对象是几日<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = d1.getDate();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-getDay"><a href="#2-getDay" class="headerlink" title="2).getDay()"></a>2).getDay()</h4><ul>
<li>获取当前日期对象是周几，会返回0-6的值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = d1.getDay();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-getMonth"><a href="#3-getMonth" class="headerlink" title="3).getMonth()"></a>3).getMonth()</h4><ul>
<li>获取当前日期对象的月份，会返回0-11的值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = d1.getMonth();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-getFullYear"><a href="#4-getFullYear" class="headerlink" title="4).getFullYear()"></a>4).getFullYear()</h4><ul>
<li>获取当前日期对象的年份<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = d1.getFullYear();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-getTime"><a href="#5-getTime" class="headerlink" title="5).getTime()"></a>5).getTime()</h4><ul>
<li><p>获取当前日期对象的时间戳（从1970年1月1日到当前日期所花费的毫秒数）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = d1.getTime();</span><br><span class="line"><span class="built_in">console</span>.log(date);</span><br></pre></td></tr></table></figure></li>
<li><p>如果时间为1970年1月1日0时0分0秒，得出的时间戳应该为负数（因为时区缘故）</p>
</li>
<li><p>直接获取当前时间的时间戳</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">time = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(time);</span><br></pre></td></tr></table></figure></li>
<li><p>通过时间戳，可以测试代码执行性能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> end = <span class="built_in">Date</span>.now();</span><br><span class="line"><span class="built_in">console</span>.log(end - start);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-Math对象"><a href="#4-Math对象" class="headerlink" title="4.Math对象"></a>4.Math对象</h2><h3 id="1-简介-4"><a href="#1-简介-4" class="headerlink" title="(1).简介"></a>(1).简介</h3><ul>
<li>Math 不是一个构造函数，它属于工具类不用创建对象，它里边包含了数学运算相关的属性和方法</li>
</ul>
<h3 id="2-属性"><a href="#2-属性" class="headerlink" title="(2).属性"></a>(2).属性</h3><ul>
<li>具体属性如下图：<br><img src="https://s1.ax1x.com/2020/10/18/0j0X1f.png" alt="js07.png"></li>
</ul>
<h3 id="3-Math的方法"><a href="#3-Math的方法" class="headerlink" title="(3).Math的方法"></a>(3).Math的方法</h3><h4 id="1-random"><a href="#1-random" class="headerlink" title="1).random()"></a>1).random()</h4><ul>
<li><p>可以用来生成一个0-1之间的随机数（开区间）</p>
</li>
<li><p>如果想要生成一个0-x之间的随机数（开区间），则可以如下实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.random()*x);</span><br></pre></td></tr></table></figure></li>
<li><p>如果想要生成一个0-x之间的随机数（闭区间），则可以通过四舍五入法来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()*x));</span><br></pre></td></tr></table></figure></li>
<li><p>如果想要生成一个x-y之间的随机数（闭区间），则可以通过四舍五入法来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.round(<span class="built_in">Math</span>.random()*(y-x)+x));</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-other"><a href="#2-other" class="headerlink" title="2).other"></a>2).other</h4><ul>
<li>其余方法如下图：<br><img src="https://s1.ax1x.com/2020/10/18/0j0jc8.png" alt="js08.png"></li>
</ul>
<h1 id="五、宿主对象"><a href="#五、宿主对象" class="headerlink" title="五、宿主对象"></a>五、宿主对象</h1><h2 id="1-DOM"><a href="#1-DOM" class="headerlink" title="1.DOM"></a>1.DOM</h2><h3 id="1-简介-5"><a href="#1-简介-5" class="headerlink" title="(1).简介"></a>(1).简介</h3><ul>
<li><p>DOM<br><img src="https://s1.ax1x.com/2020/10/18/0jBPNn.png" alt="js12.png"></p>
</li>
<li><p>模型：<br><img src="https://s1.ax1x.com/2020/10/18/0jBp7j.png" alt="js13.png"></p>
</li>
</ul>
<h3 id="2-节点"><a href="#2-节点" class="headerlink" title="(2).节点"></a>(2).节点</h3><ul>
<li><p>节点（Node）是构成网页的最基本的组成部分，网页中的每一个部分都可以称为是一个节点</p>
</li>
<li><p>类型不同：<br>文档节点：整个HTML文档<br>元素节点：HTML标签<br>属性节点：元素的属性<br>文本节点：标签中的文本</p>
</li>
<li><p>节点的属性：<br><img src="https://s1.ax1x.com/2020/10/18/0jBihq.png" alt="js14.png"></p>
</li>
<li><p>浏览器已经为我们提供了文档节点对象，这个对象是 Window 属性，可以在页面中直接使用，文档节点代表的是整个网页</p>
</li>
</ul>
<h3 id="3-事件"><a href="#3-事件" class="headerlink" title="(3).事件"></a>(3).事件</h3><ul>
<li>就是用户和浏览器之间的交互行为，如：点击按钮，鼠标移动，关闭窗口</li>
</ul>
<h4 id="a-编写位置"><a href="#a-编写位置" class="headerlink" title="a).编写位置"></a>a).编写位置</h4><ul>
<li><p>我们可以在事件对应的属性中设置一些JS代码，这样当事件被处罚时，这些代码将会执行（但不推荐）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;你还点!&#x27;);&quot;</span>&gt;</span>我是一个按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>可以为按钮的对应事件绑定处理函数（称为xx相应函数）的形式来响应事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">在body标签中编写时：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="javascript">	btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		alert(<span class="string">&quot;别点了！&quot;</span>);</span></span><br><span class="line"><span class="javascript">	&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">在head标签中编写时：</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span></span><br><span class="line"><span class="javascript">		btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			alert(<span class="string">&quot;别点了！&quot;</span>);</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">	&#125;;	</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-onclick-事件"><a href="#b-onclick-事件" class="headerlink" title="b).onclick 事件"></a>b).onclick 事件</h4><ul>
<li>会在执行点击时触发该事件</li>
<li>为按钮绑定一个 onclick 事件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-onload-事件"><a href="#c-onload-事件" class="headerlink" title="c).onload 事件"></a>c).onload 事件</h4><ul>
<li>会在整个页面加载完成之后才触发，这样可以确保我们的代码执行时所有的 DOM 对象已经加载完毕了</li>
<li>为 window 绑定一个 onload 事件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="d-onscroll-事件"><a href="#d-onscroll-事件" class="headerlink" title="d).onscroll 事件"></a>d).onscroll 事件</h4><ul>
<li>该事件会在元素的滚动条滚动时触发</li>
<li>为某元素绑定一个 onscroll 事件<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">info.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="e-onmousemove-事件"><a href="#e-onmousemove-事件" class="headerlink" title="e).onmousemove 事件"></a>e).onmousemove 事件</h4><ul>
<li>该事件将会在元素中移动时被触发<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="string">&quot;你好！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="f-onmousedown-up-事件"><a href="#f-onmousedown-up-事件" class="headerlink" title="f).onmousedown/up 事件"></a>f).onmousedown/up 事件</h4><ul>
<li>该事件将会在元素被鼠标点击与松开时触发</li>
</ul>
<h4 id="g-onmousewheel-onwheel-事件"><a href="#g-onmousewheel-onwheel-事件" class="headerlink" title="g).onmousewheel/onwheel 事件"></a>g).onmousewheel/onwheel 事件</h4><ul>
<li>该事件将会给元素绑定一个鼠标滚轮滚动的事件，前者火狐不支持后者IE不支持</li>
<li>相关的事件对象在 <a href="#wheel">这里</a></li>
</ul>
<h4 id="h-onkeydown-up-事件"><a href="#h-onkeydown-up-事件" class="headerlink" title="h).onkeydown/up 事件"></a>h).onkeydown/up 事件</h4><ul>
<li>表示键盘被按下/松开</li>
<li>键盘事件一般都给绑定给一些可以获取到焦点的对象或者document</li>
<li>对于前者，如果一直按着某个键不松手，则事件会一直触发，且第一次和第二次之间会间隔长一些，是为了防止误操作</li>
<li>相关的事件对象在 <a href="#key">这里</a></li>
</ul>
<h3 id="4-事件的对象"><a href="#4-事件的对象" class="headerlink" title="(4).事件的对象"></a>(4).事件的对象</h3><ul>
<li>当事件的响应函数被触发时，浏览器每次都会将一个事件对象作为实参传递进响应函数</li>
<li>在事件对象中封装了当前事件相关的一切信息。比如：鼠标的坐标、键盘哪个键被按下、鼠标滚轮滚动的方向</li>
<li>在IE8及以下的浏览器中，响应函数被触发时，浏览器不会传递事件对象，而是将事件对象作为 window 对象的属性保存的，所以需要使用 <code>window.event</code> 来调用 </li>
</ul>
<h4 id="a-clientX-Y-属性"><a href="#a-clientX-Y-属性" class="headerlink" title="a).clientX/Y 属性"></a>a).clientX/Y 属性</h4><ul>
<li>可以获取鼠标指针在当前的可见窗口的水平/垂直坐标</li>
</ul>
<h4 id="b-pageX-Y-属性"><a href="#b-pageX-Y-属性" class="headerlink" title="b).pageX/Y 属性"></a>b).pageX/Y 属性</h4><ul>
<li>可以获取鼠标相对于当前页面的坐标</li>
<li>不支持IE8及以下</li>
<li>关于该属性和上一个属性的区别如下图：<br><img src="https://s1.ax1x.com/2020/10/18/0jBCAs.png" alt="js15.png"></li>
</ul>
<h4 id="c-target-属性"><a href="#c-target-属性" class="headerlink" title="c).target 属性"></a>c).target 属性</h4><ul>
<li>表示触发事件的对象是谁</li>
</ul>
<h4 id="d-wheelDelta-属性"><a href="#d-wheelDelta-属性" class="headerlink" title="d).wheelDelta 属性"></a>d).<span id="wheel">wheelDelta 属性</span></h4><ul>
<li><p>可以获取鼠标滚轮滚动的方向，向上滚是正值，向下滚是负值</p>
</li>
<li><p>而且一般需要取消浏览器的默认行为，即浏览器会跟随鼠标滚轮上下移动</p>
</li>
<li><p>但是这个属性火狐中不支持<br>需要使用 <code>event.deltaY</code> 属性来获取，但正负值刚好相反<br>需要使用 <code>DOMMouseScroll</code> 来绑定滚动事件，该事件需要通过 <code>addEventListener()</code> 函数来绑定，然后使用 <code>event.detai</code> 属性来获取，但正负值刚好相反</p>
</li>
<li><p>火狐方法二解决办法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">		box1.onmousewheel = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			event = event || <span class="built_in">window</span>.event;</span><br><span class="line">			<span class="keyword">if</span>(event.wheelDelta &gt; <span class="number">0</span> || event.detail &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="comment">//鼠标滚轮向上滚</span></span><br><span class="line">				box1.style.height = box1.clientHeight - <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//鼠标滚轮向下滚</span></span><br><span class="line">				box1.style.height = box1.clientHeight + <span class="number">10</span> + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			event.preventDefault &amp;&amp; event.preventDefault();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		bind(box1,<span class="string">&quot;DOMMouseScroll&quot;</span>,box1.onmousewheel)</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">obj,eventStr,callback</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj.addEventListener)&#123;</span><br><span class="line">			<span class="comment">//大部分浏览器兼容的方式</span></span><br><span class="line">			obj.addEventListener(eventStr,callback,<span class="literal">false</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//IE8及以下</span></span><br><span class="line">			obj.attachEvent(<span class="string">&quot;on&quot;</span>+eventStr,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="comment">//匿名函数，用来将回调函数更改为用户调用而不是浏览器调用</span></span><br><span class="line">				<span class="comment">//即更改this为对象而不是window</span></span><br><span class="line">				callback.call(obj);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="e-keyCode-altKey-ctrlKey-shiftKey-属性"><a href="#e-keyCode-altKey-ctrlKey-shiftKey-属性" class="headerlink" title="e).keyCode/altKey/ctrlKey/shiftKey 属性"></a>e).<span id="key">keyCode/altKey/ctrlKey/shiftKey 属性</span></h4><ul>
<li>可以通过 keyCode 来获取按键的编码</li>
<li>若想要判断两个键同时按下时，可以使用后三个进行获取相应按键的编码</li>
</ul>
<h3 id="5-事件的冒泡"><a href="#5-事件的冒泡" class="headerlink" title="(5).事件的冒泡"></a>(5).事件的冒泡</h3><ul>
<li>冒泡就是事件的向上传导，当后代元素上的事件被触发时，其祖先元素的相同事件也会被触发</li>
<li>在开发中大部分情况下冒泡都是有用的，如果不希望发生事件的冒泡，可以通过事件的对象来取消冒泡</li>
<li>即 <code>event.cancelBubble = true;</code> 即可取消冒泡</li>
</ul>
<h3 id="6-事件的委派"><a href="#6-事件的委派" class="headerlink" title="(6).事件的委派"></a>(6).事件的委派</h3><ul>
<li>指将事件统一绑定给元素的共同的祖先元素，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件</li>
<li>事件的委派实际上是利用了事件的冒泡，通过委派可以减少事件绑定的次数，提高程序性能</li>
</ul>
<h3 id="7-事件的绑定"><a href="#7-事件的绑定" class="headerlink" title="(7).事件的绑定"></a>(7).事件的绑定</h3><ul>
<li>传统的 <code>对象.事件 = 函数</code> 绑定响应函数只能同时为一个元素的一个事件绑定一个响应函数，不能绑定多个，如果绑定了多个则后边的会覆盖掉前面的</li>
<li>通过以下两个方法可以同时绑定多个响应函数</li>
</ul>
<h4 id="a-addEventListener"><a href="#a-addEventListener" class="headerlink" title="a).addEventListener()"></a>a).addEventListener()</h4><ul>
<li>可以同时为一个元素的相同事件同时绑定多个响应函数，按照顺序执行响应函数</li>
<li>语法：<code>对象.addEventListener(参数1,参数2,参数3)</code></li>
<li>参数如下：<ul>
<li>事件的字符串，不加on</li>
<li>回调函数，当事件触发时该函数会被调用</li>
<li>是否在捕获阶段触发事件，需要一个布尔值，一般都传false</li>
</ul>
</li>
<li><font color=#F00>注意：该方法不支持 IE8 及以下，且它的 this 是绑定事件的对象</font></li>
<li><font color=#F00>注意：使用该方法绑定响应函数时，取消默认行为时不能使用 retuen false，而应该使用 event.preventDefault() 来取消默认行为，且IE8不支持</font></li>
</ul>
<h4 id="b-attachEvent"><a href="#b-attachEvent" class="headerlink" title="b).attachEvent()"></a>b).attachEvent()</h4><ul>
<li>可以同时为一个元素的相同事件同时绑定多个响应函数，按照反向顺序执行响应函数</li>
<li>语法：<code>对象.attachEvent(参数1,参数2)</code> </li>
<li>参数如下：<br>1.事件的字符串，要加on<br>2.回调函数，当事件触发时该函数会被调用</li>
<li><font color=#F00>注意：该方法只支持IE 5-10，且它的 this 是 window</font></li>
</ul>
<h5 id="！解决this是window的方法"><a href="#！解决this是window的方法" class="headerlink" title="！解决this是window的方法"></a>！解决this是window的方法</h5><ul>
<li>因为attachEvent()是浏览器调用的，所以它的this是window</li>
<li>我们无法控制浏览器的调用方式，所以需要在回调函数参数处写一个匿名函数</li>
<li>在匿名函数中我们再调用回调函数，此时this就是绑定事件的对象了</li>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> btn01 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn01&quot;</span>);</span><br><span class="line">		bind(btn01,<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			alert(<span class="number">1</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//定义一个函数，用来指定元素绑定响应函数</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 参数：</span></span><br><span class="line"><span class="comment">	 * obj：要绑定事件的对象</span></span><br><span class="line"><span class="comment">	 * eventStr：事件的字符串（不要on）</span></span><br><span class="line"><span class="comment">	 * callback：回调函数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">obj,eventStr,callback</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj.addEventListener)&#123;</span><br><span class="line">			<span class="comment">//大部分浏览器兼容的方式</span></span><br><span class="line">			obj.addEventListener(eventStr,callback,<span class="literal">false</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//IE8及以下</span></span><br><span class="line">			obj.attachEvent(<span class="string">&quot;on&quot;</span>+eventStr,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="comment">//匿名函数，用来将回调函数更改为用户调用而不是浏览器调用</span></span><br><span class="line">				<span class="comment">//即更改this为对象而不是window</span></span><br><span class="line">				callback.call(obj);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-事件的传播"><a href="#8-事件的传播" class="headerlink" title="(8).事件的传播"></a>(8).事件的传播</h3><ul>
<li>事件的传播一共分为以下三个阶段</li>
<li>如果希望在捕获阶段就触发事件，可以将 addEventListener() 的第三个参数设置为 true，一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是 false</li>
<li>IE8及以下的浏览器没有捕获阶段</li>
</ul>
<h4 id="a-捕获阶段"><a href="#a-捕获阶段" class="headerlink" title="a).捕获阶段"></a>a).捕获阶段</h4><ul>
<li>在捕获阶段是从最外层的祖先元素向目标元素进行事件的捕获，但是默认不会触发事件</li>
</ul>
<h4 id="b-目标阶段"><a href="#b-目标阶段" class="headerlink" title="b).目标阶段"></a>b).目标阶段</h4><ul>
<li>事件捕获到目标元素，捕获结束开始在目标元素上触发事件</li>
</ul>
<h4 id="c-冒泡阶段"><a href="#c-冒泡阶段" class="headerlink" title="c).冒泡阶段"></a>c).冒泡阶段</h4><ul>
<li>事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件</li>
</ul>
<h3 id="9-获取元素节点"><a href="#9-获取元素节点" class="headerlink" title="(9).获取元素节点"></a>(9).获取元素节点</h3><h4 id="a-document-getElementById"><a href="#a-document-getElementById" class="headerlink" title="a).document.getElementById()"></a>a).document.getElementById()</h4><ul>
<li>通过id属性获取一个元素节点对象</li>
<li>括号中填写id名，可以获取到指定id的对象</li>
<li>如果需要读取元素节点属性，直接使用 元素.属性名 即可，例如<code>btn01.innerHTML</code> </li>
</ul>
<h4 id="b-document-getElementsByTagName"><a href="#b-document-getElementsByTagName" class="headerlink" title="b).document.getElementsByTagName()"></a>b).document.getElementsByTagName()</h4><ul>
<li>通过标签名获取<font color=#F00>一组</font>元素节点对象</li>
<li>这个方法会返回一个类数组对象，所有查询到的元素都会封装到对象中</li>
</ul>
<h4 id="c-document-getElementsByName"><a href="#c-document-getElementsByName" class="headerlink" title="c).document.getElementsByName()"></a>c).document.getElementsByName()</h4><ul>
<li>通过name属性获取一组元素节点对象</li>
<li>这个方法会返回一个类数组对象，所有查询到的元素都会封装到对象中</li>
<li>如果需要读取元素节点属性，直接使用 元素.属性名 即可，例如<code>inputs[i].value</code>。但class不能采用这种方式，可以使用 元素.className 来代替</li>
</ul>
<h4 id="d-document-getElemeentsByClassName"><a href="#d-document-getElemeentsByClassName" class="headerlink" title="d).document.getElemeentsByClassName()"></a>d).document.getElemeentsByClassName()</h4><ul>
<li>根据元素的class属性值查询一组元素节点对象，但该方法不支持 IE8及以下的浏览器</li>
</ul>
<h4 id="e-document-querySelector"><a href="#e-document-querySelector" class="headerlink" title="e).document.querySelector()"></a>e).document.querySelector()</h4><ul>
<li>需要一个选择器的字符串作为参数，可以根据一个 CSS选择器来查询一个元素节点对象，支持 IE8及以上</li>
<li>使用该方法总会返回唯一的元素，如果满足条件的元素有多个，只会返回第一个</li>
</ul>
<h4 id="f-document-querySelectorAll"><a href="#f-document-querySelectorAll" class="headerlink" title="f).document.querySelectorAll()"></a>f).document.querySelectorAll()</h4><ul>
<li>该方法类似上面，不同的是会将符合条件的元素封装到一个数组中返回</li>
<li>即使只有一个，也会返回数组</li>
</ul>
<h4 id="g-document-body"><a href="#g-document-body" class="headerlink" title="g).document.body"></a>g).document.body</h4><ul>
<li>它保存的是body的引用</li>
</ul>
<h4 id="h-document-documentElement"><a href="#h-document-documentElement" class="headerlink" title="h).document.documentElement"></a>h).document.documentElement</h4><ul>
<li>它保存的是html根标签</li>
</ul>
<h4 id="i-document-all"><a href="#i-document-all" class="headerlink" title="i).document.all"></a>i).document.all</h4><ul>
<li>它代表页面中所有的元素</li>
</ul>
<h3 id="10-获取元素节点的子节点"><a href="#10-获取元素节点的子节点" class="headerlink" title="(10).获取元素节点的子节点"></a>(10).获取元素节点的子节点</h3><ul>
<li>通过具体的元素节点调用</li>
</ul>
<h4 id="a-当前节点-getElementById"><a href="#a-当前节点-getElementById" class="headerlink" title="a).当前节点.getElementById()"></a>a).当前节点.getElementById()</h4><ul>
<li>方法，返回当前节点的指定标签名后代节点</li>
</ul>
<h4 id="b-当前节点-childNodes"><a href="#b-当前节点-childNodes" class="headerlink" title="b).当前节点.childNodes"></a>b).当前节点.childNodes</h4><ul>
<li>属性，表示当前节点的所有子节点</li>
<li>该属性会获取包括文本节点在内的所有节点，根据DOM标准，标签间的空白也会当成文本节点</li>
<li>注意：IE8及以下不会将空白文本当成子节点</li>
</ul>
<h4 id="c-当前节点-children"><a href="#c-当前节点-children" class="headerlink" title="c).当前节点.children"></a>c).当前节点.children</h4><ul>
<li>属性，表示获取当前元素的所有子元素</li>
<li>区别于子节点：不会获取到空白文本</li>
</ul>
<h4 id="d-当前节点-firstChild"><a href="#d-当前节点-firstChild" class="headerlink" title="d).当前节点.firstChild"></a>d).当前节点.firstChild</h4><ul>
<li>属性，表示当前节点的第一个子节点</li>
</ul>
<h4 id="e-当前节点-firstElementChild"><a href="#e-当前节点-firstElementChild" class="headerlink" title="e).当前节点.firstElementChild"></a>e).当前节点.firstElementChild</h4><ul>
<li>属性，表示获取当前元素的第一个子元素，不支持IE8及以下</li>
</ul>
<h4 id="f-当前节点-lastChild"><a href="#f-当前节点-lastChild" class="headerlink" title="f).当前节点.lastChild"></a>f).当前节点.lastChild</h4><ul>
<li>属性，表示当前节点的最后一个子节点</li>
</ul>
<h3 id="11-获取父节点和兄弟节点"><a href="#11-获取父节点和兄弟节点" class="headerlink" title="(11).获取父节点和兄弟节点"></a>(11).获取父节点和兄弟节点</h3><ul>
<li>通过具体的节点调用</li>
</ul>
<h4 id="a-parentNode"><a href="#a-parentNode" class="headerlink" title="a).parentNode"></a>a).parentNode</h4><ul>
<li>属性，表示当前节点的父节点</li>
</ul>
<h4 id="b-previousSibling"><a href="#b-previousSibling" class="headerlink" title="b).previousSibling"></a>b).previousSibling</h4><ul>
<li>属性，表示当前节点的前一个兄弟节点</li>
<li>该属性会获取包括文本节点在内的所有节点，根据DOM标准，标签间的空白也会当成文本节点</li>
</ul>
<h4 id="c-previousElementSibling"><a href="#c-previousElementSibling" class="headerlink" title="c).previousElementSibling"></a>c).previousElementSibling</h4><ul>
<li>属性，表示当前节点的前一个兄弟元素，不支持IE8及以下</li>
</ul>
<h4 id="c-nextSibling"><a href="#c-nextSibling" class="headerlink" title="c).nextSibling"></a>c).nextSibling</h4><ul>
<li>属性，表示当前节点的后一个兄弟节点</li>
</ul>
<h3 id="12-增删查改方法"><a href="#12-增删查改方法" class="headerlink" title="(12).增删查改方法"></a>(12).增删查改方法</h3><h4 id="a-document-createElement"><a href="#a-document-createElement" class="headerlink" title="a).document.createElement()"></a>a).document.createElement()</h4><ul>
<li>可以用于创建一个元素节点对象</li>
<li>它需要一个标签名作为参数，将会根据该标签名创建元素节点对象，并将创建好的对象作为返回值返回</li>
</ul>
<h4 id="b-document-createTextNode"><a href="#b-document-createTextNode" class="headerlink" title="b).document.createTextNode()"></a>b).document.createTextNode()</h4><ul>
<li>可以用来创建一个文本节点对象</li>
<li>它需要一个文本内容作为参数，将会根据内容创建文本节点，并将新的节点返回</li>
</ul>
<h4 id="c-appendChild"><a href="#c-appendChild" class="headerlink" title="c).appendChild()"></a>c).appendChild()</h4><ul>
<li>向一个父节点中添加一个新的子节点</li>
<li>用法：<code>父节点.appendChild(子节点);</code> </li>
</ul>
<h4 id="d-insertBefore"><a href="#d-insertBefore" class="headerlink" title="d).insertBefore()"></a>d).insertBefore()</h4><ul>
<li>可以在指定的子节点前插入新的子节点</li>
<li>语法：<code>父节点.insertBefore(新节点,旧节点);</code></li>
</ul>
<h4 id="e-replaceChild"><a href="#e-replaceChild" class="headerlink" title="e).replaceChild()"></a>e).replaceChild()</h4><ul>
<li>可以使用指定的子节点替换已有的子节点</li>
<li>语法：<code>父节点.replaceChild(新节点,旧节点);</code></li>
</ul>
<h4 id="f-removeChild"><a href="#f-removeChild" class="headerlink" title="f).removeChild()"></a>f).removeChild()</h4><ul>
<li>可以删除一个子节点</li>
<li>语法：<code>父节点.removeChild(子节点);</code></li>
<li>常用语法：<code>子节点.parentNode.removeChild(子节点);</code></li>
</ul>
<h4 id="g-innerHTML"><a href="#g-innerHTML" class="headerlink" title="g).innerHTML"></a>g).innerHTML</h4><ul>
<li>属性，获取该元素节点的HTML内容</li>
<li>也可以使用 <code>innerHTML = &quot;修改文本区域&quot;;</code> 来修改非自结束标签内部的文本内容</li>
<li>使用该属性可以进行DOM的增删改的相关操作，一般推荐和上面的结合使用，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> city = <span class="built_in">document</span>.getElementById(<span class="string">&quot;city&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">li.innerHTML = <span class="string">&quot;广州&quot;</span>;</span><br><span class="line">city.appendChild(li);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="h-innerText"><a href="#h-innerText" class="headerlink" title="h).innerText"></a>h).innerText</h4><ul>
<li>属性，获取该元素节点的Text内容</li>
</ul>
<h3 id="13-操作内联样式"><a href="#13-操作内联样式" class="headerlink" title="(13).操作内联样式"></a>(13).操作内联样式</h3><h4 id="a-修改"><a href="#a-修改" class="headerlink" title="a).修改"></a>a).修改</h4><ul>
<li><p>可以通过JS修改元素的样式，语法为：<code>元素.style.样式名=样式值</code> </p>
</li>
<li><p><font color=#F00>注意：如果 CSS 样式中含有<code>-</code>，则需要将其改为驼峰命名法，即去掉-然后将-之后的字母大写</font>。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-color</span><br><span class="line">需要改成：</span><br><span class="line">backgroundColor</span><br></pre></td></tr></table></figure></li>
<li><p>我们通过 style 属性设置的样式都是内联样式，而内联样式有较高的优先级，所以通过JS修改的样式往往会立即显示。但是如果在样式中写了 <code>!important</code> ，则此时样式会有最高的优先级，即使通过JS也不能覆盖该样式，所以会导致 JS 修改样式失效，所以尽量不要添加 <code>!important</code> </p>
</li>
</ul>
<h4 id="b-读取"><a href="#b-读取" class="headerlink" title="b).读取"></a>b).读取</h4><ul>
<li>也可以通过 JS 读取元素的样式，语法为：<code>元素.style.样式名</code> </li>
<li>通过 style 属性设置和读取的都是内联样式，无法读取样式表中的样式</li>
</ul>
<h3 id="14-获取元素的样式"><a href="#14-获取元素的样式" class="headerlink" title="(14).获取元素的样式"></a>(14).获取元素的样式</h3><h4 id="a-IE独有"><a href="#a-IE独有" class="headerlink" title="a).IE独有"></a>a).IE独有</h4><ul>
<li>可以获取元素当前显示的样式，语法为：<code>元素.currentStyle.样式名</code> </li>
<li>如果当前元素没有设置该样式，则获取它的默认值</li>
</ul>
<h4 id="b-其他通用"><a href="#b-其他通用" class="headerlink" title="b).其他通用"></a>b).其他通用</h4><ul>
<li>使用 <code>getComputedStyle()</code> 这个方法来获取元素当前的样式，这个是 window 的方法，可以直接使用</li>
<li>此时需要两个参数。第一个为要获取样式的元素，第二个可以传递一个伪元素，一般都传null</li>
<li>该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过 <code>对象.样式名</code> 来读取样式，如果获取的样式没有设置，则会获取到真实的值，而不是默认值</li>
<li>不支持IE8及以下</li>
</ul>
<h4 id="c-兼容方法"><a href="#c-兼容方法" class="headerlink" title="c).兼容方法"></a>c).兼容方法</h4><ul>
<li><p>首先需要定义一个函数，用来获取指定元素的当前样式</p>
</li>
<li><p>因为IE8及以下没有 <code>getComputedStyle()</code> 方法，所以可以作为条件判断语句的判定条件。这里需要注意一下：如果是只是 <code>getComputedStyle</code> 那么这里为变量，变量如果找不到就会报错；而 <code>window.getComputedStyle</code> 为对象的属性，如果找不到就会返回 undefined。</p>
</li>
<li><p>在相应的域中将获取元素的语句返回即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">obj,name</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">window</span>.getComputedStyle)&#123;</span><br><span class="line">		<span class="keyword">return</span> getComputedStyle(obj,<span class="literal">null</span>)[name];</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> obj.currentStyle[name];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在点击函数中，使用函数调用即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getStyle(box1,<span class="string">&quot;width&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="15-其他样式的相关属性"><a href="#15-其他样式的相关属性" class="headerlink" title="(15).其他样式的相关属性"></a>(15).其他样式的相关属性</h3><h4 id="a-clientWidth-Height"><a href="#a-clientWidth-Height" class="headerlink" title="a).clientWidth/Height"></a>a).clientWidth/Height</h4><ul>
<li>可以获取元素的可见宽度和高度，包括内容区和内边距</li>
<li>这两个属性都是不带px的，返回都是一个数字，可以直接计算</li>
<li>这两个属性都是只读的，不能修改</li>
</ul>
<h4 id="b-offsetWidth-Height"><a href="#b-offsetWidth-Height" class="headerlink" title="b).offsetWidth/Height"></a>b).offsetWidth/Height</h4><ul>
<li>可以获取元素的整个宽度和高度，包括内容区、内边距和边框</li>
</ul>
<h4 id="c-offsetParent"><a href="#c-offsetParent" class="headerlink" title="c).offsetParent"></a>c).offsetParent</h4><ul>
<li>可以用来获取到离当前元素最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位，则返回body</li>
</ul>
<h4 id="d-offsetLeft-Top"><a href="#d-offsetLeft-Top" class="headerlink" title="d).offsetLeft/Top"></a>d).offsetLeft/Top</h4><ul>
<li>可以获取当前元素相对于其定位父元素的水平/垂直偏移量</li>
</ul>
<h4 id="e-scrollWidth-Height"><a href="#e-scrollWidth-Height" class="headerlink" title="e).scrollWidth/Height"></a>e).scrollWidth/Height</h4><ul>
<li>可以获取元素整个滚动区域的宽度和高度</li>
</ul>
<h4 id="f-scrollLeft-Top"><a href="#f-scrollLeft-Top" class="headerlink" title="f).scrollLeft/Top"></a>f).scrollLeft/Top</h4><ul>
<li>可以获取水平/垂直滚动条滚动的距离</li>
<li>当满足 <code>scrollHeight - scrollTop == clientHeight</code> 说明垂直滚动条滚动到底了</li>
<li>当满足 <code>scrollWidth - scrollLeft == clientWidth</code> 说明水平滚动条滚动到底了</li>
</ul>
<h2 id="2-DOM-案例分析"><a href="#2-DOM-案例分析" class="headerlink" title="2.DOM 案例分析"></a>2.DOM 案例分析</h2><h3 id="1-切换上下图"><a href="#1-切换上下图" class="headerlink" title="(1).切换上下图"></a>(1).切换上下图</h3><h4 id="a-思路"><a href="#a-思路" class="headerlink" title="a).思路"></a>a).思路</h4><ol>
<li>因为通过点击按钮来切换上下图，所以需要给按钮绑定点击事件</li>
<li>将图片的路径存放在一个数组中，通过修改 img 的 src 属性来形成切换下一张图的效果</li>
<li>设置个索引变量，在切换上下图时，自减或自增，并使用 if 语句来控制索引溢出问题</li>
<li>通过重新复制索引变量还可以形成循环效果</li>
<li>如果想要提示当前第几张图片的效果，需要通过索引和数组长度来控制总图与当前图</li>
</ol>
<h4 id="b-代码"><a href="#b-代码" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>JS 代码如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//获取第一张图像</span></span><br><span class="line">		<span class="keyword">var</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;img&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">//用数组存放三张图片的地址</span></span><br><span class="line">		<span class="keyword">var</span> imgArr = [<span class="string">&quot;./img/asd1.jpg&quot;</span> ,<span class="string">&quot;./img/asd2.jpg&quot;</span> ,<span class="string">&quot;./img/asd3.jpg&quot;</span>];</span><br><span class="line">		<span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//获取提示文字</span></span><br><span class="line">		<span class="keyword">var</span> info = <span class="built_in">document</span>.getElementById(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">		info.innerHTML = (index+<span class="number">1</span>)+<span class="string">&quot;/&quot;</span>+imgArr.length;</span><br><span class="line">		<span class="comment">//上一张</span></span><br><span class="line">		<span class="keyword">var</span> perv = <span class="built_in">document</span>.getElementById(<span class="string">&quot;prev&quot;</span>);</span><br><span class="line">		prev.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			index--;</span><br><span class="line">			<span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="comment">//到开头时固定在第一张图片</span></span><br><span class="line">				<span class="comment">//index = 0;</span></span><br><span class="line">				<span class="comment">//到开头时返回最后一张</span></span><br><span class="line">				index = imgArr.length-<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			img.src = imgArr[index];</span><br><span class="line">			info.innerHTML = (index+<span class="number">1</span>)+<span class="string">&quot;/&quot;</span>+imgArr.length;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//下一张</span></span><br><span class="line">		<span class="keyword">var</span> next = <span class="built_in">document</span>.getElementById(<span class="string">&quot;next&quot;</span>);</span><br><span class="line">		next.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			index++;</span><br><span class="line">			<span class="keyword">if</span>(index&gt;imgArr.length-<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="comment">//到末尾时返回第一张</span></span><br><span class="line">				index = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">//到末尾时固定在最后一张图片</span></span><br><span class="line">				<span class="comment">//index = imgArr.length-1;</span></span><br><span class="line">			&#125;</span><br><span class="line">			img.src = imgArr[index];</span><br><span class="line">			info.innerHTML = (index+<span class="number">1</span>)+<span class="string">&quot;/&quot;</span>+imgArr.length;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-实现全选-全不选"><a href="#2-实现全选-全不选" class="headerlink" title="(2).实现全选/全不选"></a>(2).实现全选/全不选</h3><h4 id="a-思路-1"><a href="#a-思路-1" class="headerlink" title="a).思路"></a>a).思路</h4><ul>
<li>通过id属性来获取到需要点击的按钮</li>
<li>通过name属性来获取到多个选项并将其封装到一个数组中去</li>
<li>遍历该数组，通过input的CheckBox对象的checked属性来检查是否被选中</li>
<li>全选/全不选时，直接设置true/false</li>
<li>反选时，如果是true就设置为false，如果是false就设置为true</li>
<li>提交时，通过遍历数组找到为true的并封装到另一个数组中，等遍历完后直接打印数组</li>
</ul>
<h4 id="b-代码-1"><a href="#b-代码-1" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">myClick</span>(<span class="params">idStr,fun</span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(idStr);</span><br><span class="line">			btn.onclick = fun;</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="keyword">var</span> checkedAllBox = <span class="built_in">document</span>.getElementById(<span class="string">&quot;checkedAllBox&quot;</span>);</span><br><span class="line">		checkedAllBox.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> items = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(items[i].checked)&#123;</span><br><span class="line">					items[i].checked = <span class="literal">false</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					items[i].checked = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">//1.#checkedAllBtn</span></span><br><span class="line">		myClick(<span class="string">&quot;checkedAllBtn&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> items = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">				items[i].checked = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);	</span><br><span class="line">		<span class="comment">//2.#checkedNoBtn</span></span><br><span class="line">		myClick(<span class="string">&quot;checkedNoBtn&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> items = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">				items[i].checked = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//3.#checkedRevBtn</span></span><br><span class="line">		myClick(<span class="string">&quot;checkedRevBtn&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> items = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(items[i].checked)&#123;</span><br><span class="line">					items[i].checked = <span class="literal">false</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					items[i].checked = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);	</span><br><span class="line">		<span class="comment">//4.#sendBtn</span></span><br><span class="line">		myClick(<span class="string">&quot;sendBtn&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> items = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">			<span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">var</span> itemsArr = [];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;items.length;i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(items[i].checked)&#123;</span><br><span class="line">					itemsArr[j] = items[i].value;</span><br><span class="line">					j++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			alert(<span class="string">&quot;你提交的是&quot;</span>+itemsArr);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-实现删除表格内容"><a href="#3-实现删除表格内容" class="headerlink" title="(3).实现删除表格内容"></a>(3).实现删除表格内容</h3><h4 id="a-思路-2"><a href="#a-思路-2" class="headerlink" title="a).思路"></a>a).思路</h4><ul>
<li>这个删除按钮可以使用超链接来使用，其中的href属性可以设置为 <code>javascript:;</code> 来清除默认跳转行为，也可以在响应函数中使用 <code>return false</code> 来清除</li>
<li>首先因为是表格，每行都有数据项，那么每行都应该有个删除按钮，所以在响应函数中应该先使用for循环来遍历出每个超链接</li>
<li>因为超链接存放在了一个数组中，所以可以直接给数组绑定点击事件</li>
<li>根据实际需求，超链接是放在td里的，而删除一行数据的话应该是删除一整个tr，所以需要通过超链接来找到tr</li>
<li>删除元素需要考虑到用户的使用体验，那么在删除之前就应该给出相应的提示——confirm()语句，并将其放入if判断中</li>
</ul>
<h4 id="b-代码-2"><a href="#b-代码-2" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">//点击超链接以后删除一个员工的信息</span></span><br><span class="line">	<span class="comment">//获取所有的超链接</span></span><br><span class="line">	<span class="keyword">var</span> allA = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;allA.length;i++)&#123;</span><br><span class="line">		allA[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="comment">//获取超链接的爷爷元素</span></span><br><span class="line">			<span class="comment">//这里的this指的是超链接中的href属性</span></span><br><span class="line">			<span class="keyword">var</span> tr = <span class="built_in">this</span>.parentNode.parentNode;</span><br><span class="line">			<span class="keyword">var</span> name = tr.getElementsByTagName(<span class="string">&quot;td&quot;</span>)[<span class="number">0</span>].innerHTML;</span><br><span class="line">			<span class="comment">//判断是否删除</span></span><br><span class="line">			<span class="keyword">var</span> flag = confirm(<span class="string">&quot;确定删除&quot;</span>+name+<span class="string">&quot;吗？&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">				<span class="comment">//删除该爷爷元素</span></span><br><span class="line">				tr.parentNode.removeChild(tr);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-实现用户保密协议"><a href="#4-实现用户保密协议" class="headerlink" title="(4).实现用户保密协议"></a>(4).实现用户保密协议</h3><h4 id="a-思路-3"><a href="#a-思路-3" class="headerlink" title="a).思路"></a>a).思路</h4><ul>
<li>用户保密协议部分需要要求用户阅读完协议才可以勾选同意按钮，并提交注册</li>
<li>首先需要将保密协议溢出部分隐藏掉，使其拖动滚动条才可以查看；并将复选框和提交按钮添加 disabled 属性，将其设置为不可点击</li>
<li>给盒子设置 onscroll 事件，并使用 scrollHeight 重要等式来判断是否拉到了底端</li>
<li>最后将 disabled 属性设置为 false 即可</li>
</ul>
<h4 id="b-代码-3"><a href="#b-代码-3" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> info = <span class="built_in">document</span>.getElementById(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> inputs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;input&quot;</span>);</span><br><span class="line">		info.onscroll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(info.scrollHeight -info.scrollTop == info.clientHeight)&#123;</span><br><span class="line">				inputs[<span class="number">0</span>].disabled = <span class="literal">false</span>;</span><br><span class="line">				inputs[<span class="number">1</span>].disabled = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-获取鼠标坐标并打印"><a href="#5-获取鼠标坐标并打印" class="headerlink" title="(5).获取鼠标坐标并打印"></a>(5).获取鼠标坐标并打印</h3><h4 id="a-思路-4"><a href="#a-思路-4" class="headerlink" title="a).思路"></a>a).思路</h4><ul>
<li>需要在第一个盒子里获取鼠标坐标，在第二个盒子里打印鼠标坐标</li>
<li>根据事件的对象内容，需要将一个形参传入响应函数中，然后调用 clientX/Y 属性，最后将坐标写入第二个盒子中</li>
<li>这里要注意兼容IE8及以下</li>
</ul>
<h4 id="b-代码-4"><a href="#b-代码-4" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> mouseArea = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mouseArea&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> mouseCoordinate = <span class="built_in">document</span>.getElementById(<span class="string">&quot;mouseCoordinate&quot;</span>);</span><br><span class="line">		mouseArea.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//兼容IE8及以下的方法一：</span></span><br><span class="line">			<span class="keyword">if</span>(!event)&#123;</span><br><span class="line">				event = <span class="built_in">window</span>.event;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="comment">//兼容IE8及以下的方法二(推荐)：</span></span><br><span class="line">			event = event || <span class="built_in">window</span>.event;</span><br><span class="line">			<span class="keyword">var</span> x = event.clientX;</span><br><span class="line">			<span class="keyword">var</span> y = event.clientY;</span><br><span class="line">			mouseCoordinate.innerHTML = (<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot; , y = &quot;</span> + y);</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-盒子跟随鼠标移动"><a href="#6-盒子跟随鼠标移动" class="headerlink" title="(6).盒子跟随鼠标移动"></a>(6).盒子跟随鼠标移动</h3><h4 id="a-思路-5"><a href="#a-思路-5" class="headerlink" title="a).思路"></a>a).思路</h4><ul>
<li>首先需要通过事件的对象获取鼠标的坐标</li>
<li>当网页长度/宽度足够长/宽时，因为滚动条的存在使用 clientX 会导致坐标偏移的情况</li>
<li>此时需要获取到 html 的 scrollTop/scrollLeft 属性（其实并不是body的）</li>
<li>将获取到的偏移量设置给盒子的偏移量，计算公式为：盒子的偏移量 = clientX + scrollTop/scrollLeft ，注意 clientX 获取到的是数值，所以需要给其拼串拼一个单位</li>
<li>注意兼容IE8及以下</li>
</ul>
<h4 id="b-代码-5"><a href="#b-代码-5" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">		<span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//解决IE8兼容性问题</span></span><br><span class="line">			event = event || <span class="built_in">window</span>.event;</span><br><span class="line">			<span class="comment">//获取鼠标的坐标</span></span><br><span class="line">			<span class="keyword">var</span> left = event.clientX;</span><br><span class="line">			<span class="keyword">var</span> top = event.clientY;</span><br><span class="line">			<span class="comment">//获取滚动条滚动的长度</span></span><br><span class="line">			<span class="keyword">var</span> st = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">			<span class="keyword">var</span> sl = <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">			<span class="comment">//设置div的偏移量</span></span><br><span class="line">			box1.style.left = left + sl + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">			box1.style.top = top + st + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-为新添加的超链接绑定响应函数"><a href="#7-为新添加的超链接绑定响应函数" class="headerlink" title="(7).为新添加的超链接绑定响应函数"></a>(7).为新添加的超链接绑定响应函数</h3><h4 id="a-思路-6"><a href="#a-思路-6" class="headerlink" title="a).思路"></a>a).思路</h4><ul>
<li>根据事件的冒泡与事件的委派，如果想要给超链接绑定单击响应函数，那么只需要给超链接的祖先元素设置单击响应函数即可</li>
<li>如果想要实现点击按钮添加超链接，那么只需要创建一个li节点，给li节点设置其innerHTML属性，最后将li加入到ul中即可</li>
<li>由于事件的委派可以传递给其下的所有后代元素，所以我们需要通过 event.target 来指定我们希望触发事件的对象（在本例中为超链接）</li>
</ul>
<h4 id="b-代码-6"><a href="#b-代码-6" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line">		<span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">		btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">			li.innerHTML = <span class="string">&quot;&lt;a href=&#x27;javascript:;&#x27; class=&#x27;a1&#x27;&gt;你点我啊！&lt;/a&gt;&quot;</span>;</span><br><span class="line">			ul.appendChild(li);</span><br><span class="line">		&#125;;</span><br><span class="line">		ul.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			event = event || <span class="built_in">window</span>.event;</span><br><span class="line">			<span class="keyword">if</span>(event.target.className == <span class="string">&quot;a1&quot;</span>)&#123;</span><br><span class="line">				alert(<span class="string">&quot;这是ul的单击响应函数！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-拖拽元素"><a href="#8-拖拽元素" class="headerlink" title="(8).拖拽元素"></a>(8).拖拽元素</h3><h4 id="a-思路-7"><a href="#a-思路-7" class="headerlink" title="a).思路"></a>a).思路</h4><ul>
<li>想要实现拖拽功能，需要用到 onmousedown、onmousemove、onmouseup 事件</li>
<li>当我们拖拽一个网页中的内容时，浏览器会默认去搜索引擎中搜索内容，此时会导致拖拽功能的异常，此时可以使用以下两个方法来解决这个问题</li>
</ul>
<p>1.在 onmousedown 响应函数的最下边写 return false 来取消默认行为，但不支持IE8及以下<br>2.在 onmousedown 开头使用 setCapture 来捕获所有鼠标按下的事件，在 onmouseup 末尾使用 releaseCapture 来取消捕获。但是该方法只在IE中生效，且在谷歌中会报错，所以需要判断才可以正常使用。</p>
<h4 id="b-代码-7"><a href="#b-代码-7" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">		box1.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			<span class="comment">//取消IE浏览器在鼠标点下时的默认行为，并解决谷歌的兼容性问题</span></span><br><span class="line">			<span class="keyword">if</span>(box1.setCapture)&#123;</span><br><span class="line">				box1.setCapture();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//或这种短路与方式</span></span><br><span class="line">			<span class="comment">//box1.setCapture &amp;&amp; box1.setCapture();</span></span><br><span class="line">			event = event || <span class="built_in">window</span>.event;</span><br><span class="line">			<span class="comment">//获取div的偏移量 鼠标.clientX/Y - 元素.offsetLeft/Top</span></span><br><span class="line">			<span class="keyword">var</span> ol = event.clientX - box1.offsetLeft;</span><br><span class="line">			<span class="keyword">var</span> ot = event.clientY - box1.offsetTop;</span><br><span class="line">			<span class="built_in">document</span>.onmousemove = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">				event = event || <span class="built_in">window</span>.event;</span><br><span class="line">				<span class="comment">//获取鼠标的坐标 此时应该是 鼠标的偏移量 - div的偏移量</span></span><br><span class="line">				<span class="keyword">var</span> left = event.clientX - ol;</span><br><span class="line">				<span class="keyword">var</span> top = event.clientY - ot;</span><br><span class="line">				<span class="comment">//获取滚动条的坐标</span></span><br><span class="line">				<span class="keyword">var</span> st = <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">				<span class="keyword">var</span> sl = <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line">				box1.style.left = left + sl + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">				box1.style.top = top + st + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="comment">//当页面中有其他元素时，在其他元素上松开鼠标不会固定相应的盒子，所以这里不能给box1绑定响应函数，而应该绑定给document</span></span><br><span class="line">			<span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">				<span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">				<span class="comment">//此时，当松开鼠标以后，该函数并没有停止，点击盒子以外的部分依然会触发，所以需要将onmouseup事件设置为null</span></span><br><span class="line">				<span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">				<span class="keyword">if</span>(box1.releaseCapture)&#123;</span><br><span class="line">					box1.releaseCapture();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//或这种短路与的方式</span></span><br><span class="line">				<span class="comment">//box1.releaseCapture &amp;&amp; box1.releaseCapture();</span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="comment">//取消其他浏览器在鼠标点下时的默认行为</span></span><br><span class="line">			<span class="keyword">return</span> fasle;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-实现方向键控制盒子移动"><a href="#9-实现方向键控制盒子移动" class="headerlink" title="(9).实现方向键控制盒子移动"></a>(9).实现方向键控制盒子移动</h3><h4 id="a-思路-8"><a href="#a-思路-8" class="headerlink" title="a).思路"></a>a).思路</h4><ul>
<li>按下方向键控制盒子移动首先需要获取方向键代表的 keyCode</li>
<li>因为盒子无法绑定键盘按下事件，所以需要给 document 绑定</li>
<li>因为涉及到四个按键，所以最好使用 switch </li>
<li><font color=#F00>注意：修改 box1 的水平或垂直偏移量时一定要使用 <code>元素.style.属性</code> 来修改</li>
</ul>
<h4 id="b-代码-8"><a href="#b-代码-8" class="headerlink" title="b).代码"></a>b).代码</h4><ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> box1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>);</span><br><span class="line">		<span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">			event = event || <span class="built_in">window</span>.event;</span><br><span class="line">			<span class="comment">//左上右下分别为：37/38/39/40</span></span><br><span class="line">			<span class="comment">//设置移动速度</span></span><br><span class="line">			<span class="keyword">var</span> speed = <span class="number">10</span>;</span><br><span class="line">			<span class="comment">//当按下ctrl时加速</span></span><br><span class="line">			<span class="keyword">if</span>(event.ctrlKey)&#123;</span><br><span class="line">				speed = <span class="number">50</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">switch</span>(event.keyCode)&#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">37</span>:</span><br><span class="line">					box1.style.left = box1.offsetLeft - speed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">39</span>:</span><br><span class="line">					box1.style.left = box1.offsetLeft + speed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">38</span>:</span><br><span class="line">					box1.style.top = box1.offsetTop - speed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="number">40</span>:</span><br><span class="line">					box1.style.top = box1.offsetTop + speed + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-注意"><a href="#c-注意" class="headerlink" title="c).注意"></a>c).注意</h4><ul>
<li>这里因为有浏览器的默认行为，所以会导致盒子在移动的时候第一下总会卡顿一下，这时防止用户误操作而设置的</li>
<li>如果想要优化，则需要使用定时器来优化，具体请看<a href="#setInterval">这里</a></li>
</ul>
<h2 id="3-BOM"><a href="#3-BOM" class="headerlink" title="3.BOM"></a>3.BOM</h2><h3 id="1-简介-6"><a href="#1-简介-6" class="headerlink" title="(1).简介"></a>(1).简介</h3><ul>
<li>是浏览器对象模型，可以通过JS来操作浏览器</li>
<li>BOM 中为我们提供了一组对象，用来完成对浏览器的操作</li>
</ul>
<h3 id="2-BOM对象"><a href="#2-BOM对象" class="headerlink" title="(2).BOM对象"></a>(2).BOM对象</h3><ul>
<li>这些 BOM 对象在浏览器中都是作为 Window 对象的属性保存的，可以通过 window 对象来使用，也可以直接使用</li>
</ul>
<h4 id="a-window"><a href="#a-window" class="headerlink" title="a).window"></a>a).window</h4><ul>
<li>代表的是整个浏览器的窗口，同时也是网页中的全局对象</li>
</ul>
<h4 id="a1-window方法之定时调用"><a href="#a1-window方法之定时调用" class="headerlink" title="a1).window方法之定时调用"></a>a1).window方法之定时调用</h4><ul>
<li><p>如果希望一个程序可以每隔一段时间执行一次，可以使用定时调用</p>
</li>
<li><p>setInterval() 为定时调用，可以将一个函数每隔一段时间执行一次，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数如下：</span><br><span class="line">	1.回调函数</span><br><span class="line">	2.每次调用间隔的时间，单位为ms</span><br><span class="line">	setInterval(function()&#123;</span><br><span class="line">		代码;</span><br><span class="line">	&#125;,1000);</span><br><span class="line">返回值：</span><br><span class="line">	返回一个Number类型的数据，用来作为定时器的唯一标识</span><br></pre></td></tr></table></figure></li>
<li><p>clearInterval() 可以用来关闭一个定时器，该方法需要一个定时器的标识作为参数，这样将关闭标识对应的定时器。如果参数不是一个有效的标识，则什么也不做</p>
</li>
</ul>
<h4 id="a2-window方法之延时（超时）调用"><a href="#a2-window方法之延时（超时）调用" class="headerlink" title="a2).window方法之延时（超时）调用"></a>a2).window方法之延时（超时）调用</h4><ul>
<li><p>延时调用时一个函数不马上执行，而是隔一段事件以后再执行，且只会执行一次</p>
</li>
<li><p>setTimeout() 为延时调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数如下：</span><br><span class="line">	1.回调函数</span><br><span class="line">	2.每次调用间隔的时间，单位为ms</span><br><span class="line">	setTimeout(function()&#123;</span><br><span class="line">		代码;</span><br><span class="line">	&#125;,1000);</span><br><span class="line">返回值：</span><br><span class="line">	返回一个Number类型的数据，用来作为延时调用的唯一标识</span><br></pre></td></tr></table></figure></li>
<li><p>clearTimeout() 可以用来关闭一个延时调用，该方法需要一个延时调用的标识作为参数，这样将关闭标识对应的延时调用</p>
</li>
<li><p>延时调用和定时调用实际上是可以互相替代的，在开发中可以根据自己的需要去选择</p>
</li>
</ul>
<h4 id="b-navigator"><a href="#b-navigator" class="headerlink" title="b).navigator"></a>b).navigator</h4><ul>
<li>代表的是当前浏览器的信息</li>
<li>通过该对象可以来识别不同的浏览器</li>
<li>该对象中的大部分属性已经无法使用了，除了 <code>userAgent</code> 可以用来判断浏览器的信息，搭配正则表达式来判断</li>
</ul>
<h4 id="c-location"><a href="#c-location" class="headerlink" title="c).location"></a>c).location</h4><ul>
<li>代表当前浏览器的地址栏信息</li>
<li>通过该对象可以获取地址栏信息，或者操作浏览器跳转页面</li>
<li>assign() 方法用来跳转到其他的页面，作用和直接修改 location 一样</li>
<li>reload() 方法用于重新加载当前页面，作用和刷新按钮一样。如果在方法中传递一个 true 作为参数，则会强制清空缓存刷新页面</li>
<li>replace() 方法可以使用一个新的页面替换当前页面，调用完毕也会跳转页面，不会生成历史记录，即不能使用回退按钮回退</li>
</ul>
<h4 id="d-history"><a href="#d-history" class="headerlink" title="d).history"></a>d).history</h4><ul>
<li>代表浏览器的历史记录</li>
<li>通过该对象来操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或者向后翻页，且该操作只在当次访问时有效</li>
<li>length 属性可以获取到当前访问的链接数量</li>
<li>back() 方法可以用来回退到上一个页面</li>
<li>forward() 方法可以用来前进到下一个页面</li>
<li>go() 方法可以用来跳转到指定的页面，需要一个整数作为一个参数（1表示向前跳转一个页面，-1表示向后跳转一个页面）</li>
</ul>
<h4 id="e-screen"><a href="#e-screen" class="headerlink" title="e).screen"></a>e).screen</h4><ul>
<li>代表用户的屏幕信息</li>
<li>通过该对象可以获取到用户的显示器的相关信息</li>
</ul>
<h2 id="4-BOM-案例分析"><a href="#4-BOM-案例分析" class="headerlink" title="4.BOM 案例分析"></a>4.BOM 案例分析</h2><h3 id="1-定时切换图片"><a href="#1-定时切换图片" class="headerlink" title="(1).定时切换图片"></a>(1).定时切换图片</h3><h4 id="a-实现思路"><a href="#a-实现思路" class="headerlink" title="a).实现思路"></a>a).实现思路</h4><ul>
<li>想要实现切换图片，则需要修改 src 属性，而为了方便，可以把 src 放入一个数组中</li>
<li>有数组以后需要一个索引变量，用来获取到数组中的内容</li>
<li>为了防止图片一直播放，还需要判断图片是否超过最大索引（可以使用if，也可以使用取模运算）</li>
<li>使用定时器来自动切换图片，如果开启定时器事件绑定给了按钮，为了防止连续点击按钮造成多个事件重复发生，需要在点击前先关闭定时器再开启定时器</li>
<li>由于关闭定时器需要获取定时器的标识，如果点击另一个按钮关闭定时器，那么需要将定时器的标识定义在全局中，这样才可以正确获取到在别的按钮中的定时器标识</li>
</ul>
<h4 id="b-展示与源码"><a href="#b-展示与源码" class="headerlink" title="b).展示与源码"></a>b).展示与源码</h4><ul>
<li>请点击 <a href="/demo/JSex/bomChangePicture.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h3 id="2-方向键控制盒子移动优化版"><a href="#2-方向键控制盒子移动优化版" class="headerlink" title="(2).方向键控制盒子移动优化版"></a><span id="setInterval">(2).方向键控制盒子移动优化版</span></h3><h4 id="a-实现思路-1"><a href="#a-实现思路-1" class="headerlink" title="a).实现思路"></a>a).实现思路</h4><ul>
<li>这个是基于 DOM 案例中进行的优化，之前的版本在移动刚开始会卡顿一下，这里使用定时器来进行优化</li>
<li>将定时器定义在全局范围内，让他每30ms运行一次</li>
<li>在键盘按下时进入 switch，即可执行当前语句</li>
<li>在键盘松开时就需要将键盘按钮值设置为一个与其不相关的值来终止移动</li>
<li>若需要更改速度，一定要把速度定义在 <code>window.onload</code> 的全局范围内</li>
</ul>
<h4 id="b-展示与源码-1"><a href="#b-展示与源码-1" class="headerlink" title="b).展示与源码"></a>b).展示与源码</h4><ul>
<li>请点击 <a href="/demo/JSex/bomKeyCodeUpDown.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h3 id="3-点击按钮盒子移动到固定点"><a href="#3-点击按钮盒子移动到固定点" class="headerlink" title="(3).点击按钮盒子移动到固定点"></a>(3).点击按钮盒子移动到固定点</h3><h4 id="a-实现思路-2"><a href="#a-实现思路-2" class="headerlink" title="a).实现思路"></a>a).实现思路</h4><ul>
<li>首先你得获取到盒子的原始位置，这里创建了一个函数用来获取元素的样式</li>
<li>此时获取到的盒子位置数值带有单位，所以需要使用取整函数来取整——parseInt()</li>
<li>盒子移动的实质就是在盒子原有数值上进行速度的增加</li>
<li>如果盒子到达固定宽度时，需要判断一下，同时考虑不是整数速度时怎么控制停在整数位置</li>
</ul>
<h4 id="b-展示与源码-2"><a href="#b-展示与源码-2" class="headerlink" title="b).展示与源码"></a>b).展示与源码</h4><ul>
<li>请点击 <a href="/demo/JSex/bomButtonBox.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h3 id="4-点击按钮盒子左右移动到固定点"><a href="#4-点击按钮盒子左右移动到固定点" class="headerlink" title="(4).点击按钮盒子左右移动到固定点"></a>(4).点击按钮盒子左右移动到固定点</h3><h4 id="a-实现思路-3"><a href="#a-实现思路-3" class="headerlink" title="a).实现思路"></a>a).实现思路</h4><ul>
<li>该案例是上面那个案例的优化版，需要实现两个按钮控制一个元素左右移动到固定点</li>
<li>因为两个按钮实现的事件都是一致的，所以这里将控制盒子移动的动画封装到一个函数中</li>
<li>为了避免用户自行判断盒子移动方向和速度正负，这里需要判断目标位置和当前位置，来判断左右移和速度正负值</li>
</ul>
<h4 id="b-展示与源码-3"><a href="#b-展示与源码-3" class="headerlink" title="b).展示与源码"></a>b).展示与源码</h4><ul>
<li>请点击 <a href="/demo/JSex/bomButtonBoxPlus.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h3 id="5-点击按钮盒子随意变换移动"><a href="#5-点击按钮盒子随意变换移动" class="headerlink" title="(5).点击按钮盒子随意变换移动"></a>(5).点击按钮盒子随意变换移动</h3><h4 id="a-实现思路-4"><a href="#a-实现思路-4" class="headerlink" title="a).实现思路"></a>a).实现思路</h4><ul>
<li>该案例是上面那个案例的再优化版，可以实现点击按钮使得元素随意变换</li>
<li>在上面的封装好的函数里面，又新增了两个参数，分别是属性和回调函数。属性来存放需要变换的长宽高等，回调函数中则可以继续调用该元素的动画效果</li>
<li>而在结束完此次动画后，应该判断是否有回调函数，有就执行，无则跳过</li>
</ul>
<h4 id="b-展示与源码-4"><a href="#b-展示与源码-4" class="headerlink" title="b).展示与源码"></a>b).展示与源码</h4><ul>
<li>请点击 <a href="/demo/JSex/bomButtonBoxPlusPlus.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h3 id="6-综合案例之轮播图"><a href="#6-综合案例之轮播图" class="headerlink" title="(6).综合案例之轮播图"></a>(6).综合案例之轮播图</h3><h4 id="a-实现思路-5"><a href="#a-实现思路-5" class="headerlink" title="a).实现思路"></a>a).实现思路</h4><ul>
<li>首先轮播图可以通过无序列表来实现，让 ul 水平排放在页面中央，将需要显示的放在显示区域，其余溢出部分使用 overflow 来设置</li>
<li>注意开启定位元素，其大小是由内容撑开的，所以居中效果和平常不太一样</li>
<li>类似于 ul 的整体宽度并不能在 css 中写死，因为图片的数量是不定的，所以需要在 js 中动态的去改变</li>
<li>图片转动的原理就是修改 ul 的水平偏移量为一个图片的大小，这样它就可以按顺序依次进行轮播</li>
<li>当图片转到最后一张时，我们需要让其重新回到第一张，解决办法就是在最后一张照片后面加第一张照片，在其切换过去的瞬间，使 ul 的水平偏移量瞬间变为0，则其可以正常从第一张开始进行无限轮回</li>
<li>当点击到下面的按钮（即超链接）时，图片应该跟随跳转，这里运用我们之前写好的一个 js 脚本即可实现</li>
<li>如果想要实现自动切换图片，那么需要开启定时器，但此时定时器的自动切换和点击超链接的切换会冲突，所以需要在点击事件刚开始时取消定时器，在点击事件完毕时开启定时器</li>
</ul>
<h4 id="b-展示与源码-5"><a href="#b-展示与源码-5" class="headerlink" title="b).展示与源码"></a>b).展示与源码</h4><ul>
<li>请点击 <a href="/demo/JSex/bomImageRotators.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="5-类的操作"><a href="#5-类的操作" class="headerlink" title="5.类的操作"></a>5.类的操作</h2><ul>
<li>通过 style 属性来修改元素的样式，每修改一个样式，浏览器就重新渲染一次页面，这样的执行性能是比较差的，而且这种形式当我们要修改多个样式时，也不方便</li>
<li>我们可以通过修改元素的 class 属性来间接修改样式，这样只需修改一次即可同时修改多个样式，浏览器只需要重新渲染页面一次，性能比较好，更有利于行为和表现分离<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">box.className = <span class="string">&quot;b2&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-是否含有指定class属性"><a href="#1-是否含有指定class属性" class="headerlink" title="(1).是否含有指定class属性"></a>(1).是否含有指定class属性</h3><ul>
<li>定义一个函数，判断一个元素中是否含有指定的class属性</li>
<li>具体如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasClass</span>(<span class="params">obj,cn</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//创建一个正则表达式，因为这里是传obj不需要写死，所以需要构造函数的写法</span></span><br><span class="line">	<span class="comment">//有时候class属性有很多个，所以需要使用 \b 来设置字符边界</span></span><br><span class="line">	<span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\b&quot;</span>+cn+<span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">	<span class="comment">//使用test()方法来检测其中是否有cn</span></span><br><span class="line">	<span class="keyword">return</span> reg.test(obj.className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-添加指定class属性"><a href="#2-添加指定class属性" class="headerlink" title="(2).添加指定class属性"></a>(2).添加指定class属性</h3><ul>
<li>定义一个函数，用来向一个元素中添加指定的 class 属性</li>
<li>具体如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * obj 要添加的class属性</span></span><br><span class="line"><span class="comment"> * cn 要添加的class值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">obj,cn</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//检查obj中是否含有cn，有的时候就不管，没有就添加</span></span><br><span class="line">	<span class="keyword">if</span>(!hasClass(obj,cn))&#123;</span><br><span class="line">		obj.className += <span class="string">&quot; &quot;</span> + cn;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-删除指定class属性"><a href="#3-删除指定class属性" class="headerlink" title="(3).删除指定class属性"></a>(3).删除指定class属性</h3><ul>
<li>定义一个函数，删除一个元素中指定的class属性</li>
<li>具体如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeClass</span>(<span class="params">obj,cn</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//创建一个正则表达式</span></span><br><span class="line">	<span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;\\b&quot;</span>+cn+<span class="string">&quot;\\b&quot;</span>);</span><br><span class="line">	<span class="comment">//删除class，即用空串替换掉原本的class属性</span></span><br><span class="line">	obj.className = obj.className.replace(reg,<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-切换一个类的class属性"><a href="#4-切换一个类的class属性" class="headerlink" title="(4).切换一个类的class属性"></a>(4).切换一个类的class属性</h3><ul>
<li>定义一个函数，可以切换一个类，即有则删除，无则添加</li>
<li>具体如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggleClass</span>(<span class="params">obj,cn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(hasClass(obj,cn))&#123;</span><br><span class="line">		removeClass(obj,cn);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		addClass(obj,cn);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-类的操作-案例分析"><a href="#6-类的操作-案例分析" class="headerlink" title="6.类的操作 案例分析"></a>6.类的操作 案例分析</h2><h3 id="1-二级菜单的实现"><a href="#1-二级菜单的实现" class="headerlink" title="(1).二级菜单的实现"></a>(1).二级菜单的实现</h3><h4 id="a-实现思路-6"><a href="#a-实现思路-6" class="headerlink" title="a).实现思路"></a>a).实现思路</h4><ul>
<li>每一个一级菜单都是一个盒子，二级菜单是由众多的a链接组成的</li>
<li>想要实现二级菜单的隐藏，则只需要其高度等于一级菜单的高度即可实现</li>
<li>想要实现二级菜单的显示与否，只要给其增加或删除相应的 class 属性即可</li>
<li>想要鼠标移入非链接处变为可点击状态，那么需要给其添加 cursor 的 css属性</li>
</ul>
<h4 id="b-展示与源码-6"><a href="#b-展示与源码-6" class="headerlink" title="b).展示与源码"></a>b).展示与源码</h4><ul>
<li>请点击 <a href="/demo/JSex/menuTwoLeval.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h1 id="六、正则表达式"><a href="#六、正则表达式" class="headerlink" title="六、正则表达式"></a>六、正则表达式</h1><h2 id="1-简介-7"><a href="#1-简介-7" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li>用于定义一些字符串的规则</li>
<li>计算机可以根据正则表达式来检查一个字符串是否符合规则或者将字符串中符合规则的内容提取出来</li>
<li>正则表达式也是一个对象</li>
</ul>
<h2 id="2-创建正则表达式"><a href="#2-创建正则表达式" class="headerlink" title="2.创建正则表达式"></a>2.创建正则表达式</h2><ul>
<li>使用构造函数创建更加灵活，而使用字面量创建更加方便</li>
</ul>
<h3 id="1-使用构造函数创建"><a href="#1-使用构造函数创建" class="headerlink" title="(1).使用构造函数创建"></a>(1).使用构造函数创建</h3><ul>
<li><p>语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;正则表达式&quot;</span>,<span class="string">&quot;匹配模式&quot;</span>);</span><br><span class="line">匹配模式有两个：</span><br><span class="line">i：忽略大小写</span><br><span class="line">g：全局匹配模式</span><br></pre></td></tr></table></figure></li>
<li><p>正则表达式中有个 test() 方法，可以用来检查一个字符串是否符合正则表达式的规则，符合返回 true，之为 false</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">result = reg.test(str);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-使用字面量创建"><a href="#2-使用字面量创建" class="headerlink" title="(2).使用字面量创建"></a>(2).使用字面量创建</h3><ul>
<li>语法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量 = <span class="regexp">/正则表达式/</span>匹配模式;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-正则语法"><a href="#3-正则语法" class="headerlink" title="3.正则语法"></a>3.正则语法</h2><h3 id="1-或"><a href="#1-或" class="headerlink" title="(1).或"></a>(1).或</h3><ul>
<li>使用<code>[]</code>或者<code>|</code><br><code>[a-z]</code> ：任意小写字母<br><code>[A-Z]</code> ：任意大写字母<br><code>[A-z]</code> ：任意字母（实际并不准确，因为在 Unicode 编码中 A-z 中还有其他符号）<br><code>a[bcd]e</code> ：以a开头，以e结尾，中间包含b或c或d<br><code>[0-9]</code> ：任意数字</li>
</ul>
<h3 id="2-量词"><a href="#2-量词" class="headerlink" title="(2).量词"></a>(2).量词</h3><ul>
<li>在<code>&#123;&#125;</code>中加入数字，即可指定出现多少次</li>
<li>量词只对它前边的一个内容起作用，如果需要多个可以给前面多个内容加一个()<br><code>[a&#123;3&#125;]</code> ：即为aaa<br><code>[a&#123;1,3&#125;b]</code> ：即为ab，aab，aaab<br><code>[a&#123;3,&#125;]</code> ：a最少为3次<br><code>[(ab)&#123;3&#125;]</code> ：即为ababab<br><code>[ab+c]</code> ：至少一个，相当于{1,}<br><code>[ab*c]</code> ：0个或多个，相当于{0,}<br><code>[ab?c]</code> ：0个或1个，相当于{0,1}</li>
</ul>
<h3 id="3-开头与结尾"><a href="#3-开头与结尾" class="headerlink" title="(3).开头与结尾"></a>(3).开头与结尾</h3><ul>
<li>使用 <code>^</code> 来检查一个字符串是否以指定内容开头<br><code>^a</code> ：检查一个字符串是否以a开头</li>
<li>使用 <code>$</code> 来检查一个字符串是否以指定内容结尾<br><code>a$</code> ：检查一个字符串是否以a结尾</li>
<li>如果在一个正则表达式中同时使用上面两个字符，则要求字符串必须完全符合正则表达式<br><code>^a$</code> ：表示只含有字符a</li>
</ul>
<h3 id="4-除了"><a href="#4-除了" class="headerlink" title="(4).除了"></a>(4).除了</h3><ul>
<li>使用 <code>^</code> 可以表示除了指定内容</li>
<li>区别于上面的开头：<br><code>^abc</code> ：这个指的是以abc开头<br><code>[^abc]</code> ：这个指的是除了abc</li>
</ul>
<h3 id="4-任意字符"><a href="#4-任意字符" class="headerlink" title="(4).任意字符"></a>(4).任意字符</h3><ul>
<li>在正则中 <code>.</code> 表示任意字符，如果需要查找字符串中是否含有 <code>.</code> 时需要使用转义字符</li>
</ul>
<h3 id="5-转义字符"><a href="#5-转义字符" class="headerlink" title="(5).转义字符"></a>(5).转义字符</h3><ul>
<li><p>在正则中 <code>\</code> 表示转义字符</p>
</li>
<li><p><font color=#F00>注意：在使用构造函数时，由于它的参数时一个字符串，而 <code>\</code> 是字符串中的转义字符，所以如果要使用 <code>\</code> 则需要使用 <code>\\</code> 来代替</font></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&quot;abc.&quot;</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>转义字符中比较特殊的：<br><code>\w</code> ：查找任意字母、数字、_<br><code>\W</code> ：查找除了字母、数字、_<br><code>\d</code> ：查找任意的数字<br><code>\D</code> ：查找除了数字<br><code>\s</code> ：查找空格<br><code>\S</code> ：查找除了空格<br><code>\b</code> ：查找单词边界<br><code>\B</code> ：查找除了单词边界</p>
</li>
</ul>
<h2 id="4-字符串和正则相关的方法"><a href="#4-字符串和正则相关的方法" class="headerlink" title="4.字符串和正则相关的方法"></a>4.字符串和正则相关的方法</h2><ul>
<li>看<a href="#split">这里</a>的 j-m 部分</li>
<li>test() 函数用来检测一个字符串是否匹配某个模式，它返回一个布尔值，语法如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">regexp.test(str)	即正则表达式模式或者可用标志的正则表达式对象</span><br><span class="line">例如：</span><br><span class="line">/[a-z]/i.test(123a)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-案例分析"><a href="#5-案例分析" class="headerlink" title="5.案例分析"></a>5.案例分析</h2><h3 id="1-检测手机号是否正确"><a href="#1-检测手机号是否正确" class="headerlink" title="(1).检测手机号是否正确"></a>(1).检测手机号是否正确</h3><ul>
<li>手机号的规则如下：</li>
</ul>
<p>1.第一位为1<br>2.第二位为3-9<br>3.第三位开始为0-9（9位）<br>4.手机号总共为11位</p>
<ul>
<li>且手机号都是数字开头结尾，所以需要同时使用 <code>^$</code> 符号<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> phoneStr=<span class="string">&quot;17835204401&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^1[3-9][0-9]&#123;9&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(phoneStr));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-去除字符串左右两端的空格"><a href="#2-去除字符串左右两端的空格" class="headerlink" title="(2).去除字符串左右两端的空格"></a>(2).去除字符串左右两端的空格</h3><ul>
<li>当从用户那里获取到一个字符串时，用户可能无意间在左右两边打上了空格，这时我们可以自动的帮其去除</li>
<li>去除空格可以考虑用空串替换空格，只替换开头结尾可以使用 <code>^$</code> ，同时去除可以用 <code>|</code> 和全局匹配模式。如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;   abcd efgh   &quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/^\s*|\s*$/g</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-检测邮箱是否准确"><a href="#3-检测邮箱是否准确" class="headerlink" title="(3).检测邮箱是否准确"></a>(3).检测邮箱是否准确</h3><ul>
<li><p>在写正则表达式时，可以将需要写的内容分段来写，然后再合在一起，可看下图：<br><img src="https://s1.ax1x.com/2020/10/18/0jBSBQ.png" alt="js11.png"></p>
</li>
<li><p>所以根据上述可以这样写出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\w&#123;3,&#125;   (\.\w&#123;3,&#125;)*   @   [a-z0-9]+   (\.[a-z]&#123;2,5&#125;)&#123;1,2&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因为只能包含有邮件格式，所以需要加上开头与结尾符号，实际效果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mailStr = <span class="string">&quot;15035374951@126.com&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\w&#123;3,&#125;(\.\w&#123;3,&#125;)*@[a-z0-9]+(\.[a-z]&#123;2,5&#125;)&#123;1,2&#125;$/i</span>;</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(mailStr));</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="七、包装类"><a href="#七、包装类" class="headerlink" title="七、包装类"></a>七、包装类</h1><h2 id="1-简介-8"><a href="#1-简介-8" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li><p>在 JS 中提供了三种包装类，通过这三种包装类可以将基本数据类型的数据转换为对象</p>
</li>
<li><p>这三个包装类分别为：String()、Number()、Boolean()</p>
</li>
<li><p>调用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure></li>
<li><p>但其实在开发中并不会使用上面的方法调用</p>
</li>
</ul>
<h2 id="2-浏览器的隐式调用"><a href="#2-浏览器的隐式调用" class="headerlink" title="2.浏览器的隐式调用"></a>2.浏览器的隐式调用</h2><ul>
<li>首先，方法和属性只能添加给对象，不能添加给基本数据类型</li>
<li>但是我们对一些基本数据类型的值去调用属性和方法时，浏览器会 <strong>临时</strong> 使用包装类将其转换为对象，然后再调用对象的属性和方法，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="number">123</span>;</span><br><span class="line">s = s.toString();</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-String"><a href="#3-String" class="headerlink" title="3.String()"></a>3.String()</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="(1).属性"></a>(1).属性</h3><ul>
<li>该对象的属性如下：<br><img src="https://s1.ax1x.com/2020/10/18/0j0vjS.png" alt="js09.png"></li>
</ul>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="(2).方法"></a>(2).方法</h3><h4 id="a-charAt"><a href="#a-charAt" class="headerlink" title="a.charAt()"></a>a.charAt()</h4><ul>
<li>可以返回字符串中指定位置的字符</li>
<li>根据索引获取指定的字符<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;Wrysmile&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.charAt(<span class="number">6</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-charCodeAt"><a href="#b-charCodeAt" class="headerlink" title="b.charCodeAt()"></a>b.charCodeAt()</h4><ul>
<li>获取指定位置字符的字符编码（Unicode编码）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;Wrysmile&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.charCodeAt(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-fromCharCodeAt"><a href="#c-fromCharCodeAt" class="headerlink" title="c.fromCharCodeAt()"></a>c.fromCharCodeAt()</h4><ul>
<li>可以根据字符编码来获取字符</li>
<li>该方法需要使用 String 去调用，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">String</span>.fromCharCodeAt(<span class="number">0x2692</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="d-conCat"><a href="#d-conCat" class="headerlink" title="d.conCat()"></a>d.conCat()</h4><ul>
<li>可以用来连接两个或多个字符串</li>
<li>作用和+号一样<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;Wrysmile&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.conCat(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="e-indexOf"><a href="#e-indexOf" class="headerlink" title="e.indexOf()"></a>e.<span id="indexOf">indexOf()</span></h4><ul>
<li><p>可以检索一个字符串中是否含有指定内容</p>
</li>
<li><p>如果字符串中含有该内容，则会返回其第一次出现的索引<br>如果没有该内容，则返回 -1</p>
</li>
<li><p>也可以指定第二个参数，指定开始查找的位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;Wrysmile&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.indexOf(<span class="string">&quot;s&quot;</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="f-lastIndexOf"><a href="#f-lastIndexOf" class="headerlink" title="f.lastIndexOf()"></a>f.lastIndexOf()</h4><ul>
<li>和上面用法一样，不同的是上者从前往后找，而下者从后往前找</li>
<li>也可以指定一个第二个参数，指定开始查找的位置<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;Wrysmile&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.lastIndexOf(<span class="string">&quot;s&quot;</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="g-slice"><a href="#g-slice" class="headerlink" title="g.slice()"></a>g.slice()</h4><ul>
<li><p>可以从字符串中截取指定的内容，不会影响原字符串，而是将截取到的内容返回</p>
</li>
<li><p>参数：<br>第一个：开始位置的索引（包括开始位置）<br>第二个：结束位置的索引（不包括结束位置）</p>
</li>
<li><p>如果省略第二个参数，则会截取到后边所有的，也可以传递一个负数作为参数，负数的话将会从后边计算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;Wrysmile&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.slice(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="h-substring"><a href="#h-substring" class="headerlink" title="h.substring()"></a>h.substring()</h4><ul>
<li>可以用来截取一个字符串</li>
<li>和 slice() 的区别是：</li>
</ul>
<p>1.该方法不接受负值作为参数，否则会默认使用0<br>2.该方法会自动调整参数的位置，即第二个参数小于第一个参数，会自动交换</p>
<h4 id="i-substr"><a href="#i-substr" class="headerlink" title="i.substr()"></a>i.substr()</h4><ul>
<li>用来截取字符串</li>
<li>参数：<br>第一个：开始位置的索引<br>第二个：截取的长度</li>
</ul>
<h4 id="j-split"><a href="#j-split" class="headerlink" title="j.split()"></a>j.<span id="split">split()</span></h4><ul>
<li><p>可以将一个字符串拆分成一个数组</p>
</li>
<li><p>参数：需要一个字符串作为参数，将会根据该字符串去拆分数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;Wrysmile&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
<li><p>按字母来拆分成数组，且默认为全局匹配模式，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;1a2b3c4d5e6&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.split(<span class="regexp">/[A-z]/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
<li><p>空串会将每个字符拆分成数组元素</p>
</li>
</ul>
<h4 id="k-search"><a href="#k-search" class="headerlink" title="k.search()"></a>k.search()</h4><ul>
<li>可以搜索字符串中是否含有指定内容</li>
<li>如果搜索到指定内容，则会返回第一次（即使设置全局匹配模式也还是第一个）出现的索引，否则返回-1</li>
<li>但是该方法可以接收一个正则表达式作为参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;abc def ghi adc&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.search(<span class="regexp">/a[bdf]c/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="l-match"><a href="#l-match" class="headerlink" title="l.match()"></a>l.match()</h4><ul>
<li>可以根据正则表达式，从一个字符串中将符合条件的内容提取出来</li>
<li>默认情况下只会找到第一个符合要求的内容，所以需要设置全局匹配模式来获取所有内容</li>
<li>该方法会将匹配到的内容封装到一个数组中返回，即便只有一个结果<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;1a2b3c4d5e6A&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.match(<span class="regexp">/[A-z]/ig</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="m-replace"><a href="#m-replace" class="headerlink" title="m.replace()"></a>m.replace()</h4><ul>
<li>可以将字符串中指定的内容替换为新的内容</li>
<li>参数：</li>
</ul>
<p>1.被替换的内容<br>2.新的内容，空串为空</p>
<ul>
<li>默认情况下只会替换第一个内容，所以可以在第一个参数中传入正则表达式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">str = <span class="string">&quot;1a2b3c4d5e6A&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> result = str.replace(<span class="regexp">/[a-z]/ig</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="n-other"><a href="#n-other" class="headerlink" title="n.other"></a>n.other</h4><ul>
<li>其他的方法如下：<br><img src="https://s1.ax1x.com/2020/10/18/0j0zng.png" alt="js10.png"></li>
</ul>
<h1 id="八、JSON"><a href="#八、JSON" class="headerlink" title="八、JSON"></a>八、JSON</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><ul>
<li>JSON 为 JavaScript Object Notation，即JS对象表示法</li>
<li>JSON 就是一个特殊格式的字符串，可以被任意的语言所识别，并且可以转换为任意语言中的对象，在开发中主要用来数据的交互</li>
<li><font color=#F00>注意：JSON 字符串中的属性名必须加双引号</font></li>
</ul>
<h2 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类"></a>2.分类</h2><h3 id="1-对象"><a href="#1-对象" class="headerlink" title="(1).对象"></a>(1).对象</h3><ul>
<li>使用 {} 括起来的，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-数组"><a href="#2-数组" class="headerlink" title="(2).数组"></a>(2).数组</h3><ul>
<li>使用 [] 括起来的，如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="string">&#x27;[1,2,3,&quot;hello&quot;]&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-允许值"><a href="#3-允许值" class="headerlink" title="3.允许值"></a>3.允许值</h2><ul>
<li><p>JSON 中只允许传入以下值：<br>字符串<br>数值<br>布尔值<br>null<br>对象<br>数组</p>
</li>
<li><p>示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="string">&#x27;&#123;&quot;arr&quot;:[1,2,3]&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="string">&#x27;[&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;,&#123;&quot;name&quot;:&quot;猪八戒&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;]&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-JSON工具类"><a href="#4-JSON工具类" class="headerlink" title="4.JSON工具类"></a>4.JSON工具类</h2><ul>
<li>在 JS 中有个工具类，就叫 JSON，可以将一个 JSON 转换为 JS对象，也可以将一个 JS对象转换为 JSON</li>
<li>JSON 对象在IE7及以下不支持</li>
</ul>
<h3 id="1-JSON-parse-方法"><a href="#1-JSON-parse-方法" class="headerlink" title="(1).JSON.parse()方法"></a>(1).JSON.parse()方法</h3><ul>
<li>可以将一个 JSON 字符串转换为 JS对象</li>
<li>它需要一个 JSON 字符串作为参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">JSON</span>.parse(obj);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-JSON-stringify-方法"><a href="#2-JSON-stringify-方法" class="headerlink" title="(2).JSON.stringify()方法"></a>(2).JSON.stringify()方法</h3><ul>
<li>可以将一个 JS对象转换为 JSON 字符串</li>
<li>它需要一个 JS对象作为参数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&quot;孙悟空&quot;</span>,<span class="attr">age</span>:<span class="number">18</span>,<span class="attr">gender</span>:<span class="string">&quot;男&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-兼容IE7及以下"><a href="#3-兼容IE7及以下" class="headerlink" title="(3).兼容IE7及以下"></a>(3).兼容IE7及以下</h3><ul>
<li><p>eval() 这个函数可以用来执行一段字符串形式的 JS 代码，并将执行结果返回</p>
</li>
<li><p>如果使用该函数执行得字符串中含有 {}，他会将其当成是代码块。如果不希望将其当成代码块解析，则需要在字符串前后各加一个 ()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;孙悟空&quot;,&quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span>+str+<span class="string">&quot;)&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure></li>
<li><p><font color=#F00>注意：eval() 这个函数的功能很强大，可以直接执行一个字符串中的 JS代码，但在开发中尽量不要使用，首先它的性能比较差，而且它还具有安全隐患</font></p>
</li>
</ul>
<h4 id="最终方案"><a href="#最终方案" class="headerlink" title="!最终方案"></a>!最终方案</h4><ul>
<li>如果需要兼容 IE7集以下的 JSON 操作，则可以通过引入一个外部的 JS文件来处理</li>
<li>该 js 文件重新创建了一个 JSON 对象</li>
</ul>
<h1 id="九、JS高级内容"><a href="#九、JS高级内容" class="headerlink" title="九、JS高级内容"></a>九、JS高级内容</h1><h2 id="1-基础深入"><a href="#1-基础深入" class="headerlink" title="1.基础深入"></a>1.基础深入</h2><h3 id="1-数据类型部分"><a href="#1-数据类型部分" class="headerlink" title="(1).数据类型部分"></a>(1).数据类型部分</h3><h4 id="1-undefined-和-null-的区别？"><a href="#1-undefined-和-null-的区别？" class="headerlink" title="1).undefined 和 null 的区别？"></a>1).undefined 和 null 的区别？</h4><ul>
<li>undefined 是定义但未赋值</li>
<li>null 是定义且赋值了，只是值为 null</li>
</ul>
<h4 id="2-什么时候给变量赋值为-null？"><a href="#2-什么时候给变量赋值为-null？" class="headerlink" title="2).什么时候给变量赋值为 null？"></a>2).什么时候给变量赋值为 null？</h4><ul>
<li>初始赋值时，表明将要赋值的对象</li>
<li>结束时赋值，让对象成为垃圾对象，被垃圾回收器回收</li>
</ul>
<h4 id="3-如何判断数据类型？"><a href="#3-如何判断数据类型？" class="headerlink" title="3).如何判断数据类型？"></a>3).如何判断数据类型？</h4><ul>
<li>typeof：<ul>
<li>特点：判断基本数据类型，返回字符串</li>
<li>作用：判断变量的数据类型</li>
<li>优点：可以判断undefined、数值、字符串、布尔值、function</li>
<li>缺点：不能判断null与object、array与object</li>
</ul>
</li>
<li>instanceof：<ul>
<li>特点：判断引用数据类型，返回布尔值</li>
<li>作用：判断一个变量是否属于某个对象的实例</li>
</ul>
</li>
<li>===：可以判断undefined、null</li>
</ul>
<h3 id="2-常量与变量部分"><a href="#2-常量与变量部分" class="headerlink" title="(2).常量与变量部分"></a>(2).常量与变量部分</h3><h4 id="1-怎么严格区分变量类型与数据类型？"><a href="#1-怎么严格区分变量类型与数据类型？" class="headerlink" title="1).怎么严格区分变量类型与数据类型？"></a>1).怎么严格区分变量类型与数据类型？</h4><ul>
<li>数据的类型包含：基本数据类型和对象数据类型</li>
<li>变量的类型包含：基本数据类型（保存的是基本类型的数据）和引用数据类型（保存的是地址值）</li>
</ul>
<h4 id="2-在JS调用函数时传递变量参数时，是值传递还是引用传递？"><a href="#2-在JS调用函数时传递变量参数时，是值传递还是引用传递？" class="headerlink" title="2).在JS调用函数时传递变量参数时，是值传递还是引用传递？"></a>2).在JS调用函数时传递变量参数时，是值传递还是引用传递？</h4><ul>
<li>理解1：都是值（基本/地址值）传递</li>
<li>理解2：可能是前者，也可能是后者（地址值）</li>
</ul>
<h3 id="3-垃圾回收部分"><a href="#3-垃圾回收部分" class="headerlink" title="(3).垃圾回收部分"></a>(3).垃圾回收部分</h3><p><strong><font color=#F00>问：JS引擎如何管理内存？</font></strong></p>
<h4 id="1-内存生命周期"><a href="#1-内存生命周期" class="headerlink" title="1).内存生命周期"></a>1).内存生命周期</h4><ul>
<li>分配小内存空间，得到它的使用权</li>
<li>存储数据，可以反复进行操作</li>
<li>释放小内存空间</li>
</ul>
<h4 id="2-释放内存"><a href="#2-释放内存" class="headerlink" title="2).释放内存"></a>2).释放内存</h4><ul>
<li>局部变量：函数执行完毕后自动释放</li>
<li>对象：成为垃圾对象后由垃圾回收器回收</li>
</ul>
<h3 id="4-对象部分"><a href="#4-对象部分" class="headerlink" title="(4).对象部分"></a>(4).对象部分</h3><h4 id="1-如何访问对象内部的数据？"><a href="#1-如何访问对象内部的数据？" class="headerlink" title="1).如何访问对象内部的数据？"></a>1).如何访问对象内部的数据？</h4><ul>
<li><code>.属性名</code>：编码简单，有时不能使用</li>
<li><code>[&#39;属性名&#39;]</code>：编码麻烦，但可通用</li>
</ul>
<h4 id="2-什么时候使用第二种访问？"><a href="#2-什么时候使用第二种访问？" class="headerlink" title="2).什么时候使用第二种访问？"></a>2).什么时候使用第二种访问？</h4><ul>
<li>属性名含特殊字符：- 空格</li>
<li>属性名不确定</li>
</ul>
<h3 id="5-函数部分"><a href="#5-函数部分" class="headerlink" title="(5).函数部分"></a>(5).函数部分</h3><h4 id="1-如何调用（执行）函数？"><a href="#1-如何调用（执行）函数？" class="headerlink" title="1).如何调用（执行）函数？"></a>1).如何调用（执行）函数？</h4><ul>
<li>test()：直接调用</li>
<li>obj.test()：通过对象调用</li>
<li>new test()：new调用</li>
<li>test.call/apply(obj)：临时让test成为obj的方法进行调用</li>
</ul>
<h4 id="2-什么是回调函数？"><a href="#2-什么是回调函数？" class="headerlink" title="2).什么是回调函数？"></a>2).什么是回调函数？</h4><ul>
<li>自定义</li>
<li>没有调用</li>
<li>函数执行</li>
</ul>
<h4 id="3-常见回调函数有什么？"><a href="#3-常见回调函数有什么？" class="headerlink" title="3).常见回调函数有什么？"></a>3).常见回调函数有什么？</h4><ul>
<li>dom事件的回调函数</li>
<li>定时器的回调函数</li>
<li>ajax请求回调函数</li>
<li>生命周期回调函数</li>
</ul>
<h4 id="4-立即执行函数的作用是什么？"><a href="#4-立即执行函数的作用是什么？" class="headerlink" title="4).立即执行函数的作用是什么？"></a>4).立即执行函数的作用是什么？</h4><ul>
<li>隐藏实现</li>
<li>不会污染外部（全局）命名空间</li>
</ul>
<h4 id="5-this是什么？"><a href="#5-this是什么？" class="headerlink" title="5).this是什么？"></a>5).this是什么？</h4><ul>
<li>任何函数本质上都是通过某个对象来调用的，如果没有直接指定就是window</li>
<li>所有函数内部都有一个变量this</li>
<li>它的值是调用函数的当前对象</li>
</ul>
<h4 id="6-如何确定this的值？"><a href="#6-如何确定this的值？" class="headerlink" title="6).如何确定this的值？"></a>6).如何确定this的值？</h4><ul>
<li>test()：window</li>
<li>p.test()：p</li>
<li>new test()：新建对象</li>
<li>p.call(obj)：obj</li>
</ul>
<h3 id="6-代码格式部分"><a href="#6-代码格式部分" class="headerlink" title="(6).代码格式部分"></a>(6).代码格式部分</h3><ul>
<li><p>js一条语句的后面可以不加分号，Vue.js就是一个例子</p>
</li>
<li><p>在下面两种情况下不加分号会有问题：</p>
<ul>
<li>小括号开头的前一条语句</li>
<li>中方括号开头的前一条语句</li>
</ul>
</li>
<li><p>解决办法：在行首加分号即可</p>
</li>
</ul>
<h2 id="2-函数高级"><a href="#2-函数高级" class="headerlink" title="2.函数高级"></a>2.函数高级</h2><h3 id="1-原型部分"><a href="#1-原型部分" class="headerlink" title="(1).原型部分"></a>(1).原型部分</h3><h4 id="1-prototype-属性"><a href="#1-prototype-属性" class="headerlink" title="1).prototype 属性"></a>1).prototype 属性</h4><ul>
<li><p>每个函数都有一个 prototype 属性，他默认指向一个 Object 空对象（即称为原型对象）</p>
</li>
<li><p>原型对象中有一个属性 constructor，它指向函数对象，如下图：<br><img src="https://s3.ax1x.com/2020/12/16/rlrNCR.png" alt="js16.png"></p>
</li>
<li><p>给原型对象添加属性（一般都是方法）的作用：函数的所有实例对象自动拥有原型中的属性（方法）</p>
</li>
</ul>
<h4 id="2-显示与隐式原型"><a href="#2-显示与隐式原型" class="headerlink" title="2).显示与隐式原型"></a>2).显示与隐式原型</h4><ul>
<li>显示原型（属性）：每个函数function都有一个 <code>prototype</code></li>
<li>隐式原型（属性）：每个实例对象都有一个 <code>__proto__</code></li>
<li><font color=#F00>对象的隐式原型的值为其对应构造函数的显示原型的值</font>，相关内存结构图如下：<br><img src="https://s3.ax1x.com/2020/12/22/rsNtIA.png" alt="js17.png"></li>
</ul>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ul>
<li>函数的 <code>prototype</code> 属性：在定义函数时自动添加，默认值是一个空的Object对象</li>
<li>对象的 <code>__proto__</code> 属性：创建对象时自动添加，默认值为构造函数的prototype属性值</li>
<li>程序员能直接操作显示原型，但不能直接操作隐式原型（ES6之前）</li>
</ul>
<h4 id="3-原型链"><a href="#3-原型链" class="headerlink" title="3).原型链"></a>3).原型链</h4><h5 id="a-基础"><a href="#a-基础" class="headerlink" title="a).基础"></a>a).基础</h5><ul>
<li>访问一个对象的属性时，具体步骤如下：<ul>
<li>先在自身属性中查找，找到返回</li>
<li>如果没有，再沿着 <code>__proto__</code> 这条链向上查找，找到返回</li>
<li>如果最终没找到，返回 undefined </li>
</ul>
</li>
<li>根据上述步骤可以看出，访问对象属性时仅仅只看隐式原型，所以实质上叫做<font color=#F00>隐式原型链</font></li>
<li>作用：查找对象的属性或方法</li>
<li>原型链示意图如下：<br><img src="https://s3.ax1x.com/2020/12/22/rsNDsS.png" alt="js18.png"></li>
</ul>
<h5 id="b-构造函数、原型、实例对象之间的关系"><a href="#b-构造函数、原型、实例对象之间的关系" class="headerlink" title="b).构造函数、原型、实例对象之间的关系"></a>b).构造函数、原型、实例对象之间的关系</h5><ul>
<li><p>原型对象由 <code>constructor</code> 属性指向其构造函数，结构如下图：<br><img src="https://s3.ax1x.com/2021/01/19/s2Sd56.png" alt="js19.png"></p>
</li>
<li><p>所有函数的 <code>__proto__</code> 都是一样的，结构如下图：<br><img src="https://s3.ax1x.com/2021/01/19/s2STMQ.png" alt="js20.png"></p>
</li>
<li><p>根据上图可以得知：</p>
<ul>
<li>函数的显示原型指向的对象默认是空的Object实例对象（但Object不满足）</li>
<li>所有函数都是 Function 的实例（包含Function）</li>
<li>Object 的原型对象是原型链的尽头，为 null</li>
</ul>
</li>
</ul>
<h5 id="c-属性问题"><a href="#c-属性问题" class="headerlink" title="c).属性问题"></a>c).属性问题</h5><ul>
<li>读取对象的属性值时：会自动到原型链中查找</li>
<li>设置对象的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值</li>
<li>方法一般定义在原型中，属性一般通过构造函数定义在对象本身上<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	Fn.prototype.a = <span class="string">&quot;xxx&quot;</span>;</span><br><span class="line">	<span class="comment">// 对应上面第一句</span></span><br><span class="line">	<span class="keyword">var</span> fn1 = <span class="keyword">new</span> Fn();</span><br><span class="line">	<span class="built_in">console</span>.log(fn1,fn1.a);</span><br><span class="line">	<span class="comment">// 对应上面第二句</span></span><br><span class="line">	<span class="keyword">var</span> fn2 = <span class="keyword">new</span> Fn();</span><br><span class="line">	fn2.a = <span class="string">&quot;yyy&quot;</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(fn2,fn1.a);</span><br><span class="line">	<span class="comment">// 对应上面第三句</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">	p1.setName(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(p1);</span><br><span class="line">	<span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Jack&#x27;</span>,<span class="number">18</span>);</span><br><span class="line">	p2.setName(<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(p2);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="d-instanceof如何判断的？"><a href="#d-instanceof如何判断的？" class="headerlink" title="d).instanceof如何判断的？"></a>d).instanceof如何判断的？</h5><ul>
<li>表达式：A instanceof B</li>
<li>如果B函数的显示原型对象在A对象的原型链上，返回 true，否则返回 false</li>
</ul>
<ol>
<li>案例代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> Foo);		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(f1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);	<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>图片解析：<br><img src="https://s3.ax1x.com/2021/01/19/s2yLvj.png" alt="js21.png"></li>
</ul>
<ol start="2">
<li>案例代码：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);	<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span> <span class="keyword">instanceof</span> Foo);			<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>图片解析：<br><img src="https://s3.ax1x.com/2021/01/19/s2yzV0.png" alt="js22.png"></li>
</ul>
<h3 id="2-执行上下文部分"><a href="#2-执行上下文部分" class="headerlink" title="(2).执行上下文部分"></a>(2).执行上下文部分</h3><h4 id="1-变量提升与函数提升"><a href="#1-变量提升与函数提升" class="headerlink" title="1).变量提升与函数提升"></a>1).变量提升与函数提升</h4><ul>
<li>先执行变量提升，后执行函数提升</li>
</ul>
<h5 id="a-变量声明提升"><a href="#a-变量声明提升" class="headerlink" title="a).变量声明提升"></a>a).变量声明提升</h5><ul>
<li>通过 var 定义（声明）的变量，在定义语句之前就可以访问到</li>
<li>值：undefined</li>
</ul>
<h5 id="b-函数声明提升"><a href="#b-函数声明提升" class="headerlink" title="b).函数声明提升"></a>b).函数声明提升</h5><ul>
<li>通过 function 声明的函数，在之前就可以直接调用</li>
<li>值：函数定义（对象）</li>
</ul>
<h5 id="c-出现原因"><a href="#c-出现原因" class="headerlink" title="c).出现原因"></a>c).出现原因</h5><ul>
<li>因为下面的全局执行上下文和函数执行上下文中的预处理操作</li>
</ul>
<h4 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2).执行上下文"></a>2).执行上下文</h4><ul>
<li>执行上下文个数规律：n+1，n为执行函数的次数，1为全局执行上下文</li>
</ul>
<h5 id="a-全局执行上下文"><a href="#a-全局执行上下文" class="headerlink" title="a).全局执行上下文"></a>a).全局执行上下文</h5><ul>
<li>在执行全局代码前将 <strong>window</strong> 确定为全局执行上下文</li>
<li>对全局数据进行预处理：<ul>
<li>var 定义的全局变量 ==&gt; undefined，添加为 window 的属性</li>
<li>function 声明的全局函数 ==&gt; 赋值（fun），添加为 window 的方法</li>
<li>this ==&gt; 赋值（window）</li>
</ul>
</li>
<li>开始执行全局代码</li>
</ul>
<h5 id="b-函数执行上下文"><a href="#b-函数执行上下文" class="headerlink" title="b).函数执行上下文"></a>b).函数执行上下文</h5><ul>
<li>在调用函数，准备执行函数体之前，创建对应的函数执行上下文对象（虚拟的，存在于栈中）</li>
<li>对局部数据进行预处理：<ul>
<li>形参变量 ==&gt; 赋值（实参），添加为执行上下文的属性</li>
<li>arguments ==&gt; 赋值（实参列表），添加为执行上下文的属性</li>
<li>var 定义的局部变量 ==&gt; undefined，添加为执行上下文的属性</li>
<li>function 声明的函数 ==&gt; 赋值（fun），添加为执行上下文的方法</li>
<li>this ==&gt; 赋值（调用函数的对象）</li>
</ul>
</li>
<li>开始执行函数体代码</li>
</ul>
<h4 id="3-执行上下文栈"><a href="#3-执行上下文栈" class="headerlink" title="3).执行上下文栈"></a>3).执行上下文栈</h4><ul>
<li>在全局代码执行前，JS 引擎就会创建一个栈来存储管理所有的执行上下文对象</li>
<li>在全局执行上下文（window）确定后，将其添加到栈中（压栈）</li>
<li>在函数执行上下文创建后，将其添加到栈中（压栈）</li>
<li>在当前函数执行完后，将栈顶的对象移除（出栈）</li>
<li>当所有的代码执行完后，栈中只剩下 window</li>
</ul>
<h4 id="4-相关面试题"><a href="#4-相关面试题" class="headerlink" title="4).相关面试题"></a>4).相关面试题</h4><ul>
<li>共有四个题，请点击 <a href="/demo/JSex/executionContext.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h3 id="3-作用域部分"><a href="#3-作用域部分" class="headerlink" title="(3).作用域部分"></a>(3).作用域部分</h3><h4 id="1-分类"><a href="#1-分类" class="headerlink" title="1).分类"></a>1).分类</h4><ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li><font color=#F00>(ES6增加)块作用域</font>：即大括号作用域</li>
<li>作用域个数规律：n+1，n为函数作用域的个数，1为全局作用域</li>
</ul>
<h4 id="2-作用"><a href="#2-作用" class="headerlink" title="2).作用"></a>2).作用</h4><ul>
<li>隔离变量，不同作用域下同名变量不会有冲突</li>
</ul>
<h4 id="3-与执行上下文的区别"><a href="#3-与执行上下文的区别" class="headerlink" title="3).与执行上下文的区别"></a>3).与执行上下文的区别</h4><h5 id="a-区别1"><a href="#a-区别1" class="headerlink" title="a).区别1"></a>a).区别1</h5><ul>
<li>全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就确定了，而不是在函数调用时</li>
<li>全局执行上下文环境是在全局作用域确定之后，js代码马上执行之前创建</li>
<li>函数执行上下文环境是在调用函数时，函数体代码执行之前创建</li>
</ul>
<h5 id="b-区别2"><a href="#b-区别2" class="headerlink" title="b).区别2"></a>b).区别2</h5><ul>
<li>作用域是静态的，只要函数定义好了就一直存在，且不会变化</li>
<li>上下文环境是动态的，调用函数时创建，函数调用结束时上下文环境就会释放</li>
</ul>
<h5 id="c-联系"><a href="#c-联系" class="headerlink" title="c).联系"></a>c).联系</h5><ul>
<li>上下文环境（对象）是从属于所在的作用域</li>
<li>全局上下文环境 ==&gt; 全局作用域</li>
<li>函数上下文环境 ==&gt; 对应的函数使用域</li>
</ul>
<h4 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4).作用域链"></a>4).作用域链</h4><ul>
<li>多个上下文关系的作用域形成的链，方向是从下向上的（从内到外）</li>
<li>查找变量时就是沿着作用域链来查找的</li>
</ul>
<h3 id="4-闭包部分"><a href="#4-闭包部分" class="headerlink" title="(4).闭包部分"></a>(4).闭包部分</h3><h4 id="1-循环遍历加监听"><a href="#1-循环遍历加监听" class="headerlink" title="1).循环遍历加监听"></a>1).循环遍历加监听</h4><ul>
<li>常规方法一：正常的循环遍历，请点击 <a href="/demo/JSex/closureClick1.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
<li>常规方法二：利用立即执行函数来遍历（即闭包），请点击 <a href="/demo/JSex/closureClick2.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h4 id="2-理解闭包"><a href="#2-理解闭包" class="headerlink" title="2).理解闭包"></a>2).理解闭包</h4><h5 id="a-如何产生闭包？"><a href="#a-如何产生闭包？" class="headerlink" title="a).如何产生闭包？"></a>a).如何产生闭包？</h5><ul>
<li>当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包</li>
</ul>
<h5 id="b-闭包到底是什么？"><a href="#b-闭包到底是什么？" class="headerlink" title="b).闭包到底是什么？"></a>b).闭包到底是什么？</h5><ul>
<li><font color=#F00>需要使用Chrome调试来查看</font></li>
<li>理解一：闭包是嵌套的内部函数</li>
<li>理解二：包含被引用变量（函数）的对象，<font color=#F00>闭包存在于嵌套的内部函数中</font></li>
</ul>
<h5 id="c-产生闭包的条件？"><a href="#c-产生闭包的条件？" class="headerlink" title="c).产生闭包的条件？"></a>c).产生闭包的条件？</h5><ul>
<li>函数嵌套</li>
<li>内部函数引用了外部函数的数据（变量/函数）</li>
<li>执行外部函数（<font color=#F00>貌似目前需执行内部函数才会出现闭包，存疑</font>）</li>
</ul>
<h4 id="3-常见的闭包"><a href="#3-常见的闭包" class="headerlink" title="3).常见的闭包"></a>3).常见的闭包</h4><ul>
<li><p>将函数作为另一个函数的返回值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 此时已经产生了闭包（函数提升，内部函数对象已经创建了）</span></span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		a++;</span><br><span class="line">		<span class="built_in">console</span>.log(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fn2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn1();</span><br><span class="line"><span class="comment">// 这里执行的是内部函数，因为fn1中返回了fn2，相当于是将fn2赋值给了f</span></span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line"><span class="comment">// 若想要再产生一个闭包，则只需再调用一次外部函数即可</span></span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure></li>
<li><p>将函数作为实参传递给另一个函数调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDeley</span>(<span class="params">msg,time</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(msg);</span><br><span class="line">	&#125;,time);</span><br><span class="line">&#125;</span><br><span class="line">showDeley(<span class="string">&#x27;Wrysmile&#x27;</span>,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-闭包的作用"><a href="#4-闭包的作用" class="headerlink" title="4).闭包的作用"></a>4).闭包的作用</h4><ul>
<li>在函数执行完后，使用函数内部的变量仍然存活在内存中（延长了局部变量的生命周期）</li>
<li>让函数外部可以操作（读写）到函数内部的数据（变量/函数）</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>函数执行完后，函数内部声明的局部变量一般是不存在的，存在于闭包中的变量才可能存在</li>
<li>在函数外部不能直接访问函数内部的局部变量，但可以通过闭包让外部操作它</li>
</ul>
<h4 id="5-闭包的生命周期"><a href="#5-闭包的生命周期" class="headerlink" title="5).闭包的生命周期"></a>5).闭包的生命周期</h4><ul>
<li>产生：在嵌套内部函数定义执行完时就产生了（<font color=#F00>注意：不是在调用时</font>）</li>
<li>死亡：在嵌套的内部函数成为垃圾对象时</li>
</ul>
<h4 id="6-闭包的应用——自定义JS模块"><a href="#6-闭包的应用——自定义JS模块" class="headerlink" title="6).闭包的应用——自定义JS模块"></a>6).闭包的应用——自定义JS模块</h4><ul>
<li>特点：<ul>
<li>具有特定功能的 js 文件</li>
<li>将所有的数据和功能都封装在一个函数内部（私有的）</li>
<li>只向外暴露一个包含n个方法的对象或函数</li>
<li>模块的使用者，只需要通过模块暴露的对象调用方法来实现对应的功能</li>
</ul>
</li>
<li>应用：<ul>
<li>请点击 <a href="/demo/JSex/closureJsModule1.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
</li>
</ul>
<h4 id="7-闭包的缺点"><a href="#7-闭包的缺点" class="headerlink" title="7).闭包的缺点"></a>7).闭包的缺点</h4><ul>
<li>函数执行完后，函数内的局部变量没有释放。占用内存时间会变长（<font color=#F00>解决办法：及时释放</font>）</li>
<li>容易造成<a href="#closure">内存泄漏</a>（<font color=#F00>解决办法：能不用闭包就不用</font>）</li>
</ul>
<h4 id="8-闭包面试题"><a href="#8-闭包面试题" class="headerlink" title="8).闭包面试题"></a>8).闭包面试题</h4><ul>
<li>请点击 <a href="/demo/JSex/closureExam.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="3-面向对象高级"><a href="#3-面向对象高级" class="headerlink" title="3.面向对象高级"></a>3.面向对象高级</h2><h3 id="1-对象创建模式"><a href="#1-对象创建模式" class="headerlink" title="(1).对象创建模式"></a>(1).对象创建模式</h3><h4 id="1-Object构造函数模式"><a href="#1-Object构造函数模式" class="headerlink" title="1).Object构造函数模式"></a>1).Object构造函数模式</h4><ul>
<li>方法：先创建空Object对象，再动态添加属性/方法</li>
<li>适用场景：起始时不确定对象内部的数据</li>
<li>问题：语句太多<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">p.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line">p.age = <span class="number">18</span>;</span><br><span class="line">p.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p.name,p.age);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-对象字面量模式"><a href="#2-对象字面量模式" class="headerlink" title="2).对象字面量模式"></a>2).对象字面量模式</h4><ul>
<li>方法：适用{}创建对象，同时指定属性/方法</li>
<li>适用场景：起始时对象内部数据时确定的</li>
<li>问题：如果创建多个对象，有重复代码<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">	<span class="attr">name</span> : <span class="string">&#x27;Tomm&#x27;</span>,</span><br><span class="line">	<span class="attr">age</span> : <span class="number">19</span>,</span><br><span class="line">	<span class="attr">setName</span> : <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p.name,p.age);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3).工厂模式"></a>3).工厂模式</h4><ul>
<li>方法：通过工厂函数动态创建对象并返回</li>
<li>适用场景：需要创建多个对象，但一般不用</li>
<li>问题：对象没有一个具体类型，都是Object类型</li>
<li>工厂函数：返回一个对象的函数就叫做工厂函数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;</span><br><span class="line">		<span class="attr">name</span> : name,</span><br><span class="line">		<span class="attr">age</span> : age,</span><br><span class="line">		<span class="attr">setName</span> : <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">&#x27;Tommm&#x27;</span>,<span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p2.name,p2.age);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-自定义构造函数模式"><a href="#4-自定义构造函数模式" class="headerlink" title="4).自定义构造函数模式"></a>4).自定义构造函数模式</h4><ul>
<li>方法：自定义构造函数，通过new创建对象</li>
<li>适用场景：需要创建多个类型确定的对象</li>
<li>问题：每个对象都有相同的数据，浪费内存<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">	<span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tommmm&#x27;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p3.name,p3.age);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-构造函数-原型的组合模式"><a href="#5-构造函数-原型的组合模式" class="headerlink" title="5).构造函数+原型的组合模式"></a>5).构造函数+原型的组合模式</h4><ul>
<li>方法：自定义构造函数，属性在函数中初始化，方法添加到原型上</li>
<li>适用场景：需要创建多个类型确定的对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> Person(<span class="string">&#x27;Tommmmm&#x27;</span>,<span class="number">22</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p4.name,p4.age);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-继承模式"><a href="#2-继承模式" class="headerlink" title="(2).继承模式"></a>(2).继承模式</h3><h4 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1).原型链继承"></a>1).原型链继承</h4><ul>
<li>方法：</li>
</ul>
<p>1.定义父类型构造函数<br>2.给父类型的原型添加方法<br>3.定义子类型构造函数<br>4.创建父类型的对象赋值给子类型的原型<br>5.将子类型原型的构造属性设置为子类型<br>6.给子类型原型添加方法<br>7.创建子类型的对象即可调用父类型的方法</p>
<ul>
<li>关键：子类型的原型为父类型的一个实例对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.fatherProp = <span class="string">&#x27;Father Property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.showFatherProp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.fatherProp);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.sunProp = <span class="string">&#x27;Sun Property&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sun.prototype = <span class="keyword">new</span> Father();</span><br><span class="line">Sun.prototype.constructor = Sun;</span><br><span class="line">Sun.prototype.showSunProp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.sunProp);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> sun = <span class="keyword">new</span> Sun();</span><br><span class="line">sun.showSunProp();</span><br><span class="line">sun.showFatherProp();</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-借用构造函数继承（假的）"><a href="#2-借用构造函数继承（假的）" class="headerlink" title="2).借用构造函数继承（假的）"></a>2).借用构造函数继承<font color=#F00>（假的）</font></h4><ul>
<li>方法：</li>
</ul>
<p>1.定义父类型构造函数<br>2.定义子类型构造函数<br>3.在子类型构造函数中调用父类型构造函数</p>
<ul>
<li>关键：在子类型构造函数中通过 call() 调用父类型构造函数<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,height</span>)</span>&#123;</span><br><span class="line">	Person.call(<span class="built_in">this</span>,name,age);</span><br><span class="line">	<span class="built_in">this</span>.height = height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">18</span>,<span class="number">170</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name,s.age,s.height);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-组合继承（最优解）"><a href="#3-组合继承（最优解）" class="headerlink" title="3).组合继承（最优解）"></a>3).组合继承<font color=#F00>（最优解）</font></h4><ul>
<li>方法：</li>
</ul>
<p>1.利用原型链实现对父类型对象的方法继承<br>2.利用 call() 借用父类型构造函数初始化相同属性</p>
<ul>
<li>如下：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,height</span>)</span>&#123;</span><br><span class="line">	Person.call(<span class="built_in">this</span>,name,age);		<span class="comment">// 为了得到属性</span></span><br><span class="line">	<span class="built_in">this</span>.height = height;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();	<span class="comment">// 为了能看到父类型的方法</span></span><br><span class="line">Student.prototype.constructor = Student;	<span class="comment">// 修正constructor属性</span></span><br><span class="line">Student.prototype.setHeight = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.height = height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Student(<span class="string">&#x27;Tom&#x27;</span>,<span class="number">18</span>,<span class="number">170</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name,s.age,s.height);</span><br><span class="line">s.setName(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line">s.setHeight(<span class="number">171</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s.name,s.age,s.height);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-new一个对象背后做了什么？"><a href="#3-new一个对象背后做了什么？" class="headerlink" title="(3).new一个对象背后做了什么？"></a>(3).new一个对象背后做了什么？</h3><ul>
<li>创建了一个空对象</li>
<li>给对象设置了 <code>__proto__</code> ，值为构造函数对象的 prototype 属性值</li>
<li>执行构造函数体（给对象添加属性/方法） </li>
</ul>
<h2 id="4-线程机制与事件机制"><a href="#4-线程机制与事件机制" class="headerlink" title="4.线程机制与事件机制"></a>4.线程机制与事件机制</h2><h3 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="(1).进程与线程"></a>(1).进程与线程</h3><ul>
<li><strong>进程</strong>：程序的一次执行，它占有一片独有的内存空间</li>
<li><strong>线程</strong>：是进程内的一个独立执行单元、是程序执行的一个完整流程、是 CPU 的最小调度单元</li>
<li><strong>线程池（thread pool）</strong>：保存多个线程对象的容器，实现线程对象的反复利用</li>
</ul>
<h4 id="1-相关知识"><a href="#1-相关知识" class="headerlink" title="1).相关知识"></a>1).相关知识</h4><ul>
<li>应用程序必须运行在某个进程的某个线程上</li>
<li>一个进程中至少有一个运行的线程为<strong>主线程</strong>，进程启动后会自动创建</li>
<li>一个进程中也可以同时运行多个线程，即程序是多线程运行的</li>
<li>一个进程内的数据可以供其中的多个线程直接共享</li>
<li>多个进程之间的数据是不能直接共享的</li>
</ul>
<h4 id="2-相关问题"><a href="#2-相关问题" class="headerlink" title="2).相关问题"></a>2).相关问题</h4><h5 id="a-多线程与多进程？"><a href="#a-多线程与多进程？" class="headerlink" title="a).多线程与多进程？"></a>a).多线程与多进程？</h5><ul>
<li>多进程运行：一个应用程序可以同时启动多个实例运行</li>
<li>多线程：在一个进程内，同时有多个线程运行</li>
</ul>
<h5 id="b-单线程与多线程？"><a href="#b-单线程与多线程？" class="headerlink" title="b).单线程与多线程？"></a>b).单线程与多线程？</h5><ul>
<li>单线程：<ul>
<li>优点：顺序编程简单易懂</li>
<li>缺点：效率低</li>
</ul>
</li>
<li>多线程：<ul>
<li>优点：能有效提升 CPU 的利用率</li>
<li>缺点：创建多线程开销、线程间切换开销、死锁与状态同步问题</li>
</ul>
</li>
</ul>
<h5 id="c-JS是单线程还是多线程？"><a href="#c-JS是单线程还是多线程？" class="headerlink" title="c).JS是单线程还是多线程？"></a>c).JS是单线程还是多线程？</h5><ul>
<li>js 是单线程运行</li>
<li><font color=#F00>使用 H5 中的 Web Workers 可以多线程运行</font></li>
</ul>
<h5 id="d-浏览器运行是单线程还是多线程？"><a href="#d-浏览器运行是单线程还是多线程？" class="headerlink" title="d).浏览器运行是单线程还是多线程？"></a>d).浏览器运行是单线程还是多线程？</h5><ul>
<li>都是多线程</li>
</ul>
<h5 id="e-浏览器运行是单进程还是多进程？"><a href="#e-浏览器运行是单进程还是多进程？" class="headerlink" title="e).浏览器运行是单进程还是多进程？"></a>e).浏览器运行是单进程还是多进程？</h5><ul>
<li>有的是单进程，有的是多进程</li>
</ul>
<h3 id="2-浏览器内核"><a href="#2-浏览器内核" class="headerlink" title="(2).浏览器内核"></a>(2).浏览器内核</h3><ul>
<li>是支撑浏览器运行的最核心的程序，且不同的浏览器可能不一样</li>
<li>内核是由很多模块组成的（前四个为主线程，后三个为分线程）：<ul>
<li>JS 引擎模块：负责 js 程序的编译与运行</li>
<li>html、css 文档解析模块：负责页面文本的解析</li>
<li>DOM、CSS 模块：负责 dom、css 在内存中的相关处理</li>
<li>布局和渲染模块：负责页面的布局和效果的绘制（内存中的对象）</li>
<li>定时器模块：负责定时器的管理</li>
<li>事件响应模块：负责事件的管理</li>
<li>网络请求模块：负责 ajax 请求</li>
</ul>
</li>
</ul>
<h3 id="3-思考定时器"><a href="#3-思考定时器" class="headerlink" title="(3).思考定时器"></a>(3).思考定时器</h3><h4 id="1-定时器真是定时执行的吗？"><a href="#1-定时器真是定时执行的吗？" class="headerlink" title="1).定时器真是定时执行的吗？"></a>1).定时器真是定时执行的吗？</h4><ul>
<li>定时器并不能保证真正定时执行</li>
<li>一般会延迟一丁点（可以接受），有时也会延迟很长时间（不能接受）</li>
</ul>
<h4 id="2-定时器的回调函数时在分线程执行的吗？"><a href="#2-定时器的回调函数时在分线程执行的吗？" class="headerlink" title="2).定时器的回调函数时在分线程执行的吗？"></a>2).定时器的回调函数时在分线程执行的吗？</h4><ul>
<li>在主线程执行，因为js是单线程</li>
</ul>
<h4 id="3-定时器是如何实现的？"><a href="#3-定时器是如何实现的？" class="headerlink" title="3).定时器是如何实现的？"></a>3).定时器是如何实现的？</h4><ul>
<li>事件循环模型</li>
</ul>
<h3 id="4-思考JS单线程"><a href="#4-思考JS单线程" class="headerlink" title="(4).思考JS单线程"></a>(4).思考JS单线程</h3><h4 id="1-如何证明js执行是单线程的？"><a href="#1-如何证明js执行是单线程的？" class="headerlink" title="1).如何证明js执行是单线程的？"></a>1).如何证明js执行是单线程的？</h4><ul>
<li>setTimeout() 的回调函数是在主线程执行的</li>
<li>定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行</li>
</ul>
<h4 id="2-为什么js要用单线程模式？"><a href="#2-为什么js要用单线程模式？" class="headerlink" title="2).为什么js要用单线程模式？"></a>2).为什么js要用单线程模式？</h4><ul>
<li>JS 的单线程与它的用途有关</li>
<li>作为浏览器脚本语言，JS 的主要用途是与用户互动以及操作 DOM</li>
<li>这决定了它只能是单线程，否则会带来很复杂的<strong>同步</strong>问题</li>
</ul>
<h4 id="3-代码的分类？"><a href="#3-代码的分类？" class="headerlink" title="3).代码的分类？"></a>3).代码的分类？</h4><ul>
<li>初始化执行代码</li>
<li>回调执行代码</li>
</ul>
<h4 id="4-js引擎执行代码的基本流程？"><a href="#4-js引擎执行代码的基本流程？" class="headerlink" title="4).js引擎执行代码的基本流程？"></a>4).js引擎执行代码的基本流程？</h4><ul>
<li>先执行初始化代码：包含一些特别的代码<ul>
<li>设置定时器</li>
<li>绑定事件监听</li>
<li>发送 ajax 请求</li>
</ul>
</li>
<li>后面在某个时刻才会执行回调代码，回调函数异步执行</li>
</ul>
<h3 id="5-事件循环模型"><a href="#5-事件循环模型" class="headerlink" title="(5).事件循环模型"></a>(5).事件循环模型</h3><h4 id="1-模型的两个重要组成部分？"><a href="#1-模型的两个重要组成部分？" class="headerlink" title="1).模型的两个重要组成部分？"></a>1).模型的两个重要组成部分？</h4><ul>
<li>事件管理模块</li>
<li>回调队列</li>
</ul>
<h4 id="2-模型的运转流程？"><a href="#2-模型的运转流程？" class="headerlink" title="2).模型的运转流程？"></a>2).模型的运转流程？</h4><ul>
<li>执行初始化代码，将事件回调函数交给对应模块管理</li>
<li>当事件发生时，管理模块会将回调函数及其数据添加到回调队列中</li>
<li>只有当初始化代码执行完后（可能要一定时间），才会遍历读取回调队列中的回调函数执行</li>
</ul>
<h4 id="3-模型原理图"><a href="#3-模型原理图" class="headerlink" title="3).模型原理图"></a>3).模型原理图</h4><ul>
<li>如下图：<br><img src="https://s3.ax1x.com/2021/02/18/yWKDzR.png" alt="js23.png"></li>
</ul>
<h4 id="4-相关概念"><a href="#4-相关概念" class="headerlink" title="4).相关概念"></a>4).相关概念</h4><ul>
<li><strong>执行栈</strong>（execution stack）：所有的代码都是在此空间中执行的</li>
<li><strong>浏览器内核</strong>（browser core）</li>
<li><strong>回调队列</strong>（callback queue）：以下均总称为此<ul>
<li><strong>任务队列</strong>（task queue）</li>
<li><strong>消息队列</strong>（message queue）</li>
<li><strong>事件队列</strong>（event queue）</li>
</ul>
</li>
<li><strong>事件轮询</strong>（event loop）：从任务队列中循环取出回调函数放入执行栈中处理（一个接一个）</li>
<li><strong>事件驱动模型</strong>（event-driven interaction model）</li>
<li><strong>请求响应模型</strong>（request-response model）</li>
</ul>
<h3 id="6-H5-Web-Workers（多线程）"><a href="#6-H5-Web-Workers（多线程）" class="headerlink" title="(6).H5 Web Workers（多线程）"></a>(6).H5 Web Workers（多线程）</h3><h4 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="1).介绍"></a>1).介绍</h4><ul>
<li>H5 规范提供了 js 分线程的实现，取名为：Web Workers</li>
<li>相关 API：<ul>
<li>Worker：构造函数，加载分线程执行的js文件</li>
<li>Worker.prototype.onmessage：用于接收另一个线程的回调函数</li>
<li>Worker.prototype.postMessage：向另外一个线程发送消息</li>
</ul>
</li>
<li>可以将一些大计算量的代码交由 Web Workers 运行而<strong>不冻结</strong>用户界面，但是子线程完全受主线程控制，且不得操作 DOM，所以它并没有改变 JS 单线程的本质</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2).使用"></a>2).使用</h4><ul>
<li><p>创建在分线程执行的 js 文件，一般命名为 <code>worker.js</code> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 不能用函数声明</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;onMessage()&#x27;</span>);</span><br><span class="line">	<span class="comment">// 通过event.data获得发送来的数据</span></span><br><span class="line">	<span class="keyword">var</span> upper = event.data.toUpperCase();</span><br><span class="line">	<span class="comment">// 将获取到的数据发送回主线程</span></span><br><span class="line">	postMessage(upper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在主线程中的 js 中发消息并设置回调</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个Worker对象并向它传递将在新线程中执行的脚本的URL</span></span><br><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">&quot;js/worker.js&quot;</span>);</span><br><span class="line"><span class="comment">// 接收Worker传过来的数据函数</span></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 传过来的数据存放在event.data里面</span></span><br><span class="line">	<span class="built_in">console</span>.log(event.data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向Worker发送数据</span></span><br><span class="line">worker.postMessage(<span class="string">&quot;xxx&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-图解"><a href="#3-图解" class="headerlink" title="3).图解"></a>3).图解</h4><ul>
<li>如下图：<br><img src="https://s3.ax1x.com/2021/02/18/yW0e91.png" alt="js24.png"></li>
</ul>
<h4 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4).缺点"></a>4).缺点</h4><ul>
<li>慢</li>
<li>不能跨域加载 JS</li>
<li>worker 内代码不能访问 DOM（更新UI）</li>
<li>不是每个浏览器都支持这个新特性</li>
</ul>
<h4 id="5-应用之斐波那契数列"><a href="#5-应用之斐波那契数列" class="headerlink" title="5).应用之斐波那契数列"></a>5).应用之斐波那契数列</h4><ul>
<li>不使用该方案求解，当数值较大时会卡住且用户无法操作。请点击 <a href="/demo/JSex/fibonacci.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
<li>使用该方案求解，用户可以进行正常操作。请点击 <a href="/demo/JSex/fibonacciNew.html" target="_blank">这里</a> 查看（为了体验到完整功能，请使用PC打开，源码右键“查看网页源代码”即可）</li>
</ul>
<h2 id="5-引申"><a href="#5-引申" class="headerlink" title="5.引申"></a>5.引申</h2><h3 id="1-内存溢出"><a href="#1-内存溢出" class="headerlink" title="(1).内存溢出"></a>(1).内存溢出</h3><ul>
<li>一种程序运行出现的错误</li>
<li>当程序运行需要的内存超过了剩余的内存时，就会抛出内存溢出的错误</li>
</ul>
<h3 id="2-内存泄漏"><a href="#2-内存泄漏" class="headerlink" title="(2).内存泄漏"></a>(2).内存泄漏</h3><ul>
<li>占用的内存没有及时释放</li>
<li>内存泄漏积累多了就容易导致内存溢出</li>
</ul>
<h4 id="常见的内存泄漏"><a href="#常见的内存泄漏" class="headerlink" title="常见的内存泄漏"></a>常见的内存泄漏</h4><ul>
<li><p>意外的全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	a = <span class="number">3</span>;</span><br><span class="line">	<span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure></li>
<li><p>没有及时清理的计时器或回调函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;----&#x27;</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><span id='closure'>闭包</span></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> b = <span class="number">4</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(++b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fn3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn2();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：微信小程序</title>
    <url>/Learn-Wechat.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>记录在开发微信小程序时的一些知识点<span id="more"></span></li>
</ul>
<h1 id="一、储备"><a href="#一、储备" class="headerlink" title="一、储备"></a>一、储备</h1><ul>
<li>理解事件机制</li>
<li>理解组件化</li>
<li>理解数据绑定</li>
<li>Flex 布局</li>
<li>移动端适配方案</li>
</ul>
<h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><h2 id="1-Flex布局"><a href="#1-Flex布局" class="headerlink" title="1.Flex布局"></a>1.Flex布局</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="(1).介绍"></a>(1).介绍</h3><blockquote>
<p>相关知识请前往<a href="https://www.runoob.com/w3cnote/flex-grammar.html">这里</a>查看</p>
</blockquote>
<ul>
<li>即弹性布局 —— <code>display: flex;</code></li>
<li>采用 Flex 布局的元素，称为 Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex项目（flex item），简称”项目”</li>
<li><strong style="color:red;">注意：当一个元素设置为 flex，其子元素会自动成为 block 元素</strong></li>
</ul>
<h3 id="2-容器属性"><a href="#2-容器属性" class="headerlink" title="(2).容器属性"></a>(2).容器属性</h3><h4 id="1-flex-direction"><a href="#1-flex-direction" class="headerlink" title="1).flex-direction"></a>1).flex-direction</h4><ul>
<li>决定主轴的方向（即项目的排列方向）</li>
<li>可选值：<br>row（默认值）：主轴为水平方向，起点在左端<br>row-reverse：主轴为水平方向，起点在右端<br>column：主轴为垂直方向，起点在上沿<br>column-reverse：主轴为垂直方向，起点在下沿</li>
</ul>
<h4 id="2-flex-wrap"><a href="#2-flex-wrap" class="headerlink" title="2).flex-wrap"></a>2).flex-wrap</h4><ul>
<li>定义如果一条轴线排不下如何换行</li>
<li>可选值：<br>nowrap（默认）：不换行<br>wrap：换行，第一行在上方<br>wrap-reverse：换行，第一行在下方</li>
</ul>
<h4 id="3-flex-flow"><a href="#3-flex-flow" class="headerlink" title="3).flex-flow"></a>3).flex-flow</h4><ul>
<li>是 <code>flex-direction</code> 属性和 <code>flex-wrap</code> 属性的简写形式</li>
<li>可选值：<br>默认值为 row nowrap<br>其余自行组合</li>
</ul>
<h4 id="4-justify-content"><a href="#4-justify-content" class="headerlink" title="4).justify-content"></a>4).justify-content</h4><ul>
<li>定义了项目在主轴上的对齐方式</li>
<li>可选值（具体对齐方式与轴的方向有关。下面假设主轴为从左到右）：<br>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔都相等<br>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<h4 id="5-align-items"><a href="#5-align-items" class="headerlink" title="5).align-items"></a>5).align-items</h4><ul>
<li>定义项目在交叉轴上如何对齐</li>
<li>可选值（具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下）：<br>flex-start：交叉轴的起点对齐<br>flex-end：交叉轴的终点对齐<br>center：交叉轴的中点对齐<br>baseline: 项目的第一行文字的基线对齐<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度</li>
</ul>
<h4 id="6-align-content"><a href="#6-align-content" class="headerlink" title="6).align-content"></a>6).align-content</h4><ul>
<li>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</li>
<li>可选值：<br>flex-start：与交叉轴的起点对齐<br>flex-end：与交叉轴的终点对齐<br>center：与交叉轴的中点对齐<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍<br>stretch（默认值）：轴线占满整个交叉轴</li>
</ul>
<h3 id="3-项目属性"><a href="#3-项目属性" class="headerlink" title="(3).项目属性"></a>(3).项目属性</h3><h4 id="1-order"><a href="#1-order" class="headerlink" title="1).order"></a>1).order</h4><ul>
<li>定义项目的排列顺序</li>
<li>数值越小，排列越靠前，默认为0</li>
</ul>
<h4 id="2-flex-grow"><a href="#2-flex-grow" class="headerlink" title="2).flex-grow"></a>2).flex-grow</h4><ul>
<li>定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</li>
<li>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）</li>
<li>如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍</li>
</ul>
<h4 id="3-flex-shrink"><a href="#3-flex-shrink" class="headerlink" title="3).flex-shrink"></a>3).flex-shrink</h4><ul>
<li>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</li>
<li>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小</li>
<li>如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</li>
<li>负值对该属性无效</li>
</ul>
<h4 id="4-flex-basis"><a href="#4-flex-basis" class="headerlink" title="4).flex-basis"></a>4).flex-basis</h4><ul>
<li>定义了在分配多余空间之前，项目占据的主轴空间（main size）</li>
<li>浏览器根据这个属性，计算主轴是否有多余空间</li>
<li>默认值为auto，即项目的本来大小</li>
</ul>
<h4 id="5-flex"><a href="#5-flex" class="headerlink" title="5).flex"></a>5).flex</h4><ul>
<li>是 <code>flex-grow</code>、 <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为0 1 auto，其中后两个属性可选</li>
<li>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto) 以及 1(1 1 0%)</li>
<li><font color=#F00><strong>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值</strong></font></li>
</ul>
<h4 id="6-align-self"><a href="#6-align-self" class="headerlink" title="6).align-self"></a>6).align-self</h4><ul>
<li>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</li>
<li>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</li>
<li>该属性可能取6个值，除了auto，其他都与align-items属性完全一致</li>
</ul>
<h2 id="2-移动端"><a href="#2-移动端" class="headerlink" title="2.移动端"></a>2.移动端</h2><h3 id="1-物理像素"><a href="#1-物理像素" class="headerlink" title="(1).物理像素"></a>(1).物理像素</h3><ul>
<li>指屏幕的分辨率，即设备能控制显示的最小单元，可看成对应的像素点</li>
</ul>
<h3 id="2-设备独立像素"><a href="#2-设备独立像素" class="headerlink" title="(2).设备独立像素"></a>(2).设备独立像素</h3><ul>
<li><strong>设备独立像素（也叫密度无关像素）</strong>：可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的虚拟像素（比如：css像素，只是在 android 机中 css 像素就不叫”css像素”了而是叫”设备独立像素”），然后由相关系统转换为物理像素</li>
<li>设备独立像素相当于 CSS 像素</li>
</ul>
<h3 id="3-dpr-比"><a href="#3-dpr-比" class="headerlink" title="(3).dpr 比"></a>(3).dpr 比</h3><ul>
<li><strong>dpr</strong>：即设备像素比=物理像素/设备独立像素，一般以iPhone 6 的dpr为准，即dpr=2</li>
<li><strong>PPI</strong>：一英寸显示屏上的像素点个数</li>
<li><strong>DPI</strong>：最早指的是打印机在单位面积上打印的墨点数，墨点越多越清晰</li>
</ul>
<h3 id="4-适配方案"><a href="#4-适配方案" class="headerlink" title="(4).适配方案"></a>(4).适配方案</h3><h4 id="0-视口"><a href="#0-视口" class="headerlink" title="0).视口"></a>0).视口</h4><ul>
<li>视觉视口：手机窗口大小</li>
<li>布局视口：指网页</li>
<li>完美视口/理想视口：为了使上面的两个视口基本一致</li>
</ul>
<h4 id="1-viewport-适配"><a href="#1-viewport-适配" class="headerlink" title="1).viewport 适配"></a>1).viewport 适配</h4><ul>
<li><p>目的：为了将页面完全显示在不同手机屏幕上且不会出现滚动条</p>
</li>
<li><p>实现方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><font color=#F00>微信底层就进行了 viewport 适配，即 width=device-width</font></p>
</li>
</ul>
<h4 id="2-rem-适配"><a href="#2-rem-适配" class="headerlink" title="2).rem 适配"></a>2).rem 适配</h4><ul>
<li><p>目的：一套设计稿的内容在不同的机型上呈现的效果一致，根据屏幕大小不同的变化，页面中的内容也相应变化</p>
</li>
<li><p>实现方案（通过原生js实现）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function remRefresh() &#123;</span><br><span class="line">	let clientWidth = document.documentElement.clientWidth;</span><br><span class="line">	// 将屏幕等分10份 </span><br><span class="line">	let rem = clientWidth / 10;</span><br><span class="line">	document.documentElement.style.fontSize = rem + &#x27;px&#x27;;</span><br><span class="line">	document.body.style.fontSize = &#x27;12px&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&#x27;pageshow&#x27;, () =&gt; &#123;</span><br><span class="line">	remRefresh()</span><br><span class="line">&#125;)</span><br><span class="line">// 函数防抖</span><br><span class="line">let timeoutId;</span><br><span class="line">window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123;</span><br><span class="line">	timeoutId &amp;&amp; clearTimeout(timeoutId);</span><br><span class="line">	timeoutId = setTimeout(() =&gt; &#123;</span><br><span class="line">		remRefresh()</span><br><span class="line">	&#125;, 300)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>实现方案（第三方库）：<code>lib-flexible + px2rem-loadelr</code></p>
</li>
</ul>
<h2 id="3-小程序"><a href="#3-小程序" class="headerlink" title="3.小程序"></a>3.小程序</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="(1).特点"></a>(1).特点</h3><ul>
<li>没有 DOM</li>
<li>组件化开发：具备特定功能效果的代码集合</li>
<li>体积小，单个压缩包体积不大于2M</li>
</ul>
<h3 id="2-文件结构"><a href="#2-文件结构" class="headerlink" title="(2).文件结构"></a>(2).文件结构</h3><ul>
<li>wxml —— view结构</li>
<li>wxss —— view样式</li>
<li>js —— view行为</li>
<li>json —— 数据及配置</li>
</ul>
<h4 id="！js中固定格式"><a href="#！js中固定格式" class="headerlink" title="！js中固定格式"></a><font color=#F00>！js中固定格式</font></h4><ul>
<li>注册小程序：<code>App()</code> 里面需要写个对象</li>
<li>注册页面：<code>Page()</code> 里面需要写个对象</li>
</ul>
<h3 id="3-适配方案"><a href="#3-适配方案" class="headerlink" title="(3).适配方案"></a>(3).适配方案</h3><ul>
<li><p>小程序适配单位：rpx（响应式像素单位）</p>
</li>
<li><p>规定任何屏幕下宽度为 <strong>750rpx</strong></p>
</li>
<li><p>小程序会根据屏幕的宽度自动计算 rpx值的大小</p>
</li>
<li><p>在 iPhone 6下：<font color=#F00>1rpx=1个物理像素=0.5px</font></p>
</li>
</ul>
<h3 id="4-图片路径"><a href="#4-图片路径" class="headerlink" title="(4).图片路径"></a>(4).图片路径</h3><ul>
<li>本地图片为静态资源，建议放在 <code>static/images</code> 目录下</li>
<li>建议使用绝对路径，当绝对路径无法使用时再使用相对路径</li>
</ul>
<h3 id="5-项目文件说明"><a href="#5-项目文件说明" class="headerlink" title="(5).项目文件说明"></a>(5).项目文件说明</h3><h4 id="a-app-js"><a href="#a-app-js" class="headerlink" title="a).app.js"></a>a).app.js</h4><ul>
<li>在该文件中必须要有首字母大写的 <code>App</code> ，用来注册整个小程序应用</li>
</ul>
<h4 id="b-app-json"><a href="#b-app-json" class="headerlink" title="b).app.json"></a>b).app.json</h4><ul>
<li><code>pages</code> 中哪个是第一个哪个默认就是首页，且不能加根路径</li>
<li><code>navigationBarBackgroundColor</code> ：导航栏背景颜色，只能使用16进制格式</li>
<li><code>navigationBarTextStyle</code> ：导航栏标题颜色，仅支持 <code>black</code> / <code>white</code></li>
</ul>
<h4 id="c-app-wxss"><a href="#c-app-wxss" class="headerlink" title="c).app.wxss"></a>c).app.wxss</h4><ul>
<li>存放公共样式</li>
<li>小程序中只能使用 class 类</li>
<li>小程序会自动的为所有的页面加一个 <code>&lt;page&gt;</code> 标签，而该标签宽度指定但高度未指定，如果想要给整个页面添加背景颜色，那么需要在这里将高度设置为 100%，这样所有的页面就都可以继承它的大小了</li>
</ul>
<h4 id="d-index-js"><a href="#d-index-js" class="headerlink" title="d).index.js"></a>d).index.js</h4><ul>
<li>在该文件中必须要有首字母大写的 <code>Page</code> ，用来注册当前页面的实例</li>
</ul>
<h3 id="6-编译模式"><a href="#6-编译模式" class="headerlink" title="(6).编译模式"></a>(6).编译模式</h3><ul>
<li>当我们想要同时看两个页面的显示情况时，可以<strong>自定义编译模式</strong></li>
<li>在开发者工具的最上方自定义一个，然后更改启动页面路径即可</li>
</ul>
<h2 id="4-字体图标"><a href="#4-字体图标" class="headerlink" title="4.字体图标"></a>4.字体图标</h2><h3 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="(1).介绍"></a>(1).介绍</h3><ul>
<li>小程序中可以使用阿里云的 <a href="https://www.iconfont.cn/">iconfont</a> 字体图标库</li>
</ul>
<h3 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="(2).使用方法"></a>(2).使用方法</h3><ul>
<li>在官网选好自己需要的字体图标并加入购物车</li>
<li>选好之后将其添加进项目中去</li>
<li>在当前项目中点击 <code>Font class</code> 选项并查看在线链接生成最新代码（该代码可以在网页中直接引用，而在小程序中无法引入）</li>
<li>在浏览器地址栏输入该地址，将里面的内容复制到小程序的 <code>wxss</code> 文件中去</li>
<li>我们可以将该文件放入 <code>/static/iconfont</code> 目录下，并在全局的 <code>app.wxss</code> 中使用如下语句进行引入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;/static/iconfont/iconfont.wxss&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果想要使用某图标，在网站复制该图标的class名，按如下即可：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;text class=&quot;iconfont icon-diantai&quot;&gt;&lt;/text&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>想要修改字体图标的样式，直接修改 <code>iconfont</code> 的样式即可</li>
</ul>
<h2 id="5-内网穿透"><a href="#5-内网穿透" class="headerlink" title="5.内网穿透"></a>5.内网穿透</h2><ul>
<li>我们一般在做项目的时候使用的是电脑上本地的服务器，如果想要在真机上调试小程序需要使用到<strong>内网穿透</strong></li>
<li>推荐使用 <a href="https://u.tools/">utools</a> 工具，搜索安装<strong>内网穿透</strong>插件</li>
<li>按提示设置地址，修改项目的服务器配置文件即可</li>
<li>如果无法正常显示，可能是预览不会去发送请求，可以打开小程序的调试模式即可</li>
</ul>
<h2 id="6-登录流程"><a href="#6-登录流程" class="headerlink" title="6.登录流程"></a>6.登录流程</h2><h3 id="1-收集表单项数据"><a href="#1-收集表单项数据" class="headerlink" title="(1).收集表单项数据"></a>(1).收集表单项数据</h3><ul>
<li>用户名，账号以及密码等</li>
</ul>
<h3 id="2-前端验证"><a href="#2-前端验证" class="headerlink" title="(2).前端验证"></a>(2).前端验证</h3><ul>
<li>验证用户信息（账号、密码）是否合法<ul>
<li>验证不通过，提示用户，不需要发请求给后端</li>
<li>验证通过，发请求（携带账号、密码）给服务器端</li>
</ul>
</li>
</ul>
<h3 id="3-后端验证"><a href="#3-后端验证" class="headerlink" title="(3).后端验证"></a>(3).后端验证</h3><ul>
<li>验证用户是否存在<ul>
<li>用户不存在直接返回，告诉前端用户不存在</li>
<li>用户存在需要验证密码是否正确<ul>
<li>密码不正确返回给前端提示密码不正确</li>
<li>密码正确返回给前端数据，提示用户登录成功（会携带用户的相关信息）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-视口单位"><a href="#7-视口单位" class="headerlink" title="7.视口单位"></a>7.视口单位</h2><ul>
<li>视口单位分别为：vh 和 vw</li>
<li>1vh = %1 的视口高度</li>
<li>1vw = %1 的视口宽度</li>
<li><code>calc()</code> 可以动态计算 css 的宽高，运算符左右两侧必须加空格，否则计算会失效</li>
</ul>
<h2 id="8-数据分页"><a href="#8-数据分页" class="headerlink" title="8.数据分页"></a>8.数据分页</h2><ul>
<li>前端分页：总共接收到100条数据，每次给用户显示10条</li>
<li>后端分页：每发一次请求给用户显示10条数据</li>
</ul>
<h2 id="9-日期函数"><a href="#9-日期函数" class="headerlink" title="9.日期函数"></a>9.日期函数</h2><ul>
<li>小程序中支持内置的日期函数用来获取当前的年月日<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 更新日期的状态</span><br><span class="line">this.setData(&#123;</span><br><span class="line">	day: new Date().getDate(),</span><br><span class="line">	month: new Date().getMonth() + 1</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-npm-包"><a href="#10-npm-包" class="headerlink" title="10.npm 包"></a>10.npm 包</h2><h3 id="1-使用方法"><a href="#1-使用方法" class="headerlink" title="(1).使用方法"></a>(1).使用方法</h3><h4 id="1-初始化-package-json"><a href="#1-初始化-package-json" class="headerlink" title="1).初始化 package.json"></a>1).初始化 package.json</h4><ul>
<li><p>在小程序调试器的终端中输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li>
<li><p>该文件相当于整个项目的配置文件，并可初始化包名，一般只保留包名和版本号即可</p>
</li>
</ul>
<h4 id="2-修改小程序设置"><a href="#2-修改小程序设置" class="headerlink" title="2).修改小程序设置"></a>2).修改小程序设置</h4><ul>
<li>在详情 - 本地设置中勾选 “使用npm模块”</li>
</ul>
<h4 id="3-下载npm包"><a href="#3-下载npm包" class="headerlink" title="3).下载npm包"></a>3).下载npm包</h4><ul>
<li>在小程序调试器的终端中输入以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install 包名</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-构建npm"><a href="#4-构建npm" class="headerlink" title="4).构建npm"></a>4).构建npm</h4><ul>
<li>在开发工具的 工具 - 构建npm 选项，这样会将下载的包自动转化为小程序可以使用的格式，并放入指定路径</li>
<li>当小程序引入npm包时，该页面首先会从小程序指定npm包路径查找，查找不到会去当前文件夹内进行查找，所以如果不构建 npm 那么就会出现找不到该npm包</li>
</ul>
<h4 id="5-导入npm包"><a href="#5-导入npm包" class="headerlink" title="5).导入npm包"></a>5).导入npm包</h4><ul>
<li>在需要导入npm的 js 文件中使用以下语句进行导入<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import 自定义名 from &#x27;包名&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-常见第三方库"><a href="#2-常见第三方库" class="headerlink" title="(2).常见第三方库"></a>(2).常见第三方库</h3><h4 id="1-PubSub"><a href="#1-PubSub" class="headerlink" title="1).PubSub"></a>1).PubSub</h4><ul>
<li>功能：用来在两个页面之间进行通信</li>
<li>地址：<a href="https://github.com/mroderick/PubSubJS">点击这里</a></li>
<li>使用 <code>npm install pubsub-js</code> 命令进行安装</li>
<li>关于订阅方与接收方的内容，请点击 <a href="#event">这里</a> 跳转查看</li>
</ul>
<h4 id="2-Moment"><a href="#2-Moment" class="headerlink" title="2).Moment"></a>2).Moment</h4><ul>
<li>功能：使用JavaScript 日期处理类库来格式化时间</li>
<li>地址：<a href="http://momentjs.cn/">点击这里</a></li>
<li>使用 <code>npm install moment</code> 命令进行安装</li>
<li>该js语法中使用的是单位是ms</li>
</ul>
<h4 id="3-Fly"><a href="#3-Fly" class="headerlink" title="3).Fly"></a>3).Fly</h4><ul>
<li>功能：一个支持所有JavaScript运行环境的基于Promise的、支持请求转发、强大的http请求库。可以让您在多个端上尽可能大限度的实现代码复用</li>
<li>地址：<a href="https://github.com/wendux/fly">点击这里</a></li>
<li>使用 <code>npm install flyio</code> 命令进行安装</li>
<li>Node 中引入的方式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Fly=require(&quot;flyio/src/node&quot;);</span><br><span class="line">const fly=new Fly;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-jsonwebtoken"><a href="#4-jsonwebtoken" class="headerlink" title="4).jsonwebtoken"></a>4).jsonwebtoken</h4><ul>
<li><p>功能：可以对传输的数据进行加密解密</p>
</li>
<li><p>地址：<a href="https://github.com/auth0/node-jsonwebtoken">点击这里</a></p>
</li>
<li><p>使用 <code>npm install jsonwebtoken</code> 命令进行安装</p>
</li>
<li><p>Node 中引入的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const jwt = require(&#x27;jsonwebtoken&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><p>加密与解密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 加密</span><br><span class="line">const token = jwt.sign(&#123; foo: &#x27;bar&#x27; &#125;, &#x27;shhhhh&#x27;);</span><br><span class="line">// 解密</span><br><span class="line">const decoded = jwt.verify(token, &#x27;shhhhh&#x27;);</span><br><span class="line">console.log(decoded.foo)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-函数节流与防抖"><a href="#11-函数节流与防抖" class="headerlink" title="11.函数节流与防抖"></a>11.函数节流与防抖</h2><ul>
<li>使用延时定时器???</li>
</ul>
<h2 id="12-小程序登录"><a href="#12-小程序登录" class="headerlink" title="12.小程序登录"></a>12.小程序登录</h2><ul>
<li>小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系</li>
</ul>
<h3 id="1-获取登录凭证"><a href="#1-获取登录凭证" class="headerlink" title="(1).获取登录凭证"></a>(1).获取登录凭证</h3><ul>
<li>wx.login()：使用该API进行获取，code是从成功的回调中获取到的</li>
<li>如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.login(&#123;</span><br><span class="line">	success: (res) =&gt; &#123;</span><br><span class="line">		let code = res.code;        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-将登录凭证发送给服务器"><a href="#2-将登录凭证发送给服务器" class="headerlink" title="(2).将登录凭证发送给服务器"></a>(2).将登录凭证发送给服务器</h3><ul>
<li>这里需要自己在个人服务器中写一个接口，然后这里调用接口即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let result = await request(&#x27;/getOpenId&#x27;, &#123;code&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-调试错误"><a href="#13-调试错误" class="headerlink" title="13.调试错误"></a>13.调试错误</h2><ul>
<li>当在写 js 语句时，如果发现有些地方有问题，可以在该处写一个 <code>return</code> 来阻断一下</li>
<li>这样该条语句下面的语句就不会执行了</li>
</ul>
<h1 id="三、框架"><a href="#三、框架" class="headerlink" title="三、框架"></a>三、框架</h1><ul>
<li>关于 框架 的详细内容请查看小程序官方<a href="https://developers.weixin.qq.com/miniprogram/dev/reference/">文档</a></li>
</ul>
<h2 id="1-小程序配置"><a href="#1-小程序配置" class="headerlink" title="1.小程序配置"></a>1.小程序配置</h2><h3 id="1-全局配置"><a href="#1-全局配置" class="headerlink" title="(1).全局配置"></a>(1).全局配置</h3><h4 id="1-tabBar"><a href="#1-tabBar" class="headerlink" title="1).tabBar"></a>1).tabBar</h4><ul>
<li>可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面（需全局json文件中配置）</li>
<li>常用属性：<ul>
<li>color：tab 上的文字默认颜色，仅支持十六进制颜色</li>
<li>selectedColor：tab 上的文字选中时的颜色，仅支持十六进制颜色</li>
<li>backgroundColor：tab 的背景色，仅支持十六进制颜色</li>
<li>list：tab 的列表，最少 2 个、最多 5 个 tab</li>
<li>position：tabBar 的位置，仅支持 <code>bottom</code> / <code>top</code></li>
</ul>
</li>
<li>**<code>&lt;list&gt;</code>**属性：<ul>
<li>pagePath：页面路径，必须在 pages 中先定义</li>
<li>text：tab 上按钮的文字</li>
<li>iconPath：图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片</li>
<li>selectedIconPath：选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片</li>
</ul>
</li>
</ul>
<h2 id="2-框架接口"><a href="#2-框架接口" class="headerlink" title="2.框架接口"></a>2.框架接口</h2><h3 id="1-getAPP"><a href="#1-getAPP" class="headerlink" title="(1).getAPP"></a>(1).getAPP</h3><ul>
<li>获取到小程序全局唯一的 <code>App</code> 实例</li>
</ul>
<h2 id="3-wxml语法"><a href="#3-wxml语法" class="headerlink" title="3.wxml语法"></a>3.wxml语法</h2><h3 id="1-数据绑定"><a href="#1-数据绑定" class="headerlink" title="(1).数据绑定"></a>(1).数据绑定</h3><h4 id="1-初始化数据"><a href="#1-初始化数据" class="headerlink" title="1).初始化数据"></a>1).初始化数据</h4><ul>
<li>在当前页面的 js 文件中的 <strong>data</strong> 选项中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		msg:&quot;Wrysmile的博客&quot;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-使用数据"><a href="#2-使用数据" class="headerlink" title="2).使用数据"></a>2).使用数据</h4><ul>
<li>在页面模板结构中使用双大括号来使用数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;text class=&quot;userName&quot;&gt;&#123; &#123;msg&#125; &#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-修改数据"><a href="#3-修改数据" class="headerlink" title="3).修改数据"></a>3).修改数据</h4><ul>
<li><p>修改数据需要在生命周期函数的 onLoad() 中进行</p>
</li>
<li><p>获取数据需要使用 <code>this.data.msg</code> 来获取</p>
</li>
<li><p>修改数据需要使用 <code>this.setData</code> 来修改，如下（回调函数可省）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">	msg:&quot;Wrysmile的小站&quot;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>特点：</p>
<ul>
<li>同步修改：this.data 的值同步修改，在非自身的钩子函数也是同步的</li>
<li>异步更新：异步将 setData 函数用于将数据从逻辑层发送到视图层</li>
</ul>
</li>
</ul>
<h4 id="4-与Vue和React的对比"><a href="#4-与Vue和React的对比" class="headerlink" title="4).与Vue和React的对比"></a>4).与Vue和React的对比</h4><h5 id="a-小程序"><a href="#a-小程序" class="headerlink" title="a).小程序"></a>a).小程序</h5><ul>
<li>data 中初始化数据</li>
<li>修改数据：<code>this.setData()</code>（该行为始终是同步的）</li>
<li>数据流：<ul>
<li>单向数据流：Model –&gt; View</li>
</ul>
</li>
</ul>
<h5 id="b-Vue"><a href="#b-Vue" class="headerlink" title="b).Vue"></a>b).Vue</h5><ul>
<li>data 中初始化数据</li>
<li>修改数据：this.key = value</li>
<li>数据流：<ul>
<li>单向数据流：Model –&gt; View</li>
<li>实现了双向数据绑定：v-model</li>
</ul>
</li>
</ul>
<h5 id="c-React"><a href="#c-React" class="headerlink" title="c).React"></a>c).React</h5><ul>
<li>state 中初始化状态数据</li>
<li>修改数据：<code>this.setState()</code><ul>
<li>在自身的钩子函数中（componentDidMount）中是异步的</li>
<li>在非自身的钩子函数中（定时器的回调）中是同步的</li>
</ul>
</li>
<li>数据流：<ul>
<li>单向数据流：Model –&gt; View</li>
</ul>
</li>
</ul>
<h4 id="扩展：数据劫持代理"><a href="#扩展：数据劫持代理" class="headerlink" title="扩展：数据劫持代理"></a>扩展：数据劫持代理</h4><ul>
<li>如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Vue数据劫持代理</span><br><span class="line">// 模拟Vue中data选项</span><br><span class="line">let data = &#123;</span><br><span class="line">  username: &#x27;curry&#x27;,</span><br><span class="line">  age: 33</span><br><span class="line">&#125;</span><br><span class="line">// 模拟组件的实例</span><br><span class="line">let _this = &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 利用Object.defineProperty()</span><br><span class="line">for(let item in data)&#123;</span><br><span class="line">  // console.log(item, data[item]);</span><br><span class="line">  Object.defineProperty(_this, item, &#123;</span><br><span class="line">    // get：用来获取扩展属性值的，当获取该属性值的时候调用get方法</span><br><span class="line">    get()&#123;</span><br><span class="line">      console.log(&#x27;get()&#x27;);</span><br><span class="line">      return data[item]</span><br><span class="line">    &#125;,</span><br><span class="line">    // set： 监视扩展属性的， 只要已修改就调用</span><br><span class="line">    set(newValue)&#123;</span><br><span class="line">      console.log(&#x27;set()&#x27;, newValue);</span><br><span class="line">      // _this.username = newValue; 千万不要在set方法中直接修改当前扩展属性的值，会出现死循环</span><br><span class="line">      data[item] = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(_this);</span><br><span class="line">// 通过Object.defineProperty的get方法添加的扩展属性不能直接对象.属性修改</span><br><span class="line">_this.username = &#x27;wade&#x27;;</span><br><span class="line">console.log(_this.username);</span><br></pre></td></tr></table></figure>

<h3 id="2-事件绑定"><a href="#2-事件绑定" class="headerlink" title="(2).事件绑定"></a>(2).事件绑定</h3><h4 id="1-冒泡事件"><a href="#1-冒泡事件" class="headerlink" title="1).冒泡事件"></a>1).冒泡事件</h4><ul>
<li>当一个组件上的事件被触发后，该事件会向父节点传递</li>
<li><code>bind+事件名</code> ：该绑定不会阻止冒泡事件向上冒泡<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;goStudy&quot; bindtap=&quot;handleParent&quot;&gt;</span><br><span class="line">	&lt;text bindtap=&quot;handleChild&quot;&gt;Hello World!&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-非冒泡事件"><a href="#2-非冒泡事件" class="headerlink" title="2).非冒泡事件"></a>2).非冒泡事件</h4><ul>
<li>当一个组件上的事件被触发后，该事件不会向父节点传递</li>
<li><code>catch+事件名</code> ：该绑定会阻止冒泡事件向上冒泡<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;goStudy&quot; catchtap=&quot;handleParent&quot;&gt;</span><br><span class="line">	&lt;text catchtap=&quot;handleChild&quot;&gt;Hello World!&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-事件回调"><a href="#3-事件回调" class="headerlink" title="3).事件回调"></a>3).事件回调</h4><ul>
<li>对应的事件回调应该在对应页面的 js 文件中定义，且位置应该与 <code>data</code> 和 <code>生命周期函数</code> 平行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleParent()&#123;</span><br><span class="line">	console.log(&quot;parent&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">handleChild()&#123;</span><br><span class="line">	console.log(&quot;child&quot;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-事件委托"><a href="#4-事件委托" class="headerlink" title="4).事件委托"></a>4).事件委托</h4><h5 id="a-概念"><a href="#a-概念" class="headerlink" title="a).概念"></a>a).概念</h5><ul>
<li>将子元素的事件委托（绑定）给父元素</li>
</ul>
<h5 id="b-好处"><a href="#b-好处" class="headerlink" title="b).好处"></a>b).好处</h5><ul>
<li>减少绑定的次数</li>
<li>后期新添加的元素也可以享用之前委托的事件</li>
</ul>
<h5 id="c-原理"><a href="#c-原理" class="headerlink" title="c).原理"></a>c).原理</h5><ul>
<li>冒泡</li>
</ul>
<h5 id="d-触发事件的是谁"><a href="#d-触发事件的是谁" class="headerlink" title="d).触发事件的是谁"></a>d).触发事件的是谁</h5><ul>
<li>子元素</li>
</ul>
<h5 id="e-如何找到触发事件的对象"><a href="#e-如何找到触发事件的对象" class="headerlink" title="e).如何找到触发事件的对象"></a>e).如何找到触发事件的对象</h5><ul>
<li>event.target：绑定事件的元素不一定是触发事件的元素</li>
<li>event.currentTarget：要求绑定的元素一定是触发事件的元素</li>
</ul>
<h4 id="拓展：事件流三阶段"><a href="#拓展：事件流三阶段" class="headerlink" title=" 拓展：事件流三阶段"></a><strong style="color:red;"> 拓展：事件流三阶段</strong></h4><ul>
<li>捕获：从外向内</li>
<li>执行目标阶段</li>
<li>冒泡：从内向外</li>
</ul>
<h4 id="拓展：绑定事件"><a href="#拓展：绑定事件" class="headerlink" title="拓展：绑定事件"></a><strong style="color:red;">拓展：绑定事件</strong></h4><ul>
<li>bindtap</li>
<li>bindinput：表单项内容实时发生改变时触发</li>
<li>bindchange：表单项内容实时发生改变且失去焦点时触发</li>
</ul>
<h4 id="拓展：事件分类"><a href="#拓展：事件分类" class="headerlink" title="拓展：事件分类"></a><strong style="color:red;">拓展：<span id="event">事件分类</span></strong></h4><ul>
<li>标准DOM事件<ul>
<li>事件名固定，事件由浏览器触发</li>
</ul>
</li>
<li>自定义事件<ul>
<li>绑定事件<ul>
<li>事件名</li>
<li>事件的回调</li>
<li>订阅方：是接收数据的一方，例如PubSub.subscribe(消息名,事件的回调)、PubSub.unsubscribr(消息名)取消订阅</li>
</ul>
</li>
<li>触发事件<ul>
<li>事件名</li>
<li>提供事件参数对象，等同于原生事件的event事件</li>
<li>发布方：是提供数据的一方，例如PubSub.publish(消息名,提供的数据)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-列表渲染"><a href="#3-列表渲染" class="headerlink" title="(3).列表渲染"></a>(3).列表渲染</h3><ul>
<li><code>wx:for=&quot;&#123; &#123;array&#125; &#125;&quot;</code> （这里双大括号之间没有空格）<ul>
<li>下标为 index，个体为 item</li>
</ul>
</li>
<li><code>wx:key=&quot;unique&quot;</code> 的值以两种形式提供：<ul>
<li>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变</li>
<li>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字<strong style="color:red;">（几乎用不上）</strong></li>
</ul>
</li>
</ul>
<h4 id="为什么wx-key不使用下标index而是ID？"><a href="#为什么wx-key不使用下标index而是ID？" class="headerlink" title="为什么wx:key不使用下标index而是ID？"></a>为什么wx:key不使用下标index而是ID？</h4><ul>
<li>因为使用下标时，当一个元素发生变化时，后面的其余元素全都需要重新计算</li>
<li>而使用ID时，只需要计算不同ID即可</li>
</ul>
<h3 id="4-条件渲染"><a href="#4-条件渲染" class="headerlink" title="(4).条件渲染"></a>(4).条件渲染</h3><ul>
<li>wx:if=’条件’</li>
<li>wx:elif=’条件’</li>
<li>wx:else</li>
</ul>
<h4 id="引申：动态隐藏元素"><a href="#引申：动态隐藏元素" class="headerlink" title="引申：动态隐藏元素"></a>引申：动态隐藏元素</h4><ul>
<li>一般情况下使用 wx:if 来进行判断来使某元素动态显示或隐藏，但这种性能并不算好</li>
<li>这里可以使用 <code>hidden=&quot;&quot;</code> 来进行动态显示隐藏，这里需要一个布尔值来判断</li>
</ul>
<h3 id="5-生命周期"><a href="#5-生命周期" class="headerlink" title="(5).生命周期"></a>(5).生命周期</h3><ul>
<li>生命周期如下图：<br><img src="https://s3.ax1x.com/2021/02/22/yHUKM9.png" alt="mp01.png"></li>
</ul>
<h3 id="6-模板"><a href="#6-模板" class="headerlink" title="(6).模板"></a>(6).模板</h3><ul>
<li>模板（template），可以在模板中定义代码片段，然后在不同的地方调用</li>
<li>template 页面只需要 wxml 和 wxss 两个页面即可</li>
</ul>
<h4 id="1-定义模板"><a href="#1-定义模板" class="headerlink" title="1).定义模板"></a>1).定义模板</h4><ul>
<li>使用 name 属性，作为模板的名字，然后在<code>&lt;template/&gt;</code>内定义代码片段</li>
</ul>
<h4 id="2-引入模板"><a href="#2-引入模板" class="headerlink" title="2).引入模板"></a>2).引入模板</h4><ul>
<li><p>在目标页面的 wxml 中用下面语法引入页面结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;import src=&quot;页面结构路径&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在目标页面的 wxss 中用下面语法引入页面样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;页面样式路径&quot;;</span><br></pre></td></tr></table></figure></li>
<li><p>在需要模板的地方通过下面语法引入模板</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template is=&quot;name属性值&quot; data=&quot;&#123; &#123;...item&#125; &#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-使用模板"><a href="#3-使用模板" class="headerlink" title="3).使用模板"></a>3).使用模板</h4><ul>
<li>使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入，如上</li>
</ul>
<h3 id="7-引用"><a href="#7-引用" class="headerlink" title="(7).引用"></a>(7).引用</h3><ul>
<li>wxml 提供两种文件引用方式 <code>import</code> 和 <code>include</code> </li>
<li>wxss 提供一种文件引用方式 <code>@import &quot;&quot;</code> </li>
</ul>
<h3 id="8-数组与对象"><a href="#8-数组与对象" class="headerlink" title="(8).数组与对象"></a>(8).数组与对象</h3><ul>
<li>在中括号中的是数组，在大括号中的是对象</li>
</ul>
<h1 id="四、组件"><a href="#四、组件" class="headerlink" title="四、组件"></a>四、组件</h1><ul>
<li>关于 组件 的详细内容请查看小程序官方<a href="https://developers.weixin.qq.com/miniprogram/dev/component/">文档</a></li>
</ul>
<h2 id="1-swiper"><a href="#1-swiper" class="headerlink" title="1.swiper"></a>1.swiper</h2><ul>
<li>滑块视图容器。其中只可放置 <code>&lt;swiper-item&gt;</code> 组件</li>
<li>有些属性默认为 flase，如果想要开启时需要在 <code>&lt;swiper&gt;</code> 中声明，但可以省略 true，因为只要声明了就为 true</li>
</ul>
<h3 id="1-常用属性"><a href="#1-常用属性" class="headerlink" title="(1).常用属性"></a>(1).常用属性</h3><ul>
<li>indicator-dots：是否显示面板指示点</li>
<li>indicator-color：指示点颜色</li>
<li>indicator-active-color：当前选中的指示点颜色</li>
<li>autoplay：是否自动切换</li>
<li>circular：是否采用衔接滑动</li>
<li>previous-margin：前边距，可用于露出前一项的一小部分，接受 px 和 rpx 值</li>
<li>next-margin：后边距，可用于露出后一项的一小部分，接受 px 和 rpx 值</li>
</ul>
<h2 id="2-scroll-view"><a href="#2-scroll-view" class="headerlink" title="2.scroll-view"></a>2.scroll-view</h2><ul>
<li>可滚动视图区域。使用竖向滚动时，需要给 <code>&lt;croll-view&gt;</code> 一个固定高度，通过 WXSS 设置 height</li>
<li>如果想要设置 flex 布局，必须将 <code>&lt;croll-view&gt;</code> 中的 enable-flex 属性打开才可以生效</li>
<li><strong style="color:red;">注意：该组件横向滚动时，也是需要给其设置高度的，否则高度会自动变大</strong></li>
</ul>
<h3 id="1-常用属性-1"><a href="#1-常用属性-1" class="headerlink" title="(1).常用属性"></a>(1).常用属性</h3><ul>
<li>enable-flex：启用 flexbox 布局</li>
<li>scroll-x/y：允许横/纵向滚动</li>
<li>scroll-into-view：设置哪个方向可滚动，则在哪个方向滚动到该元素。<strong style="color:red;">注意：值应为某子元素id（id不能以数字开头）</strong></li>
<li>scroll-with-animation：在设置滚动条位置时使用动画过渡</li>
<li>refresher-enabled：开启自定义下拉刷新</li>
<li>refresher-triggered：设置当前下拉刷新状态，true 表示下拉刷新已经被触发，false 表示下拉刷新未被触发</li>
<li>bindscrolltoupper：滚动到顶部/左边时触发</li>
<li>bindscrolltolower：滚动到底部/右边时触发</li>
<li>bindrefresherrefresh：自定义下拉刷新被触发</li>
</ul>
<h2 id="3-video"><a href="#3-video" class="headerlink" title="3.video"></a>3.video</h2><ul>
<li>bindplay：当开始/继续播放时触发play事件</li>
<li>object-fit：当视频大小与 video 容器大小不一致时，视频的表现形式<br>contain：包含<br>fill：填充<br>cover：覆盖</li>
<li>bindtimeupdate：播放进度变化时触发，<code>event.detail = &#123;currentTime, duration&#125;</code> 。触发频率 250ms 一次</li>
<li>bindended：当播放到末尾时触发 ended 事件</li>
</ul>
<h2 id="4-block"><a href="#4-block" class="headerlink" title="4.block"></a>4.block</h2><ul>
<li>可以将 <code>&lt;view&gt;</code> 放在 <code>&lt;block&gt;</code> 标签中，表示块的意思，同时圈住多个元素表示一个整体</li>
<li>该标签在页面结构中并不会加载，所以可通过<strong>条件判断</strong>来让他显示哪个块</li>
</ul>
<h2 id="5-button"><a href="#5-button" class="headerlink" title="5.button"></a>5.button</h2><ul>
<li>form-type：用于 form 组件，点击分别会触发 form 组件的 submit/reset 事件</li>
<li>type：按钮的样式类型</li>
</ul>
<h2 id="6-form"><a href="#6-form" class="headerlink" title="6.form"></a>6.form</h2><ul>
<li>bindsubmit：携带 form 中的数据触发 submit 事件，此时需要组件中带有 name 属性</li>
</ul>
<h2 id="7-radio"><a href="#7-radio" class="headerlink" title="7.radio"></a>7.radio</h2><ul>
<li><p>修改 <code>&lt;radio&gt;</code> 组件的大小方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">radio&#123;</span><br><span class="line">	transform: scale(0.7);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>具体大小自行修改括号中数值，0-1以内</p>
</li>
</ul>
<h2 id="8-封装功能函数-组件"><a href="#8-封装功能函数-组件" class="headerlink" title="8.封装功能函数/组件"></a>8.封装功能函数/组件</h2><h3 id="1-封装功能函数"><a href="#1-封装功能函数" class="headerlink" title="(1).封装功能函数"></a>(1).封装功能函数</h3><ul>
<li>功能点明确</li>
<li>函数内部应该保留固定代码（静态的）</li>
<li>将动态的数据抽取成形参，由使用者根据自身的情况动态的传入实参</li>
<li>一个良好的功能函数应该设置形参的默认值（ES6的形参默认值）</li>
</ul>
<h3 id="2-封装功能组件"><a href="#2-封装功能组件" class="headerlink" title="(2).封装功能组件"></a>(2).封装功能组件</h3><ul>
<li>功能点明确</li>
<li>组件内部保留静态的代码</li>
<li>将动态的数据抽取成 props 参数，由使用者根据自身的情况以标签属性的形式动态传入 props 数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">	msg: &#123;</span><br><span class="line">		required: true,</span><br><span class="line">		default: 默认值,</span><br><span class="line">		type: String</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个良好的组件应该设置组件的必要性及数据类型</li>
</ul>
<h3 id="3-小程序封装函数方法"><a href="#3-小程序封装函数方法" class="headerlink" title="(3).小程序封装函数方法"></a>(3).小程序封装函数方法</h3><ul>
<li><p>在根目录新建 <code>utils</code> 目录，将需要封装的函数放入该目录中</p>
</li>
<li><p>关于服务器中的配置内容，我们可以将其单独放在另一个 js 文件中，方便配置</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 配置服务器相关信息</span><br><span class="line">export default &#123;</span><br><span class="line">	host: &#x27;http://localhost:3000&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在封装好的函数中引入服务器配置文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入服务器配置信息</span><br><span class="line">import config from &#x27;./config&#x27;</span><br><span class="line">// 发送ajax请求</span><br><span class="line">// 为了复用，应该以模块化的思想将函数暴露出去;动态的内容应该抽取为参数</span><br><span class="line">export default (url,data=&#123;&#125;,method=&quot;GET&quot;) =&gt; &#123;</span><br><span class="line">	return new Promise((resolve,reject) =&gt; &#123;</span><br><span class="line">		// new Promise 初始化 promise 实例的状态为 pending</span><br><span class="line">		wx.request(&#123;</span><br><span class="line">			// ES6 同名属性可以省略不写</span><br><span class="line">			url: config.host + url,</span><br><span class="line">			data,</span><br><span class="line">			method,</span><br><span class="line">			success: (res) =&gt; &#123;</span><br><span class="line">				// 修改promise的状态为成功状态resolved</span><br><span class="line">				resolve(res.data);</span><br><span class="line">			&#125;,</span><br><span class="line">			fail: (err) =&gt; &#123;</span><br><span class="line">				// 修改promise的状态为失败状态rejected</span><br><span class="line">				reject(err);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在需要引用该函数的文件中引入封装好的函数，并调用该函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import request from &#x27;../../utils/request&#x27;</span><br><span class="line">····</span><br><span class="line">onLoad: async function (options) &#123;</span><br><span class="line">	// 使用 await 等待异步任务的结果，且需要搭配 async 来使用</span><br><span class="line">	let result = await request(&#x27;/banner&#x27;,&#123;type:2&#125;);</span><br><span class="line">	console.log(&#x27;结果数据为：&#x27;,result);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="9-自定义组件"><a href="#9-自定义组件" class="headerlink" title="9.自定义组件"></a>9.自定义组件</h2><ul>
<li>自定义组件可以将相同的结构提取出来，提高复用率</li>
</ul>
<h3 id="1-参数"><a href="#1-参数" class="headerlink" title="(1).参数"></a>(1).参数</h3><ul>
<li>我们主要用到 <code>properties</code> 和 <code>data</code> 两个参数</li>
<li><code>properties</code>：组件的对外属性，是属性名到属性设置的映射表，其定义有：<ul>
<li>type： 属性的类型</li>
<li>optionalTypes：属性的类型（可以指定多个）</li>
<li>value：属性的初始值</li>
</ul>
</li>
<li><code>data</code>：组件的内部数据，和 <code>properties</code> 一同用于组件的模板渲染</li>
</ul>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="(2).方法"></a>(2).方法</h3><ul>
<li>在项目根目录新建 <code>components</code> 目录，并在其中创建所需的组件文件夹，在文件夹右键<strong>新建component</strong></li>
<li>在主页面的 json 文件中注册该组件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;usingComponents&quot;: &#123;</span><br><span class="line">		&quot;NavHeader&quot;:&quot;/components/NavHeader/NavHeader&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将页面中所需自定义部分的结构和样式提取到组件相应文件中去</p>
</li>
<li><p>组件一般是复用的，所以其中内容我们应该用变量的形式</p>
</li>
<li><p>在组件的 js 文件中的 <code>properties</code> 中给这些变量设置type和value，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">	title: &#123;</span><br><span class="line">		type: String,</span><br><span class="line">		value: &quot;title默认值&quot;</span><br><span class="line">	&#125;,</span><br><span class="line">	nav: &#123;</span><br><span class="line">		type: String,</span><br><span class="line">		value: &quot;nav默认值&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>在主页面中以标签名（即json文件中设置的属性值）的方式引入设置好的组件，并设置相应变量值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;NavHeader title=&quot;推荐歌曲&quot; nav=&quot;为你精心推荐&quot;&gt;&lt;/NavHeader&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、API"><a href="#五、API" class="headerlink" title="五、API"></a>五、API</h1><ul>
<li>关于 API 的详细内容请查看小程序官方<a href="https://developers.weixin.qq.com/miniprogram/dev/api/">文档</a></li>
<li>小程序的全局对象是 <code>wx</code> </li>
</ul>
<h2 id="1-路由跳转"><a href="#1-路由跳转" class="headerlink" title="1.路由跳转"></a>1.路由跳转</h2><ul>
<li>可以从当前页面跳转到另一个页面</li>
<li>使用路由跳转的相关函数时，路径需要使用<strong>绝对路径</strong></li>
</ul>
<h3 id="1-路由传参"><a href="#1-路由传参" class="headerlink" title="(1).路由传参"></a>(1).路由传参</h3><ul>
<li>原生小程序中路由传参，对参数的长度有限制，如果参数长度过长会自动截取掉</li>
</ul>
<h2 id="2-本地存储"><a href="#2-本地存储" class="headerlink" title="2.本地存储"></a>2.本地存储</h2><ul>
<li>将数据存储在本地缓存中指定的 key 中</li>
<li>语法：<code>wx.setStorage() || wx.setStorageSync() || ···</code></li>
<li>注意：<ul>
<li>建议存储的数据为 json 数据</li>
<li>单个 key 允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB</li>
<li>属于永久存储，同 H5 的 localStorage 一样</li>
</ul>
</li>
</ul>
<h2 id="3-界面"><a href="#3-界面" class="headerlink" title="3.界面"></a>3.界面</h2><h3 id="1-交互-——-显示等待提示框"><a href="#1-交互-——-显示等待提示框" class="headerlink" title="(1).交互 —— 显示等待提示框"></a>(1).交互 —— 显示等待提示框</h3><ul>
<li>语法：wx.showLoading()</li>
<li>需主动调用 wx.hideLoading 才能关闭提示框</li>
</ul>
<h3 id="2-交互-——-显示模态对话框"><a href="#2-交互-——-显示模态对话框" class="headerlink" title="(2).交互 —— 显示模态对话框"></a>(2).交互 —— 显示模态对话框</h3><ul>
<li>语法：wx.showModal()</li>
<li>content：提示的内容</li>
<li>其 success 的回调中 confirm 为 true 时，表示用户点击了确定按钮</li>
</ul>
<h3 id="3-导航栏-——-动态设置当前页面的标题"><a href="#3-导航栏-——-动态设置当前页面的标题" class="headerlink" title="(3).导航栏 —— 动态设置当前页面的标题"></a>(3).导航栏 —— 动态设置当前页面的标题</h3><ul>
<li>语法：wx.setNavigationBarTitle(Object object)</li>
</ul>
<h2 id="4-媒体"><a href="#4-媒体" class="headerlink" title="4.媒体"></a>4.媒体</h2><h3 id="1-背景音频"><a href="#1-背景音频" class="headerlink" title="(1).背景音频"></a>(1).背景音频</h3><ul>
<li>BackgroundAudioManager 实例，可通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html">wx.getBackgroundAudioManager</a> 获取</li>
<li>要想播放音乐，必须设置该实例的 title 与 src 属性</li>
<li>若需要小程序在退到后台后继续播放音频，需要在 app.json 中配置 requiredBackgroundModes 属性</li>
<li>BackgroundAudioManager 实例，可通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html">wx.getBackgroundAudioManager</a> 获取<ul>
<li>BackgroundAudioManager.onPlay(function callback)监听背景音频播放事件</li>
<li>BackgroundAudioManager.onPause(function callback)监听背景音频暂停事件</li>
<li>BackgroundAudioManager.onStop(function callback)监听背景音频停止事件</li>
<li>BackgroundAudioManager.onTimeUpdate(function callback)监听背景音频播放进度更新事件，只有小程序在前台时会回调</li>
</ul>
</li>
</ul>
<h1 id="六、动画"><a href="#六、动画" class="headerlink" title="六、动画"></a>六、动画</h1><h2 id="1-触摸滑动回弹"><a href="#1-触摸滑动回弹" class="headerlink" title="1.触摸滑动回弹"></a>1.触摸滑动回弹</h2><h3 id="1-事件绑定"><a href="#1-事件绑定" class="headerlink" title="(1).事件绑定"></a>(1).事件绑定</h3><ul>
<li>bindtouchstart：手指触摸时</li>
<li>bindtouchmove：手指移动时</li>
<li>bindtouchend：手指离开时</li>
</ul>
<h3 id="2-计算手指移动的距离"><a href="#2-计算手指移动的距离" class="headerlink" title="(2).计算手指移动的距离"></a>(2).计算手指移动的距离</h3><ul>
<li>在js文件中初始化三个值为0<br>手指起始的坐标：startY<br>手指移动的坐标：moveY<br>手指移动的距离：moveDistance</li>
<li>获取手指的起始坐标需要用到 <code>event</code> 对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleTouchStart(event)&#123;</span><br><span class="line">	// 拿到第一个手指的纵向起始坐标</span><br><span class="line">	startY = event.touches[0].clientY;</span><br><span class="line">&#125;,</span><br><span class="line">handleTouchMove(event)&#123;</span><br><span class="line">	moveY = event.touches[0].clientY;</span><br><span class="line">	moveDistance = moveY - startY;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-设置滑动效果"><a href="#3-设置滑动效果" class="headerlink" title="(3).设置滑动效果"></a>(3).设置滑动效果</h3><ul>
<li><p>这里可以使用 CSS3 的 <code>transform</code> </p>
</li>
<li><p>在 data 中初始化数据，然后让其动态更新translateY的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.setData(&#123;</span><br><span class="line">	// 使用ES6的模板字符串，因为需要写变量值</span><br><span class="line">	coverTransform: `translateY($ &#123;moveDistance&#125;rpx)`,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>然后在手指松开时设置过渡让其恢复原样，并在手指点击时清除过渡效果</p>
</li>
</ul>
<h2 id="2-导航过渡效果"><a href="#2-导航过渡效果" class="headerlink" title="2.导航过渡效果"></a>2.导航过渡效果</h2><ul>
<li>导航一般使用 <code>&lt;scroll-view&gt;</code> 来编写，当切换导航时，应当使该标签自动滑动到第一位</li>
<li>使用 scroll-into-view 来使其滚动</li>
<li>使用 scroll-with-animation 来设置滚动的过渡效果</li>
</ul>
<h2 id="3-留声机磁盘旋转效果"><a href="#3-留声机磁盘旋转效果" class="headerlink" title="3.留声机磁盘旋转效果"></a>3.留声机磁盘旋转效果</h2><ul>
<li>使用 <code>animation</code> 来设置旋转动画</li>
<li>使用 <code>animation-dely</code> 来设置动画延迟</li>
<li>使用 <code>@keyframes</code> 来设置动画桢<ul>
<li>from to：使用于简单的动画，只有起始帧和结束帧</li>
<li>百分比：多用于复杂的动画，动画不止两帧</li>
</ul>
</li>
<li>使用 <code>transform</code> 来设置旋转角度</li>
</ul>
<h1 id="七、分包"><a href="#七、分包" class="headerlink" title="七、分包"></a>七、分包</h1><h2 id="1-介绍-2"><a href="#1-介绍-2" class="headerlink" title="1.介绍"></a>1.介绍</h2><ul>
<li>小程序要求压缩包体积不能大于2M，否则无法发布，而实际开发中小程序体积如果大于2M就需要使用分包机制进行发布上传</li>
<li>作用：分包后可解决2M限制，并且能分包加载内容，提高性能</li>
<li>官方文档点击 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html">这里</a></li>
</ul>
<h2 id="2-分包形式"><a href="#2-分包形式" class="headerlink" title="2.分包形式"></a>2.分包形式</h2><h3 id="1-常规分包"><a href="#1-常规分包" class="headerlink" title="(1).常规分包"></a>(1).常规分包</h3><ul>
<li>开发者通过在 <code>app.json</code> 中的 subpackages 字段声明项目分包结构</li>
<li>特点：<ul>
<li>加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容</li>
<li>分包的页面可以访问主包的文件，数据，图片等资源</li>
</ul>
</li>
<li>适用于：通常放置启动页/tabBar页面</li>
</ul>
<h3 id="2-独立分包"><a href="#2-独立分包" class="headerlink" title="(2).独立分包"></a>(2).独立分包</h3><ul>
<li>只要在 <code>app.json</code> 中的 subpackages 字段中设置 independent 为 true即可</li>
<li>特点：<ul>
<li>独立分包可单独访问分包的内容，不需要下载主包</li>
<li>独立分包不能依赖主包或者其他包的内容</li>
</ul>
</li>
<li>适用于：通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包，如：临时加的广告页或活动页</li>
</ul>
<h3 id="3-分包预下载"><a href="#3-分包预下载" class="headerlink" title="(3).分包预下载"></a>(3).分包预下载</h3><ul>
<li>配置：<ul>
<li>在 <code>app.json</code> 中设置 preloadRule 选项</li>
<li>语法：<code>key(页面路径) : &#123; packages: [预下载的包名 || 预下载的包的根路径] &#125;</code> </li>
</ul>
</li>
<li>特点：<ul>
<li>在加载当前包的时候可以设置预下载其他的包</li>
<li>缩短用户等待时间，提高用户体验</li>
</ul>
</li>
</ul>
<h1 id="八、上传"><a href="#八、上传" class="headerlink" title="八、上传"></a>八、上传</h1><h2 id="1-注意"><a href="#1-注意" class="headerlink" title="1.注意"></a>1.注意</h2><ul>
<li>上传正式版本时，一定要记得取消<strong>不校验合法域名</strong>的勾选，并将自己的外网域名添加到小程序的后台中</li>
<li>上传正式版本之前一定要进行本机测试</li>
</ul>
<h2 id="2-版本命名规则"><a href="#2-版本命名规则" class="headerlink" title="2.版本命名规则"></a>2.版本命名规则</h2><ul>
<li>1.1.0<ul>
<li>第一位代表大版本更新或迭代</li>
<li>第二位代表重要功能的更新</li>
<li>第三位代表最小的功能，如修补bug、修复补丁、进行局部优化之类的</li>
</ul>
</li>
</ul>
<h2 id="3-提交审核"><a href="#3-提交审核" class="headerlink" title="3.提交审核"></a>3.提交审核</h2><ul>
<li>从小程序开发工具上传以后并不会上线</li>
<li>需要去小程序后台管理网站中进行<strong>提交审核</strong></li>
</ul>
<h1 id="九、云开发"><a href="#九、云开发" class="headerlink" title="九、云开发"></a>九、云开发</h1><ul>
<li>关于<strong>云开发</strong>的详细内容请查看小程序官方<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">文档</a></li>
</ul>
<h2 id="0-区分this"><a href="#0-区分this" class="headerlink" title="0.区分this"></a>0.区分this</h2><ul>
<li><code>.onLoad()</code> 中的 this 指向的是这个页面，即 page</li>
<li><code>.get()</code> 中的成功回调中的 this 为这个成功回调函数，即 function</li>
<li><code>.then()</code> 中的回调中的 this 指向的是这个页面，即 page</li>
</ul>
<h3 id="如何将-get-中的this指向页面？"><a href="#如何将-get-中的this指向页面？" class="headerlink" title="如何将.get()中的this指向页面？"></a><strong style="color:red;">如何将.get()中的this指向页面？</strong></h3><ul>
<li><p>如果想要在 <code>.get()</code> 的回调函数中获取到全局 this，则需要使用中间变量来获取</p>
</li>
<li><p>在 <code>.onLoad()</code> 中使用如下语句来获取到 this</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let that = this;</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>.get()</code> 的成功回调中使用如下语句来更新 data 中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">that.setData(&#123;</span><br><span class="line">	xxx: xxx</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.数据库"></a>1.数据库</h2><h3 id="0-权限"><a href="#0-权限" class="headerlink" title="(0).权限"></a>(0).权限</h3><ul>
<li><strong style="color:red;">读取、操作数据库时，必须修改 云开发-数据库-数据权限 中为第一个选项，否则无法读取到集合中的内容</strong></li>
</ul>
<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="(1).初始化"></a>(1).初始化</h3><ul>
<li><p>引入数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引入默认环境的数据库</span><br><span class="line">const db = wx.cloud.database()</span><br><span class="line">// 引入其他环境的数据库</span><br><span class="line">const testDB = wx.cloud.database(&#123;</span><br><span class="line">  env: &#x27;test&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>引入数据库中的集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const todos = db.collection(&#x27;todos&#x27;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-查询"><a href="#2-查询" class="headerlink" title="(2).查询"></a>(2).查询</h3><ul>
<li><p>获取某个集合中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection(&#x27;todos&#x27;).get(&#123;</span><br><span class="line">	success: (res) =&gt; &#123;</span><br><span class="line">		console.log(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>获取某个集合中某个id的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).get(&#123;</span><br><span class="line">	success: (res) =&gt; &#123;</span><br><span class="line">		console.log(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="解决多层成功回调嵌套"><a href="#解决多层成功回调嵌套" class="headerlink" title="!解决多层成功回调嵌套"></a>!解决多层成功回调嵌套</h4><ul>
<li><p>这里建议使用 <strong>ES6</strong> 的 promise</p>
</li>
<li><p>具体执行如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).get().then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">	console.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>then() 为成功的回调，catch() 为失败的回调</p>
</li>
</ul>
<h4 id="查询指令"><a href="#查询指令" class="headerlink" title="!查询指令"></a>!查询指令</h4><ul>
<li><code>.doc(&quot;&quot;)</code>：只通过id来进行查询</li>
<li><code>.where(&#123;&#125;)</code>：可通过各个属性进行查询</li>
<li><code>.count()</code>：查询数据库集合中的数据个数</li>
<li><code>.watch()</code>：监听数据库集合中的数据变化，需要使用 <code>onChange()</code> 和 <code>onError()</code> 属性来返回成功与失败的回调<ul>
<li>其中 res 返回的 docChanges 代表改变的数据、docs 代表数据库中最新的数据</li>
</ul>
</li>
<li><code>.limit()</code>：指定查询结果集数量上限（小程序端默认及最大上限为 20，在云函数端默认及最大上限为 1000）</li>
<li><code>.orderBy()</code>：指定查询排序条件，参数一为需要排序的属性，参数二中定义顺序（asc）、逆序（desc）</li>
<li><code>.skip()</code>：指定查询返回结果时从指定序列后的结果开始返回，常用于分页</li>
<li><code>.field()</code>：指定返回结果中记录需返回的字段</li>
</ul>
<h3 id="3-添加"><a href="#3-添加" class="headerlink" title="(3).添加"></a>(3).添加</h3><h4 id="a-普通添加"><a href="#a-普通添加" class="headerlink" title="a).普通添加"></a>a).普通添加</h4><ul>
<li>代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).add(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		title: &quot;我是新添加的&quot;,</span><br><span class="line">		author: &quot;张三&quot;,</span><br><span class="line">		content: &quot;法外狂徒&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	// 成功的回调</span><br><span class="line">	console.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-表单提交添加"><a href="#b-表单提交添加" class="headerlink" title="b).表单提交添加"></a>b).表单提交添加</h4><ul>
<li><p>方法一：定义相同变量来进行数据添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let title = res.detail.value.title;</span><br><span class="line">let author = res.detail.value.author;</span><br><span class="line">let content = res.detail.value.contebbbb//nt;</span><br><span class="line">db.collection(&quot;demolist&quot;).add(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		title: title,</span><br><span class="line">	bb	author: author,</span><br><span class="line">		content: content</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：通过ES6的解构赋值来进行数据添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123;title,author,content&#125; = res.detail.value;</span><br><span class="line">db.collection(&quot;demolist&quot;).add(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		title,</span><br><span class="line">		author,</span><br><span class="line">		content</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>方法三：通过同名对象来进行数据提交（此方法必须保证数据库中对象名和表单中的name属性值相同）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let detailValue = res.detail.value;</span><br><span class="line">db.collection(&quot;demolist&quot;).add(&#123;</span><br><span class="line">	data: detailValue</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-更新"><a href="#4-更新" class="headerlink" title="(4).更新"></a>(4).更新</h3><ul>
<li><p>通过 <code>.update()</code> 来更新：只更新对应数据的某一项（可以使用where进行查询）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).where(&#123;</span><br><span class="line">	author: &quot;Wrysmile&quot;</span><br><span class="line">&#125;).update(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		author: &quot;wrysmile&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>通过 <code>.set()</code> 来更新：直接将对应数据覆盖掉所有内容（不可以使用where进行查询）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;).doc(&quot;b00064a7606af40c0d563c370374ae1f&quot;).set(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		author: &quot;wrysmile&quot;,</span><br><span class="line">		title: &quot;通过set设置的标题&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-删除"><a href="#5-删除" class="headerlink" title="(5).删除"></a>(5).删除</h3><ul>
<li>通过 <code>.remove()</code> 来删除：小程序端只可以删除一条数（不可以使用where进行查询）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.collection(&quot;demolist&quot;)</span><br><span class="line">  .doc(inputValue)</span><br><span class="line">  .remove()</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">		console.log(res);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-command"><a href="#6-command" class="headerlink" title="(6).command"></a>(6).command</h3><ul>
<li>数据库操作符，通过 <code>db.command</code> 获取</li>
</ul>
<h4 id="a-定义"><a href="#a-定义" class="headerlink" title="a).定义"></a>a).定义</h4><ul>
<li>一般在定义数据库的时候就顺便定义command指令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const db = wx.cloud.database();</span><br><span class="line">const _ = db.command;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-逻辑操作符"><a href="#b-逻辑操作符" class="headerlink" title="b).逻辑操作符"></a>b).逻辑操作符</h4><ul>
<li>查询：<ul>
<li><code>.and()</code>：用于表示逻辑 “与” 的关系，表示需同时满足多个查询筛选条件</li>
<li><code>.or()</code>：用于表示逻辑 “或” 的关系，表示需同时满足多个查询筛选条件</li>
<li><code>.not()</code>：用于表示逻辑 “非” 的关系，表示需不满足指定的条件</li>
<li><code>.nor()</code>：用于表示逻辑 “都不” 的关系，表示需不满足指定的所有条件</li>
</ul>
</li>
</ul>
<h4 id="c-比较操作符"><a href="#c-比较操作符" class="headerlink" title="c).比较操作符"></a>c).比较操作符</h4><ul>
<li>查询：<ul>
<li><code>.eq()</code>：表示字段等于某个值，可接收 <code>number</code>, <code>boolean</code>, <code>string</code>, <code>object</code>, <code>array</code>, <code>Date</code></li>
<li><code>.neq()</code>：表示字段不等于某个值，可接收 <code>number</code>, <code>boolean</code>, <code>string</code>, <code>object</code>, <code>array</code>, <code>Date</code></li>
<li><code>.lt/gt()</code>：表示需小于/大于指定值，可以传入 <code>Date</code> 对象用于进行日期比较</li>
<li><code>.lte/gte()</code>：表示需小于/大于或等于指定值，可以传入 <code>Date</code> 对象用于进行日期比较</li>
<li><code>.in/nin()</code>：表示要求值在/不在给定的数组内</li>
</ul>
</li>
</ul>
<h4 id="d-字段操作符"><a href="#d-字段操作符" class="headerlink" title="d).字段操作符"></a>d).字段操作符</h4><ul>
<li>查询：<ul>
<li><code>.exists()</code>：判断字段是否存在</li>
</ul>
</li>
<li>更新：<ul>
<li><code>.set()</code>：用于设定字段等于指定值</li>
<li><code>.remove()</code>：用于表示删除某个字段</li>
<li><code>.inc()/mul()</code>：原子操作，用于指示字段自增/自乘某个值</li>
<li><code>.min()/max()</code>：给定一个值，只有该值小于/大于字段当前值才进行更新</li>
<li><code>.rename()</code>：字段重命名<ul>
<li>如果需要对嵌套深层的字段做重命名，需要用点路径表示法</li>
<li>不能对嵌套在数组里的对象的字段进行重命名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="e-数组操作符"><a href="#e-数组操作符" class="headerlink" title="e).数组操作符"></a>e).数组操作符</h4><ul>
<li>查询：<ul>
<li><code>.all()</code>：用于数组字段的查询筛选条件，要求数组字段中包含给定数组的所有元素</li>
<li><code>.elemMatch()</code>：用于数组字段的查询筛选条件，要求数组中包含至少一个满足 <code>elemMatch</code> 给定的所有条件的元素</li>
<li><code>.size()</code>：用于数组字段的查询筛选条件，要求数组长度为给定值</li>
</ul>
</li>
<li>更新：<ul>
<li><code>.push()</code>：对一个值为数组的字段，往数组添加一个或多个值；若字段原为空，则创建该字段并设数组为传入值</li>
<li><code>.pop()</code>：对一个值为数组的字段，将数组尾部元素删除</li>
<li><code>.unshift()</code>：对一个值为数组的字段，往数组头部添加一个或多个值；若字段原为空，则创建该字段并设数组为传入值</li>
<li><code>.shift()</code>：对一个值为数组的字段，将数组头部元素删除</li>
<li><code>.pull()</code>：给定一个值或一个查询条件，将数组中所有匹配给定值或查询条件的元素都移除掉</li>
<li><code>.pullAll()</code>：给定一个值或一个查询条件，将数组中所有匹配给定值的元素都移除掉。跟 <code>pull</code> 的差别在于只能指定常量值、传入的是数组</li>
<li><code>.addToSet()</code>：原子操作，给定一个或多个元素，除非数组中已存在该元素，否则添加进数组</li>
</ul>
</li>
</ul>
<h2 id="2-云函数"><a href="#2-云函数" class="headerlink" title="2.云函数"></a>2.云函数</h2><ul>
<li>我们一般将调用数据库的操作放在云函数中，实现前后端分离</li>
<li>优势：突破小程序端只能返回20条数据的限制，最大支持100条数据</li>
</ul>
<h3 id="1-云函数调用数据库"><a href="#1-云函数调用数据库" class="headerlink" title="(1).云函数调用数据库"></a>(1).云函数调用数据库</h3><ul>
<li><p>在 <code>cloud.init()</code> 后面定义数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 此时这里就不需要使用wx.了</span><br><span class="line">const db = cloud.database();</span><br></pre></td></tr></table></figure></li>
<li><p>在入口函数中返回数据库的请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 这里使用ES6的promise语法</span><br><span class="line">return await db.collection(&quot;demolist&quot;).get()</span><br></pre></td></tr></table></figure></li>
<li><p>在需要调用数据库的页面的onload中调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">	name: &quot;getData&quot;,</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-前端与云函数传递数据"><a href="#2-前端与云函数传递数据" class="headerlink" title="(2).前端与云函数传递数据"></a>(2).前端与云函数传递数据</h3><ul>
<li><p>前端是在调用云函数方法的 data 属性中传递需要给云函数的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">	name: &quot;getData&quot;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		num: 3</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).then(res =&gt; &#123;</span><br><span class="line">	console.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>云函数则通过 event 来接收前端传送来的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = event.num;</span><br><span class="line">return await db.collection(&quot;demolist&quot;).limit(num).get()</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-修改数据-1"><a href="#3-修改数据-1" class="headerlink" title="(3).修改数据"></a>(3).修改数据</h3><ul>
<li>小程序端只能创建数据的用户修改本条数据</li>
<li>而云函数端拥有最高权限，无论是谁都可以修改别人或者自己的数据</li>
</ul>
<h2 id="3-云存储"><a href="#3-云存储" class="headerlink" title="3.云存储"></a>3.云存储</h2><h3 id="0-选择图片"><a href="#0-选择图片" class="headerlink" title="(0).选择图片"></a>(0).选择图片</h3><ul>
<li>上传文件之前需要用户自行选择本地文件来进行上传</li>
<li>使用 <code>wx.chooseImage()</code> API 来调用系统文件夹或者相册，属性有：<ul>
<li>count：最多可以选择的图片张数</li>
<li>sizeType：所选的图片的尺寸</li>
<li>sourceType：选择图片的来源</li>
<li>success：成功的回调函数</li>
</ul>
</li>
<li>使用该 API 上传图片时会返回一个临时链接，该链接无法在浏览器中打开，只用作上传作用</li>
</ul>
<h3 id="1-上传文件"><a href="#1-上传文件" class="headerlink" title="(1).上传文件"></a>(1).上传文件</h3><h4 id="a-小程序端"><a href="#a-小程序端" class="headerlink" title="a).小程序端"></a>a).小程序端</h4><ul>
<li><code>wx.cloud.uploadFile()</code>：将本地资源上传至云存储空间，如果上传至同一路径则是覆盖写</li>
<li>属性：<ul>
<li>cloudPath：云存储路径</li>
<li>filePath：要上传文件资源的路径</li>
<li>success：成功回调</li>
</ul>
</li>
</ul>
<h4 id="b-云函数端"><a href="#b-云函数端" class="headerlink" title="b).云函数端"></a>b).云函数端</h4><ul>
<li><code>uploadFile()</code>：将本地资源上传至云存储空间，如果上传至同一路径则是覆盖</li>
<li>属性：<ul>
<li>cloudPath：云存储路径</li>
<li>fileContent：要上传文件的内容</li>
</ul>
</li>
</ul>
<h3 id="2-文件下载地址"><a href="#2-文件下载地址" class="headerlink" title="(2).文件下载地址"></a>(2).文件下载地址</h3><ul>
<li>当文件传入云开发存储后，可以点击文件查看相关信息</li>
<li>其中有个下载地址，可以直接预览文件<ul>
<li>如果整条链接都复制，则文件有一定的有效期</li>
<li>如果只复制问好前面的，则文件为永久有效</li>
</ul>
</li>
</ul>
<h2 id="4-问题集合"><a href="#4-问题集合" class="headerlink" title="4.问题集合"></a>4.问题集合</h2><h3 id="1-Environment-not-found"><a href="#1-Environment-not-found" class="headerlink" title="(1).Environment not found"></a>(1).Environment not found</h3><ul>
<li>此问题一般出现在部署云函数时多个云环境共存导致的无法找到当前云环境</li>
<li>解决办法有如下两种：</li>
</ul>
<h4 id="a-云函数中指定当前云环境"><a href="#a-云函数中指定当前云环境" class="headerlink" title="a).云函数中指定当前云环境"></a>a).云函数中指定当前云环境</h4><ul>
<li><p>在云函数中按如下进行当前环境的设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cloud.init(&#123;</span><br><span class="line">	env: &#x27;环境id&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>缺点：当切换云环境时，需要手动将这里的环境id进行更改</p>
</li>
</ul>
<h4 id="b-使用常量动态获取当前云环境（推荐）"><a href="#b-使用常量动态获取当前云环境（推荐）" class="headerlink" title="b).使用常量动态获取当前云环境（推荐）"></a>b).使用常量动态获取当前云环境（推荐）</h4><ul>
<li>使用 <code>DYNAMIC_CURRENT_ENV</code> 常量值时，后续的 API 请求会自动请求当前所在环境的云资源<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cloud.init(&#123;</span><br><span class="line">	env: cloud.DYNAMIC_CURRENT_ENV</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="十、基础案例"><a href="#十、基础案例" class="headerlink" title="十、基础案例"></a>十、基础案例</h1><h2 id="0-页面跳转并携带数据"><a href="#0-页面跳转并携带数据" class="headerlink" title="0.页面跳转并携带数据"></a>0.页面跳转并携带数据</h2><h3 id="1-发送页面"><a href="#1-发送页面" class="headerlink" title="(1).发送页面"></a>(1).发送页面</h3><ul>
<li>在A页面中可以通过 <code>data-xx</code> 来设置需要传递的值</li>
<li>而上面设置的值可以在函数的 <code>res.currentTarget.dataset</code> 中获取到</li>
<li>然后在跳转页面的 API 中将URL以如下形式进行连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">	url: &#x27;/pages/demo-2/demo-2?title=&#x27; + res.currentTarget.dataset.title,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-接收页面"><a href="#2-接收页面" class="headerlink" title="(2).接收页面"></a>(2).接收页面</h3><ul>
<li>在B页面中的 onLoad() 函数中可以通过 <code>options.title</code> 来获取到A页面传送来的数据，然后渲染到页面即可</li>
</ul>
<h2 id="1-用户信息"><a href="#1-用户信息" class="headerlink" title="1.用户信息"></a>1.用户信息</h2><h3 id="1-获取用户信息"><a href="#1-获取用户信息" class="headerlink" title="(1).获取用户信息"></a>(1).获取用户信息</h3><h4 id="1-用户未授权（首次登陆）"><a href="#1-用户未授权（首次登陆）" class="headerlink" title="1).用户未授权（首次登陆）"></a>1).用户未授权（首次登陆）</h4><ul>
<li><p>所有需要调用的数据都需要在 data 中初始化，所以在 data 中添加 <code>userInfo:&#123; &#125;,</code></p>
</li>
<li><p>使用 <code>&lt;button&gt;</code> 组件，该组件有个 <code>open-type</code> 属性可以设置微信开放能力，该属性中的 <code>getUserInfo</code> 可以获取到用户信息，并且可通过 <code>bindgetuserinfo</code> 回调来取得信息，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;handleGetUserInfo&quot;&gt;授权&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>进行 <code>handleGetUserInfo</code> 回调函数的编写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取用户基本信息</span><br><span class="line">handleGetUserInfo(res)&#123;</span><br><span class="line">	if(res.detail.userInfo)&#123;</span><br><span class="line">		// 修改 userInfo的状态数据</span><br><span class="line">		this.setData(&#123;</span><br><span class="line">			userInfo : res.detail.userInfo,</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>首页动态获取用户名和头像，变量需要使用双大括号括住</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;image src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; class=&quot;avatarUrl&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;text class=&quot;userName&quot;&gt;&#123; &#123;userInfo.nickName&#125; &#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-用户已授权（再次登陆）"><a href="#2-用户已授权（再次登陆）" class="headerlink" title="2).用户已授权（再次登陆）"></a>2).用户已授权（再次登陆）</h4><ul>
<li>使用 API 中的开放接口 <code>wx.getUserInfo</code> 来获取用户信息，且应该在页面加载时就获取到，所以需要写在 <code>onload()</code> 中<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">	// 授权以后获取用户的信息</span><br><span class="line">	wx.getUserInfo(&#123;</span><br><span class="line">		// 这里使用箭头函数时 this可以指向当前页面</span><br><span class="line">		success: (res) =&gt; &#123;</span><br><span class="line">			// 更新用户信息</span><br><span class="line">			this.setData(&#123;</span><br><span class="line">				userInfo : res.userInfo,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;,</span><br><span class="line">		fail: (err) =&gt; &#123;</span><br><span class="line">			console.log(err);</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-头像与按钮的隐藏"><a href="#3-头像与按钮的隐藏" class="headerlink" title="3).头像与按钮的隐藏"></a>3).头像与按钮的隐藏</h4><ul>
<li><p>用户名、头像和按钮是互斥关系，所以需要使用条件渲染</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;image wx:if=&quot;&#123; &#123;userInfo.avatarUrl&#125; &#125;&quot; src=&quot;&#123; &#123;userInfo.avatarUrl&#125; &#125;&quot; class=&quot;avatarUrl&quot;&gt;&lt;/image&gt;</span><br><span class="line">&lt;button wx:else open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;handleGetUserInfo&quot;&gt;授权&lt;/button&gt;</span><br><span class="line">&lt;text wx:if=&quot;&#123; &#123;userInfo.nickName&#125; &#125;&quot; class=&quot;userName&quot;&gt;&#123; &#123;userInfo.nickName&#125; &#125;&lt;/text&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改按钮样式，使其占据原本头像位置，当授权后不会显示很突兀</p>
</li>
</ul>
<h3 id="2-获取用户cookie"><a href="#2-获取用户cookie" class="headerlink" title="(2).获取用户cookie"></a>(2).获取用户cookie</h3><ul>
<li>获取cookie需要在用户登录请求时获取，将cookie存储在本地</li>
<li>在发请求时增加 header 字段，并在其中读取本地存储的cookie（为了防止用户未登录时报错，应该使用三元运算符进行判断，cookie为空时将其设置为空串）</li>
</ul>
<h2 id="2-轮播图"><a href="#2-轮播图" class="headerlink" title="2.轮播图"></a>2.轮播图</h2><h3 id="1-放置轮播图容器"><a href="#1-放置轮播图容器" class="headerlink" title="(1).放置轮播图容器"></a>(1).放置轮播图容器</h3><ul>
<li>在小程序中使用 <code>&lt;swiper&gt;</code> 组件来制作轮播图，其中只可放置 <code>&lt;swiper-item&gt;</code> 组件，而文字和图片可以放在 <code>&lt;swiper-item&gt;</code> 组件中</li>
</ul>
<h3 id="2-设置容器样式"><a href="#2-设置容器样式" class="headerlink" title="(2).设置容器样式"></a>(2).设置容器样式</h3><ul>
<li>根据需求设置容器大小，并将图像的长宽设置为父元素的100%</li>
</ul>
<h3 id="3-设置组件属性"><a href="#3-设置组件属性" class="headerlink" title="(3).设置组件属性"></a>(3).设置组件属性</h3><ul>
<li><code>&lt;swiper&gt;</code> 组件有很多属性，如果想要面板指示点的相关设置，直接去开发者文档中找</li>
</ul>
<h2 id="3-文本溢出隐藏"><a href="#3-文本溢出隐藏" class="headerlink" title="3.文本溢出隐藏"></a>3.文本溢出隐藏</h2><ul>
<li>当单行或者多行文本溢出某个容器时，我们一般将溢出部分隐藏起来，并在后面以省略号展示</li>
</ul>
<h3 id="1-单行文本溢出"><a href="#1-单行文本溢出" class="headerlink" title="(1).单行文本溢出"></a>(1).单行文本溢出</h3><ul>
<li>单行文本溢出时的解决办法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 转换为块元素 */</span><br><span class="line">display: block;</span><br><span class="line">/* 规定段落中的文本不进行换行，属性值为文本不会换行，文本会在在同一行上继续，直到遇到 &lt;br&gt; 标签为止 */</span><br><span class="line">white-space: nowrap;</span><br><span class="line">/* 将溢出部分隐藏 */</span><br><span class="line">overflow: hidden;</span><br><span class="line">/* 规定当文本溢出包含元素时发生的事情，属性值为显示省略符号来代表被修剪的文本 */</span><br><span class="line">text-overflow: ellipsis;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-多行文本溢出"><a href="#2-多行文本溢出" class="headerlink" title="(2).多行文本溢出"></a>(2).多行文本溢出</h3><ul>
<li>多行文本溢出时的解决办法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display: -webkit-box;</span><br><span class="line">/* 设置对齐模式 */</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line">/* 设置盒子内容的行数 */</span><br><span class="line">-webkit-line-clamp: 2;</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-前后端交互"><a href="#4-前后端交互" class="headerlink" title="4.前后端交互"></a>4.前后端交互</h2><ul>
<li>使用 API 来进行前后端交互，语法：<code>wx.request()</code></li>
<li>发起请求可以在生命周期函数的 onLoad 和 onReady 中填写</li>
<li>注意点：<ul>
<li>协议必须是 https 协议</li>
<li>一个接口最多配置20个域名</li>
<li>并发限制上限是10个</li>
<li><strong>设置不检验合法域名</strong>：开发工具-详情-本地设置-不检验</li>
</ul>
</li>
<li>调用接口时，可以根据接口的参数在 data 中进行相应的调用，如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">	url: &#x27;http://localhost:3000/banner&#x27;,</span><br><span class="line">	data: &#123;type:2&#125;,</span><br><span class="line">	success: (res) =&gt; &#123;</span><br><span class="line">		console.log(res);</span><br><span class="line">	&#125;,</span><br><span class="line">	fail: (err) =&gt; &#123;</span><br><span class="line">		console.log(err);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-登录界面逻辑"><a href="#5-登录界面逻辑" class="headerlink" title="5.登录界面逻辑"></a>5.登录界面逻辑</h2><h3 id="1-收集表单项数据-1"><a href="#1-收集表单项数据-1" class="headerlink" title="(1).收集表单项数据"></a>(1).收集表单项数据</h3><ul>
<li>给元素绑定 bindinput 事件</li>
<li>这里可以给不同输入框绑定相同事件名，然后用id或者data-来区分，详见<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html">这里</a></li>
<li>在js中初始化数据</li>
<li>在事件回调中更新数据<ul>
<li>若使用id，则使用 <code>event.currentTarget.id</code> 来获取不同输入框</li>
<li>若使用data-，则使用 <code>event.currentTarget.dataset.type</code> 来获取不同输入框</li>
</ul>
</li>
</ul>
<h3 id="2-前端验证实现"><a href="#2-前端验证实现" class="headerlink" title="(2).前端验证实现"></a>(2).前端验证实现</h3><ul>
<li>首先需要从表单项中获取到数据，即 <code>let &#123;phone,password&#125; = this.data;</code></li>
<li>然后进行前端验证，是否账号为空，是否账号合法等</li>
<li>验证完以后使用 <code>wx.showToast</code> API 来进行提示用户</li>
</ul>
<h3 id="3-后端验证实现"><a href="#3-后端验证实现" class="headerlink" title="(3).后端验证实现"></a>(3).后端验证实现</h3><ul>
<li>首先需要发送请求给后端，并将账号密码作为参数传给后端</li>
<li>根据不同的返回值判断登录情况（账号错误、密码错误、账号不存在、登录成功）</li>
</ul>
<h3 id="4-个人中心与登录界面交互"><a href="#4-个人中心与登录界面交互" class="headerlink" title="(4).个人中心与登录界面交互"></a>(4).个人中心与登录界面交互</h3><h4 id="1-跳转到登录界面"><a href="#1-跳转到登录界面" class="headerlink" title="1).跳转到登录界面"></a>1).跳转到登录界面</h4><ul>
<li>我们需要给头像与用户名区域绑定单击事件</li>
<li>通过单击事件的回调函数跳转到登录界面</li>
</ul>
<h4 id="2-本地存储用户数据"><a href="#2-本地存储用户数据" class="headerlink" title="2).本地存储用户数据"></a>2).本地存储用户数据</h4><ul>
<li>在登录界面的后端验证中，如果手机与密码正确，则需要将我们获取到的用户信息存储在本地</li>
<li>使用 wx.setStorageSync() 来存储数据，建议这里使用 <code>JSON.stringify()</code> 转换为JSON对象</li>
<li>跳转到个人中心页面，这里为了让个人中心页面一进入就获取信息，使用 wx.reLaunch() 跳转，即关闭之前所有页面，跳转到目标页面</li>
</ul>
<h4 id="3-本地读取用户数据"><a href="#3-本地读取用户数据" class="headerlink" title="3).本地读取用户数据"></a>3).本地读取用户数据</h4><ul>
<li>在个人中心页面的 onLoad() 中使用 wx.getStorageSync() 来获取数据</li>
<li>进行判断，如果用户数据不为空，则更新用户数据并将用户数据更新到 data 中去，同时使用 <code>JSON.parse()</code> 将JSON对象转换为js对象</li>
</ul>
<h4 id="4-修改页面结构"><a href="#4-修改页面结构" class="headerlink" title="4).修改页面结构"></a>4).修改页面结构</h4><ul>
<li>此时页面结构中的头像和用户名需要动态更新，这里可以使用三目运算符<ul>
<li>存在用户数据，将用户数据更新到页面上</li>
<li>不存在用户数据，则显示默认内容</li>
</ul>
</li>
<li>代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;image src=&quot;&#123; &#123;userInfo.avatarUrl?userInfo.avatarUrl:&#x27;/static/images/personal/missing-face.png&#x27;&#125; &#125;&quot;&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-视频播放"><a href="#6-视频播放" class="headerlink" title="6.视频播放"></a>6.视频播放</h2><h3 id="1-多个视频同时播放"><a href="#1-多个视频同时播放" class="headerlink" title="(1).多个视频同时播放"></a>(1).多个视频同时播放</h3><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1).需求"></a>1).需求</h4><ul>
<li>在点击播放的事件中需要找到上一个播放的视频</li>
<li>在播放新的视频之前关闭上一个正在播放的视频</li>
</ul>
<h4 id="2-关键"><a href="#2-关键" class="headerlink" title="2).关键"></a>2).关键</h4><ul>
<li>如何找到上一个视频的实例对象</li>
<li>如何确认点击播放的视频和正在播放的视频不是同一个视频</li>
</ul>
<h4 id="3-方案"><a href="#3-方案" class="headerlink" title="3).方案"></a>3).方案</h4><ul>
<li><p>将相关参数添加到 this 中来进行判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handlePlay(event)&#123;</span><br><span class="line">	let vid = event.currentTarget.id;</span><br><span class="line">	/*</span><br><span class="line">	 * 当第一次点击时，没有videoContext所以不执行关闭操作，且将当前的vid和videoContext赋给this</span><br><span class="line">	 * 当第二次点击时，判断当前vid是否与this中相等，相等不执行关闭操作；不相等说明不是同一个视频，此时执行关闭操作</span><br><span class="line">	 */</span><br><span class="line">	this.vid !== vid &amp;&amp; this.videoContext &amp;&amp; this.videoContext.stop();</span><br><span class="line">	this.vid = vid;</span><br><span class="line">	// 创建控制video标签的实例对象</span><br><span class="line">	this.videoContext = wx.createVideoContext(vid);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>以上方案使用了 <strong>单例模式</strong> ，即需要创建多个对象的场景下，通过一个变量接收，始终保持只有一个对象，可以节省内存空间</p>
</li>
</ul>
<h4 id="4-终极方案"><a href="#4-终极方案" class="headerlink" title="4).终极方案"></a>4).终极方案</h4><ul>
<li>通过 <code>&lt;image&gt;</code> 代替 <code>&lt;video&gt;</code> 来进行性能优化同时解决多个视频同时播放</li>
<li>在 <code>&lt;video&gt;</code> 标签中通过poster属性获取到当前视频的封面图地址</li>
<li>在 <code>&lt;image&gt;</code> 标签中的地址就使用上面获取到的封面图地址，并绑定和video一样的点击事件与样式和id属性</li>
<li>在相应的点击回调函数中更新data中的视频id数据</li>
<li>在 <code>&lt;video&gt;</code> 中使用wx:if来判断视频id是否和当前项目的id一致，一致显示视频，不一致显示图片<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 点击播放、继续播放的回调</span><br><span class="line">handlePlay(event)&#123;</span><br><span class="line">	let vid = event.currentTarget.id;</span><br><span class="line">	// 更新data中videoId的状态数据</span><br><span class="line">	this.setData(&#123;</span><br><span class="line">		videoId: vid</span><br><span class="line">	&#125;)</span><br><span class="line">	// 创建控制video标签的实例对象</span><br><span class="line">	this.videoContext = wx.createVideoContext(vid);</span><br><span class="line">	// 当点击图片时，自动播放视频</span><br><span class="line">	this.videoContext.play();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-音乐播放"><a href="#7-音乐播放" class="headerlink" title="7.音乐播放"></a>7.音乐播放</h2><h3 id="1-音乐播放时系统栏的控制"><a href="#1-音乐播放时系统栏的控制" class="headerlink" title="(1).音乐播放时系统栏的控制"></a>(1).音乐播放时系统栏的控制</h3><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1).问题"></a>1).问题</h4><ul>
<li>当用户在操作系统的控制音乐播放/暂停的按钮时，页面并不知道播放状态而导致页面播放状态与真实播放状态不一致</li>
</ul>
<h4 id="2-方案"><a href="#2-方案" class="headerlink" title="2).方案"></a>2).方案</h4><ul>
<li>我们需要在页面刚加载时监听音乐的播放/暂停/停止状态</li>
<li>当监听到某种状态时就执行回调函数中的内容</li>
<li>BackgroundAudioManager 实例，可通过 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/media/background-audio/wx.getBackgroundAudioManager.html">wx.getBackgroundAudioManager</a> 获取<ul>
<li>BackgroundAudioManager.onPlay(function callback)监听背景音频播放事件</li>
<li>BackgroundAudioManager.onPause(function callback)监听背景音频暂停事件</li>
<li>BackgroundAudioManager.onStop(function callback)监听背景音频停止事件</li>
</ul>
</li>
</ul>
<h3 id="2-页面销毁时音乐的播放状态"><a href="#2-页面销毁时音乐的播放状态" class="headerlink" title="(2).页面销毁时音乐的播放状态"></a>(2).页面销毁时音乐的播放状态</h3><h4 id="1-问题-1"><a href="#1-问题-1" class="headerlink" title="1).问题"></a>1).问题</h4><ul>
<li>当从音乐播放页面返回时，再打开该首歌时，音乐的播放状态与页面显示并不相同</li>
</ul>
<h4 id="2-关键-1"><a href="#2-关键-1" class="headerlink" title="2).关键"></a>2).关键</h4><ul>
<li>使用 globalData 来存放音乐的播放状态</li>
<li>使用 getApp 获取到小程序全局唯一的 <code>App</code> 实例</li>
</ul>
<h4 id="3-方案-1"><a href="#3-方案-1" class="headerlink" title="3).方案"></a>3).方案</h4><ul>
<li><p>先在 app.js 页面中定义相应的全局数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">globalData: &#123;</span><br><span class="line">	isMusicPlay: false, // 某个音乐的播放状态</span><br><span class="line">	musicId: &#x27;&#x27;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li>
<li><p>在当前页面的 js 中获取全局数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 获取全局实例</span><br><span class="line">const appInstance = getApp();</span><br></pre></td></tr></table></figure></li>
<li><p>在监听音乐播放/暂停/停止的回调中修改全局音乐播放的状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改全局音乐播放的状态</span><br><span class="line">appInstance.globalData.isMusicPlay = isPlay;</span><br><span class="line">appInstance.globalData.musicId = musicId;</span><br></pre></td></tr></table></figure></li>
<li><p>最后在页面加载刚开始判断全局数据中是否有播放状态，如果有则修改当前音乐的播放状态为播放</p>
</li>
</ul>
<h3 id="3-歌曲播放性能优化"><a href="#3-歌曲播放性能优化" class="headerlink" title="(3).歌曲播放性能优化"></a>(3).歌曲播放性能优化</h3><ul>
<li>当我们在播放/暂停歌曲时，如果代码编写不当，会重复发送多次请求，这样会很消耗我们的性能</li>
<li>所以我们应该在获取音乐链接时进行判断，如果音乐链接为空我们就发请求，如果不为空我们就不发送请求</li>
</ul>
<h2 id="8-历史搜索"><a href="#8-历史搜索" class="headerlink" title="8.历史搜索"></a>8.历史搜索</h2><h3 id="1-保存历史搜索记录"><a href="#1-保存历史搜索记录" class="headerlink" title="(1).保存历史搜索记录"></a>(1).保存历史搜索记录</h3><ul>
<li>获取用户的搜索数据并更新到 data 中</li>
<li>将搜索的关键字添加到搜索历史记录中（如果历史记录中没有该字段，则直接添加；如果有，将该字段放在第一位）</li>
<li>将历史记录的相关内容存放在本地，然后将获取本地历史封装为一个函数，如果本地历史有值则将其更新到 data 中</li>
<li>在生命周期函数中的 onLoad() 中调用之前的函数</li>
</ul>
<h3 id="2-清除当前搜索框中的内容"><a href="#2-清除当前搜索框中的内容" class="headerlink" title="(2).清除当前搜索框中的内容"></a>(2).清除当前搜索框中的内容</h3><ul>
<li>给相应的组件绑定单击响应事件</li>
<li>将<strong>用户输入的表单项数据</strong>和<strong>关键字模糊匹配的数据</strong>都置为空并更新到 data 中（可以给input组件添加 value 值，将<strong>用户输入的表单项数据</strong>绑定到该 value 值中即可同时清空）</li>
</ul>
<h3 id="3-删除历史搜索记录"><a href="#3-删除历史搜索记录" class="headerlink" title="(3).删除历史搜索记录"></a>(3).删除历史搜索记录</h3><ul>
<li>使用 wx.showModal() 来提示用户是否进行删除</li>
<li>在 success 的回调中可以通过 res.confirm 来判断用户是否点击了确认</li>
<li>当用户点击确认时，清空 data 中 historyList 并且移除本地的历史记录缓存</li>
</ul>
<h3 id="4-动态显示历史栏与清除按钮"><a href="#4-动态显示历史栏与清除按钮" class="headerlink" title="(4).动态显示历史栏与清除按钮"></a>(4).动态显示历史栏与清除按钮</h3><ul>
<li>使用条件渲染，当 historyList 的长度存在时就显示，否则不显示</li>
<li>使用 <code>hidden=&quot;&quot;</code> 属性来动态显示或隐藏清除按钮</li>
</ul>
<h1 id="十一、云开发案例"><a href="#十一、云开发案例" class="headerlink" title="十一、云开发案例"></a>十一、云开发案例</h1><h2 id="1-点击数据增加阅读量"><a href="#1-点击数据增加阅读量" class="headerlink" title="1.点击数据增加阅读量"></a>1.点击数据增加阅读量</h2><h3 id="1-获取点击的id和index"><a href="#1-获取点击的id和index" class="headerlink" title="(1).获取点击的id和index"></a>(1).获取点击的id和index</h3><ul>
<li>将获取到的id和index传给云函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123;id,index&#125; = res.currentTarget.dataset;</span><br><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">	name: &quot;updateData&quot;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		id: id,</span><br><span class="line">		index: index</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-云函数进行更新操作"><a href="#2-云函数进行更新操作" class="headerlink" title="(2).云函数进行更新操作"></a>(2).云函数进行更新操作</h3><ul>
<li>创建一个专门用来更新的云函数</li>
<li>在云函数中通过id获取到当前点击元素的阅读量并进行自增更新操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let id = event.id;</span><br><span class="line">return await db.collection(&quot;demolist&quot;).doc(id).update(&#123;</span><br><span class="line">	data: &#123;</span><br><span class="line">		hits: _.inc(1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-前后端交互"><a href="#3-前后端交互" class="headerlink" title="(3).前后端交互"></a>(3).前后端交互</h3><ul>
<li><p>前端在接收返回值的成功回调中执行获取数据的云函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">	name: &quot;getData&quot;,</span><br><span class="line">	data: &#123;</span><br><span class="line">		id: id</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>这里获取数据的云函数可以通过判断传来的值来执行不同的返回语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num = event.num;</span><br><span class="line">let page = event.page;</span><br><span class="line">let id = event.id;</span><br><span class="line">if(event.id)&#123;</span><br><span class="line">	return await db.collection(&quot;demolist&quot;).doc(id).get()</span><br><span class="line">&#125;</span><br><span class="line">if(event.num || event.page)&#123;</span><br><span class="line">	return await db.collection(&quot;demolist&quot;).skip(page).limit(num).get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-重新渲染列表数据"><a href="#4-重新渲染列表数据" class="headerlink" title="(4).重新渲染列表数据"></a>(4).重新渲染列表数据</h3><ul>
<li>因为我们只是更新了data中数组的一项数据，所以只需要更新该条数据就可以，无需更新整个数组</li>
<li>只要定义一个新的变量使用拼串的方法获取到当前数组中的某个值</li>
<li>最后使用ES6语法即可实现重新渲染指定列表数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let newHits = &quot;listData[&quot;+index+&quot;].hits&quot;;</span><br><span class="line">this.setData(&#123;</span><br><span class="line">	[newHits]: res.result.data.hits</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客之高级优化教程</title>
    <url>/Hexo-03.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>在看本篇之前，请确保你已成功搭建好个人博客且进行了 NexT 主题的相应配置，如没有，请移步：<a href="/Hexo-01.html" title="[博客搭建教程]">[博客搭建教程]</a> 与 <a href="/Hexo-02.html" title="[NexT 配置教程]">[NexT 配置教程]</a></li>
<li>事实上，使用过一段时间 Hexo 后就会发现存在很多问题，真正在打开博客时加载速度相对较慢；每一篇文章链接都显得过长；搜索引擎检索不到博客······</li>
<li>该教程主要是针对我们博客的一些 SEO 上的优化，当然，对于 SEO 优化我也只是处于入门级别而已<span id="more"></span></li>
</ul>
<h1 id="一、关于SEO"><a href="#一、关于SEO" class="headerlink" title="一、关于SEO"></a>一、关于SEO</h1><ul>
<li><p>概念：</p>
<blockquote>
<p>SEO（Search Engine Optimization）：汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。很大程度上是网站经营者的一种商业行为，将自己或自己公司的排名前移。   ——源自《百度百科》</p>
</blockquote>
</li>
<li><p>简单来说就是通过对网站的优化，来提高网站在搜索引擎的排名，从而增加更多的访问量</p>
</li>
<li><p>而搜索引擎的工作过程大致可以分为下面三个阶段（具体基本原理这里不去阐述）：<br>1.爬行和抓取：搜索引擎通过跟踪链接访问网页、获得页面 HTML 代码并存入数据库<br>2.预处理：索引程序对抓取来的页面数据进行文字提取、中文分词、索引等处理，以备排名程序调用<br>3.排名：用户输入关键词后，排名程序调用索引数据库，计算相关性，然后按照一个的格式生成搜索结果页面</p>
</li>
<li><p>SEO 优化可以分为站内优化和站外优化，而站内优化又分为：<strong>网站结构优化</strong> 和 <strong>网站页面优化</strong>，下面的优化内容主要就是针对站内优化的</p>
</li>
<li><p>具体的内容比较繁多，我这里就单单是针对掘金里的 <a href="https://juejin.im/post/5ae7fafbf265da0b7e0c0dc0#heading-11">这篇博文</a> 所讲解到的内容进行了相关的优化与整理</p>
</li>
</ul>
<h1 id="二、网站结构优化"><a href="#二、网站结构优化" class="headerlink" title="二、网站结构优化"></a>二、网站结构优化</h1><h2 id="1-网站地图"><a href="#1-网站地图" class="headerlink" title="1.网站地图"></a>1.网站地图</h2><blockquote>
<p>无论站点的多少，网站地图都是需要的，网站地图有 HTML 和 XML 两种版本。 HTML 版本的网站地图就是一个页面列出网站的结构；而 XML 版本则是通过在根目录添加 <code>sitemap.xml</code> 文件</p>
</blockquote>
<ul>
<li><p>首先给你的文章生成 <code>sitemap</code> 文件，在 <code>Git Bash</code> 界面执行如下代码（后面的注释无需填写）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save		    #sitemap.xml适合提交给谷歌搜素引擎</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save		#baidusitemap.xml适合提交百度搜索引擎</span><br></pre></td></tr></table></figure></li>
<li><p>然后在 <font color=#1E90FF><em>站点配置文件</em></font> 中添加以下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自动生成sitemap</span><br><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">path: baidusitemap.xml</span><br></pre></td></tr></table></figure></li>
<li><p>修改 <font color=#1E90FF><em>站点配置文件</em></font> 中的 url</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: http://你的网站</span><br></pre></td></tr></table></figure></li>
<li><p>这样在每次执行 <code>hexo g</code> 命令后都会在 <strong>/public</strong> 目录下生成 <code>sitemap.xml</code> 和 <code>baidusitemap.xml</code>，这就是你的网站地图</p>
</li>
</ul>
<h2 id="2-链接结构"><a href="#2-链接结构" class="headerlink" title="2.链接结构"></a>2.链接结构</h2><ul>
<li>SEO 认为，网站的最佳结构是用户从首页 <strong>点击三次</strong> 就可以到达任何一个页面，很显然，我们使用 hexo 编译的站点打开文章的 url 是：<code>sitename/year/mounth/day/title</code> 四层的结构，这样的 url 结构很不利于 SEO，爬虫就会经常爬不到我们的文章</li>
<li>所以，我们需要对 url 的形式进行优化，将 url 修改为 <code>domain/postname</code> 的形式，修改 <font color=#1E90FF><em>站点配置文件</em></font> 中的 <code>permalink</code>：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: :title.html</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></li>
<li>这样就可以优化每篇文章的 url 了</li>
<li><font color=#F00>实际上：虽然我对 url 进行了相关优化，但可以从下方的图片看出，中文类型的标题还是会被解析为数字乱码（英文并不影响，但我们不可能只采用英文标题），这样给别人的观感并不好，尤其是你想要分享某一篇文章时，别人甚至会以为你这个链接并不怎么安全，所以我采用下面的这种方法来优化我的 url</font><br><img src="https://i.loli.net/2020/03/28/Yy9Vjcd5I1LSela.png" alt="高级优化01.png"></li>
</ul>
<h2 id="3-链接唯一且永久化"><a href="#3-链接唯一且永久化" class="headerlink" title="3.链接唯一且永久化"></a>3.链接唯一且永久化</h2><ul>
<li>很多人并不喜欢上面数字乱码，那么你可以使用下面的插件来使自己的 URL 唯一且永久化</li>
</ul>
<h3 id="1-安装插件"><a href="#1-安装插件" class="headerlink" title="(1).安装插件"></a>(1).安装插件</h3><ul>
<li>安装 <a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="(2).修改配置"></a>(2).修改配置</h3><ul>
<li><p>在 <font color=#1E90FF><em>站点配置文件</em></font> 中添加如下代码，并修改 <code>permalink</code> 的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">permalink: :abbrlink.html</span><br><span class="line">#abbrlink配置</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class="line">  rep: dec    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure></li>
<li><p>关于属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alg -- Algorithm (currently support crc16 and crc32, which crc16 is default)</span><br><span class="line">rep -- Represent (the generated link could be presented in hex or dec value)</span><br></pre></td></tr></table></figure></li>
<li><p>关于属性值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crc16 &amp; hex:</span><br><span class="line">http://www.wrysmile.cn/66c8.html</span><br><span class="line">crc16 &amp; dec:</span><br><span class="line">http://www.wrysmile.cn/65535.html</span><br><span class="line">crc32 &amp; hex:</span><br><span class="line">http://www.wrysmile.cn/8ddf18fb.html</span><br><span class="line">crc32 &amp; dec:</span><br><span class="line">http://www.wrysmile.cn/1690090958.html</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-修改-Front-matter"><a href="#3-修改-Front-matter" class="headerlink" title="(3).修改 Front-matter"></a>(3).修改 Front-matter</h3><ul>
<li>将 <code>abbrlink: xxx</code> 永久固定在 <code>Front-matter</code> 中，在 <code>hexo/scaffolds/</code> 路径中找到 <code>post.md</code> 文档，在其中添加如下一行即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">abbrlink: </span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">description:</span><br></pre></td></tr></table></figure></li>
<li>如果不在每篇文章的 <code>Front-matter</code> 中指定 <code>abbrlink: xxx</code> 的值，那么就会根据算法随机生成数字；如果你指定了值的话，就会以指定内容显示</li>
<li>当重新执行 <code>hexo clean &amp;&amp; hexo g</code> 命令时，该插件就会自动为没有设置 abbrlink 值的文章生成相应的编号，这样编号不变，该文章的 url 就不变，可以随意修改文件名，文章标题</li>
</ul>
<h3 id="4-显示效果"><a href="#4-显示效果" class="headerlink" title="(4).显示效果"></a>(4).显示效果</h3><ul>
<li>以下展示了两种状态：添加了 <code>abbrlink: Hexo&#39;s-03</code> 属性值；只添加了 <code>abbrlink: </code> 而没有添加属性值<br><img src="https://i.loli.net/2020/03/28/yKqjekUI7bpdVli.png" alt="高级优化02.png"></li>
</ul>
<h2 id="4-nofollow-标签"><a href="#4-nofollow-标签" class="headerlink" title="4.nofollow 标签"></a>4.nofollow 标签</h2><ul>
<li><p>nofollow 标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，nofollow 是 a 标签的一个属性值</p>
</li>
<li><p><font color=#F00>引用 nofollow 标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有 nofollow 属性的任何出站链接，以减少垃圾链接的分散网站权重</font></p>
</li>
<li><p>以 Hexo 的 NexT 主题为例，需要修改两处：</p>
</li>
<li><p>找到 <code>hexo/themes/next/layout/_partials/footer.swig</code> 文件，按下面修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一处：</span><br><span class="line">&#123;&#123; __(&#x27;footer.powered&#x27;, &#x27;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot;&gt;Hexo&lt;/a&gt;&#x27;) &#125;&#125;</span><br><span class="line">改成</span><br><span class="line">&#123;&#123; __(&#x27;footer.powered&#x27;, &#x27;&lt;a class=&quot;theme-link&quot; href=&quot;http://hexo.io&quot; rel=&quot;external nofollow&quot;&gt;Hexo&lt;/a&gt;&#x27;) &#125;&#125;</span><br><span class="line">第二处：</span><br><span class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;</span><br><span class="line">改成</span><br><span class="line">&lt;a class=&quot;theme-link&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot; rel=&quot;external nofollow&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>找到 <code>hexo/themes/next/layout/_macro/sidebar.swig</code> 文件，按下面修改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一处：</span><br><span class="line">&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt;</span><br><span class="line">改成</span><br><span class="line">&lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/a&gt;</span><br><span class="line">第二处：</span><br><span class="line">&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">改成</span><br><span class="line">&lt;a href=&quot;http://creativecommons.org/licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&quot; class=&quot;cc-opacity&quot; target=&quot;_blank&quot; rel=&quot;external nofollow&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>安装 nofollow 插件，可以自动为出站链接添加 nofollow 标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-autonofollow --save</span><br></pre></td></tr></table></figure></li>
<li><p>该插件会将博客中的出站链接自动加上 nofollow 标签，例外请在 <font color=#1E90FF><em>站点配置文件</em></font> 中添加如下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 出站链接添加 nofollow 标签</span><br><span class="line">nofollow:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - www.abc.com</span><br><span class="line">    - 友链地址</span><br></pre></td></tr></table></figure></li>
<li><p>这样，例外的链接将不会被加上 nofollow 标签</p>
</li>
</ul>
<h2 id="5-蜘蛛协议"><a href="#5-蜘蛛协议" class="headerlink" title="5.蜘蛛协议"></a>5.蜘蛛协议</h2><h3 id="1-内容"><a href="#1-内容" class="headerlink" title="(1).内容"></a>(1).内容</h3><ul>
<li>搜索引擎用来爬行和抓取页面的程序也就是我们熟知的蜘蛛（spider），也称为机器人（bot）。spider 访问网站页面类似于普通用户使用的浏览器。spider 发出页面访问请求后，服务器返回 HTML 代码，spider 把收到的程序存入原始页面数据库。为了提高爬行和抓取速度，搜索引擎通常或多个 spider 并行爬行</li>
<li>spider 访问任何一个网站时，都会先访问该网站根目录下的 rotbots.txt 文件。该文件可以告诉 spider 哪些文件或目录可以抓取或者禁止抓取</li>
<li>根据以上内容，我们可以通过设置 rotbots.txt 文件来进行相应设置</li>
</ul>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="(2).方法"></a>(2).方法</h3><ul>
<li><p>在 <code>hexo/source</code> 文件夹下新建 <code>robots.txt</code> 文件，文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/</span><br><span class="line">Allow: /categories/</span><br><span class="line">Allow: /tags/ </span><br><span class="line">Allow: /resources/ </span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"># 下面中间部分写你自己的域名</span><br><span class="line">Sitemap: https://你的域名/sitemap.xml</span><br><span class="line">Sitemap: https://你的域名/baidusitemap.xml</span><br></pre></td></tr></table></figure></li>
<li><p><code>Allow</code> 字段的值即为允许搜索引擎爬区的内容<br><code>Disallow</code> 字段的值为不允许搜索引擎爬区的内容<br><code>Sitemap</code> 字段的值就是网站地图，专门给爬虫用的</p>
</li>
<li><p>对于允许不允许的值，可以对应到主题配置文件中的 menu 目录配置，如果菜单栏还有其他选项都可以按照格式自行添加</p>
</li>
</ul>
<h1 id="三、网站页面优化"><a href="#三、网站页面优化" class="headerlink" title="三、网站页面优化"></a>三、网站页面优化</h1><h2 id="1-首页标题优化"><a href="#1-首页标题优化" class="headerlink" title="1.首页标题优化"></a>1.首页标题优化</h2><ul>
<li><p>SEO 中最重要的就是标题，一般搜索都是搜索标题的</p>
</li>
<li><p>在 <code>hexo/themes/next/layout/</code> 路径中找到 <code>index.swig</code> 文件，找到如下一段代码（这里代码有两种，至于为什么，我感觉应该是 NexT 版本不同的问题，所以这里将两个全都列出来了）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125;</span><br><span class="line">或者</span><br><span class="line">&#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后对应按下边修改即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;</span><br><span class="line">或者</span><br><span class="line">&#123;% block title %&#125;&#123;&#123; config.title &#125;&#125;&#123;% if theme.index_with_subtitle and config.subtitle %&#125; - &#123;&#123;config.subtitle &#125;&#125;&#123;% endif %&#125;&#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这时候你的首页会更符合网站名称 - 网站描述这习惯</p>
</li>
</ul>
<h3 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a><font color=#F00>进阶操作</font></h3><ul>
<li><p>做了 SEO 优化，也可以把关键词显示在 title 标题里，只要在上面代码的前两句中间加入以下内容即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block title %&#125;&#123;&#123; theme.keywords &#125;&#125; -&#123;&#123; config.title &#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color=#F00>注意：别堆砌关键字，整个标题一般不超过80个字符，可以通过 chinaz 的 SEO 综合查询检查</font></p>
</li>
</ul>
<h2 id="2-页面标题优化"><a href="#2-页面标题优化" class="headerlink" title="2.页面标题优化"></a>2.页面标题优化</h2><ul>
<li></li>
</ul>
<h2 id="3-关键词与描述优化"><a href="#3-关键词与描述优化" class="headerlink" title="3.关键词与描述优化"></a>3.关键词与描述优化</h2><ul>
<li><p>搜索引擎除了主要抓取标题外，页面的关键词和描述也会被抓取</p>
</li>
<li><p>在 <code>hexo/scaffolds/post.md</code> 中添加如下代码，用于生成的文章中添加关键字和描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">keywords: </span><br><span class="line">description: </span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>/themes/next/layout/_partials/head.swig</code> 中有如下代码，用于生成文章的 keywords。暂时还没找到生成 description 的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if page.keywords %&#125;</span><br><span class="line">  &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; page.keywords &#125;&#125;&quot; /&gt;</span><br><span class="line">&#123;% elif page.tags and page.tags.length %&#125;</span><br><span class="line">  &lt;meta name=&quot;keywords&quot; content=&quot;&#123;% for tag in page.tags %&#125;&#123;&#123; tag.name &#125;&#125;,&#123;% endfor %&#125;&quot; /&gt;</span><br><span class="line">&#123;% elif theme.keywords %&#125;</span><br><span class="line">  &lt;meta name=&quot;keywords&quot; content=&quot;&#123;&#123; theme.keywords &#125;&#125;&quot; /&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这时就需要对 description 进行相关优化了，我在前面主题配置章节说过，通过 description 来开启 <strong>阅读全文</strong> 的选项，因为这个是默认的。<font color=#F00>如果你想要将描述直接默认为首页内容，那么就无需进行下方改动，如果还是想要通过 <strong>文章截断</strong> 的方法，那么请跟着我往下做：</font></p>
</li>
<li><p>在 <code>/themes/next/layout/_macro/post.swig</code> 中找到下面这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if post.description and theme.excerpt_description %&#125;</span><br><span class="line">          &#123;&#123; post.description &#125;&#125;</span><br><span class="line">          &lt;!--noindex--&gt;</span><br><span class="line">          &lt;div class=&quot;post-button text-center&quot;&gt;</span><br><span class="line">            &lt;a class=&quot;btn&quot; href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot;&gt;</span><br><span class="line">              &#123;&#123; __(&#x27;post.read_more&#x27;) &#125;&#125; &amp;raquo;</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">          &lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>按照我下图的方法进行修改：<br><img src="https://i.loli.net/2020/03/28/4sjPYRDtTH68MdX.png" alt="高级优化03.png"></p>
</li>
<li><p>修改后如图:<br><img src="https://i.loli.net/2020/03/28/jKERP6vhwaz3L8G.png" alt="高级优化04.png"></p>
</li>
<li><p>最后在文章中进行编写即可，例如我的如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Hexo博客之高级优化教程</span><br><span class="line">date: 2020-03-22 10:51:09</span><br><span class="line">abbrlink: Hexo-03</span><br><span class="line">tags: [博客,Hexo]</span><br><span class="line">categories: 博客搭建</span><br><span class="line">keywords: [博客,Hexo]</span><br><span class="line">description: 总结一下使用 Hexo 搭建博客后，SEO 优化方案的总结，后期会不定期更新。</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、Hexo相关优化"><a href="#四、Hexo相关优化" class="headerlink" title="四、Hexo相关优化"></a>四、Hexo相关优化</h1><h2 id="1-NexT主题的SEO优化"><a href="#1-NexT主题的SEO优化" class="headerlink" title="1.NexT主题的SEO优化"></a>1.NexT主题的SEO优化</h2><ul>
<li>Hexo 博客的 NexT 提供了 SEO 优化选项</li>
<li>在 <font color=#9932CC><em>主题配置文件</em></font> 中找到 seo，其值默认是 false，改成 true 即可开启 SEO 优化，会进行一些 SEO 优化，如改变博文 title 等</li>
<li>在 <font color=#9932CC><em>主题配置文件</em></font> 中有个关键字选项 keywords，将其改成你的网址关键词，如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Set default keywords (Use a comma to separate)</span><br><span class="line">keywords: &quot;Wrysmile&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-压缩文件"><a href="#2-压缩文件" class="headerlink" title="2.压缩文件"></a>2.压缩文件</h2><ul>
<li>因为 Hexo 生成的文件是静态 html，里面占用了大量的空白符，而且由于 .md 文档转 html 文档，你可以发现在每篇文章的源码中留有大量的空白，这样的后果就是博客首页加载慢，反应时间长，非常不利于体验，所以我们需要对 html、js、image 等进行相应的压缩</li>
<li>网上给出的方法有下面两个，本来大部分网站主推第二种方法的，但我在实际使用后发现<font color=#F00>第二种方法并不能把文章页面的 html 源码进行压缩，换言之，就是在 md 转 html 时依然并不完美，而且实际压缩率并不太好，</font>所以我现在主推方法一<br><img src="https://i.loli.net/2020/03/30/vZsWDcxBlXtmq3T.png" alt="高级优化05.png"></li>
</ul>
<h3 id="1-使用hexo-neat插件"><a href="#1-使用hexo-neat插件" class="headerlink" title="(1).使用hexo-neat插件"></a>(1).使用hexo-neat插件</h3><h4 id="a-插件介绍"><a href="#a-插件介绍" class="headerlink" title="a.插件介绍"></a>a.插件介绍</h4><ul>
<li>该方法操作比较方便，省去了一些繁琐的步骤，压缩率大，更推荐使用</li>
<li>这个插件是由 rozbo 大佬开发的 <code>hexo-neat</code> 压缩插件，配置简单，无需额外命令，你只要使用原本的调试三连或者部署三连就可以自动帮你完成静态资源的压缩</li>
</ul>
<h4 id="b-准备环境"><a href="#b-准备环境" class="headerlink" title="b.准备环境"></a>b.准备环境</h4><ul>
<li>在你的 Hexo 根目录中打开 <code>Git Bash</code> 安装插件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-添加配置文件"><a href="#c-添加配置文件" class="headerlink" title="c.添加配置文件"></a>c.添加配置文件</h4><ul>
<li><p>在 <font color=#1E90FF><em>站点配置文件</em></font> 中添加以下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件压缩，设置一些需要跳过的文件 </span><br><span class="line"># hexo-neat</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩 html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩 css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/*.min.css&#x27;</span><br><span class="line"># 压缩 js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/*.min.js&#x27;</span><br><span class="line">    - &#x27;**/jquery.fancybox.pack.js&#x27;</span><br><span class="line">    - &#x27;**/index.js&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>这里的 exclude 即为跳过相应文件，跳过的文件不会被压缩</p>
</li>
<li><p>这样，在你执行 <code>hexo g</code> 的命令的时候就会自动进行压缩了，如图：<br><img src="https://i.loli.net/2020/03/30/xKezPmhuJ8Mjw9f.png" alt="高级优化06.png"></p>
</li>
<li><p>压缩本文的源码后如图，可以看出几乎没有空白符：<br><img src="https://i.loli.net/2020/03/30/nHmasNZG19TJAPO.png" alt="高级优化07.png"></p>
</li>
</ul>
<h4 id="d-注意事项"><a href="#d-注意事项" class="headerlink" title="d.注意事项"></a>d.注意事项</h4><ul>
<li><p><font color=#F00><strong>跳过压缩文件的正确配置方式</strong></font>：如果按照官方插件的文档说明来配置 <code>exclude</code>，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/*.min.css&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><font color=#F00><strong>压缩html时不要跳过.md文件</strong></font>：.md 文件就是我们写文章时的 markdown 文件，如果跳过压缩 .md 文件，而你又刚好在文章中使用到了 NexT 自带的 tab 标签，那么当 hexo 在生成静态页面时就会发生解析错误，这会导致使用到了 tab 标签的页面生成失败而无法访问</p>
</li>
<li><p><font color=#F00><strong>压缩html时不要跳过.swig文件</strong></font>：.swig 文件是模板引擎文件，简单的说 Hexo 可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白</p>
</li>
</ul>
<h3 id="2-使用gulp-js文件"><a href="#2-使用gulp-js文件" class="headerlink" title="(2).使用gulp.js文件"></a>(2).使用gulp.js文件</h3><h4 id="a-Gulp-简介"><a href="#a-Gulp-简介" class="headerlink" title="a.Gulp 简介"></a>a.Gulp 简介</h4><ul>
<li>gulp.js 是一种基于流的，代码优于配置的新一代构建工具，具体内容可以查看 <a href="https://www.gulpjs.com.cn/">官网</a></li>
<li>总之是一个基于 node 的用于自动化的工具，和 Grunt 比较类似，不过亮点是 <strong>流</strong> 和 <strong>写代码</strong> ，所以会比 Grunt 快一点</li>
<li>我们可以通过一些 gulp 插件实现对 html、css、js、image 等静态资源的高效压缩，通过压缩这些静态资源，可以减少请求的数据量从而达到优化博客访问速度的目的</li>
</ul>
<h4 id="b-准备环境-1"><a href="#b-准备环境-1" class="headerlink" title="b.准备环境"></a>b.准备环境</h4><ul>
<li><p>在你的 Hexo 根目录中打开 <code>Git Bash</code> 安装 <code>gulp</code> 模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp --save</span><br><span class="line">提醒：这里有个坑，网上教程大多是使用 -g 命令进行全局安装，我这里使用后发现并没有成功安装 gulp 而且还爆出一堆错误，而我换成 --save 将模块安装到项目 node_modules目录下时并没有出错，所以记录一下</span><br></pre></td></tr></table></figure></li>
<li><p>安装压缩需要的模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save</span><br><span class="line">提醒：每个模块的功能分别是：</span><br><span class="line">gulp-htmlclean	// 清理html</span><br><span class="line">gulp-htmlmin	// 压缩html</span><br><span class="line">gulp-minify-css // 压缩css</span><br><span class="line">gulp-uglify		// 混淆js</span><br><span class="line">gulp-imagemin	// 压缩图片</span><br><span class="line">提醒：这里相当于一个命令安装了5个模块，安装过程很慢，我这边还出现一堆自己看不懂的东西，但最后模块还是成功安装了，如果不放心的话，可以一个一个安装，只要在每一个插件后面加入 --save 即可</span><br></pre></td></tr></table></figure></li>
<li><p>安装的模块可以在 Hexo 根目录下的 <code>package.json</code> 文件里面看到</p>
</li>
</ul>
<h4 id="c-添加配置文件-1"><a href="#c-添加配置文件-1" class="headerlink" title="c.添加配置文件"></a>c.添加配置文件</h4><ul>
<li><p>在你的 Hexo 根目录中新建 <code>gulpfile.js</code> 文件，并将以下内容复制进去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">var minifycss = require(&#x27;gulp-minify-css&#x27;);</span><br><span class="line">var uglify = require(&#x27;gulp-uglify&#x27;);</span><br><span class="line">var htmlmin = require(&#x27;gulp-htmlmin&#x27;);</span><br><span class="line">var htmlclean = require(&#x27;gulp-htmlclean&#x27;);</span><br><span class="line">var imagemin = require(&#x27;gulp-imagemin&#x27;);</span><br><span class="line">// 压缩css文件</span><br><span class="line">gulp.task(&#x27;minify-css&#x27;, function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.css&#x27;)</span><br><span class="line">    .pipe(minifycss(&#123;</span><br><span class="line">        compatibility: &#x27;ie8&#x27;</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩html文件</span><br><span class="line">gulp.task(&#x27;minify-html&#x27;, function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.html&#x27;)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">        removeComments: true,</span><br><span class="line">        minifyJS: true,</span><br><span class="line">        minifyCSS: true,</span><br><span class="line">        minifyURLs: true,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩js文件</span><br><span class="line">gulp.task(&#x27;minify-js&#x27;, function() &#123;</span><br><span class="line">    return gulp.src([&#x27;./public/**/*.js&#x27;,&#x27;!./public/js/**/*min.js&#x27;])</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩图片，以下两个选一种，一般推荐最大化</span><br><span class="line">// // 压缩public目录下的所有img： 这个采用默认配置</span><br><span class="line">// gulp.task(&#x27;minify-img&#x27;, function() &#123;</span><br><span class="line">//     return gulp.src(&#x27;./public/images/**/*.*&#x27;)</span><br><span class="line">//         .pipe(imagemin())</span><br><span class="line">//         .pipe(gulp.dest(&#x27;./public/images&#x27;))</span><br><span class="line">// &#125;)</span><br><span class="line">// 压缩public目录下的所有img： 这个采用最大化压缩效果</span><br><span class="line">gulp.task(&#x27;minify-images&#x27;, function() &#123;</span><br><span class="line">    gulp.src(&#x27;./public/images/**/*.*&#x27;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">           optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）</span><br><span class="line">           progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片</span><br><span class="line">           interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br><span class="line">           multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public/images&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// 默认任务	gulp 4.0 适用的方式</span><br><span class="line">gulp.task(&#x27;default&#x27;, gulp.parallel(&#x27;minify-html&#x27;, &#x27;minify-css&#x27;, &#x27;minify-js&#x27;, &#x27;minify-images&#x27;</span><br><span class="line"> //build the website</span><br><span class="line">));</span><br></pre></td></tr></table></figure></li>
<li><p>然后执行如下命令即可进行压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">gulp</span><br><span class="line">hexo d</span><br><span class="line">提醒：这里我执行 gulp 时报错：bash: gulp: command not found ，根据网上教程，在 Git 端执行 npm -g install gulp-cli 命令，等安装完成后即可正常执行 gulp</span><br></pre></td></tr></table></figure></li>
<li><p>压缩本文的源码后如图，可以看出仍然留有大量空白符：<br><img src="https://i.loli.net/2020/03/30/Po32geHWkxKN7OS.png" alt="高级优化08.png"></p>
</li>
</ul>
<h1 id="五、网站推送优化"><a href="#五、网站推送优化" class="headerlink" title="五、网站推送优化"></a>五、网站推送优化</h1><h2 id="1-查看博客是否被收入"><a href="#1-查看博客是否被收入" class="headerlink" title="1.查看博客是否被收入"></a>1.查看博客是否被收入</h2><ul>
<li>在谷歌或者百度的搜索链接中，使用以下格式可以直接搜索自己的域名，如果能搜索到就说明已经被收录，反之则没有</li>
<li>可以直接搜索自己的域名，或者加一些关键词来更好地判断</li>
<li>例如： <code>site: https://www.wrysmile.cn</code> </li>
</ul>
<h2 id="2-谷歌搜索引擎"><a href="#2-谷歌搜索引擎" class="headerlink" title="2.谷歌搜索引擎"></a>2.谷歌搜索引擎</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="(1).创建"></a>(1).创建</h3><ul>
<li><p>进入 <a href="https://search.google.com/search-console?hl=zh-CN">谷歌搜索引擎入口</a> ，首先需要选择资源类型</p>
</li>
<li><p>这里我发现发现旧版功能并不适用于网域，而且网上教程现在大部分都是针对于旧版的，而谷歌正在从旧版向新版过渡，所以我个人认为可能两个的出入可能并不大，但如果有需求可以选择网址前缀<br><img src="https://i.loli.net/2020/04/02/JMw8t7VW64iBEdb.png" alt="高级优化09（ys）.png"></p>
</li>
</ul>
<ul>
<li>然后按照我下图进行验证即可（网址前缀的也适用，只要选择DNS就可以进行验证了）<br><img src="https://i.loli.net/2020/04/02/TRreQO1KmZMEYS5.png" alt="高级优化10.png"></li>
</ul>
<h3 id="2-关于-robots-txt"><a href="#2-关于-robots-txt" class="headerlink" title="(2).关于 robots.txt"></a>(2).关于 robots.txt</h3><ul>
<li>这个在旧版教程里貌似是需要自己手动提交的，但新版好像只要你的网站里按上边操作设置了 robots.txt 文件，那么是不需要提交的</li>
<li>你可以在左侧栏的 旧版工具和报告-了解详情-点击右边的帮助栏-robots.txt测试工具 进行查看</li>
</ul>
<h3 id="3-提交-sitemap-xml"><a href="#3-提交-sitemap-xml" class="headerlink" title="(3).提交 sitemap.xml"></a>(3).提交 sitemap.xml</h3><ul>
<li>点击左侧栏 索引-站点地图</li>
<li>如果输入框前面什么都没有，那么你需要提交你的网站的正确链接（如：<a href="https://www.wrysmile.cn/sitemap.xml">https://www.wrysmile.cn/sitemap.xml</a> ）；如果输入框中已经有网站的链接，只要在后面添加 sitemap.xml 即可</li>
<li>等待一会便可提交成功</li>
</ul>
<h2 id="3-百度搜索引擎"><a href="#3-百度搜索引擎" class="headerlink" title="3.百度搜索引擎"></a>3.百度搜索引擎</h2><h3 id="1-创建-1"><a href="#1-创建-1" class="headerlink" title="(1).创建"></a>(1).创建</h3><ul>
<li>进入 <a href="https://ziyuan.baidu.com/dashboard/index">百度站点平台</a> ，使用百度账号登录</li>
<li>绑定自己的域名，这里不做过多介绍，和谷歌类似，网上教程也有，自行搜索</li>
<li>在左侧 <strong>链接提交</strong> 中找到 自动提交-主动推送，将下面这个接口调用地址的 token 复制，一会需要使用<br><img src="https://i.loli.net/2020/04/02/4SPCa1FeEMYRI7O.png" alt="高级优化11.png"></li>
</ul>
<h3 id="2-插件安装"><a href="#2-插件安装" class="headerlink" title="(2).插件安装"></a>(2).插件安装</h3><ul>
<li><p>由于 GitHub 屏蔽了百度的爬虫，所以我们可以通过插件来直接推送 <code>.github.io</code> 结尾的网页的链接给百度而避免百度无法爬取 GitHub 中链接的问题</p>
</li>
<li><p>在你的 Hexo 根目录中打开 <code>Git Bash</code> 安装插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure></li>
<li><p>在 <font color=#1E90FF><em>站点配置文件</em></font> 中添加以下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 3							//比如3，代表提交最新的三个链接</span><br><span class="line">  host: https://www.wrysmile.cn		  //在百度站长平台中注册的域名</span><br><span class="line">  token: your_token					//上面的秘钥，请不要发布在公众仓库里</span><br><span class="line">  path: baidu_urls.txt				//文档的地址，新链接会保存在此文档里</span><br></pre></td></tr></table></figure></li>
<li><p>检查确认 <font color=#1E90FF><em>站点配置文件</em></font> 中的 url 值与 host 后的值一致</p>
</li>
<li><p>最后修改 <font color=#1E90FF><em>站点配置文件</em></font> 中的 deploy 字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type:  git</span><br><span class="line">  repo:  git@github.com:zhangyangeng/zhangyangeng.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">- type: baidu_url_submitter</span><br></pre></td></tr></table></figure></li>
<li><p>之后进行部署后该插件将自动进行主动推送至百度，如图所示表示推送成功<br><img src="https://i.loli.net/2020/04/02/GpxVcy5lORaUE9S.png" alt="高级优化12.png"></p>
</li>
</ul>
<h1 id="六、该系列文章"><a href="#六、该系列文章" class="headerlink" title="六、该系列文章"></a>六、该系列文章</h1><ul>
<li>想要了解基础搭建教程请移步这里：<a href="/Hexo-01.html" title="[Hexo博客之基础搭建教程]">[Hexo博客之基础搭建教程]</a></li>
<li>想要了解主题配置教程请移步这里：<a href="/Hexo-02.html" title="[Hexo博客之NexT配置教程]">[Hexo博客之NexT配置教程]</a></li>
<li>想要了解Markdown教程请移步这里：<a href="/Hexo-04.html" title="[Hexo博客之Markdown教程]">[Hexo博客之Markdown教程]</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>小白教程：V2Ray搭建服务器之服务器的购买</title>
    <url>/V2Ray-01.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>如果你想要自己动手搭建一个梯子来使用，那么你可以跟着本系列的教程进行搭建</li>
<li>本文主要讲解服务器的选择和购买，推荐使用谷歌云，如果你搞不到外币借记卡，那么还是选择Vultr吧</li>
<li><font color=#FF0000>注意：请不要进行任何商业行为，产生任何后果都与本人无关</font><span id="more"></span></li>
</ul>
<h1 id="一、Google-Cloud-服务器"><a href="#一、Google-Cloud-服务器" class="headerlink" title="一、Google Cloud 服务器"></a>一、Google Cloud 服务器</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li><font color=#F00>为什么选择谷歌云？</font> 因为新用户注册直接赠送一年300美金使用权，根本无需自己充值，白嫖难道不香吗？</li>
<li>谷歌云更像是国内阿里云之类云服务平台，谷歌云本身也是VM实例，这与 VPS 有很大差别，比如谷歌云是有专有网络的，而 VPS 几乎是不会给你的</li>
<li>谷歌云可以直接给 VM 实例设置 <strong>防火墙</strong>，这非常重要，若防火墙未开放相关端口，是没有办法执行任何操作的</li>
</ul>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><ul>
<li>一张 VISA 或者万事达的借记卡或者信用卡（这里推荐办理中国银行的万事达或者 VISA的借记卡）</li>
<li>Google 账户</li>
<li>可以访问 Google 的网络（你可以先在网上找一些免费的 VPN）</li>
</ul>
<h2 id="2-注册"><a href="#2-注册" class="headerlink" title="2.注册"></a>2.注册</h2><ol>
<li><p>访问 Google cloud 官网（点击 <a href="https://cloud.google.com/">这里</a>），用你的 Google 账户登录</p>
</li>
<li><p>在官网首页右上角点击免费试用<br><img src="https://i.loli.net/2020/03/17/eQ6lcBa8AoFs5fm.png" alt="谷歌云1.png"></p>
</li>
<li><p>进行国家和地区资料填写，2019年，国家/地区选项栏已取消了 <strong>中国</strong> 选项，这里我们可以随便选一个，比如香港或者台湾。<br><img src="https://i.loli.net/2020/03/17/FBLcRfpCIvsMDmg.png" alt="谷歌云2.png"></p>
</li>
</ol>
<blockquote>
<p><font color=#F00>注意：如果你的VISA或者万事达的卡没有绑定谷歌play商店，那么这里可以直接选择香港或者台湾；如果已经绑定谷歌play商店，且绑定美区或者日区，那么这里的国家必须选择美国或者日本</font></p>
</blockquote>
<ol start="4">
<li>进行个人资料的填写，如实填写就好<br><img src="https://i.loli.net/2020/03/17/iertobCfpKJqwdN.png" alt="谷歌云3.png"></li>
</ol>
<blockquote>
<p><font color=#F00>注意：如果你的国家是美国或者日本且已绑定谷歌play商店，那么这里的图片就和我的不相同了，上面会直接显示你的卡信息，而且建议这里的地址尽量选择免税地区，以免以后出现税收方面的问题</font></p>
</blockquote>
<ol start="5">
<li><p>绑定支持外币的借记卡/信用卡，会扣除1美元作为卡验证费用，验证通过后会原路返还，这里注意填写时，卡号和月份年份在卡的正面，验证码在卡的背面签名栏后边的3位数字<br><img src="https://i.loli.net/2020/03/17/sZkQ6qULrtCjv4m.png" alt="谷歌云4.png"></p>
</li>
<li><p>如果介意的话可以把 <strong>信用卡或借记卡账单邮寄地址与上述地址相同</strong> 这个 √ 去掉，然后把你真实的地址填写接收账单信息，一般来说不需要修改</p>
</li>
<li><p>点击开始免费试用选项即可，接着你的借记卡/信用卡账户会消费 1 美金，这是谷歌为了确认你不是机器人用于验证账户的，5 分钟内你会收到账户退回 1 美金的消费操作，整个过程完全免费。另外除非你主动确认升级成付费账号，300 美金的赠款消费完毕以后并不会直接从你的账户续费扣款</p>
</li>
</ol>
<h2 id="3-查看奖金"><a href="#3-查看奖金" class="headerlink" title="3.查看奖金"></a>3.查看奖金</h2><ol>
<li><p>登陆到 Google Cloud 的控制台，点击左上角的导航菜单按钮，选择结算进行赠送额度查看<br><img src="https://i.loli.net/2020/03/17/8jHLA13J4NDMFoQ.png" alt="谷歌云5.png"></p>
</li>
<li><p>进入到结算页面就可以看到相关的额度信息了，如果没有其它问题的话会看到赠金300刀以及有效期365天<br><img src="https://i.loli.net/2020/03/17/3Yd5mHFO9y8aXpj.png" alt="谷歌云6.png"></p>
</li>
</ol>
<h2 id="4-创建实例"><a href="#4-创建实例" class="headerlink" title="4.创建实例"></a>4.创建实例</h2><ol>
<li><p>点击左上角的导航菜单选项，选择 Compute Engine（计算机引擎），在子菜单选择VM实例<br><img src="https://i.loli.net/2020/03/17/pkwEnrZbFM8zjeB.png" alt="谷歌云7.png"></p>
</li>
<li><p>进入 VM 实例创建页面，直接点击创建实例选项<br><img src="https://i.loli.net/2020/03/17/rj59bJwSWR1mGVu.png" alt="谷歌云8.png"></p>
</li>
<li><p>VM 实例名称自定义，VM 实例地区如果你是搭梯子的话最好选择靠近亚洲地区即 asia 开头的地区，机器类型选择通用的最低配置就可以，右上角就可以看到你每月预计的花费。<font color=#F00>注意：一定不要追求高质量的服务器，谷歌云的流量费用是单独计算的，为了防止一年内用完300美金，最好选用低配置的服务器</font><br><img src="https://i.loli.net/2020/03/17/XLfVoIT86ew7HJn.png" alt="谷歌云9.png"></p>
</li>
<li><p>选择启动磁盘，可以修改磁盘大小和类型，还可以选择操作系统，这里推荐使用 Debian 9系统，因为该系统默认开启了 BBR加速；下面防火墙那里的两项记得打钩，不启用则无法使用<br><img src="https://i.loli.net/2020/03/17/cg7FSs2fuk1xano.png" alt="谷歌云10.png"></p>
</li>
<li><p>对我们创建的 VM 实例的连接速度进行一下测试，如果连接速度不错的话我们可以继续下面的操作，如果连接速度很差的话我们可以选择重建VM实例，一般 PING 值在100以内速度都还不错</p>
</li>
<li><p>访问 IPIP（<a href="https://www.ipip.net/traceroute.php">这里</a>）对我们创建的VM实例进行测试，前面选择一个距离你比较近的地点，后面输入创建的 VM 实例的外部 IP 地址，点击查看<br><img src="https://i.loli.net/2020/03/17/Kck1ZiEnxu2v7LO.png" alt="谷歌云11.png"></p>
</li>
<li><p>可以看到测试结果，如果时间在100ms以内那么主机连接速度还是蛮不错的，就可以进行接下来的搭建工作</p>
</li>
</ol>
<h2 id="5-防火墙配置"><a href="#5-防火墙配置" class="headerlink" title="5.防火墙配置"></a>5.防火墙配置</h2><ol>
<li><p>点击实例信息右侧的更多图标，选择 <strong>查看网络详情</strong><br><img src="https://i.loli.net/2020/03/17/onWrpqswckPAi9Y.png" alt="谷歌云12.png"></p>
</li>
<li><p>点击 <strong>防火墙规则</strong> ，选择 <strong>创建防火墙规则</strong><br><img src="https://i.loli.net/2020/03/17/vzIYg6GtKjPyn82.png" alt="谷歌云13.png"></p>
</li>
<li><p>需要注意的是，目标一栏选择 <strong>网络中的所有实例</strong> ，不然外网无法访问，其余部分按照图示填写即可<br><img src="https://i.loli.net/2020/03/17/oXaxBEZT4NJIwhC.png" alt="谷歌云14.png"></p>
</li>
</ol>
<h2 id="6-设置密码登录"><a href="#6-设置密码登录" class="headerlink" title="6.设置密码登录"></a>6.设置密码登录</h2><ol>
<li><p>谷歌云和 AWS 一样，谷歌云 VM 实例默认是通过密钥文件来登录的，为了方便起见，可以设置root用户和密码，这样就可以通过Xshell等连接我们的服务器</p>
</li>
<li><p>点击实例名称，在虚拟机实例详情页面 <strong>远程访问</strong> 选择 SSH，并在浏览器窗口中打开</p>
</li>
<li><p>有的浏览器会拦截，给允许权限即可，然后就会进行连接状态<br><img src="https://i.loli.net/2020/03/17/4vuylHWDF6Mf2wU.jpg" alt="谷歌云15.png"></p>
</li>
<li><p>创建root的密码，命令如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>然后会提示你输入 new password，输入一个你要设置的 root 的密码，需要你再输入一遍进行验证</li>
<li>切换到 root 身份，并输入你刚刚设置的密码，命令如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>编辑 ssh 登录方式，命令如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>找到 <code>PasswordAuthentication no</code>，把no改成yes；找到 <code>PermitRootLogin no</code>，把no改成yes，然后按 <code>:wq</code> 退出并保存</p>
</li>
<li><p>重启 sshd 服务，命令如下：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>至此可以用 root 身份的账号密码直接登录服务器了，不需要使用密钥了，即可以在 Xshell 客户端登录</li>
</ol>
<h2 id="7-更换为静态IP"><a href="#7-更换为静态IP" class="headerlink" title="7.更换为静态IP"></a>7.更换为静态IP</h2><ul>
<li><p>IP地址类型分为了临时和静态两种</p>
</li>
<li><p>谷歌云实例的外部IP在刚建好实例时是临时的，为了保证IP地址的稳定性，我们需要将其切换为静态IP</p>
</li>
<li><p>只要选择左上角的导航菜单，选择VPC网络，选择子菜单外网IP地址选项<br><img src="https://i.loli.net/2020/03/17/Di64kFW8rvaV2Su.png" alt="谷歌云16.png"></p>
</li>
<li><p>找到创建好的实例，将IP地址修改为静态，这时会有一个弹窗信息需要输入，起一个名字点击保留即可。<font color=#F00>注意：在同一个主机地址下只能保留一个静态IP地址，否则将会收到 <code>Quota ‘STATIC_ADDRESSES’ exceeded. Limit: 1.0 in region asia-east1</code> 提示。</font><br><img src="https://i.loli.net/2020/03/17/DN1lYhKARqaJGtg.png" alt="谷歌云17.png"></p>
</li>
</ul>
<h2 id="8-进行-V2Ray-的搭建"><a href="#8-进行-V2Ray-的搭建" class="headerlink" title="8.进行 V2Ray 的搭建"></a>8.进行 V2Ray 的搭建</h2><ul>
<li>具体步骤看这里<a href="/V2Ray-02.html" title="[小白教程：V2Ray搭建服务器之基础搭建教程]">[小白教程：V2Ray搭建服务器之基础搭建教程]</a></li>
</ul>
<h1 id="二、Vultr-服务器"><a href="#二、Vultr-服务器" class="headerlink" title="二、Vultr 服务器"></a>二、Vultr 服务器</h1><h2 id="1-注册Vultr账户"><a href="#1-注册Vultr账户" class="headerlink" title="1.注册Vultr账户"></a>1.注册Vultr账户</h2><ul>
<li>点击 <a href="https://www.vultr.com/?ref=8274420-4F">这里</a> 或点击这个网址：<a href="https://www.vultr.com/?ref=8274420-4F">https://www.vultr.com</a> 直接注册并充值10美元，可以获得$50美元，必须通过该链接进行注册才可以得到50美元的奖励</li>
<li><font color=#FF0000>注意：密码首字母需要<font color=#FF0000>大写</font>，且长度需要超过10个字符。</font><br><img src="https://s2.ax1x.com/2019/09/28/uQI0Z6.png" alt="注册vultr.png"></li>
</ul>
<h2 id="2-账户充值"><a href="#2-账户充值" class="headerlink" title="2.账户充值"></a>2.账户充值</h2><ul>
<li>点击 Billing，选择相应金额，并勾选同意</li>
<li>该服务器商支持信用卡、支付宝、微信支付，不需要担心美元与人民币的转换</li>
<li>如果你刚刚是通过我那个链接进行注册的，那么这里右边就会看到相应的优惠信息<br><img src="https://i.loli.net/2019/09/28/IvJ4TrlwdG13UF9.jpg" alt="Vultr-充值及优惠信息.jpg"></li>
</ul>
<h2 id="3-添加并购买服务器"><a href="#3-添加并购买服务器" class="headerlink" title="3.添加并购买服务器"></a>3.添加并购买服务器</h2><ul>
<li>点击右上方的加号来创建一个服务器<br><img src="https://i.loli.net/2019/09/28/l9fCxogOzXwpv2S.png" alt="添加服务器.png"></li>
</ul>
<h2 id="4-选择服务器机房"><a href="#4-选择服务器机房" class="headerlink" title="4.选择服务器机房"></a>4.选择服务器机房</h2><ul>
<li>推荐使用 <code>东京</code> 和 <code>新加坡</code> 服务器，物理距离近，延迟比较低。当然并不绝对，你可以看下边的注解来选择适合自己的机房</li>
<li>选择 <code>东京</code> 服务器可能需要点耐心，因为使用人多，好多 ip 容易被墙，下面有介绍怎么看 ip 是否被墙。<br><img src="https://i.loli.net/2019/09/28/zOM5I4N6Grm9AH1.png" alt="选择服务器位置.png"></li>
</ul>
<h3 id="注解：怎么选择适合自己的服务器机房？"><a href="#注解：怎么选择适合自己的服务器机房？" class="headerlink" title="注解：怎么选择适合自己的服务器机房？"></a>注解：怎么选择适合自己的服务器机房？</h3><ul>
<li>Vultr 官网有这几个地区的服务器。你只需要用你的电脑打开 cmd 命令行，将以下注释前面的代码复制进去回车即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping hnd-jp-ping.vultr.com      //Tokyo, Japan</span><br><span class="line">ping sgp-ping.vultr.com         //Singapore</span><br><span class="line">ping ams-nl-ping.vultr.com      //Amsterdam, NL</span><br><span class="line">ping par-fr-ping.vultr.com      //Paris, France</span><br><span class="line">ping fra-de-ping.vultr.com      //Frankfurt, DE</span><br><span class="line">ping lon-gb-ping.vultr.com      //London, UK</span><br><span class="line">ping ga-us-ping.vultr.com       //Atlanta, Georgia</span><br><span class="line">ping nj-us-ping.vultr.com       //New York (NJ)</span><br><span class="line">ping il-us-ping.vultr.com       //Chicago, Illinois</span><br><span class="line">ping tx-us-ping.vultr.com       //Dallas, Texas</span><br><span class="line">ping lax-ca-us-ping.vultr.com   //Los Angeles, California</span><br><span class="line">ping fl-us-ping.vultr.com       //Miami, Florida</span><br><span class="line">ping wa-us-ping.vultr.com       //Seattle, Washington</span><br><span class="line">ping sjo-ca-us-ping.vultr.com   //Silicon Valley, California</span><br><span class="line">ping syd-au-ping.vultr.com      //Sydney, Australia</span><br></pre></td></tr></table></figure>

<ul>
<li>以我山西移动校园网为例，每个都尝试以后，发现只有新加坡和东京的延迟在100ms以下。（<font color=#F00>注意：一定要在一天的不同时间进行测试，因为有些节点白天延迟会很大，所以一天分3次进行测试最好</font>）<br><img src="https://i.loli.net/2019/09/28/HDYZis6e5vJtr21.png" alt="ping值.png"></li>
</ul>
<h2 id="5-选择操作系统及配置"><a href="#5-选择操作系统及配置" class="headerlink" title="5.选择操作系统及配置"></a>5.选择操作系统及配置</h2><ul>
<li>常用 centos7 与 Debian9，这里推荐使用 Debian9，因为该系统 <font color=#FF0000>自动开启 BBR加速</font></li>
<li>根据你上面选出的机房位置选择合适的套餐即可，现在最低$5每个月</li>
<li>剩余的东西默认就好</li>
<li>点击Deploy Now开始创建，这时稍等一会，服务器正在安装操作系统<br><img src="https://i.loli.net/2019/09/28/82f4CndNplHVewo.png" alt="选择操作系统.png"></li>
</ul>
<h2 id="6-测试-ip-是否被墙"><a href="#6-测试-ip-是否被墙" class="headerlink" title="6.测试 ip 是否被墙"></a>6.测试 ip 是否被墙</h2><ul>
<li>服务器创建完成后，点击我们创建好的服务器，复制服务器的 ip 地址<br><img src="https://i.loli.net/2019/09/28/bpeMoUkyXSZEqAW.png" alt="复制IP.png"></li>
<li>使用 <code>端口扫描</code> 工具（<a href="http://coolaf.com/tool/port">点击这里</a>）检测我们的服务器 ip，仅查看 <code>22端口</code> 是否开放。<br><img src="https://i.loli.net/2019/09/28/quNX5QegWFo1JL9.png" alt="检测IP端口.png"></li>
<li>若开放，说明 ip 没有被墙；若关闭，重复上面(3)~(6)步骤，直到找到22端口开放的 ip，如下：<br><img src="https://i.loli.net/2019/09/29/FzwMpmqTQrPO3RK.png" alt="22端口开放.png"></li>
<li>这时，再删除你之前22端口关闭的服务器。<br><img src="https://i.loli.net/2019/09/29/mvzAREcQGFa6YXl.png" alt="删除服务器.png"></li>
<li>注意：一定要等到找到开放的端口再删除之前的服务器。因为删除再重建的话，还是会分到你原来被墙的 ip。（因为服务器是按时付费，所以刚注册就删除花费不了多少钱，也就0.01美元）</li>
</ul>
<h2 id="7-进行-V2Ray-的搭建"><a href="#7-进行-V2Ray-的搭建" class="headerlink" title="7.进行 V2Ray 的搭建"></a>7.进行 V2Ray 的搭建</h2><ul>
<li>具体步骤看这里<a href="/V2Ray-02.html" title="[小白教程：V2Ray搭建服务器之基础搭建教程]">[小白教程：V2Ray搭建服务器之基础搭建教程]</a></li>
</ul>
<h1 id="三、关于IP被墙的解决办法"><a href="#三、关于IP被墙的解决办法" class="headerlink" title="三、关于IP被墙的解决办法"></a>三、关于IP被墙的解决办法</h1><h2 id="1-Google-Cloud"><a href="#1-Google-Cloud" class="headerlink" title="1.Google Cloud"></a>1.Google Cloud</h2><ul>
<li>有时会遇到外网 IP 不能用的情况，这时可以考虑不删除实例更换 IP</li>
</ul>
<ol>
<li><p>选择菜单——Compute Engine——VM实例，可以看到正在运行的实例状态<br><img src="https://i.loli.net/2020/03/17/pkwEnrZbFM8zjeB.png" alt="谷歌云7.png"></p>
</li>
<li><p>开始更换外部IP，找到菜单——VPC网络——外部IP地址<br><img src="https://i.loli.net/2020/03/17/Di64kFW8rvaV2Su.png" alt="谷歌云16.png"></p>
</li>
<li><p>附加在实例的IP不能被释放，所以找到附加在运行这个实例的IP，点击 <strong>更改</strong> ，在附加到的选项里选择 <strong>无</strong> ，确定完成<br><img src="https://i.loli.net/2020/03/18/b7pjmwJ8sd39aYq.png" alt="谷歌云18.png"></p>
</li>
<li><p>这时会重新分配一个临时IP给运行的这个实例，并且弹出计费警告。不用在意，点击确定完成<br><img src="https://i.loli.net/2020/03/18/d9SErYnkBGNVl51.png" alt="谷歌云19（需要替换）.png"></p>
</li>
<li><p>完成后会出现一个未附加到实例的静态IP和一个临时IP，一个实例只能绑定一个IP，未绑定的IP将单独计费，所以把不再需要的IP释放掉。选中需要释放IP点击“释放静态地址”，这样这个IP就被释放掉了<br><img src="https://i.loli.net/2020/03/18/vLDH9txMTwdzbFo.png" alt="谷歌云20（需要替换）.png"></p>
</li>
<li><p>使用静态IP类型重启系统后IP不会发生改变，所以新IP类型选择“静态”，点击“更改”，名称随便填，点击“保留”并附加到需要绑定的实例上<br><img src="https://i.loli.net/2020/03/18/QeRC4dYkg7H3vVw.png" alt="谷歌云21（需要替换）.png"></p>
</li>
<li><p>保留实例更换外部IP完成<br><img src="https://i.loli.net/2020/03/18/iEY319L6gOof7pT.png" alt="谷歌云22（需要替换）.png"></p>
</li>
<li><p>最后看下新IP是否生效<br><img src="https://i.loli.net/2020/03/18/ORXcoCbDFhu2MUp.png" alt="谷歌云23（需要替换）.png"></p>
</li>
</ol>
<h2 id="2-Vultr-快照法"><a href="#2-Vultr-快照法" class="headerlink" title="2.Vultr 快照法"></a>2.Vultr 快照法</h2><h3 id="1-服务器备份"><a href="#1-服务器备份" class="headerlink" title="(1).服务器备份"></a>(1).服务器备份</h3><ul>
<li><p>进入你被墙的服务器详情页面，点击Snapshots<br><img src="https://i.loli.net/2019/09/28/LtRnmVadPKTWhDb.png" alt="服务器详情—快照.png"></p>
</li>
<li><p>然后点击Take按钮，即可创建，注意：这里需要等待大约30分钟<br><img src="https://i.loli.net/2019/09/28/cTwIXKEpFSBOZnf.png" alt="拍快照.png"></p>
</li>
<li><p>重要:这台服务器的密码请自行保存（不保存后果自负）</p>
</li>
</ul>
<h3 id="2-换新服务器"><a href="#2-换新服务器" class="headerlink" title="(2).换新服务器"></a>(2).换新服务器</h3><ul>
<li>按上面 <code>第一大点的第4小点的(3)~(6)点</code> 步骤进行创建服务器</li>
</ul>
<h3 id="3-数据还原"><a href="#3-数据还原" class="headerlink" title="(3).数据还原"></a>(3).数据还原</h3><ul>
<li>点一下服务器，会跳出详细信息，计费信息等更多选项</li>
<li>找到Snapshot，底部有个Restore Snapshot部分，这里可以找到我们刚刚备份的快照</li>
<li>选择对应的快照点击后面的恢复按钮（垃圾桶按钮旁边的类似刷新的按钮），然后打勾，点击restore即可（大概30min，过程中服务器为关机状态，恢复完成后服务器自动开机）</li>
<li>快照恢复后，新服务器连接密码为原服务器的连接密码</li>
</ul>
<h3 id="4-善后处理"><a href="#4-善后处理" class="headerlink" title="(4).善后处理"></a>(4).善后处理</h3><ul>
<li>服务器按小时扣费，此时删除原来的服务器即可停止计费(Destroy)<br><img src="https://i.loli.net/2019/09/29/mvzAREcQGFa6YXl.png" alt="删除服务器.png"></li>
</ul>
<h2 id="3-重新新建部署服务器"><a href="#3-重新新建部署服务器" class="headerlink" title="3.重新新建部署服务器"></a>3.重新新建部署服务器</h2><ul>
<li>这种方法就是重新创建一个服务器，根据之前的教程重新进行配置服务器，成功后删除你原来的服务器</li>
<li>优点：几乎没有</li>
<li>缺点：太麻烦，还得重新在服务器上安装 V2Ray，很麻烦</li>
<li>所以推荐使用上面两种方法</li>
</ul>
<h1 id="四、本系列文章"><a href="#四、本系列文章" class="headerlink" title="四、本系列文章"></a>四、本系列文章</h1><ul>
<li>想要了解V2Ray的基础搭建教程请移步这里：<a href="/V2Ray-02.html" title="[小白教程：V2Ray搭建服务器之基础搭建教程]">[小白教程：V2Ray搭建服务器之基础搭建教程]</a></li>
<li>想要了解V2Ray的进阶优化教程请移步这里：<a href="/V2Ray-03.html" title="[小白教程：V2Ray搭建服务器之进阶优化教程]">[小白教程：V2Ray搭建服务器之进阶优化教程]</a></li>
<li>想要了解V2Ray的拓展资料请移步这里：<a href="/V2Ray-04.html" title="[小白教程：V2Ray搭建服务器之拓展资料]">[小白教程：V2Ray搭建服务器之拓展资料]</a></li>
</ul>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>翻墙</tag>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>小白教程：V2Ray搭建服务器之拓展资料</title>
    <url>/V2Ray-04.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文介绍一些搭建 V2ray 服务器时的一些拓展内容</li>
<li>主要是针对于搭建服务器的进阶教程的讲解</li>
<li>原文大部分内容搬运自 <a href="https://www.idleleo.com/">无主界</a></li>
<li><font color=#FF0000>注意：请不要进行任何商业行为，产生任何后果都与本人无关</font><span id="more"></span></li>
</ul>
<h1 id="一、传输协议"><a href="#一、传输协议" class="headerlink" title="一、传输协议"></a>一、传输协议</h1><ul>
<li>V2Ray 的传输协议非常之多，由于 V2Ray 本质就是一种网络传输数据的应用。因此它可以使用的工具自然也不会少，比如用于网站的 HTTP/HTTPS 协议、更底层的 TCP/UDP 协议等等。这些协议既然存在并且依然在使用，说明它们各有千秋。因此，想要知道你应该使用哪个协议，便需要你对协议本身有一定的了解</li>
</ul>
<h2 id="1-WebSocket-TLS"><a href="#1-WebSocket-TLS" class="headerlink" title="1.WebSocket+TLS"></a>1.WebSocket+TLS</h2><ul>
<li>此协议使用的人并不多，但是笔者是推荐使用此协议的。使用不多的原因是 WebSocket+TLS 协议存在一定的应用难度：你需要知道如何注册、解析域名。但是如果你能搞定域名的问题，搭配现在甚多的一键部署脚本，WebSocket+TLS 是较为简单、可靠的</li>
</ul>
<h3 id="1-WebSocket-ws"><a href="#1-WebSocket-ws" class="headerlink" title="(1).WebSocket (ws)"></a>(1).WebSocket (ws)</h3><ul>
<li>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议；WebSocket 通信协议于2011年被 IETF 定为标准 RFC 6455，并由 RFC 7936补充规范；WebSocket API 也被 W3C 定为标准。</li>
<li>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</li>
<li>简单说，WebSocket 解决了 HTTP 协议的部分问题，比如每次请求都携带状态信息（如身份认证等）、请求每次都要携带完整的头部等等。再加上由于 WebSocket 全双工通信，因此能够很好的进行实时通信。用在V2Ray 上时，请求与应答的效率要远高于 HTTP，而 V2Ray 的请求要远高于普通的请求，所以 WebSocket 可以说是一种不错的选择。同时由于 WebSocket 本身已经成熟，因此有 Cloudflare 这类云服务商支持基于 WebSocket 流量的 CDN 服务，这进一步增进了原本的服务器的安全性。</li>
<li>但是，由于 WebSocket 本身是基于 TCP 协议。既然使用了 TCP，那么自然少不了一些 TCP 的缺点，由于 TCP 协议占据了大多数的网络链接，再者有着复杂的握手机制。虽然保证了链接的可靠性，但也牺牲了效率和带宽，因此在拥堵的网络环境，WebSocket 便不在那么好用了。</li>
<li>这类的网络拥堵并不仅仅在于客户端，对于 V2Ray 的服务器端更为明显，所以使用这类协议的服务器，最好安装诸如 BBR、锐速等拥塞控制算法，减少拥堵。</li>
<li>同时，由于 WebSocket 是明文传输，这意味着与服务器的通信内容均可以被第三者探测甚至攻击。因此，这对传输安全带来了隐患。如果仅仅开启 WebSocket ，建议开启伪装，伪装的域名建议为 WebSocket 流量相对较大的网站。</li>
</ul>
<h3 id="2-TLS"><a href="#2-TLS" class="headerlink" title="(2).TLS"></a>(2).TLS</h3><ul>
<li>传输层安全性协议（英语：Transport Layer Security，缩写作TLS），及其前身安全套接层（Secure Sockets Layer，缩写作SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。网景公司（Netscape）在1994年推出首版网页浏览器——网景导航者时，推出 HTTPS 协议，以 SSL 进行加密，这是 SSL 的起源。IETF 将 SSL 进行标准化，1999年公布第一版 TLS 标准文件。随后又公布 RFC 5246 （2008年8月）与 RFC 6176（2011年3月）。在浏览器、邮箱、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。主要的网站，如 Google、Facebook 等也以这个协议来创建安全连线，发送数据。目前已成为互联网上保密通信的工业标准。</li>
<li>SSL 包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</li>
<li>TLS 作用于 HTTP 便诞生出了现今最为常用的协议 HTTPS，那么作用于 WebSocket，自然便成了 WSS，也就是 WebSocket+TLS。</li>
<li>对于 V2Ray 来说，虽然经过了协议的加密，但是这类流量本身就并不“正常”。试想，你手机连接了 V2ray，大量数据通过协议向一个固定 IP 请求，而数据内容与普通的数据格格不入。这自然会引起部分人的警觉。如果嵌套一个保险箱(TLS)，让数据显得和其他请求的数据没什么两样，这样一方面减少了审查者的怀疑，另一方面又加强了数据的安全性。</li>
<li>当然由于 TLS 本身存在一个加密解密的过程，因此势必会对传输的效率带来影响。不过影响是微乎其微的，想要追求安全，自然也需要一定的牺牲。笔者是推荐这种协议的，如果条件允许，主要推荐 WebSocket+TLS 这个协议。</li>
</ul>
<h2 id="2-mKCP伪装"><a href="#2-mKCP伪装" class="headerlink" title="2.mKCP伪装"></a>2.mKCP伪装</h2><ul>
<li>这一类协议细分有多种，由于 KCP 拥有控制头，因此可以通过修饰头部进行数据伪装。这类伪装常见的有 SRTP、UTP、DTLS、wechat-video 等。这类伪装并不能决定这类协议本质，因此便不再详细阐述。对于 mKCP 伪装最为重要的影响是 KCP 协议本身。</li>
<li>KCP 协议是传输层的一个具有可靠性的传输层 ARQ协议。它的设计是为了解决在网络拥堵情况下 TCP 协议的网络速度慢的问题。KCP 力求在保证可靠性的情况下提高传输速度。KCP 协议的关注点主要在控制数据的可靠性和提高传输速度上面，因此 KCP 没有规定下层传输协议，一般用 UDP 作为下层传输协议，KCP 层协议的数据包在 UDP 数据报文的基础上增加控制头。当用户数据很大，大于一个 UDP 包能承担的范围时（大于MSS），KCP 会将用户数据分片存储在多个 KCP 包中。</li>
<li>KCP 协议与上述的 WebSocket 协议便大大的不同了。由于本身的下层传输协议不同，KCP 通常使用 UDP 而 WebSocket 使用 TCP，因此特性也十分不同。</li>
<li>WebSocket 在拥堵的网络情况下显得效果不佳，而 KCP 则可以在拥堵的网络下依旧达到一定的速度。所以，在 3G、4G 这类用户多、网络堵的情况下，KCP 甚至可以起到加速的作用。</li>
<li>但是，这类协议虽然速度快，其本身是基于 UDP 的，UDP 协议本身并不稳定。即便有一定的可靠性，由于使用了 UDP，容易导致产生拥塞。注意，这里的拥塞并不是由于其他的连接引起的，而是协议自身引起的。如果出现拥塞，反而会导致传输效率大打折扣。因此最好启用拥塞控制。同时，由于 UDP 自身容易出现拥塞影响其他连接，又难以进行很好的管控，我们运营商可能会对这类连接阻断，也即是 QoS 。遇到这种情况， KCP 也成了牺牲品，进一步影响了连接的稳定。</li>
<li>当然由于 KCP 自身容易拥塞的特性，相应的 V2Ray 客户端有 Mux 技术来一定程度解决这类问题。Mux 是推荐开启的，它可以使 KCP 数据更为有条理的整合在一起，提高效率。</li>
</ul>
<h2 id="3-TCP"><a href="#3-TCP" class="headerlink" title="3.TCP"></a>3.TCP</h2><ul>
<li>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP 层是位于 IP 层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换。</li>
<li>这类协议本身较之其他的 V2Ray 协议更加底层和原始。这对于 V2Ray 的安全性带来了问题。由于本身就是TCP 协议，因此，看到这里大家应该知道了它的缺点在哪里。</li>
<li>当然没有了上层协议的嵌套，简单的 TCP 协议对于传输效率来说是增加了不少。这也带来一个更为严重的问题，安全。由于实在简单，据了解，审查者已经开始拦截这类数据了。基于安全与网络顺畅考虑，笔者是不推荐的。</li>
</ul>
<h2 id="4-h2-HTTP-2"><a href="#4-h2-HTTP-2" class="headerlink" title="4.h2 (HTTP/2)"></a>4.h2 (HTTP/2)</h2><ul>
<li>h2 便是 HTTP/2 （原名HTTP/2.0）即超文本传输协议 2.0，是下一代 HTTP 协议。是由互联网工程任务组（IETF）的 Hypertext Transfer Protocol Bis (httpbis)工作小组进行开发。是自1999年 http1.1 发布后的首个更新。HTTP 2.0在2013年8月进行首次合作共事性测试。在开放互联网上 HTTP 2.0 将只用于 https:// 网址，而 http:// 网址将继续使用 HTTP/1 ，目的是在开放互联网上增加使用加密技术，以提供强有力的保护去遏制主动攻击。</li>
<li>对于 V2Ray，使用 h2 必须同时使用 TLS。h2 本质是 HTTP 协议，对于传统 http1.1 协议传输速度快了不少。h2 的下层协议是 TCP，因此大家应该知道这类协议的共同缺点了。较之类似的 WebSocket 协议，传输效率略逊于 WebSocket。但是它却有比 WebSocket 更加好的伪装，由于大部分网站使用 HTTP 协议，因此 h2+TLS 这种协议能使 V2Ray 流量伪装在正常流量中，并且难以察觉。</li>
</ul>
<h2 id="5-QUIC"><a href="#5-QUIC" class="headerlink" title="5.QUIC"></a>5.QUIC</h2><ul>
<li>QUIC（Quick UDP Internet Connection）是谷歌制定的一种基于 UDP 的低时延的互联网传输层协议。我们知道，TCP/IP 协议族是互联网的基础。其中传输层协议包括 TCP 和 UDP 协议。与 TCP 协议相比，UDP 更为轻量，但是错误校验也要少得多。这意味着 UDP 往往效率更高（不经常跟服务器端通信查看数据包是否送达或者按序），但是可靠性比不上 TCP。通常游戏、流媒体以及 VoIP 等应用均采用 UDP，而网页、邮件、远程登录等大部分的应用均采用 TCP。</li>
<li>QUIC 很好地解决了当今传输层和应用层面临的各种需求，包括处理更多的连接，安全性，和低延迟。QUIC 融合了包括 TCP，TLS，HTTP/2 等协议的特性，但基于 UDP 传输。QUIC 的一个主要目标就是减少连接延迟，当客户端第一次连接服务器时，QUIC 只需要 1RTT（Round-Trip Time）的延迟就可以建立可靠安全的连接，相对于 TCP+TLS 的1-3次 RTT 要更加快捷。之后客户端可以在本地缓存加密的认证信息，再次与服务器建立连接时可以实现 0-RTT 的连接建立延迟。QUIC 同时复用了 HTTP/2 协议的多路复用功能（Multiplexing），但由于 QUIC 基于 UDP 所以避免了 HTTP/2 的线头阻塞（Head-of-Line Blocking）问题。因为 QUIC 基于 UDP，运行在用户域而不是系统内核，使得 QUIC 协议可以快速的更新和部署，从而很好地解决了 TCP 协议部署及更新的困难。</li>
<li>此协议基于 UDP，但较之 KCP 更为可靠。从传输本身来说，笔者是推荐的。但是，由于协议本身太新，这类流量本身就不多，突然出现大量流量指向一个 IP 会如何？相信大家也知道风险。同时由于现今 V2Ray 的 QUIC 并不是真正意义上的 HTTP/3，因此存在一定的兼容问题，笔者并不是很推荐。</li>
</ul>
<h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h2><ul>
<li>对于大部分用户来说，如果有能力搞定域名购买、解析。那么是推荐使用 WebSocket+TLS，可以的话最好再增加 CDN 支持。如果没有办法搞定域名，那么推荐直接使用 WebSocket 伪装或者 mKCP 伪装。</li>
<li>对于处在拥堵网络，如经常使用 3G、4G 的用户，推荐使用 mKCP 伪装。并且推荐打开 Mux 多路复用。</li>
<li>对于不在乎服务器被墙的用户来说，推荐直接使用 WebSocket 伪装。</li>
<li>对于客户端、服务器性能孱弱的用户来说，直接使用 TCP 不使用加密并将 AlterId 值调低是最好的选择。</li>
</ul>
<h1 id="二、加密方式"><a href="#二、加密方式" class="headerlink" title="二、加密方式"></a>二、加密方式</h1><ul>
<li>对于加密方式/算法来说，一般安全性与性能呈负相关，越是安全越是对性能要求高，这应该是大家的常识。由于现在大部分给出的加密协议的安全性均能达到标准，因此这里主要讨论的最好便是加密性能的优良。</li>
<li>对于 V2Ray 而言，有三种加密方式：AES-128-CFB、AES-128-GCM、ChaCha20-Poly1305（当然还有不加密）。</li>
</ul>
<h2 id="1-AES加密方式"><a href="#1-AES加密方式" class="headerlink" title="1.AES加密方式"></a>1.AES加密方式</h2><ul>
<li><p>AES（Advanced Encryption Standard）高级加密标准，这类加密标准是十分常见的对称加密算法。所谓的对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：<br><img src="https://i.loli.net/2020/03/17/Ob4sTLfPCV2G6eo.png" alt="V2ray拓展1.png"></p>
</li>
<li><p>这里的 AES-128 就是密钥的长度为128位，加密轮数为10轮。</p>
</li>
</ul>
<h2 id="2-AES-128-CFB"><a href="#2-AES-128-CFB" class="headerlink" title="2.AES-128-CFB"></a>2.AES-128-CFB</h2><ul>
<li><p>对于 CFB 模式来说，其全称为 Cipher FeedBack模式（密文反馈模式）。在 CFB 模式中，前一个密文分组会被送回到密码算法的输入端。而所谓反馈，这里指的就是返回输入端的意思。以下是其示意图：<br><img src="https://i.loli.net/2020/03/17/TpOsDLqZwiRYVPz.png" alt="V2ray拓展2.png"></p>
</li>
<li><p>从上图中可以发现，对于 AES-128-CFB 而言其优点在于它隐藏了明文模式，同时它可以及时加密传送小于分组的数据。但它也有缺点，CFB 并不利于并行计算、一个明文单元损坏影响多个单元。</p>
</li>
</ul>
<h2 id="3-AES-128-GCM"><a href="#3-AES-128-GCM" class="headerlink" title="3.AES-128-GCM"></a>3.AES-128-GCM</h2><ul>
<li><p>对于 GCM 模式来说，其全称为 Galois/Counter Mode，也就是该对称加密采用 Counter 模式，并带有 GMAC 消息认证码。</p>
</li>
<li><p>其工作原理是相对较为复杂的，与CFB不同，它可以提供对消息的加密和完整性校验，另外，它还可以提供附加消息的完整性校验。以下是其粗略的示意图：<br><img src="https://i.loli.net/2020/03/17/Cv3oOSg89XUKdR6.png" alt="V2ray拓展3.png"></p>
</li>
<li><p>对于 GCM 而言其最大的优势便是有利于并行计算，并且有消息的完整性校验。缺点自然是要考虑运行加密时硬件的支持程度。</p>
</li>
</ul>
<h2 id="4-ChaCha20-Poly1305"><a href="#4-ChaCha20-Poly1305" class="headerlink" title="4.ChaCha20-Poly1305"></a>4.ChaCha20-Poly1305</h2><ul>
<li>对于 ChaCha20-Poly1305，其全称就是 ChaCha20-Poly1305，它是由 ChaCha20 流密码和 Poly1305 消息认证码（MAC）结合的一种加密算法。</li>
<li>ChaCha20-Poly1305 是基于 RC4 流加密的一种加密方式，它与 AES 有本质的区别，对于 RC4 而言，已经被证实并不安全，那么为什么还要发展 ChaCha20-Poly1305 呢？原因很简单，兼容性。</li>
<li>对于精简指令集的 ARM 平台，由于没有 AES-NI 指令集，ChaCha20-Poly1305 在同等配置的手机中表现是 AES 的4倍（ARM v8之后加入了AES指令，所以在ARM v8平台上的设备，AES 方式反而比 chacha20-Poly1305 方式更快，性能更好），这样可减少加密解密所产生的数据量，使得性能更好。</li>
</ul>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><ul>
<li>若 V2Ray 客户端运行在普通电脑上，很明显 AES 方式更加的高效。</li>
<li>若 V2Ray 客户端运行在手机或者软路由上，从上述描述中能很好的看到，AES 和 ChaCha20-Poly1305 的选择需要依据实际情况。一般在近几年的手机/软路由 CPU 中都内置了 AES-NI 指令集，因此使用 ChaCha20-Poly1305 是没有必要的。但对于老手机而言，ChaCha20-Poly1305 则快于 AES，是你的最佳选择。</li>
<li>所以，对于服务端，一般选择 Auto；对于使用老旧手机的用户而言，毫无疑问，你需要选择 ChaCha20-Poly1305 或者直接选择不加密获得最佳性能；对于使用电脑和近两年新手机的用户而言，选择 AES-128-GCM 效果最佳；对于在乎自己数据安全的用户来说，选择 AES-128-CFB 理论上能更加安全。</li>
</ul>
<h1 id="三、本系列文章"><a href="#三、本系列文章" class="headerlink" title="三、本系列文章"></a>三、本系列文章</h1><ul>
<li>想要了解V2Ray的服务器购买教程请移步这里：<a href="/V2Ray-01.html" title="[小白教程：V2Ray搭建服务器之服务器的购买]">[小白教程：V2Ray搭建服务器之服务器的购买]</a></li>
<li>想要了解V2Ray的基础搭建教程请移步这里：<a href="/V2Ray-02.html" title="[小白教程：V2Ray搭建服务器之基础搭建教程]">[小白教程：V2Ray搭建服务器之基础搭建教程]</a></li>
<li>想要了解V2Ray的进阶优化教程请移步这里：<a href="/V2Ray-03.html" title="[小白教程：V2Ray搭建服务器之进阶优化教程]">[小白教程：V2Ray搭建服务器之进阶优化教程]</a></li>
</ul>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>翻墙</tag>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>小白教程：V2Ray搭建服务器之进阶优化教程</title>
    <url>/V2Ray-03.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本教程是 V2ray 搭建服务器的进阶教程，该教程与基础教程不同，所以需要重新配置服务端</li>
<li>本教程中的部分内容引用了 <a href="https://www.hijk.pw/">网络跳越</a> 与 <a href="https://tlanyan.me/">tlanyan</a> 的部分内容，如侵权，请联系我进行删除</li>
<li><font color=#FF0000>注意：请不要进行任何商业行为，产生任何后果都与本人无关</font><span id="more"></span></li>
</ul>
<h1 id="一、前提条件"><a href="#一、前提条件" class="headerlink" title="一、前提条件"></a>一、前提条件</h1><ul>
<li>一台境外的 vps，购买可参考该系列文章的第一篇</li>
<li>一个域名，无备案要求（备案可使用国内CDN加速，但意味着万一有事，被喝茶更容易）。域名购买可参考：<a href="https://www.hijk.pw/namesilo-buy-domain-tutorial/">Namesilo购买域名详细教程</a> 或从 <a href="https://tlanyan.me/domain-register-for-mainland/">适合国人的域名注册商推荐</a> 选购</li>
<li>为域名申请一个证书，可以用免费的Let’s Encrypt证书，参考：<a href="https://tlanyan.me/use-lets-encrypt-certificate/">使用Let’s Encrypt的免费证书</a></li>
<li>有基本linux技巧，能使用vim/nano等编辑器</li>
</ul>
<h1 id="二、脚本一键部署（第一种）"><a href="#二、脚本一键部署（第一种）" class="headerlink" title="二、脚本一键部署（第一种）"></a>二、脚本一键部署（第一种）</h1><h2 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1.域名解析"></a>1.域名解析</h2><ul>
<li>我这里因为有一个域名且解析到了现在的博客上，所以我直接采用的二级域名进行配置</li>
<li>方法雷同：进入阿里云的域名控制服务台，将我的二级域名 <code>xxx.wrysmile.cn</code> 解析到了我的服务器的ipv4的地址上</li>
</ul>
<h2 id="2-远程连接服务器"><a href="#2-远程连接服务器" class="headerlink" title="2.远程连接服务器"></a>2.远程连接服务器</h2><ul>
<li>在我上个教程中写到了使用 Xshell 远程登录到你的国外服务器上，需要的请翻上篇教程</li>
</ul>
<h2 id="3-安装v2ray"><a href="#3-安装v2ray" class="headerlink" title="3.安装v2ray"></a>3.安装v2ray</h2><ul>
<li><p>复制下面的代码，在 Xshell 黑色命令行中右键粘贴，按回车进行安装。<font color=#FF0000>注意：命令行中不可以用 Ctrl+V 快捷键进行粘贴</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure></li>
<li><p>选择传输协议：这里选择第四个 <code>WebSocket+TLS</code></p>
</li>
<li><p>选择端口号：端口号自己随意设置，脚本提示不能选择80和443端口，这里我直接设置为 <code>38222</code><br><img src="https://i.loli.net/2020/05/31/jaVDbWfcFn5qHTC.png" alt="进阶01.png"></p>
</li>
<li><p>输入域名：将第一步解析好的域名完整的写入，然后确认无误按y回车<br><img src="https://i.loli.net/2020/05/31/8BsM6hzo9OUSuJm.png" alt="进阶02.png"></p>
</li>
<li><p>自动配置TLS：这里新手建议直接选择自动配置<br><img src="https://i.loli.net/2020/05/31/vOFASDXCc3Z8BgL.png" alt="进阶03.png"></p>
</li>
<li><p>网站伪装和路径分流：分流地址建议使用二级地址或者一级较长的名字，这里我使用的是 <code>/wrysmile</code> ；网站伪装地址自行设置即可<br><img src="https://i.loli.net/2020/05/31/NtBxsVwb4zWfXLv.png" alt="进阶04.png"></p>
</li>
<li><p>选择广告拦截：建议不要开启，开启广告拦截会消耗服务器资源</p>
</li>
<li><p>选择开启SS：建议开启，iOS 端没有 V2Ray 客户端，可以借由 SS 客户端进行登陆，所以需要开启 SS<br><img src="https://i.loli.net/2019/09/29/EIUijtAshe1v3Fd.png" alt="5配置SS.png"></p>
</li>
<li><p>选择 SS 端口号：依然自己随意设置，但不可以和上面的 V2Ray 端口号一样，这里我直接设置为 <code>10086</code><br><img src="https://i.loli.net/2019/09/29/5VM8sCzcR1Z3Sl4.png" alt="6S端口.png"></p>
</li>
<li><p>设置 SS 连接密码：只要自己能记住即可<br><img src="https://i.loli.net/2019/09/29/C73JeSh89dOBlRt.png" alt="7SS密码.png"></p>
</li>
<li><p>选择 SS 加密协议：推荐使用默认的，我这里使用的另一种。这个其实因人而异，建议有时间每个都试一下，看看哪个更快点，相比较而言，cha 更为安全一些<br><img src="https://i.loli.net/2019/09/29/Vcs13OxhWMmUgSP.png" alt="8加密协议.png"></p>
</li>
<li><p>配置完成以后，会让你进行核对，然后直接两次回车，静待几分钟即可完成服务器搭建。</p>
</li>
<li><p><span id="jump">完成界面如下，在命令行中输入 <code>v2ray</code> 即可进行相应的配置</span></p>
</li>
</ul>
<h2 id="4-开启BBR加速"><a href="#4-开启BBR加速" class="headerlink" title="4.开启BBR加速"></a>4.开启BBR加速</h2><ul>
<li>关于这部分内容，我在基础教程中也写到了，debian系统无需设置，centos和Ubuntu都需要单独开启，具体内容请看基础部分</li>
</ul>
<h1 id="三、脚本一键部署（第二种）"><a href="#三、脚本一键部署（第二种）" class="headerlink" title="三、脚本一键部署（第二种）"></a>三、脚本一键部署（第二种）</h1><h2 id="1-域名解析-1"><a href="#1-域名解析-1" class="headerlink" title="1.域名解析"></a>1.域名解析</h2><ul>
<li>我这里因为有一个域名且解析到了现在的博客上，所以我直接采用的二级域名进行配置</li>
<li>方法雷同：进入阿里云的域名控制服务台，将我的二级域名 <code>xxx.wrysmile.cn</code> 解析到了我的服务器的ipv4的地址上</li>
</ul>
<h2 id="2-未完待续"><a href="#2-未完待续" class="headerlink" title="2.未完待续"></a>2.未完待续</h2><h1 id="本系列文章"><a href="#本系列文章" class="headerlink" title="本系列文章"></a>本系列文章</h1><ul>
<li>想要了解V2Ray的服务器购买教程请移步这里：<a href="/V2Ray-01.html" title="[小白教程：V2Ray搭建服务器之服务器的购买]">[小白教程：V2Ray搭建服务器之服务器的购买]</a></li>
<li>想要了解V2Ray的基础搭建教程请移步这里：<a href="/V2Ray-02.html" title="[小白教程：V2Ray搭建服务器之基础搭建教程]">[小白教程：V2Ray搭建服务器之基础搭建教程]</a></li>
<li>想要了解V2Ray的拓展资料请移步这里：<a href="/V2Ray-04.html" title="[小白教程：V2Ray搭建服务器之拓展资料]">[小白教程：V2Ray搭建服务器之拓展资料]</a></li>
</ul>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>翻墙</tag>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：Nginx</title>
    <url>/Learn-Nginx.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习 Nginx 时的一些笔记<span id="more"></span></li>
</ul>
<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-Nginx"><a href="#1-Nginx" class="headerlink" title="1.Nginx"></a>1.Nginx</h2><ul>
<li>Nginx 是一个高性能的 HTTP 和反向代理的 web 服务器，专门为性能优化而开发，且支持热部署</li>
<li>特点：占有内存少，并发能力强</li>
</ul>
<h2 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2.反向代理"></a>2.反向代理</h2><ul>
<li>对外暴露的是反向代理服务器，隐藏了真实的服务器</li>
<li>区别于正向：正向相当于把代理设置在了用户一端，而反向相当于把代理设置在了服务器一端<br><img src="https://s1.ax1x.com/2020/10/20/BSFhjS.png" alt="Nginx01.png"></li>
</ul>
<h2 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3.负载均衡"></a>3.负载均衡</h2><ul>
<li>适合于并发请求较大的时候，相当于将客户端的请求分发给各个服务器上<br><img src="https://s1.ax1x.com/2020/10/20/BSFfc8.png" alt="Nginx02.png"></li>
</ul>
<h2 id="4-动静分离"><a href="#4-动静分离" class="headerlink" title="4.动静分离"></a>4.动静分离</h2><ul>
<li>为了加快网站的解析速度，将动态资源和静态资源分离开来，分别由不同的服务器来解析，减少服务器的压力</li>
<li>静态资源：html、css、js<br>动态资源：jsp、servlet</li>
</ul>
<h1 id="二、Nginx-的安装"><a href="#二、Nginx-的安装" class="headerlink" title="二、Nginx 的安装"></a>二、Nginx 的安装</h1><blockquote>
<p>Nginx 可以安装在 windows 中，也可以安装在 linux 中，一般是安装在 linux 中，因为大多数的服务器都是运行在 linux 系统中的。</p>
</blockquote>
<h2 id="1-安装前的准备"><a href="#1-安装前的准备" class="headerlink" title="1.安装前的准备"></a>1.安装前的准备</h2><ul>
<li>pcre 依赖包。<a href="http://www.pcre.org/">官网</a></li>
<li>openssl 依赖包。<a href="https://www.openssl.org/">官网</a></li>
<li>zlib 依赖包。<a href="http://www.zlib.net/">官网</a></li>
<li>nginx 安装包。<a href="http://nginx.org/">官网</a></li>
</ul>
<h2 id="2-安装命令"><a href="#2-安装命令" class="headerlink" title="2.安装命令"></a>2.安装命令</h2><ul>
<li>上面的依赖包可以通过 <code>wget</code> 的命令进行下载，然后解压文件， 使用 <code>./configure</code> 命令检查文件，最后通过 <code>make &amp;&amp; make install</code> 命令进行安装</li>
<li>也可以通过 <code>yum -y install make zlib zlib-devel pcre-devel gcc-c++ libtool openssl openssl-devel</code> 一键安装依赖。</li>
<li>最后再安装 Nginx（解压、检查、安装）。安装完以后在 <code>/usr/local/</code> 中会有 nginx 的文件夹。</li>
</ul>
<h2 id="3-测试-Nginx"><a href="#3-测试-Nginx" class="headerlink" title="3.测试 Nginx"></a>3.测试 Nginx</h2><ul>
<li>进入 <code>/usr/local/nginx/sbin</code> 中，执行 <code>./nginx</code> 回车</li>
<li>在 <code>/usr/local/nginx/conf/nginx.conf</code> 中可以看到，nginx 默认监听80端口，所以可以通过 ip 地址+端口号来访问，以此检验 nginx 是否成功启动。</li>
<li>默认是访问不到的，需要在防火墙中添加规则或者关闭防火墙才可以访问到。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*查看开放的端口号*/</span><br><span class="line">firewall-cmd --list-all</span><br><span class="line">/*设置开放的端口号*/</span><br><span class="line">firewall-cmd --add-service=http --permanent</span><br><span class="line">sudo firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line">/*重启防火墙*/</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-Nginx-常用命令"><a href="#4-Nginx-常用命令" class="headerlink" title="4.Nginx 常用命令"></a>4.Nginx 常用命令</h2><blockquote>
<p>使用 nginx 操作命令时，必须进入 <code>/usr/local/nginx/sbin</code> 该目录中。</p>
</blockquote>
<ul>
<li>查看 nginx 版本号： <code>./nginx -v</code> </li>
<li>启动 nginx： <code>./nginx</code></li>
<li>关闭 nginx： <code>./nginx -s stop</code></li>
<li>重新加载 nginx： <code>./nginx -s reload</code></li>
</ul>
<h1 id="三、Nginx-的配置文件"><a href="#三、Nginx-的配置文件" class="headerlink" title="三、Nginx 的配置文件"></a>三、Nginx 的配置文件</h1><h2 id="1-文件位置"><a href="#1-文件位置" class="headerlink" title="1.文件位置"></a>1.文件位置</h2><ul>
<li>在 <code>/usr/local/nginx/sbin</code> 路径中。</li>
</ul>
<h2 id="2-组成部分"><a href="#2-组成部分" class="headerlink" title="2.组成部分"></a>2.组成部分</h2><ul>
<li>全局块：主要设置一些影响 nginx 服务器整体运行的配置指令</li>
<li>events 块：主要影响 nginx 服务器与用户的网络连接</li>
<li>http 块：配置代理、缓存和日志定义等绝大多数功能和第三方模块</li>
<li>http 块中包括：http 全局块和 server 块</li>
<li>server 块中包括：全局 server 块和 location 块</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>U盘向：恢复U盘内的损坏文件</title>
    <url>/14953.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>有时我们的U盘或者内存卡会因为某些不知名原因导致损坏一部分文件，就会生成 <code>LOST.DIR</code> 文件夹，这里面放的便是损坏的文件</li>
<li>该教程用TrlDNET软件识别这些损坏文件</li>
<li>当然，如果你不想下载软件，它也有在线端，请点 <a href="http://mark0.net/onlinetrid.html">这里</a></li>
<li>本教程并不能让你完全恢复，望知悉<span id="more"></span></li>
</ul>
<h1 id="一、操作步骤"><a href="#一、操作步骤" class="headerlink" title="一、操作步骤"></a>一、操作步骤</h1><h2 id="1、找到损失文件的文件夹"><a href="#1、找到损失文件的文件夹" class="headerlink" title="1、找到损失文件的文件夹"></a>1、找到损失文件的文件夹</h2><ol>
<li>进入你的U盘的根目录，找到 <code>LOST.DIR</code> 文件夹，如下：<br><img src="https://i.loli.net/2019/10/20/8cwaESl4XkvDONR.png" alt="文件夹.png"></li>
<li>将整个文件夹复制到电脑上，尽量放到易于找到的地方，比如：桌面</li>
</ol>
<h2 id="2、下载TrlDNet软件和XML定义包"><a href="#2、下载TrlDNet软件和XML定义包" class="headerlink" title="2、下载TrlDNet软件和XML定义包"></a>2、下载TrlDNet软件和XML定义包</h2><blockquote>
<p>TrlDNET通过匹配特征码，来分析文件的类型。TrlDNET拥有强大的特征码支持库，并且这款优秀的软件还是免费的。目前TrIDNet只能以XML格式加载文件类型的定义。</p>
</blockquote>
<blockquote>
<p>XML定义包里面内置了常见的文件格式，只有将XML加载完毕以后，程序才能对文件进行相应的识别。</p>
</blockquote>
<ul>
<li>你可以去官网（<a href="http://mark0.net/soft-tridnet-e.html"> 点这里 </a>），找到 <code>Download</code> 字段，那里就有TrlDNet的主程序和XML定义包</li>
<li>如果官网你点不开或者反应很慢，有可能是国内墙的原因，这里提供了百度云下载：<a href="https://pan.baidu.com/s/1cZpmJcPcQvh7QVfYUZo0JA&amp;shfl=sharepset">https://pan.baidu.com/s/1cZpmJcPcQvh7QVfYUZo0JA&amp;shfl=sharepset</a> 提取码：53z0</li>
<li><font color=#FF0000>注意：下载好的主程序和XML定义包都是压缩包的形式，你得用解压缩软件解压出来</font></li>
</ul>
<h2 id="3、放置XML定义包"><a href="#3、放置XML定义包" class="headerlink" title="3、放置XML定义包"></a>3、放置XML定义包</h2><ul>
<li>解压好以后，将XML文件夹内的 <code>defs</code> 文件夹整体复制到和主程序同一文件夹内，如下：<br><img src="https://i.loli.net/2019/10/20/F6i9dus7JjagSC3.png" alt="同一目录.png"></li>
</ul>
<h2 id="4、打开TrlDNet-exe程序"><a href="#4、打开TrlDNet-exe程序" class="headerlink" title="4、打开TrlDNet.exe程序"></a>4、打开TrlDNet.exe程序</h2><ul>
<li>如果打开以后你的程序下方有这些东西在闪烁，说明你成功的加载XML定义包了，否则重新检查第三步<br><img src="https://i.loli.net/2019/10/20/Vis6Tzd17RhBvel.png" alt="加载XML定义包.png"></li>
<li>当闪烁的地方停止的时候，显示 <code>Definitions in memory</code> 说明成功加载</li>
</ul>
<h2 id="5、开始识别文件格式"><a href="#5、开始识别文件格式" class="headerlink" title="5、开始识别文件格式"></a>5、开始识别文件格式</h2><ul>
<li>你可以点击上方的 <code>Browse</code> 按钮找到你的 <code>LOST.DIR</code> 文件夹中的文件来一个个来识别<br><img src="https://i.loli.net/2019/10/20/9UKjncEWkfXDzep.png" alt="点击Browse.png"></li>
<li>你也可以将文件直接拖动到主程序的窗口处，丢进去以后就会自动开始识别</li>
</ul>
<h2 id="6、通过分析结果来修改文件后缀"><a href="#6、通过分析结果来修改文件后缀" class="headerlink" title="6、通过分析结果来修改文件后缀"></a>6、通过分析结果来修改文件后缀</h2><ul>
<li>分析完以后，该软件会将分析结果按百分比的形式来展示，如下图，<code>Match</code> 字段代表判定概率；<code>Ext</code> 字段代表文件的扩展名；<code>Type</code> 代表文件类型。<br><img src="https://i.loli.net/2019/10/20/9UKjncEWkfXDzep.png" alt="点击Browse.png"></li>
<li>按照最大概率给的文件格式修改后缀名即可。我这里最大概率为MP4，那么我在我的 <code>123456</code> 文件后面加上 <code>.mp4</code> 即可。</li>
<li>如果无法正常打开，就依次尝试剩下的文件扩展名，如果还不行，说明这个文件并不是你想要恢复的文件，直接放弃吧</li>
</ul>
<h1 id="二、注意事项"><a href="#二、注意事项" class="headerlink" title="二、注意事项"></a>二、注意事项</h1><h2 id="1、该软件无法识别TXT文档"><a href="#1、该软件无法识别TXT文档" class="headerlink" title="1、该软件无法识别TXT文档"></a>1、该软件无法识别TXT文档</h2><ul>
<li>因为TXT文件是ASCII明码文件，该软件没有提供此类明码文件的XML定义，所以无法识别，对于该软件无法识别的文件，你可以试着修改为 <code>.txt</code> 后缀名来碰碰运气</li>
</ul>
<h2 id="2、较新的编码方式无法识别"><a href="#2、较新的编码方式无法识别" class="headerlink" title="2、较新的编码方式无法识别"></a>2、较新的编码方式无法识别</h2><ul>
<li>例如：MP3文件以MPEG编码方式的就能识别，但以新编码方式的就不能识别，有时会识成LOTUS 123的工作页文件 <code>.WK*</code> 。因为新编码的MP3文件的内容较杂，其中很多内容与LOTUS工作页文件的识别代码相同，所以会误识别</li>
</ul>
<h2 id="3、自制XML定义包"><a href="#3、自制XML定义包" class="headerlink" title="3、自制XML定义包"></a>3、自制XML定义包</h2><ul>
<li>如果你动手能力不错，也可以自己制作XML识别定义，甚至可以将XML识别代码写成病毒代码，这样就能查找文件病毒。</li>
</ul>
<h2 id="4-为什么会有几K的小文件？"><a href="#4-为什么会有几K的小文件？" class="headerlink" title="4.为什么会有几K的小文件？"></a>4.为什么会有几K的小文件？</h2><ul>
<li>这些文件一般是Andriod系统收集的SD卡扇区或簇的未及时回写的数据垃圾，基本没用的，也基本上不会是你想找回的文件。假如你的SD卡分区时一个扇区是4K,那么这些小文件中4K大小的就会最多了。</li>
</ul>
<h2 id="5-拓展"><a href="#5-拓展" class="headerlink" title="5.拓展"></a>5.拓展</h2><ul>
<li>该软件并不仅仅帮你恢复内存卡或者U盘的损失文件，甚至手机内存有损失文件时也可以帮助你快速恢复。当然了，你也可以把该软件作为一个文件格式识别软件，只要将你想要识别的文件丢进去即可，其余功能请自行探索，祝你玩的愉快！</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>干货</tag>
        <tag>U盘</tag>
      </tags>
  </entry>
  <entry>
    <title>小白教程：V2Ray搭建服务器之基础搭建教程</title>
    <url>/V2Ray-02.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>如果你想要自己动手搭建一个梯子来使用，那么你可以试着按本系列的教程进行搭建</li>
<li>本文从服务器的购买、配置，V2Ray 服务器端的配置，V2Ray 软件端的下载等方面详细展开</li>
<li><font color=#FF0000>注意：请不要进行任何商业行为，产生任何后果都与本人无关</font><span id="more"></span></li>
</ul>
<h1 id="一、购买国外服务器"><a href="#一、购买国外服务器" class="headerlink" title="一、购买国外服务器"></a>一、购买国外服务器</h1><h2 id="1-为什么选用国外服务器？"><a href="#1-为什么选用国外服务器？" class="headerlink" title="1.为什么选用国外服务器？"></a>1.为什么选用国外服务器？</h2><ul>
<li>首先，国外大部分服务器都是按时付费，且十分便宜；国内服务器即使有学生价，但依然很贵</li>
<li>其次，如果想要科学上网，理论上用国内服务器并不容易实现，所以这里选择国外服务器</li>
</ul>
<h2 id="2-选用哪些国外服务器？"><a href="#2-选用哪些国外服务器？" class="headerlink" title="2.选用哪些国外服务器？"></a>2.选用哪些国外服务器？</h2><ul>
<li>国外服务器现在比较出名的有这几个：搬瓦工、Vultr、DigitalOcean、Google Cloud等。</li>
<li>一般选用服务器考虑 cpu、ssd、月带宽、服务器位置等。正常来说，如果只是单纯想要搭个梯子，只要一核、256M 内存、20G 固态、500G 月带宽即可</li>
<li>本系列教程使用的是 <font color=#F00>Vultr 和 Google Cloud</font>，其他请自行百度</li>
</ul>
<h2 id="3-购买服务器详细教程"><a href="#3-购买服务器详细教程" class="headerlink" title="3.购买服务器详细教程"></a>3.购买服务器详细教程</h2><ul>
<li>请移步这篇文章 —— <a href="/V2Ray-01.html" title="[服务器购买教程]">[服务器购买教程]</a></li>
<li>我这里整理了一下 Google Cloud 和 Vultr 两家的教程，方便大家选择</li>
</ul>
<h1 id="二、使用-Xshell-终端连接服务器"><a href="#二、使用-Xshell-终端连接服务器" class="headerlink" title="二、使用 Xshell 终端连接服务器"></a>二、使用 Xshell 终端连接服务器</h1><h2 id="1-安装-Xshell-终端"><a href="#1-安装-Xshell-终端" class="headerlink" title="1.安装 Xshell 终端"></a>1.安装 Xshell 终端</h2><ul>
<li>你可以去 Xshell 官网下载，但请注意：Xshell 并不是免费软件，如果你从官方网站下载，那么你必须购买才可以。官网点击 <a href="http://www.xshellcn.com/">这里</a> 。</li>
<li>如果你没有足够的预算，那么这里提供了免(po)费(jie)版<br>百度云下载点 <a href="https://pan.baidu.com/s/1fJ51NMjH4Ywf34yLmXy0Ug">这里</a> 提取码：e8hb。<br>蓝奏云下载点 <a href="https://www.lanzous.com/i6ra8kb">这里</a> 。</li>
<li>下载好后解压并打开软件</li>
</ul>
<h2 id="2-会话新建与连接"><a href="#2-会话新建与连接" class="headerlink" title="2.会话新建与连接"></a>2.会话新建与连接</h2><ul>
<li>左上角新建一个会话</li>
<li>名称随便填，IP 地址就是你服务器的 IP 地址<br><img src="https://i.loli.net/2019/10/13/JRYFxtfgEMCZ3NT.png" alt="新建会话.png"></li>
<li>点击用户身份验证，将服务器的用户名和密码填入，然后点击连接<br><img src="https://i.loli.net/2019/10/13/EwvMeAnhyISWo2J.png" alt="用户身份验证.png"></li>
<li>注意：首次连接服务器会出现 SSH 安全警告，点击 <code>接受并保持</code> 即可<br><img src="https://i.loli.net/2019/10/13/PW8N6ot2hyqzXCk.png" alt="主机密匙.png"></li>
<li>此时，就会成功连接你的服务器，如果没有连接成功请重新测试，如果还不行，请检测你的22端口是否关闭<br><img src="https://i.loli.net/2020/02/10/ieKJXvNwZqxPsIS.png" alt="成功连接.png"></li>
</ul>
<h1 id="三、在服务器上搭建-V2Ray"><a href="#三、在服务器上搭建-V2Ray" class="headerlink" title="三、在服务器上搭建 V2Ray"></a>三、在服务器上搭建 V2Ray</h1><h2 id="1-使用一键安装脚本安装-V2Ray"><a href="#1-使用一键安装脚本安装-V2Ray" class="headerlink" title="1.使用一键安装脚本安装 V2Ray"></a>1.使用一键安装脚本安装 V2Ray</h2><ul>
<li>推荐使用 <code>一键安装脚本</code> ，一行代码即可完成所有东西的安装</li>
<li>复制下面的代码，在 Xshell 黑色命令行中右键粘贴，按回车进行安装。<font color=#FF0000>注意：命令行中不可以用 Ctrl+V 快捷键进行粘贴</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure></li>
<li>输入1进行安装<br><img src="https://i.loli.net/2019/09/29/dFov9fqShz1kEK8.png" alt="1.安装.png"></li>
</ul>
<h2 id="2-完成相应的配置"><a href="#2-完成相应的配置" class="headerlink" title="2.完成相应的配置"></a>2.完成相应的配置</h2><ul>
<li>选择传输协议：没有特殊需求就使用默认的 <code>TCP</code> 即可<br><img src="https://i.loli.net/2019/09/29/h3ovceWPsyq7ZKR.png" alt="2TCP协议.png"></li>
<li>选择端口号：端口号自己随意设置，但为了避免与其余设置造成冲突，建议使用1000以上65535以下的端口号，这里我直接设置为 <code>38222</code><br><img src="https://i.loli.net/2019/09/29/4XpGDoa1OMkZuTN.png" alt="3v2ray端口.png"></li>
<li>选择广告拦截：建议不要开启，开启广告拦截会消耗服务器资源<br><img src="https://i.loli.net/2019/09/29/3ETheAdJMiFtzLj.png" alt="4广告拦截.png"></li>
<li>选择开启SS：建议开启，iOS 端没有 V2Ray 客户端，可以借由 SS 客户端进行登陆，所以需要开启 SS<br><img src="https://i.loli.net/2019/09/29/EIUijtAshe1v3Fd.png" alt="5配置SS.png"></li>
<li>选择 SS 端口号：依然自己随意设置，但不可以和上面的 V2Ray 端口号一样，这里我直接设置为 <code>10086</code><br><img src="https://i.loli.net/2019/09/29/5VM8sCzcR1Z3Sl4.png" alt="6S端口.png"></li>
<li>设置 SS 连接密码：只要自己能记住即可<br><img src="https://i.loli.net/2019/09/29/C73JeSh89dOBlRt.png" alt="7SS密码.png"></li>
<li>选择 SS 加密协议：推荐使用默认的，我这里使用的另一种。这个其实因人而异，建议有时间每个都试一下，看看哪个更快点，相比较而言，cha 更为安全一些<br><img src="https://i.loli.net/2019/09/29/Vcs13OxhWMmUgSP.png" alt="8加密协议.png"></li>
<li>配置完成以后，会让你进行核对，然后直接两次回车，静待几分钟即可完成服务器搭建。<br><img src="https://i.loli.net/2019/09/29/ySiB7FVbuw6DXao.png" alt="9核对.png"></li>
<li><span id="jump">完成界面如下，在命令行中输入 <code>v2ray</code> 即可进行相应的配置</span><br><img src="https://i.loli.net/2019/09/29/IpkYyXF61zwrJBM.png" alt="10成功界面.png"></li>
</ul>
<h1 id="四、为服务器开启-BBR-加速"><a href="#四、为服务器开启-BBR-加速" class="headerlink" title="四、为服务器开启 BBR 加速"></a>四、为服务器开启 BBR 加速</h1><ul>
<li>Google BBR 是一款免费开源的 TCP拥塞传输控制协议，可以使 Linux 服务器显著提高吞吐量和减少 TCP 连接的延迟。项目地址请看 <a href="https://github.com/google/bbr">这里</a>（<font color=#FF0000>这个是 GitHub的项目，可能因为国内墙的原因打不开</font>）</li>
<li>注意：按本文教程在服务器端安装的 Debian9系统的话，BBR 加速是默认自动开启的，不用管</li>
<li>如果是其他系统，请看下面的方法</li>
</ul>
<h2 id="1-ubuntu-18-04开启-BBR-加速"><a href="#1-ubuntu-18-04开启-BBR-加速" class="headerlink" title="1.ubuntu 18.04开启 BBR 加速"></a>1.ubuntu 18.04开启 BBR 加速</h2><ol>
<li>修改系统变量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li>
<li>保存生效<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li>
<li>检查 BBR 是否开启<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回如下说明 <font color=#FF0000>开启成功</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control = bbr cubic reno</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>检查 BBR 是否启动成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回如下说明 <font color=#FF0000>开启成功</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp_bbr                20480  14</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-CentOS-7开启-BBR-加速"><a href="#2-CentOS-7开启-BBR-加速" class="headerlink" title="2.CentOS 7开启 BBR 加速"></a>2.CentOS 7开启 BBR 加速</h2><ol>
<li>yum 系统更新<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum update</span><br></pre></td></tr></table></figure></li>
<li>查看系统版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回如下表示升级到了7.6<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>安装 elrepo 并升级内核，三条命令分别执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span><br><span class="line">yum --enablerepo=elrepo-kernel install kernel-ml -y</span><br></pre></td></tr></table></figure></li>
<li>安装完成后使用下面命令查看当前已安装的内核<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F\&#x27; &#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27; /etc/grub2.cfg</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 : CentOS Linux (4.19.0-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">1 : CentOS Linux 7 Rescue ee7953a3b5944053a26f29daf8c71e2f (3.10.0-862.14.4.el7.x86_64)</span><br><span class="line">2 : CentOS Linux (3.10.0-862.14.4.el7.x86_64) 7 (Core)</span><br><span class="line">3 : CentOS Linux (3.10.0-862.3.2.el7.x86_64) 7 (Core)</span><br><span class="line">4 : CentOS Linux (3.10.0-862.el7.x86_64) 7 (Core)</span><br><span class="line">5 : CentOS Linux (0-rescue-4bbda2095d924b72b05507b68bd509f0) 7 (Core)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>把 CentOS Linux (4.19.0-1.el7.elrepo.x86_64) 7 (Core)内核设置为默认<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure></li>
<li>重启服务器<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure></li>
<li>设置 BBR，先编辑配置文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br></pre></td></tr></table></figure></li>
<li>添加如下内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.core.default_qdisc = fq</span><br><span class="line">net.ipv4.tcp_congestion_control = bbr</span><br></pre></td></tr></table></figure></li>
<li>加载系统参数（正常情况下会输出我们之前加入的内容）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></li>
<li>验证 BBR 是否已经开启<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回如下说明 <font color=#FF0000>开启成功</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_available_congestion_control = reno cubic bbr</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="11">
<li>检查 BBR 是否启动成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回如下说明 <font color=#FF0000>开启成功</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tcp_bbr                20480  2</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、各终端上分别配置-V2Ray-客户端"><a href="#五、各终端上分别配置-V2Ray-客户端" class="headerlink" title="五、各终端上分别配置 V2Ray 客户端"></a>五、各终端上分别配置 V2Ray 客户端</h1><h2 id="◇-Windows端"><a href="#◇-Windows端" class="headerlink" title="◇ Windows端"></a>◇ Windows端</h2><h3 id="1-下载-v2rayN"><a href="#1-下载-v2rayN" class="headerlink" title="1.下载 v2rayN"></a>1.下载 v2rayN</h3><ul>
<li>下载地址：百度云点 <a href="https://pan.baidu.com/s/1dUgoyl1X6a8ta0ybWDuDZQ">这里</a>（提取码: vnm7）。蓝奏云点 <a href="https://www.lanzous.com/i97n25g">这里</a>。GitHub 点 <a href="https://github.com/v2ray/v2ray-core/releases">这里</a>。</li>
<li>由于 v2rayN 是 <font color=#FF0000>绿色安装</font> ，所以下载完成后 <font color=#FF0000>解压</font> 至D盘或者其他盘符</li>
</ul>
<h3 id="2-运行-V2rayN"><a href="#2-运行-V2rayN" class="headerlink" title="2.运行 V2rayN"></a>2.运行 V2rayN</h3><ul>
<li>双击打开 v2rayN，双击后可能没反应，别着急，在右下角状态栏找到 v2rayN 图标，再单击一次，软件界面就出来了。</li>
</ul>
<h3 id="3-获取-V2ray-vmess"><a href="#3-获取-V2ray-vmess" class="headerlink" title="3.获取 V2ray vmess"></a>3.获取 V2ray vmess</h3><ul>
<li>打开 Xshell 终端连接上搭好的服务器，输入以下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2ray url</span><br></pre></td></tr></table></figure></li>
<li>复制蓝色的那段 url</li>
</ul>
<h3 id="4-导入-vmess"><a href="#4-导入-vmess" class="headerlink" title="4.导入 vmess"></a>4.导入 vmess</h3><ul>
<li>打开 v2rayN 软件界面，点击左上角的服务器，点击 <code>从剪切板导入批量url</code><br><img src="https://i.loli.net/2020/02/10/kgRQqhwpts97PLV.png" alt="导入vmess.png"></li>
</ul>
<h3 id="5-测试服务器"><a href="#5-测试服务器" class="headerlink" title="5.测试服务器"></a>5.测试服务器</h3><ul>
<li>右键点击刚刚导入的服务器，点击 <code>测试服务器延迟</code> ，测试结果显示 <code>** ms</code> 的话就说明服务器连接成功了。</li>
</ul>
<h3 id="6-开启代理模式"><a href="#6-开启代理模式" class="headerlink" title="6.开启代理模式"></a>6.开启代理模式</h3><ul>
<li>右键点击状态栏的 v2rayN 图标，把 <code>启用Http代理</code> 打上勾，然后选择 <code>Http代理模式</code> ，选择第二个 <code>PAC模式</code> ，接下来就能愉快的连接互联网啦。</li>
<li>PAC模式：只有在访问被墙了网站才会启用代理。</li>
<li>全局模式：所有连接都走代理。</li>
</ul>
<h2 id="◇-Android端"><a href="#◇-Android端" class="headerlink" title="◇ Android端"></a>◇ Android端</h2><h3 id="1-下载-V2RayNG"><a href="#1-下载-V2RayNG" class="headerlink" title="1.下载 V2RayNG"></a>1.下载 V2RayNG</h3><ul>
<li>下载地址：百度云点 <a href="https://pan.baidu.com/s/1K1v9CrdmbKbgDPTxFdtJLQ">这里</a>（提取码: yjbm）。蓝奏云点 <a href="https://www.lanzous.com/i97peqb">这里</a>。GitHub 点 <a href="https://github.com/2dust/v2rayNG/releases">这里</a>。</li>
</ul>
<h3 id="2-导入-vmess"><a href="#2-导入-vmess" class="headerlink" title="2.导入 vmess"></a>2.导入 vmess</h3><ul>
<li>安装完成后，打开 Xshell 终端并连接搭建好的服务器，输入以下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2ray qr</span><br></pre></td></tr></table></figure></li>
<li>复制蓝色的链接，到浏览器粘贴打开。</li>
<li>手机打开 V2RayNG 软件，点击右上角“+”号，点击扫描二维码，扫描刚才打开的网页二维码即可</li>
<li>当然也可以和电脑端一样，使用 url 进行从剪贴板的导入，自行摸索即可。</li>
</ul>
<h3 id="3-修改路由模式"><a href="#3-修改路由模式" class="headerlink" title="3.修改路由模式"></a>3.修改路由模式</h3><ul>
<li>左上角三横杠处，设置-路由模式-绕过局域网及大陆地址</li>
<li>全局模式：所有连接都走代理</li>
<li>绕过局域网及大陆地址：国内地址不启用代理</li>
</ul>
<h2 id="◇-IOS端"><a href="#◇-IOS端" class="headerlink" title="◇ IOS端"></a>◇ IOS端</h2><h3 id="1-软件下载"><a href="#1-软件下载" class="headerlink" title="1.软件下载"></a>1.软件下载</h3><ul>
<li>需要国外的 icloud 账号，推荐shadowrocket（小火箭），quantumult（圈），kitsunebi</li>
<li>这里提供 shadowrocket 软件，不保证可以完美使用，最好自己用国外账号下载一个</li>
<li>下载地址：点击 <a href="https://www.lanzous.com/i8i2cwh">这里</a>。（请使用 IOS 自带的 safari 浏览器下载）</li>
</ul>
<h3 id="2-添加节点"><a href="#2-添加节点" class="headerlink" title="2.添加节点"></a>2.添加节点</h3><ul>
<li>将上面 V2Ray 安装过程中设置的 Shadowsocks 配置信息一一填好即可，没有的内容不需要填</li>
<li>不知道哪个的 <a href="#jump">点击这里</a> 跳转过去</li>
<li>点击连接，允许添加 vpn 图标即可使用</li>
</ul>
<h2 id="◇-Linux端"><a href="#◇-Linux端" class="headerlink" title="◇ Linux端"></a>◇ Linux端</h2><ul>
<li>Debian、Ubuntu、CentOS等电脑桌面发行版（不能完全通用，可以尝试一下）</li>
<li>下载地址：点击 <a href="https://github.com/jiangxufeng/v2rayL/releases">这里</a></li>
</ul>
<h2 id="◇-Mac-OS端"><a href="#◇-Mac-OS端" class="headerlink" title="◇ Mac OS端"></a>◇ Mac OS端</h2><ul>
<li>下载地址：点击 <a href="https://github.com/Cenmrev/V2RayX/releases">这里</a></li>
</ul>
<h2 id="◇-路由器端"><a href="#◇-路由器端" class="headerlink" title="◇ 路由器端"></a>◇ 路由器端</h2><ul>
<li>使用服务器客户端的优点就是路由器配置好后，路由器下局域网内所有设备无需配置就能直接访问外网。（前提是需要路由器支持）</li>
<li>因为本人没有这种路由器，该部分教程引用网上教程。原文在 <a href="https://www.noobyy.com/126.html">这里</a>。以LEDE软路由为例。</li>
</ul>
<h3 id="1-安装-V2Ray"><a href="#1-安装-V2Ray" class="headerlink" title="1.安装 V2Ray"></a>1.安装 V2Ray</h3><ul>
<li>打开 LEDE 的软件中心，安装 V2Ray 插件。</li>
</ul>
<h3 id="2-获取-V2Ray-vmess"><a href="#2-获取-V2Ray-vmess" class="headerlink" title="2.获取 V2Ray vmess"></a>2.获取 V2Ray vmess</h3><ul>
<li>打开 Xshell 终端连接上搭好的服务器，输入以下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v2ray url</span><br></pre></td></tr></table></figure></li>
<li>复制蓝色的那段url</li>
</ul>
<h3 id="3-导入-vmess"><a href="#3-导入-vmess" class="headerlink" title="3.导入 vmess"></a>3.导入 vmess</h3><ul>
<li>打开 V2Ray 插件，勾选代理开关，点击服务器列表</li>
<li>在通过 vmess 链接添加节点处 粘贴刚刚复制的链接<br><img src="https://i.loli.net/2020/02/10/wZapLRltFqIYxQV.jpg" alt="路由器LEDE-填写vmess.jpg"></li>
</ul>
<h3 id="4-开启-V2Ray"><a href="#4-开启-V2Ray" class="headerlink" title="4.开启 V2Ray"></a>4.开启 V2Ray</h3><ul>
<li>点击账号设置，代理模式选择“gfwlist”模式，服务器选择刚刚添加的那个服务器，点击提交。<br><img src="https://i.loli.net/2020/02/10/iUOZN7vHqKpmLn3.jpg" alt="路由器LEDE-完成.jpg"></li>
</ul>
<h1 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h1><h2 id="1-谷歌浏览器无法翻墙的方法"><a href="#1-谷歌浏览器无法翻墙的方法" class="headerlink" title="1.谷歌浏览器无法翻墙的方法"></a>1.谷歌浏览器无法翻墙的方法</h2><ul>
<li>梯子成功搭建，其他浏览器可以翻墙，但谷歌无法翻墙，涉及到的原因有很多，这里不一一解释，可以按下面的自行排除</li>
</ul>
<ol>
<li>修改谷歌浏览器高级设置中的代理</li>
<li>关闭谷歌的一些插件，你给谷歌装了其他的扩展接管了代理设置才导致的无法使用</li>
<li>修改电脑的DNS，Hosts试试</li>
</ol>
<h2 id="2-谷歌浏览器突然无法进入-GitHub"><a href="#2-谷歌浏览器突然无法进入-GitHub" class="headerlink" title="2.谷歌浏览器突然无法进入 GitHub"></a>2.谷歌浏览器突然无法进入 GitHub</h2><ul>
<li>谷歌浏览器突然无法进入而其他浏览器可以进入，并且诊断网络时提示 <code>该设备或资源（127.0.0.1）未设置为接受端口&quot;10810&quot;上的连接</code>，这种情况很有可能是谷歌浏览器的代理设置出了问题</li>
<li>只要打开谷歌浏览器，在 <strong>设置-高级-系统-打开您计算机的代理设置</strong> 中将 <strong>自动检测</strong> 开关打开即可</li>
</ul>
<h1 id="七、本系列文章"><a href="#七、本系列文章" class="headerlink" title="七、本系列文章"></a>七、本系列文章</h1><ul>
<li>想要了解V2Ray的服务器购买教程请移步这里：<a href="/V2Ray-01.html" title="[小白教程：V2Ray搭建服务器之服务器的购买]">[小白教程：V2Ray搭建服务器之服务器的购买]</a></li>
<li>想要了解V2Ray的进阶优化教程请移步这里：<a href="/V2Ray-03.html" title="[小白教程：V2Ray搭建服务器之进阶优化教程]">[小白教程：V2Ray搭建服务器之进阶优化教程]</a></li>
<li>想要了解V2Ray的拓展资料请移步这里：<a href="/V2Ray-04.html" title="[小白教程：V2Ray搭建服务器之拓展资料]">[小白教程：V2Ray搭建服务器之拓展资料]</a></li>
</ul>
]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>翻墙</tag>
        <tag>V2Ray</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：Java</title>
    <url>/Learn-Java.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习Java课程时的一些笔记</li>
<li>关于java中的一些基础知识点，尚学堂的笔记中有提到，可直接点击 <a href="https://www.sxt.cn/Java_jQuery_in_action/thirteen-animation-effects.html">这里</a> 查看<span id="more"></span></li>
</ul>
<h1 id="一、知识点梳理"><a href="#一、知识点梳理" class="headerlink" title="一、知识点梳理"></a>一、知识点梳理</h1><h2 id="1-关于形参与实参"><a href="#1-关于形参与实参" class="headerlink" title="1.关于形参与实参"></a>1.关于形参与实参</h2><h2 id="2-关于方法的定义"><a href="#2-关于方法的定义" class="headerlink" title="2.关于方法的定义"></a>2.关于方法的定义</h2><h2 id="3-java中的排序方法"><a href="#3-java中的排序方法" class="headerlink" title="3.java中的排序方法"></a>3.java中的排序方法</h2><h2 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h2><ul>
<li>最重要的是：找递归出口，如果找不到出口就会形成死递归，无法结束</li>
<li>递归的实质就是在方法中再调用方法，故方法得设计好才行</li>
</ul>
<h2 id="5-如何实现从键盘获取数据"><a href="#5-如何实现从键盘获取数据" class="headerlink" title="5.如何实现从键盘获取数据"></a>5.如何实现从键盘获取数据</h2><ul>
<li>需要使用到 <code>Scanner</code> 关键字</li>
<li>具体实现方法如下代码块<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class Demo&#123;</span><br><span class="line">  public static void main(Strint[] args)&#123;</span><br><span class="line">    Scanner scan=new Scanner(System.in);</span><br><span class="line">    System.out.println(&quot;请输入变量a的值：&quot;);</span><br><span class="line">    int a=scan.nextInt();</span><br><span class="line">    ···</span><br><span class="line">    scan.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>因为需要从键盘获取数据，所以需要有第一行的代码来导入需要用到的类接口</li>
<li>最后一行的 <code>scan.close();</code> 用来关闭scan</li>
</ul>
<h2 id="6-String类的substring-方法"><a href="#6-String类的substring-方法" class="headerlink" title="6.String类的substring()方法"></a>6.String类的substring()方法</h2><ul>
<li><p>该方法是用来截取字符串的</p>
</li>
<li><p><code>public String substring(int beginIndex)</code> 返回一个新字符串，它是此字符串的一个子字符串。该子字符串始于指定索引处的字符，一直到此字符串末尾。</p>
<blockquote>
<p>例：”unhappy”.substring(2)   returns”happy”</p>
</blockquote>
</li>
<li><p><code>public String substring(int beginIndex, int endIndex)</code> 返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，到指定的 endIndex-1处结束。</p>
<blockquote>
<p>例：”smiles”.substring(0,5) returns “smile”</p>
</blockquote>
</li>
</ul>
<h1 id="二、问题总结"><a href="#二、问题总结" class="headerlink" title="二、问题总结"></a>二、问题总结</h1><h2 id="1-在安装时命令行输入java命令时出错"><a href="#1-在安装时命令行输入java命令时出错" class="headerlink" title="1.在安装时命令行输入java命令时出错"></a>1.在安装时命令行输入java命令时出错</h2><ul>
<li>出错内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error: Registry key &#x27;Software\JavaSoft\Java Runtime Environment&#x27;\CurrentVersion&#x27;</span><br><span class="line">has value &#x27;1.7&#x27;, but &#x27;1.8&#x27; is required.</span><br><span class="line">Error: could not find java.dll</span><br><span class="line">Error: Could not find Java SE Runtime Environment.</span><br></pre></td></tr></table></figure></li>
<li>原因分析：这是电脑中以前装过jdk8版本且没有卸载完整，而且在环境变量的顶部出现了以下内容：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Common Files\Oracle\Java\javapath;</span><br></pre></td></tr></table></figure></li>
<li>解决方法如下：</li>
</ul>
<ol>
<li>先完整卸载所有的jdk和jre软件</li>
<li>进入环境变量的path中，把顶部的这条删掉：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files (x86)\Common Files\Oracle\Java\javapath;</span><br></pre></td></tr></table></figure></li>
<li>找到以上路径的Java文件夹，直接将其删除</li>
<li>重新安装jdk7版本，并且进行相应的环境变量设置，即可正常运行</li>
</ol>
<h2 id="2-定义变量时的冗杂"><a href="#2-定义变量时的冗杂" class="headerlink" title="2.定义变量时的冗杂"></a>2.定义变量时的冗杂</h2><ul>
<li>总是先定义变量再重新给变量赋值，其实可以一步到位，减少代码数量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sum=0;</span><br><span class="line">for(int x=1;x&lt;100;x++)&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-定义方法时出错"><a href="#3-定义方法时出错" class="headerlink" title="3.定义方法时出错"></a>3.定义方法时出错</h2><ul>
<li>经检查发现方法的位置写错了地方，应该是写在主函数的外面，但是我写在了主函数的里面，所以导致无法调用方法</li>
</ul>
<h2 id="4-通过Scanner获取键盘输入时一直无法进入程序"><a href="#4-通过Scanner获取键盘输入时一直无法进入程序" class="headerlink" title="4.通过Scanner获取键盘输入时一直无法进入程序"></a>4.通过Scanner获取键盘输入时一直无法进入程序</h2><ul>
<li>经检查发现，是程序内部并不能成功运行，导致无法进行，遇到这种情况一定要仔细检查程序</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：数据库</title>
    <url>/Learn-Date.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习数据库课程时的一些笔记<span id="more"></span></li>
</ul>
<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h2><ul>
<li>数据是数据库中存储的基本对象</li>
<li>描述事物的符号记录称为数据</li>
</ul>
<h2 id="2-数据的解释"><a href="#2-数据的解释" class="headerlink" title="2.数据的解释"></a>2.数据的解释</h2><ul>
<li>是指对数据含义的说明，<font color=#FF0000>数据的含义称为数据的语义，数据与其语义是不可分的</font></li>
</ul>
<h2 id="3-记录"><a href="#3-记录" class="headerlink" title="3.记录"></a>3.记录</h2><ul>
<li>将所需要描述的信息组织在一起，构成一个记录</li>
<li>记录是计算机中表示和存储数据的一种格式或方法</li>
</ul>
<h2 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4.数据库"></a>4.数据库</h2><ul>
<li>数据库是长期储存在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和储存，具有较小的冗余度、较高的数据独立性和易扩展性，并可为各种用户共享</li>
<li>数据库数据具有永久存储、有组织和可共享三个基本特点</li>
</ul>
<h2 id="5-数据库管理系统"><a href="#5-数据库管理系统" class="headerlink" title="5.数据库管理系统"></a>5.数据库管理系统</h2><ul>
<li>位于用户与操作系统之间的一层数据管理软件，是计算机的基础软件，也是一个大型复杂的软件系统</li>
<li>主要功能：数据定义功能；数据组织、存储和管理；数据操纵功能；数据库的事务管理和运行管理；数据库的建立和维护功能；数据库管理系统与网络中其他软件系统的通信功能；一个数据库管理系统与另一个数据库管理系统或文件系统的数据转换功能；异构数据库之间的互访和互操作功能</li>
</ul>
<h2 id="6-数据库系统"><a href="#6-数据库系统" class="headerlink" title="6.数据库系统"></a>6.数据库系统</h2><ul>
<li>是由数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员组成的存储、管理、处理和维护数据的系统</li>
<li>数据库系统简称为数据库</li>
</ul>
<h2 id="7-数据库系统的特点"><a href="#7-数据库系统的特点" class="headerlink" title="7.数据库系统的特点"></a>7.数据库系统的特点</h2><ol>
<li>数据结构化：实现整体数据的的结构化（<font color=#ff0000>主要特征</font>），是数据库系统与文件系统的本质区别</li>
<li>数据的共享性高、冗余度低且易扩充：数据共享可以大大减少数据冗余，节省存储空间，避免数据之间的不相容性与不一致性</li>
<li>数据的独立性高：包括数据的物理独立性和逻辑独立性，是由数据库管理系统提供的二级映像功能来保证的</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
<h2 id="8-数据模型"><a href="#8-数据模型" class="headerlink" title="8.数据模型"></a>8.数据模型</h2><ul>
<li>是对现实世界数据特征的抽象，是数据库系统的核心和基础</li>
<li>根据模型应用的不同目的，分为两类：一类是概念模型，一类是逻辑模型和物理模型<blockquote>
<p>逻辑模型主要包括层次模型、网状模型、关系模型、面向对象数据模型和对象关系数据模型、半结构化数据模型</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：云计算</title>
    <url>/Learn-Cloud.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>该篇记录了关于云计算方向的某些重要知识点<span id="more"></span></li>
</ul>
<h1 id="一、云计算基础内容"><a href="#一、云计算基础内容" class="headerlink" title="一、云计算基础内容"></a>一、云计算基础内容</h1><h2 id="1-云计算"><a href="#1-云计算" class="headerlink" title="1.云计算"></a>1.云计算</h2><ul>
<li>是分布式计算、并行计算和网格计算的进一步延伸。基于互联网实现计算，这里的云是指通过互联网连接，以支持各类计算的资源</li>
<li>从用户角度而言，云计算是由第三方通过互联网提供的计算服务，只需关心云所提供的服务</li>
<li>从计算角度而言，云计算是由一组内部互联的物理服务器组成的并行和分布式计算系统，该系统能够根据服务提供商和客户之间协商好的服务等级协议动态提供计算资源</li>
<li>从服务角度而言，云计算是指通过互联网提供的弹性的硬件、软件和数据服务，使得计算能力不再封装于具体的软硬件产品中，而是以社会化服务的形式呈现</li>
<li>从存储角度而言，云计算主要是将信息永久存储在云上的服务器中，在使用信息时只是在客户端进行缓存</li>
<li>从配置角度而言，云是以付费使用的形式向用户提供各种服务的分布式计算系统。该系统对于用户来说是透明的</li>
</ul>
<h2 id="2-云服务的使用形态"><a href="#2-云服务的使用形态" class="headerlink" title="2.云服务的使用形态"></a>2.云服务的使用形态</h2><ul>
<li>公共云、专有云、混合云</li>
</ul>
<h2 id="3-服务计算"><a href="#3-服务计算" class="headerlink" title="3.服务计算"></a>3.服务计算</h2><ul>
<li>云计算以服务计算为核心技术。</li>
<li>服务计算是指面向服务的体系结构（SOA）和面向服务的计算（SOA）技术</li>
</ul>
<h2 id="4-服务类型"><a href="#4-服务类型" class="headerlink" title="4.服务类型"></a>4.服务类型</h2><ul>
<li>基础设施即服务（IaaS）：给用户提供对所有设施的利用服务</li>
<li>平台即服务（PaaS）：将软件研发的平台作为一种服务，是SaaS模式的一种应用</li>
<li>软件即服务（SaaS）：是一种软件交付模式</li>
</ul>
<h2 id="5-云计算的特性"><a href="#5-云计算的特性" class="headerlink" title="5.云计算的特性"></a>5.云计算的特性</h2><ul>
<li>云中资源在使用者看来可以无限扩展，且可以随时获取、按需使用、按使用量付费</li>
<li>可以管理、调度、整合、优化分布在网络上的资源，并以统一界面为用户提供各类计算服务</li>
<li>按需服务：用户按照自己需求来获取计算资源</li>
<li>通用性：可以在云端衍生出各种应用，且适用范围广</li>
<li>超大规模计算能力</li>
<li>实时在线</li>
<li>高可靠性：云计算提供商采用多副本容错、计算节点同构等措施</li>
<li>虚拟化：支持用户在任意位置、使用各种终端获取服务</li>
<li>高可伸缩性：其规模可以动态伸缩，满足应用和用户规模增长的需要</li>
</ul>
<h2 id="5-云计算的价值"><a href="#5-云计算的价值" class="headerlink" title="5.云计算的价值"></a>5.云计算的价值</h2><ol>
<li>没有前期投资</li>
<li>低成本</li>
<li>灵活的容量</li>
<li>速度和灵敏性</li>
<li>应用而非运营</li>
<li>覆盖全球</li>
</ol>
<h1 id="一、云计算相关网络基础"><a href="#一、云计算相关网络基础" class="headerlink" title="一、云计算相关网络基础"></a>一、云计算相关网络基础</h1><h2 id="云计算特点"><a href="#云计算特点" class="headerlink" title="云计算特点"></a>云计算特点</h2><ul>
<li>大分小，小聚大</li>
</ul>
<h2 id="网络在云计算中的作用"><a href="#网络在云计算中的作用" class="headerlink" title="网络在云计算中的作用"></a>网络在云计算中的作用</h2><ol>
<li>将计算与存储通过网络传给用户</li>
<li>容灾——备份系统</li>
</ol>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ol>
<li>局域网——方圆5里内<br>广域网——5里以外</li>
<li>公网——运营商的网络<br>私网——学校内部的网络</li>
<li>局域网内部使用的是MAC地址，使用交换机设备</li>
</ol>
<h2 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h2><ol>
<li>常用CE级别的数据中心的交换机</li>
<li>包括二层交换引擎（实现同一网段的快速二层转发）和三层交换引擎（实现跨网段的路由转发）</li>
</ol>
<h2 id="VLAN——虚拟局域网（重点）"><a href="#VLAN——虚拟局域网（重点）" class="headerlink" title="VLAN——虚拟局域网（重点）"></a>VLAN——虚拟局域网（重点）</h2><ol>
<li>可以隔离广播域——减少广播站的数量、提高安全性、提高信息安全使不会泛洪</li>
<li>VLAN帧格式中包含Tag（标签）——TPID（固定0x8100）、PRI（优先级，默认0<del>7）、CFI（固定为0）、VLAN ID(12字节，1</del>4094)</li>
<li>PVID：表示端口在缺省情况下所属的VLAN</li>
<li>接入链路（Access)：交换机与PC之间、交换机与路由器之间<br>干道链路（Trunk）：允许多个列表之间传输。适用于交换机与交换机之间</li>
<li>VLAN在云中的时候，服务器与交换机要用Trunk链路，实际是虚拟交换机与交换机之间相连</li>
<li>VXLAN</li>
</ol>
<h2 id="AD——活动目录"><a href="#AD——活动目录" class="headerlink" title="AD——活动目录"></a>AD——活动目录</h2><ol>
<li>提供了集中统一的界面，增强了信息的安全</li>
<li>Windows服务级操作系统——win2008（R5），win2012（R6）</li>
</ol>
<h2 id="DHCP——动态获取IP地址协议"><a href="#DHCP——动态获取IP地址协议" class="headerlink" title="DHCP——动态获取IP地址协议"></a>DHCP——动态获取IP地址协议</h2><ol>
<li>优势：简单不冲突<br>缺点：客户机IP地址不固定，无法发现静态IP地址</li>
</ol>
<h2 id="DNS——域名解析服务器（重点）"><a href="#DNS——域名解析服务器（重点）" class="headerlink" title="DNS——域名解析服务器（重点）"></a>DNS——域名解析服务器（重点）</h2><ol>
<li>一种提供域名和IP地址之间转换的分布式数据库，以方便访问网络</li>
<li>WI（Web In）——网页接入，桌面云的入口<br>License——授权组件</li>
</ol>
<h2 id="传统与云计算数据中心的区别"><a href="#传统与云计算数据中心的区别" class="headerlink" title="传统与云计算数据中心的区别"></a>传统与云计算数据中心的区别</h2><h3 id="传统数据中心"><a href="#传统数据中心" class="headerlink" title="传统数据中心"></a>传统数据中心</h3><ol>
<li>一个物理端口对用一台唯一的计算机</li>
<li>终端与网络之间的关系固定</li>
</ol>
<h3 id="云计算网络数据中心"><a href="#云计算网络数据中心" class="headerlink" title="云计算网络数据中心"></a>云计算网络数据中心</h3><ol>
<li>一个物理网络端口对应多个虚拟机</li>
<li>服务器普遍千兆口</li>
<li>虚拟机会频繁进行跨主机的迁移（升级、电源或负载策略、故障），与网络之间的关系不再固定</li>
<li>东西向流量为主，大量增长</li>
<li>热迁移使得计算机不再固定在具体物理位置，传统网络无法满足云计算的诉求</li>
</ol>
<h1 id="二、虚拟化技术基础与虚拟化类型"><a href="#二、虚拟化技术基础与虚拟化类型" class="headerlink" title="二、虚拟化技术基础与虚拟化类型"></a>二、虚拟化技术基础与虚拟化类型</h1><h2 id="虚拟化层作用"><a href="#虚拟化层作用" class="headerlink" title="虚拟化层作用"></a>虚拟化层作用</h2><ol>
<li>承上启下，让虚拟机以为有硬件接口层</li>
<li>通过将底层硬件资源池化，再通过给虚拟机创建一些逻辑上硬件，将逻辑上硬件与资源池中的资源建立映射关系，从而实现虚拟机共享资源的目的。</li>
</ol>
<h2 id="实现虚拟化技术的前提"><a href="#实现虚拟化技术的前提" class="headerlink" title="实现虚拟化技术的前提"></a>实现虚拟化技术的前提</h2><ul>
<li>建立在物理资源之上——虚拟化资源不能超过物理资源（除某些资源复用技术之外）</li>
</ul>
<h2 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h2><ol>
<li>开源——KVM，XEN（运行于Linux）<br>x86——一套固定的指令集</li>
<li>闭源——VMware，Windows</li>
<li>开源研发成本远远高于闭源</li>
</ol>
<h2 id="虚拟化后的变化"><a href="#虚拟化后的变化" class="headerlink" title="虚拟化后的变化"></a>虚拟化后的变化</h2><ol>
<li>资源抽象成共享资源池</li>
<li>操作系统与硬件解耦从资源池中分配资源</li>
</ol>
<h2 id="虚拟化的好处"><a href="#虚拟化的好处" class="headerlink" title="虚拟化的好处"></a>虚拟化的好处</h2><ul>
<li>提高硬件利用率、降低能耗、提高IT运维效率、操作系统与硬件的解耦</li>
</ul>
<h2 id="虚拟化的本质"><a href="#虚拟化的本质" class="headerlink" title="虚拟化的本质"></a>虚拟化的本质</h2><ol>
<li>分区——硬盘资源分区</li>
<li>隔离——资源的隔离（重要）</li>
<li>封装——可以实现备份，迁移（重要）</li>
<li>相对于硬件独立——解耦（重要）</li>
</ol>
<h2 id="虚拟化中的几个重要概念"><a href="#虚拟化中的几个重要概念" class="headerlink" title="虚拟化中的几个重要概念"></a>虚拟化中的几个重要概念</h2><ol>
<li>VMM相当于系统内核，Hypervisor包含VMM</li>
</ol>
<h2 id="虚拟化的类型"><a href="#虚拟化的类型" class="headerlink" title="虚拟化的类型"></a>虚拟化的类型</h2><ol>
<li>寄居虚拟化</li>
<li>裸金属虚拟化——主流</li>
<li>操作系统虚拟化</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：CSS（尚硅谷）</title>
    <url>/Learn-CSS.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 CSS 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-CSS"><a href="#1-CSS" class="headerlink" title="1.CSS"></a>1.CSS</h2><ul>
<li>即层叠样式表，网页可以看成一层一层的结构，而 CSS 可以分别为网页的各个层次设置样式。</li>
</ul>
<h2 id="2-CSS-样式编写位置"><a href="#2-CSS-样式编写位置" class="headerlink" title="2.CSS 样式编写位置"></a>2.CSS 样式编写位置</h2><h3 id="1-内联样式"><a href="#1-内联样式" class="headerlink" title="(1).内联样式"></a>(1).内联样式</h3><ul>
<li><p>可以编写到元素（即标签）内的 <code>style</code> 属性中，称为“内联样式”</p>
</li>
<li><p><code>color: red;</code> 前者为样式值，后者为样式名，中间用冒号分割开，且每一个样式都要以分号结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p style=&quot;color: red; font-size: 40px;&quot;&gt;这里修改了颜色和字体&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>该样式只对当前的元素中的内容起作用，不方便复用，属于结构和表现耦合，不方便后期维护，<font color=#F00>绝对不要使用</font></p>
</li>
</ul>
<h3 id="2-内部样式"><a href="#2-内部样式" class="headerlink" title="(2).内部样式"></a>(2).内部样式</h3><ul>
<li><p>可以编写到 <code>&lt;head&gt;</code> 中的 <code>&lt;style&gt;</code> 标签里，将样式表编写到 <code>&lt;style&gt;</code> 标签中（称为”内部样式”)</p>
</li>
<li><p>通过 css 选择器选中指定元素，然后可以同时为这些元素一起设置样式，可以使样式进一步的复用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	p&#123;							//使含有p标签的语句一起设置样式</span><br><span class="line">		color:red;</span><br><span class="line">		font-size:40px;</span><br><span class="line">	&#125;		</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>可以使表现和结构进一步分离，比较推荐的使用方式</p>
</li>
</ul>
<h3 id="3-外部样式"><a href="#3-外部样式" class="headerlink" title="(3).外部样式"></a>(3).外部样式</h3><ul>
<li><p>想要让其他文件也可以引用同样的样式表，需要将样式表编写到外部的 css，即写入 <code>.css</code> 文件中（内容形同于上面一点）</p>
</li>
<li><p>通过 <code>&lt;link&gt;</code> 标签来将外部的 css 文件引入到当前页面中。</p>
</li>
<li><p>注意：<code>&lt;link&gt;</code> 标签需要写到 <code>&lt;style&gt;</code> 标签中，<code>&lt;link&gt;</code> 前两个属性固定，后面填写相对路径即可，且为自结束标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>将 css 样式统一编写到外部的样式表中，完全使结构和表现分离，可实现在不同页面中使用，最大限度的使样式可以进行复用，同时引入 <code>&lt;link&gt;</code> 标签可以利用浏览器的缓存，加快用户访问的速度，在开发中最推荐使用</p>
</li>
</ul>
<h2 id="3-CSS-语法"><a href="#3-CSS-语法" class="headerlink" title="3.CSS 语法"></a>3.CSS 语法</h2><ol>
<li>注释写法：需要在 <code>&lt;style&gt;</code> 标签或 css 文件中填写，用 <code>/* */</code>来编写</li>
<li>选择器：通过选择器可以选中页面中指定元素，并将声明块中的样式应用到选择器对应的元素上</li>
<li>声明块：使用一对 {} 括起来，其中内容实际上是一组一组的名值对结构（称为声明）。多个声明之间用分号隔开。</li>
</ol>
<h2 id="4-样式的继承"><a href="#4-样式的继承" class="headerlink" title="4.样式的继承"></a>4.样式的继承</h2><ul>
<li><p>为一个元素设置样式同时也会应用到它的后代元素上</p>
</li>
<li><p>利用继承可以将一些通用的样式统一设置到共同的祖先元素上，这样只需设置一次即可让所有的元素都具有该样式</p>
</li>
<li><p><font color=#FF0000>注意：背景、边框、定位等相关的样式不会被继承</font></p>
</li>
</ul>
<h2 id="5-单位"><a href="#5-单位" class="headerlink" title="5.单位"></a>5.单位</h2><h3 id="a-字体单位"><a href="#a-字体单位" class="headerlink" title="a.字体单位"></a>a.字体单位</h3><ol>
<li>像素：<code>px</code> （一个像素相当于屏幕上的一个小点，像素点越小屏幕显示效果越清晰）</li>
<li>百分比：<code>%</code> （根据父元素字体大小来计算百分比）<br>当父元素的样式发生改变时，子元素也会发生改变，<font color=#F00>该单位用来创建自适应的页面</font></li>
<li><code>em</code> （相对于当前元素的字体大小来计算的字体大小，即1em=1font-size）<br>当字体大小发生改变时，em 也会发生相应的改变，该单位用来设置字体相关的样式</li>
<li><code>rem</code> （相对于根元素的字体大小来计算）</li>
</ol>
<h3 id="b-颜色单位"><a href="#b-颜色单位" class="headerlink" title="b.颜色单位"></a>b.颜色单位</h3><ol>
<li>直接用单词来表示</li>
<li>用 RGB（红色、绿色、蓝色浓度）值来表示<br>浓度为0-255或者0%-100%，百分数最后也会转变为数字<br>书写形式：<code>background-color: rgb(255,0,0)</code> 就是指红色</li>
<li>用 RGBA（红色、绿色、蓝色浓度，不透明度）来表示<br>1表示不透明，.5表示半透明</li>
<li>用十六进制的 rgb 值来表示，即三组两位的16进制数组<br>书写形式：<code>#aabbcc</code> ，数组范围为00~FF<br>三组两位数组重复的可以直接简写，即上边的可以简写为：<code>#abc</code></li>
<li>CSS 中有一个 HSL值和HSLA值，多用于工业之中<br>H：色相，取值在0<del>360<br>S：饱和度，即颜色浓度，取值在0%</del>100%<br>L：亮度，即颜色的亮度，取值在0%~100%</li>
</ol>
<h2 id="6-字体的样式"><a href="#6-字体的样式" class="headerlink" title="6.字体的样式"></a>6.字体的样式</h2><ul>
<li>注意：css 中可以使用 <code>font</code> 同时设置字体相关的所有样式，而不同的值之间使用空格隔开</li>
<li>关于 font 的相关属性，斜体、粗体、小大字母无顺序要求，但<font color=#FF0000>最后两项必须是大小和字体，且不可调换！</font></li>
</ul>
<h3 id="a-颜色"><a href="#a-颜色" class="headerlink" title="a.颜色"></a>a.颜色</h3><ul>
<li><code>color</code>：前景色，一般用于设置字体颜色</li>
</ul>
<h3 id="b-大小"><a href="#b-大小" class="headerlink" title="b.大小"></a>b.大小</h3><ul>
<li><code>font-size</code> ，浏览器默认大小为16px</li>
<li><font color=#F00>注意：正如小学时的方字格一样，每个字都处于一个隐形的方字格中，所以在设置大小时，实际上是设置的是格子的大小，并不是文字本身的大小</font></li>
<li><font color=#F00>注意：当字体不同时，文字的显示效果也不同</font></li>
</ul>
<h3 id="c-字体"><a href="#c-字体" class="headerlink" title="c.字体"></a>c.字体</h3><ul>
<li><code>font-family: &#39;字体&#39;;</code> ，如果浏览器不支持该字体，则使用默认字体</li>
<li>可以设置多个字体且之间用逗号隔开，且浏览器优先使用最前面的字体，若不支持，则下一个</li>
<li>浏览器使用的字体默认是计算机中的字体</li>
<li>引申：使用 <code>@font-face&#123;&#125;</code> 可以自定义字体</li>
</ul>
<h3 id="d-字体分类（共5类）"><a href="#d-字体分类（共5类）" class="headerlink" title="d.字体分类（共5类）"></a>d.字体分类（共5类）</h3><ul>
<li><code>衬线字体：serif</code><br><code>非衬线字体：sans-serif</code><br><code>等宽字体：monospace</code><br><code>草书字体：cursive</code><br><code>虚幻字体：fantasy</code></li>
<li>以上的分类全是字体的大类，当使用该类时，浏览器会自动选择指定的字体</li>
<li>一般使用前两个大类</li>
</ul>
<h3 id="e-斜体效果"><a href="#e-斜体效果" class="headerlink" title="e.斜体效果"></a>e.斜体效果</h3><ul>
<li><code>font-style</code> 含有以下三个可选值：<br>normal：默认值即正常显示<br>italic，斜体显示<br>oblique，倾斜</li>
<li>2和3在大部分的浏览器上不会做区分，但一般使用第二个</li>
</ul>
<h3 id="f-加粗效果"><a href="#f-加粗效果" class="headerlink" title="f.加粗效果"></a>f.加粗效果</h3><ul>
<li><code>font-weight</code> 含有以下三个可选值<br>normal：默认值即正常显示<br>bold，粗体显示<br>100~900，400为默认，低于400就是细字体效果，高于400就是粗体效果</li>
</ul>
<h3 id="g-图标字体"><a href="#g-图标字体" class="headerlink" title="g.图标字体"></a>g.图标字体</h3><ul>
<li>iconfont：在网页中的小型图标可以将其直接设置为字体，然后通过 <code>font-face</code> 属性来对字体进行引入</li>
<li>一般使用国外的 <font color=#00F>font awesome </font>（中文点 <a href="https://fontawesome.dashgame.com/">这里</a> ，英文点 <a href="https://fontawesome.com/">这里</a>），下载解压以后只需要使用 <code>css</code> 和 <code>webfonts</code> 两个文件夹</li>
<li>通过标签引入：</li>
</ul>
<p>1.将上面两个文件夹放入项目文件夹中<br>2.在网页中引入 <code>css/all.css</code> 该css文件<br>3.使用 <code>&lt;i&gt;</code> 标签引入图标，只要在其 <code>class</code> 属性中加入该行即可——<code>fas fa开头的图标名字</code> 或者 <code>fab fa开头的图标名字</code> </p>
<ul>
<li>通过伪元素来设置：</li>
</ul>
<p>1.找到要设置图标的元素且通过 <code>before</code> 和 <code>after</code> 选中<br>2.在 <code>content</code> 中设置字体的编码，编码前要使用反斜杠<br>3.设置字体的样式。图标是fab时，使用 <code>font-family: &#39;font Awesome 5 Brands&#39;;</code> ；图标是fas时，使用 <code>font-family: &#39;font Awesome 5 Free&#39;;   font-weight: 900;</code> 。</p>
<ul>
<li>通过实体来设置：<br>&amp;#x图标的编码;    这样来设置，如：<code>&lt;span class=&quot;fas&quot;&gt;&amp;#xf0f3;&lt;/span&gt;</code></li>
<li>国内使用阿里的 <font color=#00F>iconfont </font>，用法类似</li>
</ul>
<h2 id="7-行高-行间距"><a href="#7-行高-行间距" class="headerlink" title="7.行高-行间距"></a>7.行高-行间距</h2><ul>
<li>表示为： <code>line-height: 40px；</code></li>
<li><del>默认行高为 1.33</del>（存疑）</li>
</ul>
<h3 id="a-行高可接收的值"><a href="#a-行高可接收的值" class="headerlink" title="a.行高可接收的值"></a>a.行高可接收的值</h3><ol>
<li>直接接收一个大小</li>
<li>指定一个百分数，相对于字体计算行高</li>
<li>传一个数值，则行高会设置为字体大小相应的倍数（<font color=#F00>常用</font>）</li>
</ol>
<h3 id="b-注意事项"><a href="#b-注意事项" class="headerlink" title="b.注意事项"></a>b.注意事项</h3><ol>
<li>对于单行文本，可以将行高设置为和父元素一样的高度，即可实现垂直居中</li>
<li>在 font 中也可以指定行高，格式为： <code>字体大小/行高大小 字体</code> （这里行高大小为可选值，不选则为默认）</li>
<li>对于第2点，为了避免覆盖效果，行高需放在 font 后面</li>
<li>行高会在字体框的上下平均分配</li>
</ol>
<h3 id="c-行间距"><a href="#c-行间距" class="headerlink" title="c.行间距"></a>c.行间距</h3><ul>
<li>行间距=行高-字体大小</li>
<li>就是通过设置行高来间接设置行间距，而文字默认会在行高中垂直居中显示</li>
</ul>
<h2 id="8-文本的样式"><a href="#8-文本的样式" class="headerlink" title="8.文本的样式"></a>8.文本的样式</h2><h3 id="a-文本的大小写"><a href="#a-文本的大小写" class="headerlink" title="a.文本的大小写"></a>a.文本的大小写</h3><ul>
<li>表示为： <code>text-transform</code> ，对中文无意义，可选值有如下四种：<br>none：默认值<br>capitalize：单词的首字母大写（通过空格来识别单词的）<br>uppercase：所有字母都大写<br>lowercase：所有字母都小写</li>
</ul>
<h3 id="b-文本的装饰"><a href="#b-文本的装饰" class="headerlink" title="b.文本的装饰"></a>b.文本的装饰</h3><ul>
<li>表示为： <code>text-decoration</code> ，可选值有如下四种：<br>none：不添加任何修饰<br>underline：添加下划线<br>overline：添加上划线<br>line-through：删除线</li>
<li>注意：超链接中默认会添加下划线，即超链接的 <code>text-decoration</code> 中的值为 underline，若想去除该下划线，则需要给超链接的 <code>text-decoration</code> 设为 none。</li>
</ul>
<h3 id="c-字符间距"><a href="#c-字符间距" class="headerlink" title="c.字符间距"></a>c.字符间距</h3><ul>
<li>表示为： <code>letter-spacing</code> ，默认值为0 px</li>
</ul>
<h3 id="d-单词间的距离"><a href="#d-单词间的距离" class="headerlink" title="d.单词间的距离"></a>d.单词间的距离</h3><ul>
<li>表示为： <code>word-spacing</code> ，单纯设置空格大小的</li>
</ul>
<h3 id="e-文本对齐方式"><a href="#e-文本对齐方式" class="headerlink" title="e.文本对齐方式"></a>e.文本对齐方式</h3><ul>
<li>水平对齐表示为： <code>text-align</code> ，可选值有如下四种：<br>left：默认，为左对齐<br>right：右对齐<br>center：居中<br>justify：两端对齐</li>
<li>垂直对齐表示为： <code>vertical-align</code> ，可选值有如下四种：<br>baseline：默认，以基线对齐<br>top：顶部对齐<br>bottom：底部对齐<br>middle：居中对齐，这里是以小写字母 x 的中线居中对齐的<br>数字单位：进行相应单位的上下移动</li>
<li>注意：在一个标签中引入图片时，图片下边有一个缝隙，那是图片有自身的基线，如果想要让图片充满标签，则可以使用垂直对齐表示且可选值是非默认即可</li>
</ul>
<h3 id="f-首行缩进"><a href="#f-首行缩进" class="headerlink" title="f.首行缩进"></a>f.首行缩进</h3><ul>
<li>表示为： <code>text-indent</code> ，单位为 em</li>
<li>2em 即为首行缩进2字符</li>
<li>当指定负值时，即向左移动，可实现隐藏相应的内容</li>
</ul>
<h3 id="g-设置网页空白处理方式"><a href="#g-设置网页空白处理方式" class="headerlink" title="g.设置网页空白处理方式"></a>g.设置网页空白处理方式</h3><ul>
<li>使用 <code>white-space</code> 来设置网页如何处理空白，可选值如下：<br>normal：正常<br>nowrap：不换行<br>pre：保留空白</li>
<li>引申：网页中一段话只写一句后面有省略号的设计方法如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">	width: 200px;</span><br><span class="line">	white-space: nowrap;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">	text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-背景的样式"><a href="#9-背景的样式" class="headerlink" title="9.背景的样式"></a>9.背景的样式</h2><h3 id="1-背景图片"><a href="#1-背景图片" class="headerlink" title="(1).背景图片"></a>(1).背景图片</h3><ul>
<li><code>background-image: url(图片的相对路径)</code> 。</li>
<li>若图片大于元素，默认会显示左上角；若背景图片和元素一样大，则会全部显示；若图片小于元素，则会默认将背景图片平铺以充满元素</li>
<li>可以同时为一个元素指定背景色和背景图片，这样背景色会作为背景图片的底色，且在一般情况下设置背景图片时都会同时指定一个背景颜色</li>
</ul>
<h3 id="2-背景图片的重复"><a href="#2-背景图片的重复" class="headerlink" title="(2).背景图片的重复"></a>(2).背景图片的重复</h3><ul>
<li><code>background-repeat</code> 用于设置背景图片的的重复方式</li>
<li>可选值：<br>repeat：默认值，图片会双方向重复<br>no-repeat：图片不会重复，有多大就显示多大<br>repeat-x：背景图片沿水平方向重复<br>repeat-y：背景图片沿垂直方向重复</li>
</ul>
<h3 id="3-背景图片的位置"><a href="#3-背景图片的位置" class="headerlink" title="(3).背景图片的位置"></a>(3).背景图片的位置</h3><ul>
<li><code>background-position</code> 可以调整背景图片在元素中的位置</li>
<li>可选值：<br>可以使用 top、right、left、bottom、center中的两个值来指定一个背景图片的位置，如果只给定一个值，则第二个值默认为 center<br>也可以直接指定两个偏移量，第一个值为水平偏移量，第二个值为垂直偏移量（设定为正值时，会向右下移动；负值时会向左上移动）</li>
</ul>
<h3 id="4-背景图片是否跟随元素移动"><a href="#4-背景图片是否跟随元素移动" class="headerlink" title="(4).背景图片是否跟随元素移动"></a>(4).背景图片是否跟随元素移动</h3><ul>
<li><code>background-attachment</code> 用来设置背景图片是否随页面一起滚动</li>
<li>可选值：<br>scroll：默认值，背景图片随着窗口滚动<br>fixed：背景图片会固定在某一位置，不随页面滚动。此时背景图片的定位永远相对于浏览器的窗口，效果类比于博客的背景图片，不会随着滚动条而移动。且该效果一般只给 body 设置</li>
</ul>
<h3 id="5-背景的范围"><a href="#5-背景的范围" class="headerlink" title="(5).背景的范围"></a>(5).背景的范围</h3><ul>
<li><code>background-clip</code> 可以设置背景的范围</li>
<li>可选值：<br>border-box：默认值，背景会出现在边框的下边<br>padding-box：背景不会出现在边框上，只出现在内容区和内边距<br>content-box：背景只会出现在内容区</li>
</ul>
<h3 id="6-背景图片偏移量的原点"><a href="#6-背景图片偏移量的原点" class="headerlink" title="(6).背景图片偏移量的原点"></a>(6).背景图片偏移量的原点</h3><ul>
<li><code>background-origin</code> 可以设置背景图片偏移量的原点</li>
<li>可选值：<br>padding-box：默认值，背景图片的偏移量从内边距开始计算<br>content-box：背景图片的偏移量从内容区处计算<br>border-box：背景图片的偏移量从边框处计算</li>
<li>该属性常与上边第四个背景的范围一起使用</li>
</ul>
<h3 id="7-背景图片的大小"><a href="#7-背景图片的大小" class="headerlink" title="(7).背景图片的大小"></a>(7).背景图片的大小</h3><ul>
<li><code>background-size</code> 可以设置背景图片的大小</li>
<li>可选值：<br>第一个值为宽度，第二个值为高度。如果只写一个值，则另一个值默认为 auto<br>cover，表示背景图片的比例不变，将元素铺满<br>contain：图片比例不变，将图片在元素中完整显示</li>
</ul>
<h3 id="8-简写属性"><a href="#8-简写属性" class="headerlink" title="(8).简写属性"></a>(8).简写属性</h3><ul>
<li>通过 <code>background</code> 可以同时设置背景相关的样式，不写的属性就使用默认样式</li>
<li>需要注意的是：size 需要写在 position 后边，且用斜杠隔开；origin 需要写在 clip 的前面</li>
</ul>
<h2 id="10-渐变"><a href="#10-渐变" class="headerlink" title="10.渐变"></a>10.渐变</h2><ul>
<li>注意：渐变指的是图片，而不是颜色</li>
</ul>
<h3 id="1-线性渐变"><a href="#1-线性渐变" class="headerlink" title="(1).线性渐变"></a>(1).线性渐变</h3><ul>
<li>指的是颜色沿着一条直线发生变化</li>
<li>写法：<code>background-image: liner-gradient(可选值，颜色1，颜色2···);</code></li>
<li>可选值：<br>to left：从右往左渐变<br>to right：从左往右渐变<br>to bottom：默认值，从上往下渐变<br>to top：从下往上渐变<br>deg：表示度数<br>turn：表示圈</li>
<li>也可以在颜色后面跟上像素值，表示该颜色从多少像素开始渐变 —— <code>background-image: liner-gradient(red 50px; yellow 30px; blue 20px);</code></li>
<li>可以平铺的线性渐变，达到重复的效果 —— <code>background-image: repeating-linear-gradient(red 50px, yellow 100px);</code> </li>
</ul>
<h3 id="2-径向渐变"><a href="#2-径向渐变" class="headerlink" title="(2).径向渐变"></a>(2).径向渐变</h3><ul>
<li>指的是颜色从中心点向四周渐变</li>
<li>写法：<code>background-image: radial-gradient(可选值，颜色1，颜色2);</code></li>
<li>可选值：<br>数字：100px 100px 表示径向渐变的大小<br>circle：圆形<br>ellipse：椭圆形<br>100px 100px at 0 0：表示圆心在00点</li>
<li>默认情况下的径向渐变的形状是根据元素的形状来计算的</li>
</ul>
<h2 id="11-雪碧图"><a href="#11-雪碧图" class="headerlink" title="11.雪碧图"></a>11.雪碧图</h2><h3 id="1-制作"><a href="#1-制作" class="headerlink" title="(1).制作"></a>(1).制作</h3><ul>
<li>将三张图片依次放进PS中打开，由于需要将三张图片合并起来，所以需要在第一张图片上拓展相应画布大小，在 图像-画布大小 中修改，并设置相应的定位方向</li>
<li>修改好以后存储为 <code>png-24</code> 格式即可</li>
<li>雪碧图只适用于做背景的图，在网页中引入的 img 标签是不能做成雪碧图的</li>
</ul>
<h3 id="2-使用"><a href="#2-使用" class="headerlink" title="(2).使用"></a>(2).使用</h3><ul>
<li>先确定需要使用的图标</li>
<li>测量图标的大小</li>
<li>根据测量结果创建一个元素</li>
<li>将雪碧图设置为元素的背景图片</li>
<li>设置一个偏移量以显示正确的图片</li>
</ul>
<h2 id="12-表格"><a href="#12-表格" class="headerlink" title="12.表格"></a>12.表格</h2><h3 id="1-表格的基础形式"><a href="#1-表格的基础形式" class="headerlink" title="(1).表格的基础形式"></a>(1).表格的基础形式</h3><ul>
<li><p>两行两列的表格代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;td&gt;A1&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;A2&lt;/td&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;td&gt;B1&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;B2&lt;/td&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>想要加边框的话，需要给 table 标签设置一个 <code>border=&quot;1&quot;</code> 即可，但不推荐，因为使用的 HTML，而不是 CSS</p>
</li>
<li><p>想要合并单元格的话，使用 <code>colspan=&quot;合并的单元格数&quot;</code> 设置横向的合并单元格，使用 <code>rowspan=&quot;合并的单元格数&quot;</code> 设置纵向的合并单元格</p>
</li>
</ul>
<h3 id="2-长表格"><a href="#2-长表格" class="headerlink" title="(2).长表格"></a>(2).长表格</h3><ul>
<li>为了方便设置，将表格分为了3部分，<code>表头：&lt;thead&gt;</code> <code>表格主体：&lt;tbody&gt;</code> <code>表格底部：&lt;tfoot&gt;</code> ，这三个标签需要写到table 标签中，而 tr 需要写到这三个标签中</li>
<li>如果浏览器没有写 tbody ，浏览器会自动在表格中添加 tbody ，并且将所有的 tr 都放到 tbody 中，所以 tr 并不是 table 的子元素</li>
</ul>
<h3 id="3-表格的样式"><a href="#3-表格的样式" class="headerlink" title="(3).表格的样式"></a>(3).表格的样式</h3><ul>
<li>边框：给 table 设置边框只有最外边的边框，只有给 <code>&lt;td&gt;</code> 设置边框才会形成四周边框的效果<br>但这样会形成双线边框，所以在 table 中需要用 <code>border-spacing= 0px;</code> 来设置双线之间的距离为0<br>但这样会加粗边框线，所以在 table 中需要用 <code>border-collapse: collapse;</code> 来设置表格边框的合并</li>
<li>表头的默认效果：居中和加粗</li>
<li>隔行变色：给 <code>&lt;tr&gt;</code> 标签使用 <code>nth-child(even)</code> 选中偶数行，odd选中奇数行。不支持IE6</li>
<li>移入特效：给 <code>&lt;tr&gt;</code> 标签使用 <code>:hover</code> 并设置背景颜色即可。不支持IE6</li>
<li>在 <code>&lt;td&gt;</code> 标签中默认是垂直居中的，可以通过 <code>vertical-align: center;</code> 来修改</li>
</ul>
<h2 id="13-命名规范"><a href="#13-命名规范" class="headerlink" title="13.命名规范"></a>13.命名规范</h2><ul>
<li>尽量使用英文，也可以拼音，但不可以混用</li>
<li>驼峰命名法：首字母小写，每个单词的开头字母大写，如 helloWorld</li>
<li>小写字母法</li>
<li>连字符法：在单词之间使用_或-连接，如aaa-bbb-ccc</li>
</ul>
<h2 id="14-网站图标"><a href="#14-网站图标" class="headerlink" title="14.网站图标"></a>14.网站图标</h2><ul>
<li>一般网站图标以 <code>favicon.icon</code> 为名，且存放在项目的根目录下</li>
<li>获取绝大多数网站的图标 —— 在该网站的地址后面添加 <code>/favicon.ico</code> </li>
<li>用法：在 <code>&lt;head&gt;</code> 标签中使用 <code>&lt;link&gt;</code> 标签来引入：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;icon&quot; href=&quot;./favicon.icon&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="15-像素"><a href="#15-像素" class="headerlink" title="15.像素"></a>15.像素</h2><ul>
<li>默认情况下，在PC端一个 CSS 像素 = 一个物理像素</li>
</ul>
<h3 id="1-视口（view-port）"><a href="#1-视口（view-port）" class="headerlink" title="1.视口（view port）"></a>1.视口（view port）</h3><ul>
<li>即屏幕中用来显示网页的区域。可以通过查看视口的大小来确定 CSS 像素和物理像素的比例</li>
<li>在浏览器的开发者工具中找到 html 标签，在 computed 中可以找到宽度，即为 CSS 像素；自己的电脑的宽度是多少像素即为物理像素。这时就可以计算出比例了</li>
<li>可以通过改变视口的大小，来改变 CSS 像素和物理像素额比值</li>
</ul>
<h3 id="2-移动端"><a href="#2-移动端" class="headerlink" title="2.移动端"></a>2.移动端</h3><ul>
<li>该 <a href="https://material.io/resources/devices/">网址</a> 可以查看部分手机的像素大小</li>
<li>默认情况下，移动端的网页都会将视口设置为 980像素（为CSS像素），所以，移动端的像素比就是 980/移动端宽度</li>
<li>所以，想要在移动端有和PC端一样的视觉体验，那么就需要使用 <code>&lt;meta&gt;</code> 标签来设置视口的大小<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=100px&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>这里只是示范用的100px。其实每一款移动设备设计时，都会有一个最佳的像素比，一般我们只需要将像素比设置为该值即可得到一个最佳像素比，这样的视口大小为 <strong>完美视口</strong></li>
<li><font color=#F00><strong>结论：按下面的写法来使其自适应移动端</strong></font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-vw-适配"><a href="#3-vw-适配" class="headerlink" title="3.vw 适配"></a>3.vw 适配</h3><ul>
<li><font color=#ffcc01>在移动端开发时，需要使用 vw 单位而不是 px 单位，vw 代表视口的宽度，100vw=一个视口的宽度</font></li>
<li>但使用 vw 时换算较为麻烦，所以可以使用 rem 单位来进行换算，只需要将 html 标签中的字体大小设置为 1px 对应的 vw 单位即可，此时 1rem 就等于这里设置的 vw 大小</li>
<li>由于 Chrome 设置了浏览器的最小字体大小为 12px，所以一般在 html 标签中将其扩大40或者50或者100倍，而相应的 rem 则缩小40或者50或者100倍即可</li>
</ul>
<h1 id="二、元素和选择器"><a href="#二、元素和选择器" class="headerlink" title="二、元素和选择器"></a>二、元素和选择器</h1><h2 id="1-块元素"><a href="#1-块元素" class="headerlink" title="1.块元素"></a>1.块元素</h2><ul>
<li><p>块元素没有任何语义，不会为它里边的元素设置任何的默认样式。且自己会独占一行，<font color=#FF0000>主要用来对页面进行布局的</font>。</p>
</li>
<li><p><code>&lt;div&gt;</code> 标签就是一个块元素，若在其中修改 style 属性，整行都会变色，效果如下：<br><img src="https://s1.ax1x.com/2020/10/20/BSPF9f.png" alt="css01.png"></p>
</li>
<li><p><code>&lt;p&gt;/&lt;h1&gt;/&lt;h2&gt;/&lt;table&gt;</code> ….都是块元素</p>
</li>
<li><p><font color=#FF0000>注意：<code>&lt;p&gt;</code> 元素不可以包含其他的块元素</font></p>
</li>
<li><p><font color=#FF0000>一般情况下只使用块元素包含内联元素</font>，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;</span><br><span class="line">	内容</span><br><span class="line">	&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-内联元素"><a href="#2-内联元素" class="headerlink" title="2.内联元素"></a>2.内联元素</h2><ul>
<li>内联元素（行内元素，即只占自身大小），没有任何语义，专门用来选中文字用来设置样式</li>
<li><code>&lt;span&gt;</code> 没有语义，一般用来在网页选中文字</li>
<li>常见内联元素：<code>&lt;span&gt;/&lt;a&gt;/&lt;em&gt;/&lt;img&gt;/&lt;iframe&gt;/伪类</code></li>
<li><font color=#FF0000>注意：<code>&lt;a&gt;</code> 元素可以包含任意元素，除他本身</font></li>
<li><font color=#FF0000>一般情况下只使用块元素包含内联元素</font>,即：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;</span><br><span class="line">	内容</span><br><span class="line">	&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-常用选择器"><a href="#3-常用选择器" class="headerlink" title="3.常用选择器"></a>3.常用选择器</h2><h3 id="1-元素选择器"><a href="#1-元素选择器" class="headerlink" title="(1).元素选择器"></a>(1).元素选择器</h3><ul>
<li>作用：通过元素选择器可以选择页面中的所有指定元素</li>
<li>语法：<code>标签名+&#123;&#125;</code></li>
</ul>
<h3 id="2-id-选择器"><a href="#2-id-选择器" class="headerlink" title="(2).id 选择器"></a>(2).id 选择器</h3><ul>
<li><p>作用：通过元素的 <code>id</code> 属性值选中唯一的一个元素</p>
</li>
<li><p>语法：<code>#id属性值+&#123;&#125;</code>。效果如下：<br><img src="https://s1.ax1x.com/2020/10/20/BSPk38.png" alt="css02.png"></p>
</li>
<li><p><font color=#FF0000>对于id选择器来说，不建议使用复合选择器</font></p>
</li>
</ul>
<h3 id="3-类选择器"><a href="#3-类选择器" class="headerlink" title="(3).类选择器"></a>(3).类选择器</h3><ul>
<li><p>作用：通过元素的 <code>class</code> 属性值选中一组元素（相比较 <code>id</code> 属性值其使用的更多）。</p>
</li>
<li><p>语法：<code>.class属性值+&#123;&#125;</code>。效果如下：<br><img src="https://s1.ax1x.com/2020/10/20/BSPEjg.png" alt="css03.png"></p>
</li>
<li><p>特点：可以同时为一个元素设置多个 <code>class</code> 属性值，多个值之间使用空格隔开。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p class=&quot;p2 hello&quot;&gt;多个属性值&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-通配选择器"><a href="#4-通配选择器" class="headerlink" title="(4).通配选择器"></a>(4).通配选择器</h3><ul>
<li>作用：可以用来选中页面中的所有元素</li>
<li>语法：<code>*+&#123;&#125;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-选择器分组（并集选择器）"><a href="#5-选择器分组（并集选择器）" class="headerlink" title="(5).选择器分组（并集选择器）"></a>(5).选择器分组（并集选择器）</h3><ul>
<li>作用：可以同时选中多个选择器对应的元素</li>
<li>语法：<code>选择器1，选择器2，选择器N+&#123;&#125;</code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#p1 ,.p2 ,h1&#123;</span><br><span class="line">	background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-复合选择器（交集选择器）"><a href="#6-复合选择器（交集选择器）" class="headerlink" title="(6).复合选择器（交集选择器）"></a>(6).复合选择器（交集选择器）</h3><ul>
<li>作用：可以选中同时满足多个选择器元素</li>
<li>语法：<code>选择器1选择器2选择器N+&#123;&#125;</code> ，但其中有元素选择器时，必须使用元素选择器开头<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">span .p3&#123;</span><br><span class="line">	background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><font color=#FF0000>对于 <code>id</code> 选择器来说，不建议使用复合选择器</font></li>
</ul>
<h3 id="7-后代元素选择器"><a href="#7-后代元素选择器" class="headerlink" title="(7).后代元素选择器"></a>(7).后代元素选择器</h3><ul>
<li>作用：选中指定元素的指定后代元素</li>
<li>语法：<code>祖先元素 后代元素+&#123;&#125;</code> ——此处后代可以无限延长<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*给div元素中的span元素设置红色*/</span><br><span class="line">div span&#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-子元素选择器"><a href="#8-子元素选择器" class="headerlink" title="(8).子元素选择器"></a>(8).子元素选择器</h3><ul>
<li>作用：选中指定元素的指定子元素</li>
<li>语法：<code>父元素 &gt; 子元素+&#123;&#125;</code></li>
<li>注意：IE6 及以下浏览器不支持子元素选择器。区分于上边的后代元素选择器。上者为空格，下者为大于号</li>
</ul>
<h3 id="9-兄弟元素选择器"><a href="#9-兄弟元素选择器" class="headerlink" title="(9).兄弟元素选择器"></a>(9).兄弟元素选择器</h3><ol>
<li>后一个兄弟元素选择器：<code>span+p</code></li>
</ol>
<ul>
<li>作用：用来选择 <code>&lt;span&gt;</code> 元素后边的第一个 <code>&lt;p&gt;</code> 元素</li>
</ul>
<ol start="2">
<li>后边所有兄弟元素选择器：<code>span~p</code></li>
</ol>
<ul>
<li>作用：用来选择 <code>&lt;span&gt;</code> 元素后边的所有 <code>&lt;p&gt;</code> 元素</li>
</ul>
<h3 id="10-伪类选择器"><a href="#10-伪类选择器" class="headerlink" title="(10).伪类选择器"></a>(10).伪类选择器</h3><ul>
<li>写法：一般都是使用 <code>:</code> 开头的</li>
<li>作用：专门用来表示元素的一种<font color=#FF0000>特殊的状态</font><br><img src="https://s1.ax1x.com/2020/10/20/BSPAgS.png" alt="css04.png"></li>
</ul>
<h4 id="a-超链接的伪类"><a href="#a-超链接的伪类" class="headerlink" title="a.超链接的伪类"></a>a.超链接的伪类</h4><ul>
<li><p>有下面四种：<br><img src="https://s1.ax1x.com/2020/10/20/BSPP4P.png" alt="css05.png"></p>
</li>
<li><p>在写法上上面四种都类似，例如：<code>a:link+&#123;&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:link&#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><font color=#FF0000>注意：由于涉及用户隐私，<code>visited</code> 中只能设置字体的颜色</font></p>
</li>
<li><p><font color=#FF0000>注意：<code>hover</code> 和 <code>active</code> 不只是可以给 <code>&lt;a&gt;</code> 标签设置，<code>&lt;p&gt;</code> 标签也同样可以设置，IE6 中不支持对超链接以外的元素设置</font></p>
</li>
</ul>
<h4 id="b-焦点选择器"><a href="#b-焦点选择器" class="headerlink" title="b.焦点选择器"></a>b.焦点选择器</h4><ul>
<li>语法：<code>:focus</code></li>
<li>作用：用来获取焦点的</li>
<li><code>focus</code> 搭配 <code>&lt;input&gt;</code> 标签来使用，可以用来获取焦点使文本框修改颜色<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input:focus&#123;</span><br><span class="line">	background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line">······</span><br><span class="line">&lt;input type=&quot;text&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-首元素选择器"><a href="#c-首元素选择器" class="headerlink" title="c.首元素选择器"></a>c.首元素选择器</h4><ul>
<li>语法：<code>:first-child</code></li>
<li>作用：选择所有中的第一个子元素<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul &gt; li:first-child&#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="d-末元素选择器"><a href="#d-末元素选择器" class="headerlink" title="d.末元素选择器"></a>d.末元素选择器</h4><ul>
<li>语法：<code>:last-child</code></li>
<li>作用：选择所有中的最后一个子元素<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul &gt; li:last-child&#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="e-任意元素选择器"><a href="#e-任意元素选择器" class="headerlink" title="e.任意元素选择器"></a>e.任意元素选择器</h4><ul>
<li>语法：<code>:nth-child(n)</code></li>
<li>作用：选择其中的第 n 个子元素（n为0到正无穷，2n 或 even 表示选中偶数位的，2n+1 或odd 表示选中奇数位的）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul &gt; li:nth-child(n)&#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="f-上面三个的延伸"><a href="#f-上面三个的延伸" class="headerlink" title="f.上面三个的延伸"></a>f.上面三个的延伸</h4><ul>
<li>语法：<code>:first-of-type</code> 、<code>:last-of-type</code> 、<code>:nth-of-type</code></li>
<li>不同点：上面三个是根据所有子元素进行排序的，而下面这三个是在同类型元素中进行排序</li>
</ul>
<h4 id="g-否定伪类选择器"><a href="#g-否定伪类选择器" class="headerlink" title="g.否定伪类选择器"></a>g.否定伪类选择器</h4><ul>
<li>作用：从已选中的元素中剔除其指定的元素</li>
<li>语法：<code>已选中的:not(需要剔除的)</code></li>
<li>如下代码，就是剔除掉 <code>&lt;p&gt;</code> 元素中 <code>class</code> 是 hello 的<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P:not(.hello)&#123;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p class=&quot;hello&quot;&gt;我是被剔除的&lt;/p&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-伪元素选择器"><a href="#11-伪元素选择器" class="headerlink" title="(11).伪元素选择器"></a>(11).伪元素选择器</h3><ul>
<li>写法：官方使用 <code>::</code> 开头，但也可以使用 <code>:</code></li>
<li>作用：用来表示元素中的一些特殊位置，以下几个基本都不支持 IE6 了<br><img src="https://s1.ax1x.com/2020/10/20/BSPeBj.png" alt="css06.png"></li>
</ul>
<h4 id="a-首字母选择器"><a href="#a-首字母选择器" class="headerlink" title="a.首字母选择器"></a>a.首字母选择器</h4><ul>
<li><p>语法：<code>::first-letter</code></p>
</li>
<li><p>作用：为 <code>&lt;p&gt;</code> 中一段话中的第一个字符设置一个特殊的样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::first-letter&#123;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="b-首行选择器"><a href="#b-首行选择器" class="headerlink" title="b.首行选择器"></a>b.首行选择器</h4></li>
<li><p>语法：<code>::first-line</code></p>
</li>
<li><p>作用：为 <code>&lt;p&gt;</code> 中的第一行设置一个样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p:first-line&#123;</span><br><span class="line">	background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="c-before-选择器"><a href="#c-before-选择器" class="headerlink" title="c.before 选择器"></a>c.before 选择器</h4></li>
<li><p>语法：<code>::before</code></p>
</li>
<li><p>作用：表示元素最前边的部分</p>
</li>
<li><p>注意：<code>&lt;p&gt;</code> 标签前面默认什么都没有，需要结合 <code>content</code> 样式一起使用<font color=#FF0000>（<code>content</code> 可以向 <code>before</code> 或 <code>after</code> 的位置添加一些内容）</font></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p:before&#123;</span><br><span class="line">	content:&quot;我会出现在整个段落的最前端&quot;;</span><br><span class="line">	color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注意：这部分内容是由 css 添加的，故在浏览器中无法被选中</p>
</li>
</ul>
<h4 id="d-after-选择器"><a href="#d-after-选择器" class="headerlink" title="d.after 选择器"></a>d.after 选择器</h4><ul>
<li>语法：<code>::after</code></li>
<li>作用：表示元素最后边的部分</li>
<li>注意：<code>&lt;p&gt;</code> 标签后面默认什么都没有，需要结合 <code>content</code> 样式一起使用<font color=#FF0000>（<code>content</code> 可以向 <code>before</code> 或 <code>after</code> 的位置添加一些内容）</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p:after&#123;</span><br><span class="line">	content:&quot;我会出现在整个段落的最后端&quot;;</span><br><span class="line">	color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="e-selection-选择器"><a href="#e-selection-选择器" class="headerlink" title="e.selection 选择器"></a>e.selection 选择器</h4><ul>
<li>语法：<code>::selection</code></li>
<li>作用：表示选中的内容，即鼠标在网页中选中时</li>
<li><code>selection</code> 为 <code>&lt;p&gt;</code> 标签中选中的内容使用样式（该伪类在火狐浏览器中需要在冒号后加<code>-moz-</code>）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p::selection&#123;</span><br><span class="line">	background-color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-属性选择器"><a href="#12-属性选择器" class="headerlink" title="(12).属性选择器"></a>(12).属性选择器</h3><ul>
<li><p>可以根据元素中的属性或属性值来选取指定元素</p>
</li>
<li><p>语法：<br><code>[属性名]</code> 选取含有指定属性的元素；<br><code>[属性名=&quot;属性值&quot;]</code> 选取含有指定属性值的元素；<br><code>[属性名^=&quot;属性值&quot;]</code> 选取属性值以指定内容开头的元素；<br><code>[属性名$=&quot;属性值&quot;]</code> 选取属性值以指定内容结尾的元素；<br><code>[属性名*=&quot;属性值&quot;]</code> 选取属性值包含指定内容的元素</p>
</li>
<li><p>如：title 属性：<code>title=&quot;内容&quot;</code> 其作用是鼠标移动到元素上时，<code>title</code> 属性的值会作为提示文字出现</p>
</li>
<li><p>例子1：为所有具有 <code>title</code> 属性的 p 元素设置背景颜色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	p[title]&#123;</span><br><span class="line">		background-color: yellow;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>例子2：为 <code>title</code> 属性值是 hello 的元素设置一个背景颜色为换色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	p[title=&quot;hello&quot;]&#123;</span><br><span class="line">		background-color: yelow;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>例子3：为 <code>title</code> 属性值以 ab 开头的元素设置一个背景颜色为黄色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	p[title^=&quot;ab&quot;]&#123;</span><br><span class="line">		background-color: yellow;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>例子4：为 <code>title</code> 属性值以 c 结尾的元素设置一个背景颜色为黄色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	p[title$=&quot;c&quot;]&#123;</span><br><span class="line">		background-color: yellow;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>例子5：为 <code>title</code> 属性值含有 ab 的元素设置一个背景颜色为黄色</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	p[title*=&quot;ab&quot;]&#123;</span><br><span class="line">		background-color: yellow;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-选择器的优先级"><a href="#4-选择器的优先级" class="headerlink" title="4.选择器的优先级"></a>4.选择器的优先级</h2><h3 id="a-作用"><a href="#a-作用" class="headerlink" title="a.作用"></a>a.作用</h3><ul>
<li>当不同的选择器选中同一个元素且设置了不同的样式时，会根据选择器的优先级来进行选择</li>
</ul>
<h3 id="b-优先级比较"><a href="#b-优先级比较" class="headerlink" title="b.优先级比较"></a>b.优先级比较</h3><table>
<thead>
<tr>
<th align="center">选择器</th>
<th align="center">优先级</th>
</tr>
</thead>
<tbody><tr>
<td align="center">内联样式</td>
<td align="center">1,0,0,0</td>
</tr>
<tr>
<td align="center">id选择器</td>
<td align="center">0,1,0,0</td>
</tr>
<tr>
<td align="center">类和伪类</td>
<td align="center">0,0,1,0</td>
</tr>
<tr>
<td align="center">元素选择器</td>
<td align="center">0,0,0,1</td>
</tr>
<tr>
<td align="center">通配选择器</td>
<td align="center">0,0,0,0</td>
</tr>
<tr>
<td align="center">继承的样式</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h3 id="c-优先级的运算"><a href="#c-优先级的运算" class="headerlink" title="c.优先级的运算"></a>c.优先级的运算</h3><ul>
<li><p>选择器中包含多种选择器时，需要将这些优先级相加，但计算的时候不会超过他的最大数量级（正如上边的逗号，表示不能跨数量级）</p>
</li>
<li><p>当选择器的优先级一样时，优先选择靠后的样式，即覆盖</p>
</li>
<li><p>并集选择器的优先级单独运算</p>
</li>
</ul>
<h3 id="d-注意事项"><a href="#d-注意事项" class="headerlink" title="d.注意事项"></a>d.注意事项</h3><ul>
<li><p>不推荐使用内联样式，因为内联样式的优先级最高</p>
</li>
<li><p>如果在样式的最后，添加一个 <code>!important</code> ，则会获得最高的优先级，甚至超过内联样式，但在开发时不建议这样使用</p>
</li>
</ul>
<h3 id="e-关于a的伪类"><a href="#e-关于a的伪类" class="headerlink" title="e.关于a的伪类"></a>e.关于a的伪类</h3><ul>
<li><p><code>link</code> <code>visited</code> <code>hover</code> <code>active</code> 的优先级都一样，但优先使用后边的</p>
</li>
<li><p><code>link</code> 和 <code>visited</code> 必须放在其余两个的前面</p>
</li>
<li><p><code>hover</code> 和 <code>active</code> 位置不能变，否则不生效</p>
</li>
</ul>
<h1 id="三、盒子模型（重点）"><a href="#三、盒子模型（重点）" class="headerlink" title="三、盒子模型（重点）"></a>三、盒子模型（重点）</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><ul>
<li><p>盒子模型又叫框模型，所有的元素都是盒子</p>
</li>
<li><p>盒子的大小由内容区、内边距和边框共同决定的</p>
</li>
<li><p>盒子模型包含四部分：外边距（margin）、内边距（padding）、内容区（content）、边框（border）</p>
</li>
<li><p>下图就是 W3school 对盒子模型的描述<br><img src="https://s1.ax1x.com/2020/10/20/BSPmHs.png" alt="css07.png"></p>
</li>
<li><p>盒子的大小：使用 <code>box-sizing</code> 可以设置盒子尺寸的计算方式，即设置 width 和 height 的作用范围，可选值如下：<br>content-box；默认值，宽度和高度用来设置内容区的大小<br>border-box：宽度和高度用来设置盒子可见框的大小，即三者相加之和</p>
</li>
</ul>
<h2 id="2-边框（border）"><a href="#2-边框（border）" class="headerlink" title="2.边框（border）"></a>2.边框（border）</h2><ul>
<li>边框的大小会影响整个盒子的大小</li>
</ul>
<h3 id="1-必须设置的三个样式"><a href="#1-必须设置的三个样式" class="headerlink" title="(1).必须设置的三个样式"></a>(1).必须设置的三个样式</h3><ul>
<li>border-width：边框的宽度（px 单位制）</li>
<li>border-color：边框的颜色，<font color=#F00>透明可以使用 <code>transparent</code> 的属性值来设置</font></li>
<li>border-style：边框的样式（可选值——<code>none 默认</code> 、<code>solid 实线</code> 、<code>dotted 点状</code> 、 <code>dashed 虚线</code> 、<code>double 双线</code>）</li>
</ul>
<h3 id="2-4种方向的设定"><a href="#2-4种方向的设定" class="headerlink" title="(2).4种方向的设定"></a>(2).4种方向的设定</h3><ul>
<li>以上三个样式都支持指定4个方向的设置</li>
<li>若指定4个值，则按顺时针分别指定上、右、下、左。</li>
<li>若指定3个值，则按顺时针分别指定上、左右、下。</li>
<li>若指定2个值，则按顺时针分别指定上下、左右。</li>
<li>若指定1个值，则按顺时针分别指定四边。</li>
</ul>
<h3 id="3-单独设置某样式的边"><a href="#3-单独设置某样式的边" class="headerlink" title="(3).单独设置某样式的边"></a>(3).单独设置某样式的边</h3><ul>
<li>格式为：<code>border-xxx-width</code> （这里的 xxx 可以使用 top、right、bottom、left）</li>
</ul>
<h3 id="4-简写属性"><a href="#4-简写属性" class="headerlink" title="(4).简写属性"></a>(4).简写属性</h3><ul>
<li>大部分浏览器中，宽度和颜色有默认值，如 style 默认为 none。</li>
<li>简写：<code>border</code> 或 <code>border-xxx</code> ，其中没有任何顺序要求</li>
<li>如果使用 <code>border-xxx</code> 这种写法，不想要某边时可以如下写法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">border:red solid 10px;</span><br><span class="line">border-right:none;</span><br></pre></td></tr></table></figure>

<h3 id="5-与边框相关样式"><a href="#5-与边框相关样式" class="headerlink" title="(5).与边框相关样式"></a>(5).与边框相关样式</h3><h4 id="a-轮廓"><a href="#a-轮廓" class="headerlink" title="a.轮廓"></a>a.轮廓</h4><ul>
<li>使用 <code>outline</code> 用来设置元素的轮廓线，用法和 <code>border</code> 一样</li>
<li>轮廓区别于边框的是轮廓不会影响到可见框的大小</li>
</ul>
<h4 id="b-阴影"><a href="#b-阴影" class="headerlink" title="b.阴影"></a>b.阴影</h4><ul>
<li>使用 <code>box-shadow</code> 来设置元素的阴影效果，且不会影响布局</li>
<li>写法为：<code>box-shadow: 0px 0px 20px rgba(0,0,0,.3);</code><br>第一个值为水平偏移量<br>第二个值为垂直偏移量<br>第三个值为阴影的模糊半径<br>第四个值为阴影的颜色，用rgba来调试透明效果</li>
</ul>
<h4 id="c-圆角"><a href="#c-圆角" class="headerlink" title="c.圆角"></a>c.圆角</h4><ul>
<li>使用 <code>border-radius</code> 来设置圆角的半径大小</li>
<li>如果想要单独给四个角设置，可以用下面四个，指定两个值相等时相当于形成的圆角，指定两个值不同时相当于形成的椭圆角<br>border-top-left-radius: 20px 20px;<br>border-top-right-radius: 20px 20px;<br>border-bottom-left-radius: 20px 20px;<br>border-bottom-right-radius: 20px 20px;</li>
<li>简写属性：<br>四个值：border-radius: 左上 右上 右下 左下;<br>三个值：border-radius: 左上 右上/左下 右下;<br>两个值：border-radius: 左上/右下 右上/左下;<br>一个值：border-radius: 四角;<br>圆角与椭圆角：border-radius: 20px / 40px;        左值为圆角，右值为椭圆角</li>
</ul>
<h2 id="3-内边距（padding）"><a href="#3-内边距（padding）" class="headerlink" title="3.内边距（padding）"></a>3.内边距（padding）</h2><ul>
<li>与边框一样，可以设置 top、right、bottom、left 四个方向，同时设置只要使用 <code>padding</code> 即可</li>
<li>内边距会影响盒子的大小，且元素的背景会延伸到内边距</li>
</ul>
<h2 id="4-外边距（margin）"><a href="#4-外边距（margin）" class="headerlink" title="4.外边距（margin）"></a>4.外边距（margin）</h2><ul>
<li>指的是当前盒子与其他盒子之间的距离</li>
<li>外边距不会影响盒子可见框的大小，但会影响盒子的位置</li>
</ul>
<h3 id="1-4种方向的设定"><a href="#1-4种方向的设定" class="headerlink" title="(1).4种方向的设定"></a>(1).4种方向的设定</h3><ul>
<li>与边框一样，可以设置 top、right、bottom、left 四个方向，同时设置只要使用 <code>margin</code> 即可</li>
<li>设置上和左外边距时，会使盒子自身位置发生改变<br>设置右和下外边距时，会改变其他盒子的位置</li>
<li>设置负值时，会向<font color=#FF0000>反方向</font>移位</li>
<li>设置为 <code>auto</code> 时，会<font color=#FF0000>自动调整</font>，且一般只设置水平方向的 margin ，因为垂直方向默认为0。<br>当某一边设置 auto 时，会将外边距自动设置为最大值。<br>当 left 和 right 同时设置 auto 时，则两侧外边距相同，即显示居中效果</li>
<li>当实际距离大于设置的 px 时，外边距不生效，即无变化</li>
</ul>
<h3 id="2-简写属性"><a href="#2-简写属性" class="headerlink" title="(2).简写属性"></a>(2).简写属性</h3><ul>
<li>若指定4个值，则按顺时针分别指定上、右、下、左。</li>
<li>若指定3个值，则按顺时针分别指定上、左右、下。</li>
<li>若指定2个值，则按顺时针分别指定上下、左右。</li>
<li>若指定1个值，则按顺时针分别指定四边。</li>
</ul>
<h3 id="3-垂直方向的重叠"><a href="#3-垂直方向的重叠" class="headerlink" title="(3).垂直方向的重叠"></a>(3).垂直方向的重叠</h3><ul>
<li>在网页中，垂直方向的相邻外边距会发生外边距的重叠，即兄弟元素之间的相邻外边距会取所设置的较大值（都是正值）或两个求和（一正一负）或绝对值的较大值（都是负值）<br><font color=#F00>兄弟元素之间的重叠对于开发时有利的，无需处理</font></li>
<li>若父子元素的垂直外边距相邻，则子元素设置的外边距会设置给父元素</li>
</ul>
<h4 id="消除父子元素重叠的方法："><a href="#消除父子元素重叠的方法：" class="headerlink" title="消除父子元素重叠的方法："></a>消除父子元素重叠的方法：</h4><ul>
<li>方法一：给子元素使用一个样式（边框、内边距），但此时会多像素，所以需要在盒子的高度上减去多的像素</li>
<li>方法二：给父元素使用一个上内边距，但此时会多像素，所以需要在盒子的高度上减去多的像素</li>
<li>方法三：给父元素设置一个伪类，将元素设置为表格显示，即<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1:before&#123;</span><br><span class="line">	content: &quot;&quot;;</span><br><span class="line">	display: table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-水平方向的布局"><a href="#5-水平方向的布局" class="headerlink" title="5.水平方向的布局"></a>5.水平方向的布局</h2><ul>
<li>元素在其父元素中水平方向的布局，<font color=#F00>必须满足</font>由以下几个属性值组成的等式：<br><code>margin-left</code>+<code>border-left</code>+<code>padding-left</code>+<code>width</code>+<code>padding-right</code>+<code>border-right</code>+<code>margin-right</code>=其父元素内容区的宽度</li>
<li>如果相加结果使等式不成立，则称为<font color=#F00>过度约束</font>，此时等式会自动调整，调整规律如下：</li>
</ul>
<p>1.如果以上7个值中没有 auto ，则自动调整 右外边距<br>2.如果 宽度 为 auto，则左右外边距不变，宽度自动调整<br>3.如果 左/右外边距 为 auto，则宽度和右/左外边距不变，左/右外边距自动调整<br>4.如果 宽度和一个外边距 同时设置为 auto，则宽度会调整到最大，已设置的外边距会调整为0<br>5.如果 左右外边距 同时设置为 auto，宽度指定大小，则会将外边距设置为相同的值，实现水平居中效果<br>6.如果 宽度和左右外边距 同时设置为 auto，则宽度最大，左右外边距为0</p>
<h2 id="6-浏览器默认样式"><a href="#6-浏览器默认样式" class="headerlink" title="6.浏览器默认样式"></a>6.浏览器默认样式</h2><ul>
<li><p>默认不是贴着边，好像自带外边距，实际上是浏览器为在页面中没有样式时，也可以有一个比较好的显示效果，所以为很多元素设置了默认的 <code>margin</code> 和 <code>padding</code>。</p>
</li>
<li><p>在编写样式之前需要将默认的样式给去掉。用通配符选择所有元素，将 <code>margin</code> 和 <code>padding</code> 设置为0，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> *&#123;</span><br><span class="line"> 	margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>或者引用别人的重置样式表——<code>reset.css</code> 或 <code>normalize.css</code> 。前者是去除，后者是统一，两个一般不同时使用。</p>
</li>
<li><p><code>reset.css</code> 是一个外国友人所写的，他的原链接可以去 <a href="https://meyerweb.com/eric/tools/css/reset/">这里</a> 查看，如果打不开的话，可以直接点击我 <a href="https://pan.baidu.com/s/1DVApsJEjewS8bkarko904w">这里</a> （提取码：k7i2）来进行下载</p>
</li>
<li><p><code>normalize.css</code> 原链接可以去 <a href="https://github.com/necolas/normalize.css">这里</a> 查看，如果打不开的话，可以直接点击我 <a href="https://pan.baidu.com/s/1sRGzWuSWiUzytPSqNkx_4A">这里</a> （提取码：0nol）来进行下载</p>
</li>
</ul>
<h2 id="7-内联元素的盒模型"><a href="#7-内联元素的盒模型" class="headerlink" title="7.内联元素的盒模型"></a>7.内联元素的盒模型</h2><ul>
<li>内联元素不能设置 <code>width</code> 和 <code>height</code></li>
<li>内联元素可以设置水平方向的内边距（可以影响页面的布局）。也可以设置垂直方向的内边距（不会影响页面的布局）</li>
<li>内联元素可以设置水平方向的边框（可以影响页面的布局）。也可以设置垂直方向的边框（不会影响页面的布局）</li>
<li>内联元素可以设置水平方向的外边距，但不支持垂直外边距</li>
</ul>
<h2 id="8-display-样式"><a href="#8-display-样式" class="headerlink" title="8.display 样式"></a>8.display 样式</h2><ul>
<li>通过 display 样式可以修改元素的类型</li>
<li>可选值：<br>inline：可以将一个元素设置为内联元素<br>block：可以将一个元素设置为块元素<br>inline-block：可以将一个元素设置为行内块元素，既有行内元素又有块元素的特点，即可以设置宽高，又不会独占一行<br>table：可以将元素设置为表格显示<br>none：可以将一个元素隐藏，<font color=#FF0000>且不会在页面中继续占有位置，区别于下面</font></li>
</ul>
<h2 id="9-visibility-样式"><a href="#9-visibility-样式" class="headerlink" title="9.visibility 样式"></a>9.visibility 样式</h2><ul>
<li>可以用来设置元素的隐藏和显示的状态</li>
<li>可选值：<br>visible：默认值，元素默认显示在页面<br>hidden：元素会在页面上隐藏不显示，<font color=#FF0000>但会在页面中继续占有位置，区别于上面</font></li>
</ul>
<h2 id="10-overflow-样式"><a href="#10-overflow-样式" class="headerlink" title="10.overflow 样式"></a>10.overflow 样式</h2><ul>
<li>适用场景：当子元素存在于父元素的内容区中时，理论上子元素最大可以等于父元素内容区的大小，如果子元素的大小超出父元素的内容区，超出部分称为溢出的内容，需要使用 overflow来处理</li>
<li>可选值：<br>visible：默认值，超出时会显示<br>hidden：溢出的内容会被修剪，不会显示<br>scroll：会为父元素添加滚动条来查看溢出内容（不管内容是否溢出，都会添加水平和垂直方向的滚动条<br>auto：会根据需求自动添加滚动条，若不溢出则不添加</li>
</ul>
<h2 id="11-文档流"><a href="#11-文档流" class="headerlink" title="11.文档流"></a>11.文档流</h2><ul>
<li>文档流处在网页的最底层，表示的是一个页面中的位置，创建的元素默认都处在文档流中。</li>
<li>块元素在文档流中独占一行，自上向下排列。默认宽度是父元素的100%，默认高度是被子元素撑开。</li>
<li>内联元素在文档流中只占自身的大小，默认从左向右排列。默认宽度和高度都是被内容撑开。</li>
<li>父元素的高度默认是被子元素撑开的。</li>
</ul>
<h2 id="12-盒子的浮动"><a href="#12-盒子的浮动" class="headerlink" title="12.盒子的浮动"></a>12.盒子的浮动</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="(1).介绍"></a>(1).介绍</h3><ul>
<li><p>使用 float 属性来使盒子脱离文档流，达到水平排放的效果</p>
</li>
<li><p>可选值：<br>none：默认值，元素在文档流中排列<br>left：元素脱离文档流，向页面的左侧浮动<br>right：元素脱离文档流，向页面的右侧浮动</p>
</li>
</ul>
<h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="(2).注意事项"></a>(2).注意事项</h3><ul>
<li>元素浮动以后会尽量往左上或者右上浮动，直到遇到父元素的边框或者其他的浮动元素</li>
<li>如果浮动元素上边是一个没有浮动的块元素，则不会超过该块元素</li>
<li>浮动的元素不会超过他上边的兄弟元素，最多一边齐</li>
<li>浮动的元素不会盖住文字，文字会自动环绕在浮动元素周围</li>
<li>块元素脱离文档流后，高度和宽度都被内容撑开<br>内联元素脱离文档流后，会变成块元素，高度和宽度都被内容撑开</li>
</ul>
<h3 id="3-清除浮动对其他元素的影响"><a href="#3-清除浮动对其他元素的影响" class="headerlink" title="(3)清除浮动对其他元素的影响"></a>(3)清除浮动对其他元素的影响</h3><ul>
<li>使用 clear 来清除其他浮动元素对当前元素的影响</li>
<li>此方法只可以清除兄弟元素的浮动，无法清除父子元素的浮动</li>
<li>可选值：<br>none：默认值，不清除浮动<br>left：清除左侧浮动元素对当前元素的影响<br>right：清除右侧浮动元素对当前元素的影响<br>both：清除两侧浮动元素对当前元素的影响，默认清除对它影响最大的那个元素的浮动</li>
</ul>
<h2 id="13-BFC属性"><a href="#13-BFC属性" class="headerlink" title="13.BFC属性"></a>13.BFC属性</h2><h3 id="1-介绍-1"><a href="#1-介绍-1" class="headerlink" title="(1).介绍"></a>(1).介绍</h3><ul>
<li>W3C 标准中，在页面中的每个元素都有一个隐藏的属性——Block Formatting Context，简称BFC</li>
<li>该属性默认是关闭的，可以选择打开或者关闭</li>
</ul>
<h3 id="2-开启后的特性"><a href="#2-开启后的特性" class="headerlink" title="(2).开启后的特性"></a>(2).开启后的特性</h3><ul>
<li>父元素的垂直外边距不会和子元素重叠</li>
<li>开启BFC的元素不会被浮动元素所覆盖</li>
<li>开启BFC的元素可以包含浮动的子元素</li>
</ul>
<h3 id="3-开启方法"><a href="#3-开启方法" class="headerlink" title="(3).开启方法"></a>(3).开启方法</h3><ul>
<li>设置元素浮动</li>
<li>设置元素的绝对定位<font color=#FF0000>（效果和浮动类似）</font></li>
<li>设置元素的 display 样式为 inline-block</li>
<li>将元素的 overflow 设置为一个非 visible 的值（推荐设置为 hidden，auto 也可以）<font color=#FF0000>（注意：IE6不支持，如果想要支持IE6，请添加一行 <code>zoom:1;</code>）</font></li>
</ul>
<h2 id="14-0-高度塌陷问题"><a href="#14-0-高度塌陷问题" class="headerlink" title="14-0.高度塌陷问题"></a>14-0.高度塌陷问题</h2><ul>
<li>在文档流中，父元素的高度默认是被子元素撑开的。但是当为子元素设置浮动以后，子元素脱离文档流，使得子元素无法撑起父元素的高度，此时就会造成父元素的高度塌陷问题。</li>
<li>虽然可以给父元素设置一个高度，但子元素高度发生改变时，父元素并不能自动适应子元素的变化，所以不推荐此种方法。</li>
<li>推荐方法：开启元素的 BFC 属性。开启的前三种方法都会造成父元素的宽度丢失问题，所以这里推荐使用第四种方法，即在父元素中设置为：<code>overflow: hidden;</code></li>
<li><font color=#FF0000>最终方法1：在高度塌陷的父元素里边的最后，添加一个空白的div，对于这个空白的div执行清除浮动效果，此时这个div就可以撑开父元素的高度了，且基本没有副作用，但会添加多余的结构</font></li>
<li><font color=#FF0000>最终推荐方法2：通过after伪类向元素最后添加一个空白的块元素，然后对其清除浮动，这样就不会添加多余的架构，代码如下：</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">	content: &quot;&quot;;	//这里仅仅为了撑开父元素，所以内容区不需要写内容</span><br><span class="line">	display: block;	//转成块元素</span><br><span class="line">	clear: both;	//清除浮动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-1-clearfix的最终写法"><a href="#14-1-clearfix的最终写法" class="headerlink" title="14-1.clearfix的最终写法"></a>14-1.clearfix的最终写法</h2><ul>
<li><p>使用 clearfix 既可以消除父子元素的重叠问题，又可以解决高度塌陷问题，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix::before,</span><br><span class="line">.clearfix::after&#123;</span><br><span class="line">	content: &quot;&quot;;</span><br><span class="line">	display: table;</span><br><span class="line">	clear: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这里的 clearfix 是给需要设置的 div 起的 class 属性</p>
</li>
</ul>
<h2 id="15-定位"><a href="#15-定位" class="headerlink" title="15.定位"></a>15.定位</h2><ul>
<li>将指定的元素摆放到页面的任意位置</li>
<li>通过 <code>position</code> 属性来设置元素的定位</li>
<li>可选值：<br>static：默认值，没有开启定位<br>relative：开启元素的相对定位<br>absolute：开启元素的绝对定位<br>fixed：开启元素的固定定位（绝对定位的一种）<br>sticky：开启元素的粘滞定位</li>
</ul>
<h3 id="1-相对定位"><a href="#1-相对定位" class="headerlink" title="(1).相对定位"></a>(1).相对定位</h3><ul>
<li><p>当开启元素的相对定位但不设置偏移量时，没有任何变化。设置代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position: relative;</span><br><span class="line">left: 100px;		//相对于原来的位置</span><br></pre></td></tr></table></figure></li>
<li><p>相对定位是参照与元素在文档流中的位置进行定位的</p>
</li>
<li><p>偏移量为 left、right、top、bottom：元素相对于其定位位置的左、右、上、下侧偏移量</p>
</li>
<li><p>相对定位的元素不会脱离文档流</p>
</li>
<li><p>相对定位会使元素提升一个层级，所以定位的元素可以盖住文档中的元素</p>
</li>
<li><p>相对定位不会改变元素的性质，块还是块，内联还是内联</p>
</li>
</ul>
<h3 id="2-绝对定位"><a href="#2-绝对定位" class="headerlink" title="(2).绝对定位"></a>(2).绝对定位</h3><ul>
<li>开启绝对定位会使元素脱离文档流</li>
<li>开启绝对定位后如果不设置偏移量，则元素位置不会发生变化</li>
<li>绝对定位是相对于离他最近的开启了定位的祖先元素进行定位的（一般情况，开启了子元素的绝对定位都会同时开启父元素的相对定位），如果所有的祖先元素都没有开启定位，则相对于根元素进行定位的</li>
<li>绝对定位会使元素提升一个层级，所以定位的元素可以盖住文档中的元素</li>
<li>绝对定位会改变元素的性质，内联元素变成块元素，故可以设置宽高；块元素变成内联元素，故宽度和高度默认都被内容撑开</li>
</ul>
<h3 id="3-固定定位"><a href="#3-固定定位" class="headerlink" title="(3).固定定位"></a>(3).固定定位</h3><ul>
<li>固定定位也是一种绝对定位，大部分特点都和绝对定位一样</li>
<li>不同的是：固定定位永远都会相对于浏览器的视口进行定位</li>
<li>固定定位会固定在浏览器窗口的某一个位置，不会随滚动条滚动。即浏览器页面的小广告</li>
<li>IE6不支持固定定位</li>
</ul>
<h3 id="4-层级"><a href="#4-层级" class="headerlink" title="(4).层级"></a>(4).层级</h3><ul>
<li>如果定位元素的层级是一样的，则下边的元素会盖住上边的</li>
<li>通过 <code>z-index</code> 属性来设置元素的层级，其值为正整数，该值会作为当前元素的层级，层级越高，越优先显示。但父元素的层级再高，也不会盖住子元素</li>
<li>对于没有开启定位的元素，不能使用 <code>z-index</code></li>
<li>祖先元素层级再高，也不会盖住后代元素</li>
</ul>
<h3 id="5-元素透明"><a href="#5-元素透明" class="headerlink" title="(5).元素透明"></a>(5).元素透明</h3><ul>
<li>使用 <code>obacity</code> 可以用来设置元素背景的透明度，它需要一个0-1之间的值</li>
<li>0表示全透明；1表示不透明；0.5表示半透明</li>
<li>不支持IE8及以下，但可以使用 <code>filter: alpha(opacity=透明度);</code> 来设置，这里的值为0-100之间</li>
</ul>
<h3 id="6-包含块"><a href="#6-包含块" class="headerlink" title="(6).包含块"></a>(6).包含块</h3><ul>
<li>正常情况下：包含块就是离当前元素最近的祖先元素</li>
<li>绝对定位下：包含块就是离它最近的开启了定位的祖先元素，如果所有的祖先元素都没有开启定位，则根元素就是它的包含块</li>
<li>html 为根元素</li>
</ul>
<h3 id="7-绝对定位元素的位置"><a href="#7-绝对定位元素的位置" class="headerlink" title="(7).绝对定位元素的位置"></a>(7).绝对定位元素的位置</h3><h4 id="a-水平方向布局："><a href="#a-水平方向布局：" class="headerlink" title="a.水平方向布局："></a>a.水平方向布局：</h4><ul>
<li>公式：<code>left</code>+<code>margin-left</code>+<code>border-left</code>+<code>padding-left</code>+<code>width</code>+<code>padding-right</code>+<code>border-right</code>+<code>margin-right</code>+ <code>right</code> =包含块内容区的宽度</li>
<li>当开启绝对定位后，水平方向的布局等式就需要添加 left 和 right 两个值了</li>
<li>规则与之前一致，当发生过度约束时，如果9个值中没有 auto ，则自动调整 right 值以使等式成立；如果有 auto ，则自动调整 auto 的值以使等式成立</li>
<li>此时，可设置为 auto 的值就有 margin、width、left、right 四个</li>
<li>因为 left 和 right 的值默认是 auto ，所以如果不指定 left 和 right 的值，则等式不成立时，会自动调成这两个值</li>
<li>水平居中：只要将左右外边距设置为 auto 即可</li>
</ul>
<h4 id="b-垂直方向布局："><a href="#b-垂直方向布局：" class="headerlink" title="b.垂直方向布局："></a>b.垂直方向布局：</h4><ul>
<li>公式：<code>top</code>+<code>margin-top</code>+<code>border-top</code>+<code>padding-top</code>+<code>width</code>+<code>padding-bottom</code>+<code>border-bottom</code>+<code>margin-bottom</code>+ <code>bottom</code> =包含块内容区的高度</li>
<li>垂直居中：只要将上下外边距设置为 auto 即可</li>
</ul>
<h1 id="四、表单"><a href="#四、表单" class="headerlink" title="四、表单"></a>四、表单</h1><h2 id="1-基础知识-1"><a href="#1-基础知识-1" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><ul>
<li>作用：用来将用户信息提交给远程服务器的</li>
<li>需要填写表单的地方，如：百度的搜索框、注册、登录等</li>
<li>使用 <code>&lt;form&gt;&lt;/form&gt;</code> 标签来创建一个表单，该标签中的 action 属性必须指定，该属性指向的是一个服务器的地址，下面的表单设计需要在此标签中进行</li>
<li>用户填写的信息会附在 url 地址的后边以查询字符串的形式发送给服务器，为url地址？查询字符串（查询字符串的格式为 属性名=属性值）</li>
</ul>
<h2 id="2-表单的设计"><a href="#2-表单的设计" class="headerlink" title="2.表单的设计"></a>2.表单的设计</h2><h3 id="0-label-标签"><a href="#0-label-标签" class="headerlink" title="(0).label 标签"></a>(0).label 标签</h3><ul>
<li>该标签专门用来选中表单中的提示文字，如下面的：用户名、密码、男。女等</li>
<li>该标签可以指定一个 for 属性，该属性的值需要指定一个表单项的 id 值</li>
<li>该标签常用于实现点击文字即可选中某一个选项<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;label for=&quot;un&quot;&gt;用户名&lt;/label&gt;</span><br><span class="line">&lt;input id=&quot;un&quot; type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-文本框"><a href="#1-文本框" class="headerlink" title="(1).文本框"></a>(1).文本框</h3><ul>
<li><p>使用 <code>&lt;input&gt;</code> 标签来创建，它的 type 属性是 text</p>
</li>
<li><p>如果希望表单项中的数据提交的服务器，还必须给表单项指定 name 属性，name 表示提交内容的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>文本框中有水印效果，起到提示作用，但一点进文本框就会消失，需要使用到 placeholder 属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot; palceholder=&quot;Your name&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-提交按钮"><a href="#2-提交按钮" class="headerlink" title="(2).提交按钮"></a>(2).提交按钮</h3><ul>
<li>使用 input 标签来创建，它的 type 属性是 submit，可以通过 value 属性来指定按钮上的文字<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>除了使用 <code>&lt;input&gt;</code> ，也可以使用 <code>&lt;button&gt;</code> 标签来创建按钮<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;submit&quot;&gt;提交&lt;/button</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-重置按钮"><a href="#3-重置按钮" class="headerlink" title="(3).重置按钮"></a>(3).重置按钮</h3><ul>
<li>使用 <code>&lt;input&gt;</code> 标签来创建，它的 type 属性是 reset</li>
<li>点击重置按钮以后会将表单内容变成默认值<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;reset&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>除了使用 <code>&lt;input&gt;</code> ，也可以使用 <code>&lt;button&gt;</code> 标签来创建按钮<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;reset&quot;&gt;重置&lt;/button</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-按钮"><a href="#4-按钮" class="headerlink" title="(4).按钮"></a>(4).按钮</h3><ul>
<li><p>使用 <code>&lt;input&gt;</code> 标签来创建，它的 type 属性是 botton</p>
</li>
<li><p>该按钮没有任何功能，只用来被点击</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input type=&quot;botton&quot; value=&quot;按钮&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>除了使用 input ，也可以使用 button 标签来创建按钮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;button&quot;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>想要实现鼠标移到按钮上时变成小手，可以使用 cursor 属性来设置鼠标指针的样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;btn&quot; type=&quot;button&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	.btn&#123;</span><br><span class="line">		cursor: pointer;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-密码框"><a href="#5-密码框" class="headerlink" title="(5).密码框"></a>(5).密码框</h3><ul>
<li><p>使用 <code>&lt;input&gt;</code> 标签来创建，它的 type 属性是 password</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密码：&lt;input type=&quot;password&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>密码框中有水印效果，起到提示作用，但一点进密码框就会消失，需要使用到 placeholder 属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密码：&lt;input type=&quot;password&quot; placeholder=&quot;Your password&quot;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-单选按钮"><a href="#6-单选按钮" class="headerlink" title="(6).单选按钮"></a>(6).单选按钮</h3><ul>
<li>使用 <code>&lt;input&gt;</code> 标签来创建，它的 type 属性是 radio</li>
<li>单选按钮通过 name 属性来分组</li>
<li>像这种需要用户选择但不需要直接填写的内容项，还必须指定一个 value 属性，这样被选中的表单项的 value 属性值将会最终提交给服务器<ul>
<li><strong style="color:red;">PS：2021.03.23发现这里的value值必须使用双引号，不然 Hbuilder 编辑器会报错</strong></li>
</ul>
</li>
<li>如果希望单选按钮中指定默认选中的选项，则在希望选中的项中添加 <code>checked=&quot;checked&quot;</code> 即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot; /&gt;男</span><br><span class="line">	 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot; /&gt;女</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-多选按钮"><a href="#7-多选按钮" class="headerlink" title="(7).多选按钮"></a>(7).多选按钮</h3><ul>
<li>使用 <code>&lt;input&gt;</code> 标签来创建，它的 type 属性是 checkbox</li>
<li>如果希望多选按钮中指定默认选中的选项，则在希望选中的项中添加 <code>checked=&quot;checked&quot;</code> 即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爱好：&lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;zq&quot; /&gt;足球</span><br><span class="line">	 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;lq&quot; /&gt;篮球</span><br><span class="line">	 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;pq&quot; /&gt;排球</span><br><span class="line">	 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;jq&quot; /&gt;毽球</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-下拉列表"><a href="#8-下拉列表" class="headerlink" title="(8).下拉列表"></a>(8).下拉列表</h3><ul>
<li><p>使用 <code>&lt;select&gt;</code> 标签来创建，在其中使用 option 标签来创建一个一个列表项</p>
</li>
<li><p>下拉列表中的 name 属性要给 <code>&lt;select&gt;</code> 标签设置，而 value 属性要给 option 标签设置</p>
</li>
<li><p>如果希望下拉列表中指定默认选中的选项，则在希望选中的项中添加 <code>selected=&quot;selected&quot;</code> 即可</p>
</li>
<li><p>当为下拉列表添加一个 <code>multiple=&quot;multipe&quot;</code> ，则下拉列表变为一个多选的下拉列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你喜欢的明星：</span><br><span class="line">	&lt;select name=&quot;star&quot;&gt;</span><br><span class="line">		&lt;option value=&quot;cyx&quot;&gt;陈奕迅&lt;/option&gt;</span><br><span class="line">		&lt;option value=&quot;sdl&quot;&gt;苏打绿&lt;/option&gt;</span><br><span class="line">		&lt;option value=&quot;wyt&quot;&gt;五月天&lt;/option&gt;</span><br><span class="line">	&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>&lt;select&gt;</code> 中可以使用 optgroup 来对选项分组，label 属性用来填写分组的名字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select name=&quot;star&quot;&gt;</span><br><span class="line">	&lt;optgroup label=&quot;女明星&quot;&gt;</span><br><span class="line">		&lt;option value=&quot;fbb&quot;&gt;范冰冰&lt;/option&gt;</span><br><span class="line">	&lt;/optgroup&gt;</span><br><span class="line">	&lt;optgroup label=&quot;男明星&quot;&gt;</span><br><span class="line">		&lt;option value=&quot;cyx&quot;&gt;陈奕迅&lt;/option&gt;</span><br><span class="line">	&lt;/optgroup&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-文本域——简介"><a href="#9-文本域——简介" class="headerlink" title="(9).文本域——简介"></a>(9).文本域——简介</h3><ul>
<li><p>使用 <code>&lt;textarea&gt;</code> 标签来创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介：&lt;textarea name=&quot;info&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 resize 属性来设置文本域不能调整大小，即右下角没有调整按钮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resize: none;</span><br></pre></td></tr></table></figure></li>
<li><p>文本域中有水印效果，起到提示作用，但一点进文本域就会消失，需要使用到 placeholder 属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介：&lt;textarea name=&quot;info&quot; placeholder=&quot;Your introduce&quot;&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-表单项的分组"><a href="#10-表单项的分组" class="headerlink" title="(10).表单项的分组"></a>(10).表单项的分组</h3><ul>
<li>使用 <code>&lt;fieldset&gt;</code> 来为表单项进行分组，可以将表单项中的同一组放到一个 <code>&lt;filedset&gt;</code> 中</li>
<li>可以使用 legend 子标签指定组名<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;fieldset&gt;</span><br><span class="line">	&lt;legend&gt;用户信息&lt;/legend&gt;</span><br><span class="line">		&lt;label for=&quot;un&quot;&gt;用户名&lt;/label&gt;</span><br><span class="line">		&lt;input id=&quot;un&quot; type=&quot;text&quot; name=&quot;username&quot; /&gt;</span><br><span class="line">		&lt;label for=&quot;pw&quot;&gt;密码&lt;/label&gt;</span><br><span class="line">		&lt;input id=&quot;pw&quot; type=&quot;password&quot; /&gt;</span><br><span class="line">&lt;/fieldset&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-其余属性"><a href="#3-其余属性" class="headerlink" title="3.其余属性"></a>3.其余属性</h2><ul>
<li><code>autocomplete=&quot;off&quot;</code> 会关闭自动补全</li>
<li><code>readonly</code> 将表单项设置为只读，数据会提交</li>
<li><code>disabled</code> 将表单项设置为禁用，数据不会提交，其值为 disabled</li>
<li><code>autofocus</code> 设置表单项自动获取焦点</li>
</ul>
<h1 id="五、进阶之动画"><a href="#五、进阶之动画" class="headerlink" title="五、进阶之动画"></a>五、进阶之动画</h1><h2 id="1-过渡"><a href="#1-过渡" class="headerlink" title="1.过渡"></a>1.过渡</h2><ul>
<li>使用 <code>transition</code> 来指定一个属性发生变化时的切换方式</li>
<li><code>transition-property</code> 用来指定要执行过渡的属性，height、width 等可以计算的值都可以过渡，多个属性间用逗号隔开，所有属性都需要过渡时可以使用 all</li>
<li><code>transition-duration</code> 用来指定过渡效果的持续时间，可以分别指定时间，用逗号隔开，单位为秒和毫秒</li>
<li><code>transition-timing-function</code> 为时序函数，用来指定过渡的执行方式，可选值有：<br>ease：默认值，慢速开始，先加速再减速<br>linear：匀速运动，使用时并不自然<br>ease-in：加速运动<br>ease-out：减速运动<br>ease-in-out：先加速后减速<br>cubic-bezier()：贝赛尔曲线，用来指定时序函数，可在 <a href="https://cubic-bezier.com/">这个</a> 网站查看<br>steps()：分步执行过渡效果，括号内填写(2,start)或者(2,end)或者(2)</li>
<li><code>transition-delay</code> 用来指定过渡效果的延迟，等待一段时间后再执行</li>
<li>通常使用简写属性 <code>transition</code> 来进行设置，可以同时设置过渡相关的所有属性且没有顺序要求，但两个时间中第一个是持续时间，第二个是延迟时间</li>
<li><font color=#F00>注意：过渡效果必须指定执行过渡的属性和时间，且必须从一个有效数值向另一个有效数值的过渡，auto 并不是一个有效数值</font></li>
</ul>
<h2 id="2-动画"><a href="#2-动画" class="headerlink" title="2.动画"></a>2.动画</h2><ul>
<li><font color=#F00>设置动画效果，必须先要设置一个关键帧</font>，关键帧设置了动画执行的每一个步骤，语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyframes 关键帧的名字&#123;</span><br><span class="line">	from&#123;&#125;		//设置动画的开始，也可以使用0%</span><br><span class="line">	to&#123;&#125;		//设置动画的结束，也可以使用100%</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 css 中需要使用 <code>animation</code> 来设置动画</li>
<li><code>animation-name</code> 指定关键帧的名字</li>
<li><code>animation-duration</code> 指定动画的执行时间</li>
<li><code>animation-delay</code> 指定动画的延时</li>
<li><code>animation-timing-function</code> 指定动画的执行方式，类似于过渡</li>
<li><code>animation-iteration-count</code> 指定动画的执行的次数，infinite 表示无限执行</li>
<li><code>animation-direction</code> 指定动画运行的方向，可选值如下：<br>normal：默认值，从from到to<br>reverse：从to到from<br>alternate：从from到to，重复执行是反向执行<br>alternate-reverse：从to到from，重复执行是反向执行</li>
<li><code>animation-play-state</code> 指定动画的执行状态，可选值如下：<br>running：默认值，动画执行<br>paused：动画暂停</li>
<li><code>animation-fill-mode</code> 指定动画的填充模式，可选值如下：<br>none：默认值，动画执行完毕元素回到原来的位置上<br>forwards：动画执行完毕元素会停止在动画结束位置<br>backwards：动画延迟等待时，元素就会处于开始位置<br>both：结合 forwards 和 backwards</li>
<li>通常使用简写属性 <code>animation</code> 来进行设置，可以同时设置动画相关的所有属性且没有顺序要求，但两个时间中第一个是持续时间，第二个是延迟时间</li>
</ul>
<h3 id="！关键帧的拓展"><a href="#！关键帧的拓展" class="headerlink" title="！关键帧的拓展"></a><font color=#F00>！关键帧的拓展</font></h3><ul>
<li>关键帧中的 from 和 to 可以看做是一个动画的起点和终点，而在这个动画过程中，还会有其他的点位，而这些点位就可以使用百分数来表示所处的位置，如：一个动画执行需要10s，那么50%就可以表示该动画进行到第5秒的时候，所以，关键帧可以进行更详细的描述，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@keyrames run&#123;</span><br><span class="line">	from&#123;</span><br><span class="line">		margin-top: 0;</span><br><span class="line">	&#125;</span><br><span class="line">	33%&#123;</span><br><span class="line">		margin-top: 400px;</span><br><span class="line">	&#125;</span><br><span class="line">	66%&#123;</span><br><span class="line">		margin-top: 100px;</span><br><span class="line">	&#125;</span><br><span class="line">	to&#123;</span><br><span class="line">		margin-top: 400px;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如上，就可以形成一个小球从上往下又弹起又落下的效果，当然你也可以在from甚至是33%中添加 animation 属性来修改不同时段的小球速度</li>
</ul>
<h2 id="3-变形"><a href="#3-变形" class="headerlink" title="3.变形"></a>3.变形</h2><ul>
<li>变形就是通过 CSS 来改变元素的形状或位置，但不会影响到页面的布局</li>
<li>使用 <code>transform</code> 来设置元素的变形效果，可选值：</li>
</ul>
<h3 id="1-平移"><a href="#1-平移" class="headerlink" title="(1).平移"></a>(1).平移</h3><ul>
<li><p>平移可以设置像素单位，也可以使用百分比来相对于自身来计算<br>translateX()：沿着X轴平移<br>translateY()：沿着Y轴平移<br>translateZ()：沿着Z轴平移</p>
</li>
<li><p>关于Z轴方向的平移，是在调整元素和人眼之间的距离，此时，如果不设置网页的视距，那么，该平移是无任何效果的，而视距一般直接设置给 html 标签，大小无任何要求，尽量大一些！</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">html&#123;</span><br><span class="line">	perspective: 800px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="！引申-关于元素的水平垂直居中"><a href="#！引申-关于元素的水平垂直居中" class="headerlink" title="！引申-关于元素的水平垂直居中"></a><font color=#F00>！引申-关于元素的水平垂直居中</font></h4><ul>
<li>之前的方法，是建立在元素的大小确定情况下，可以通过使用 margin 的 auto 属性来设置居中，但局限在元素大小确定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	top: 0;</span><br><span class="line">	bottom: 0;</span><br><span class="line">	left: 0;</span><br><span class="line">	right: 0;</span><br><span class="line">	margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>若元素大小由内容撑开，那么就需要使用绝对定位+平移来做</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	left: 50%;	//通过定位将其离左边缘为整个父元素的50%</span><br><span class="line">	transform: translateX(-50%);	//将其自身向左平移50%，达到元素本身的中线与父元素的中线重合</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="！引申-平移造成的立体感"><a href="#！引申-平移造成的立体感" class="headerlink" title="！引申-平移造成的立体感"></a><font color=#F00>！引申-平移造成的立体感</font></h4><ul>
<li>有些网页在鼠标移入的时候，某些块元素会有一种浮动加阴影的效果，这时就可以使用变形来达到这一个效果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">	height: 100px;</span><br><span class="line">	width: 100px;</span><br><span class="line">	background-color: #fff;</span><br><span class="line">	transition: all .3s;</span><br><span class="line">&#125;</span><br><span class="line">.box1:hover&#123;</span><br><span class="line">	transform: translateY(-4px);</span><br><span class="line">	box-shadow: 0 0 10px rgba(0,0,0,.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-旋转"><a href="#2-旋转" class="headerlink" title="(2).旋转"></a>(2).旋转</h3><ul>
<li>通过旋转可以使元素沿着x,y,z旋转指定的角度，其值可以使用45deg表示45度，1turn表示1圈<br>rotateX()：沿着X轴旋转<br>rotateY()：沿着Y轴旋转<br>rotateZ()：沿着Z轴旋转</li>
<li>对于旋转，也需要设置网页的视距，而且旋转的平移方向也会变换</li>
<li>如果旋转180度，会显示元素的背面，可以使用 <code>backface-visibility</code> 来设置背面是否显示</li>
</ul>
<h4 id="！引申-利用旋转写时钟"><a href="#！引申-利用旋转写时钟" class="headerlink" title="！引申-利用旋转写时钟"></a><font color=#F00>！引申-利用旋转写时钟</font></h4><ul>
<li>实际上，表中的时针分针秒针是通过其所处的容器来达成旋转的，因为如果单纯让一条线旋转的话，会以这条线的中心点进行旋转的，并不能达成各个针沿一点旋转</li>
<li>所以，具体的设计就是给每一个针创建一个容器，然后针只取容器的50%即可实现沿一点旋转</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.sec-wrapper&#123;</span><br><span class="line">	width: 70%;</span><br><span class="line">	height: 70%;</span><br><span class="line">	animation: run 60s steps(60) infinite;</span><br><span class="line">&#125;</span><br><span class="line">.sec&#123;</span><br><span class="line">	width: 4px;</span><br><span class="line">	height: 50%;</span><br><span class="line">	background-color: #F00;</span><br><span class="line">	margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes run&#123;</span><br><span class="line">	from&#123;</span><br><span class="line">		transform: rotateZ(0);</span><br><span class="line">	&#125;</span><br><span class="line">	to&#123;</span><br><span class="line">		transform: rotateZ(360deg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3D视图"><a href="#3-3D视图" class="headerlink" title="(3).3D视图"></a>(3).3D视图</h3><ul>
<li>当使用平移和旋转时，可以制作类似于骰子的六面体东西</li>
<li>想要达到此效果，不仅需要给 html 设置视距，还需要给                                                                                                                                                                   容器设置3D视图效果才会变成立体形状</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform-style: preserve-3d;</span><br></pre></td></tr></table></figure>

<h3 id="4-缩放"><a href="#4-缩放" class="headerlink" title="(4).缩放"></a>(4).缩放</h3><ul>
<li>通过 scale 来控制元素的放大与缩小，一般用于 hover ，可选值：<br>scaleX()：水平方向缩放<br>scaleY()：垂直方向缩放<br>scale()：双方向缩放<br>中间添加数字，&gt;1为方法，&lt;1为缩小</li>
</ul>
<h3 id="5-原点"><a href="#5-原点" class="headerlink" title="(5).原点"></a>(5).原点</h3><ul>
<li>通过 <code>transform-origin</code> 来设置变形的原点，可选值：<br>center：中心<br>0 0：0 0点处<br>20px 20px：20px处</li>
</ul>
<h1 id="六、进阶之弹性盒"><a href="#六、进阶之弹性盒" class="headerlink" title="六、进阶之弹性盒"></a>六、进阶之弹性盒</h1><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h2><ul>
<li><p>又名伸缩盒，是 CSS 中的又一种布局手段，主要用来代替浮动来完成页面的布局</p>
</li>
<li><p>可以使元素具有弹性，让元素跟随页面的大小的改变而改变</p>
</li>
<li><p>要使用弹性盒，必须将一个元素设置为弹性容器，如下两种设置方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">	display: flex;			//块级弹性容器</span><br><span class="line">	display: inline-flex;	//行内弹性容器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>弹性元素：弹性容器的子元素是弹性元素，且一个元素可以同时是弹性容器和弹性元素 </p>
</li>
<li><p>主轴：弹性元素的排列方向就是主轴</p>
</li>
<li><p>侧轴：与主轴垂直的方向就是侧轴</p>
</li>
</ul>
<h2 id="2-弹性容器的属性"><a href="#2-弹性容器的属性" class="headerlink" title="2.弹性容器的属性"></a>2.弹性容器的属性</h2><ul>
<li><p><code>flex-direction</code> 属性来设置指定容器中弹性元素的排列方式，可选值：<br>row：默认值，水平排列（从左向右），主轴为从左向右<br>row-reverse：水平排列（从右向左）<br>column：纵向排列（从上向下）<br>column-reverse：纵向排列（从下向上）</p>
</li>
<li><p><code>flex-wrap</code> 属性来设置弹性元素是否在弹性容器中自动换行<br>nowrap：默认值，元素不自动换行<br>wrap：元素沿着辅轴方向自动换行<br>wrap-reverse：元素沿着辅轴反方向换行</p>
</li>
<li><p><code>flex-flow</code> 是 wrap 和 direction 的简写属性</p>
</li>
<li><p><code>justify-content</code> 用来设置主轴上的元素如何排列，可选值：<br>flex-start：元素沿着主轴起边排列<br>flex-end：元素沿着主轴终边排列<br>center：元素沿着主轴居中排列 —— <font color=#F00>不需要设置外边距，直接实现居中效果</font><br>space-around：空白分布到元素两侧<br>space-evenly：空白分布到元素的单侧，兼容性不太好<br>space-between：空白均匀分布到元素间</p>
</li>
<li><p><code>align-items</code> 用来设置辅轴上元素间的关系，可选值：<br>stretch：默认值，将元素的长度设置为相同的值<br>flex-start：元素不会拉伸，沿着辅轴起边对齐<br>flex-end：沿着辅轴终边对齐<br>center：居中对齐<br>baseline：基线对齐</p>
</li>
<li><p><code>align-content</code> 用来设置辅轴空白空间的分布，可选值和 justify 类似</p>
</li>
</ul>
<h2 id="3-弹性元素的属性"><a href="#3-弹性元素的属性" class="headerlink" title="3.弹性元素的属性"></a>3.弹性元素的属性</h2><ul>
<li><p><code>flex-grow</code> 属性来设置弹性元素的伸展系数，即当父元素有多余的空间时，子元素会如何伸展，父元素的剩余空间，会按照比例进行分配</p>
</li>
<li><p><code>flex-shrink</code> 属性来设置弹性元素的收缩系数，即当父元素中的空间不足以容纳所有的子元素时，会对子元素进行收缩（缩减多少是根据缩减洗漱和元素大小来计算的）</p>
</li>
<li><p><code>align-self</code> 用来覆盖当前弹性元素上的 <code>align-items</code></p>
</li>
<li><p><code>flex-basis</code> 属性来设置元素在主轴上的基础长度，可选值：<br>auto：默认值，表示参考元素自身的高度和宽度<br>具体数值：则以该值为主</p>
</li>
<li><p><code>flex</code> 可以设置弹性元素所有的三个样式，顺序为：增长、缩减、基础，可选值：<br>initial：默认值，即 0 1 auto<br>auto：即 1 1 auto<br>none：即 0 0 auto</p>
</li>
<li><p><code>order</code> 用来设置弹性元素的排列顺序</p>
</li>
</ul>
<h1 id="七、进阶之响应式布局"><a href="#七、进阶之响应式布局" class="headerlink" title="七、进阶之响应式布局"></a>七、进阶之响应式布局</h1><ul>
<li><p>网页可以根据不同的设备或窗口大小呈现不同的效果</p>
</li>
<li><p>响应式布局的关键就是<strong>媒体查询</strong></p>
</li>
<li><p>使用 <code>@media 查询规则｛｝</code> 中括号中需要写出完整选择器格式</p>
</li>
</ul>
<h2 id="1-查询规则"><a href="#1-查询规则" class="headerlink" title="1.查询规则"></a>1.查询规则</h2><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><ul>
<li>可以使用逗号来连接多个媒体类型，可选值有：<br>all：所有设备<br>print：打印设备<br>screen：屏幕设备<br>speech：屏幕阅读器</li>
<li>在媒体类型前面加 only ，可以兼容 IE 等老版本浏览器，避免兼容性问题</li>
</ul>
<h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><ul>
<li><p>需要使用小括号来包含媒体特性，可选值有：<br>width：视口的宽度<br>min-width：视口的最小宽度<br>max-width：视口的最大宽度<br>height：视口的高度</p>
</li>
<li><p>样式切换的分界点，称其为<strong>断点</strong>，一般比较常用的断点有：<br>小于768px：超小屏幕，即 max-width=768px<br>大于768px：小屏幕，即 min-width=768px<br>大于992px：中型屏幕，即 min-width=992px<br>大于1200px：大屏幕，即 min-width=1200px</p>
</li>
<li><p>完整写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media only screen and (min-width: 500px) and (max-width: 700px)&#123;</span><br><span class="line">	body&#123;</span><br><span class="line">		background-color: #bfa;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-响应式布局原则"><a href="#2-响应式布局原则" class="headerlink" title="2.响应式布局原则"></a>2.响应式布局原则</h2><ul>
<li>移动端优先</li>
<li>渐进增强</li>
</ul>
<h1 id="八、CSS-Hack"><a href="#八、CSS-Hack" class="headerlink" title="八、CSS Hack"></a>八、CSS Hack</h1><ul>
<li><p>使用 CSS-Hack 可以将一些特殊的代码只在某些特殊的浏览器中执行，而在其他浏览器中不执行</p>
</li>
<li><p>CSS-Hack 实际上指的是一个特殊的代码</p>
</li>
<li><p>条件Hack<br><img src="https://s1.ax1x.com/2020/10/20/BSPuEn.png" alt="css08.png"></p>
</li>
<li><p>例：想要只在IE6中显示，即可如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--[if IE 6]&gt;</span><br><span class="line">	&lt;p&gt;只会在IE6中显示&lt;/p&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>属性Hack<br><img src="https://s1.ax1x.com/2020/10/20/BSPKNq.png" alt="css09.png"></p>
</li>
<li><p>选择符Hack<br><img src="https://s1.ax1x.com/2020/10/20/BSPM40.png" alt="css10.png"></p>
</li>
</ul>
<h1 id="九、CSS-Less"><a href="#九、CSS-Less" class="headerlink" title="九、CSS Less"></a>九、CSS Less</h1><ul>
<li>是一门 CSS 的预处理语言，是 CSS 的增强版</li>
<li>CSS 原生也支持变量的设置，但 IE 并不支持，具体用法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 css 中的根标签中写该格式：</span><br><span class="line">--color: #bfa;</span><br><span class="line">在其余需要用到颜色的地方直接这样编写：</span><br><span class="line">background-color: var(--color);</span><br></pre></td></tr></table></figure>

<ul>
<li><font color=#F00>注意：浏览器无法直接执行 less 代码，要执行必须将 less 转换为 css ，然后再由浏览器执行</font></li>
</ul>
<h2 id="1-less-插件"><a href="#1-less-插件" class="headerlink" title="1.less 插件"></a>1.less 插件</h2><ul>
<li>使用 VS code 可以安装 <code>Easy LESS</code> 插件，该插件会自动把 .less 文件转换为 .css</li>
<li>由于插件会自动转换文件格式，那么只需要在 HTML 文件中引入 CSS 文件即可</li>
</ul>
<h2 id="2-less-语法"><a href="#2-less-语法" class="headerlink" title="2.less 语法"></a>2.less 语法</h2><h3 id="1-后代选择器"><a href="#1-后代选择器" class="headerlink" title="(1).后代选择器"></a>(1).后代选择器</h3><ul>
<li>可以直接在父元素中写子元素的样式，这里就是将box1的子元素box2的背景颜色直接设置了</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">	bcakground-coloe: #bfa;</span><br><span class="line">	.box2&#123;</span><br><span class="line">		background-color: #eee;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="(2).变量"></a>(2).变量</h3><ul>
<li>在变量中可以存储任意一个值，方便于修改。变量的语法：<code>@变量名:颜色/长度等</code> ，使用语法如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@a:100px;</span><br><span class="line">@b:box2;	//当存储类名时，需要按下面的方法引用</span><br><span class="line">.box1&#123;</span><br><span class="line">	width: @a;</span><br><span class="line">&#125;</span><br><span class="line">.@&#123;b&#125;&#123;</span><br><span class="line">	width: @a;</span><br><span class="line">	background-img: url(&quot;@&#123;b&#125;/1.png&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>变量发生重名时使用就近原则，谁在最下边，用谁的</li>
<li>当高度想要直接引用宽度的大小（当然，颜色也可以）时，可以使用 <code>$</code> 符号，具体如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: $width;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-选择外层父元素"><a href="#3-选择外层父元素" class="headerlink" title="(3).选择外层父元素"></a>(3).选择外层父元素</h3><ul>
<li>使用 <code>&amp;</code> 符号来选择外层的父元素，可以在 hover 上体现出来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">	background-color: red;</span><br><span class="line">	&amp;:hover&#123;</span><br><span class="line">		background-color: orange;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>进行转换后的 CSS 代码为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box1&#123;</span><br><span class="line">	background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.box1:hover&#123;</span><br><span class="line">	background-color: orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-扩展"><a href="#4-扩展" class="headerlink" title="(4).扩展"></a>(4).扩展</h3><ul>
<li>这里的扩展，相当于面向对象里的继承。即后面既有前面的内容，又有自己的内容，如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.p1&#123;</span><br><span class="line">	width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.p2:extend(.p1)&#123;</span><br><span class="line">	height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>直接对指定的样式进行引用，这里就是直接复制了p1的样式（但一般不使用），如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.p3&#123;</span><br><span class="line">	.p1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用类选择器时可以在选择器后面加一个括号，实际上就创建了一个 mixins ，这个样式并不会直接使用，当其他引入其时才会使用</li>
</ul>
<h3 id="5-混合函数"><a href="#5-混合函数" class="headerlink" title="(5).混合函数"></a>(5).混合函数</h3><ul>
<li>在混合函数中，可以直接设置变量，这里其实就相当于 <code>传参</code> 的功能，混合函数里面使用的是形参，而调用函数的时候使用的是实参</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text(@b)&#123;</span><br><span class="line">    width: @b;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">div&#123;</span><br><span class="line">    .text(200px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中可以添加多个参数，调用的时候要按顺序调用</li>
<li>其中可以添加默认值，但如果传入值以后使用传入的值</li>
</ul>
<h2 id="3-less-补充"><a href="#3-less-补充" class="headerlink" title="3.less 补充"></a>3.less 补充</h2><ul>
<li>在 less 中所有的数值都可以进行运算（加减乘除）</li>
<li>可以引入其他的 less 文件，如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;abc.less&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>想要将网页的开发者工具页面显示 less 源码的对应位置，需要在 Easy LESS 插件中进行相关配置，将其中的配置文件复制到改插件的 <code>settings.json</code> 文件中进行配置</li>
</ul>
<h1 id="十、简单布局实践"><a href="#十、简单布局实践" class="headerlink" title="十、简单布局实践"></a>十、简单布局实践</h1><h2 id="1-导航条的设计"><a href="#1-导航条的设计" class="headerlink" title="1.导航条的设计"></a>1.导航条的设计</h2><ul>
<li>导航条可以用无序列表和div来创建，一般用无序列表</li>
<li>使用无序列表时需要清除掉前面的小点，使用 <code>list-style: none;</code> 来清除</li>
<li>需要使无序列表水平摆放，所以需要给列表项即 <code>li标签</code> 设置向左浮动</li>
<li>想要给超链接即a标签设置宽度等，需要使用 <code>display: block</code> 转为块元素</li>
<li>对于宽度以及居中问题，首先给父标签即 <code>ul标签</code> 设置一个固定宽度，其子标签即 <code>li标签</code> 按父元素的比例设置，最后将超链接所在标签即 <code>a标签</code> 设置为100%即可</li>
<li>想要鼠标滑过的特效，需要使用<font color=#FF0000>伪类选择器</font>来设置</li>
<li>想要使得超链接在里面垂直水平居中，垂直方向增加相应的内边距即可，水平方向用 <code>text-align: center;</code> 来设置居中</li>
</ul>
<h2 id="1-1导航条的下拉框设计"><a href="#1-1导航条的下拉框设计" class="headerlink" title="1.1导航条的下拉框设计"></a>1.1导航条的下拉框设计</h2><ul>
<li>导航条的下拉框设计可以分为4部分——（按钮处、下拉列表、按钮移入效果、下拉列表移入效果）</li>
</ul>
<h3 id="a-按钮处"><a href="#a-按钮处" class="headerlink" title="a.按钮处"></a>a.按钮处</h3><ul>
<li>按钮处如果是下拉列表的父元素，则需要给按钮设置定位，而下拉列表设置绝对定位；如果不是下拉列表的父元素而是兄弟元素，则需要给按钮和它的父元素设置相对定位，而下拉列表设置绝对定位</li>
<li>按钮处因为移入的边框效果而导致文字或者形状发生变化时，则需要给移入之前就设置边框效果，仅仅把颜色改为透明即可</li>
<li>如果下拉列表的上边框在按钮处的下边框处显示了出来，可以给按钮处设置一个下内边距，然后通过层级来使按钮处的层级比下拉列表的层级高</li>
</ul>
<h3 id="b-下拉列表"><a href="#b-下拉列表" class="headerlink" title="b.下拉列表"></a>b.下拉列表</h3><ul>
<li>下拉列表需要给其设置为隐藏，按需求设置阴影</li>
<li>下拉列表因为绝对定位的关系，一般需要设置水平和垂直偏移量</li>
</ul>
<h3 id="c-按钮移入效果"><a href="#c-按钮移入效果" class="headerlink" title="c.按钮移入效果"></a>c.按钮移入效果</h3><ul>
<li>这个应该使用后代选择器同时选中父元素以及按钮处，再设置 <code>hover</code> 效果</li>
</ul>
<h3 id="d-下拉列表移入效果"><a href="#d-下拉列表移入效果" class="headerlink" title="d.下拉列表移入效果"></a>d.下拉列表移入效果</h3><ul>
<li>因为下拉列表默认隐藏的，所以在移入按钮和下拉列表时，需要让下拉列表显示出来，所以使用 <code>display</code> 来设置</li>
<li>所以一样使用后代选择器同时选中父元以及下拉列表，再设置 <code>hover</code> 效果</li>
</ul>
<h3 id="e-下拉列表上边的小三角设计"><a href="#e-下拉列表上边的小三角设计" class="headerlink" title="e.下拉列表上边的小三角设计"></a>e.下拉列表上边的小三角设计</h3><ul>
<li>这个小三角实际上是由边框构成的，当边框的高度和宽度都为0时，边框就会成为一个小三角的样式</li>
<li>当一个下拉列表移入时需要上小三角时，需要给父元素设置一个伪类，且上边框可以去除，给四边设置颜色为透明，单独给下边框设置一个需要的颜色即可，具体代码实现如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.app::after&#123;</span><br><span class="line">	content: &quot;&quot;;			//伪类需要加一个空的内容</span><br><span class="line">	width: 0;		</span><br><span class="line">	height: 0;</span><br><span class="line">	border: 8px solid transparent;</span><br><span class="line">	border-bottom-color: #bfa;</span><br><span class="line">	position: absolute;		//开启绝对定位来移动位置</span><br><span class="line">	bottom: 0;</span><br><span class="line">	left: 0;</span><br><span class="line">	right: 0;</span><br><span class="line">	margin: auto;			//使其在水平方向居中</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-PS的设计"><a href="#2-PS的设计" class="headerlink" title="2.PS的设计"></a>2.PS的设计</h2><ul>
<li>在首选项（快捷键ctrl+K）中把标尺和文字的单位改成像素。</li>
</ul>
<h3 id="部分快捷键："><a href="#部分快捷键：" class="headerlink" title="部分快捷键："></a>部分快捷键：</h3><ul>
<li>Ctrl+R：开启/关闭标尺</li>
<li>Ctrl+H：显示/隐藏辅助线</li>
<li>F8：用矩形选框选中以后用它可以快捷查看高度和宽度</li>
<li>Alt+鼠标左键点击图层前面的眼睛：只显示当前图层，隐藏其余图层</li>
</ul>
<h2 id="3-简单页面的设计"><a href="#3-简单页面的设计" class="headerlink" title="3.简单页面的设计"></a>3.简单页面的设计</h2><ul>
<li>浏览器默认字体16px大小，但一般使用12px大小，所以需要统一字体大小，且把行高和字体一块设置</li>
<li>如果之前通过设置行高来文字垂直居中时，修改字体大小时会影响居中效果，所以一定要在设置字体大小的时候同时把行高设置了</li>
</ul>
<h2 id="4-按钮的设计"><a href="#4-按钮的设计" class="headerlink" title="4.按钮的设计"></a>4.按钮的设计</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><ul>
<li>分别给超链接设置三张表示 link、hover、active 的图片，来形成移入、点击的效果。但第一次切换图片时，会有一个很快的闪烁</li>
<li><font color=#F00>产生原因：背景图片时以外部资源的形式加载进网页的，浏览器每加载一个外部资源就需要单独的发一次请求，但外部资源并不是一次性加载的，浏览器会在资源被使用时才会去加载资源</font></li>
</ul>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><ul>
<li>将上边的三张图片整合为一张图片（叫做“雪碧图”），然后再通过设置超链接的伪类中的 <code>background-position</code> 属性来切换要显示的图片的位置，这种技术叫做图片整合技术，即 CSS-Sprite</li>
<li>优点：浏览器只需要发送一次请求就可以同时加载多个图片，而且减小了图片的总大小</li>
</ul>
<h2 id="5-POLO-360-项目练习"><a href="#5-POLO-360-项目练习" class="headerlink" title="5.POLO 360 项目练习"></a>5.POLO 360 项目练习</h2><ul>
<li>当遇到文本即h标签或p标签在不同浏览器显示高度不同时，是因为每个浏览器对文字的行高设定不一致，所以需要给这些文字设定一个行高，可以这样快捷设置 <code>font: 15px/1;</code></li>
<li>在一个p标签中，如果想要文字环绕图片，那么需要给图片设置浮动</li>
<li>在做完页面以后，应当在多个浏览器中进行试验，一般在IE6上出现的Bug会比较多</li>
<li>最后需要压缩CSS代码，即把不用的注释，空格，换行全部删掉，这里一般是使用工具来进行压缩，如：JsCssZip 。还需要压缩图片，即把图片做成雪碧图。</li>
</ul>
<h2 id="6-小米官网首屏项目练习"><a href="#6-小米官网首屏项目练习" class="headerlink" title="6.小米官网首屏项目练习"></a>6.小米官网首屏项目练习</h2><ul>
<li>一般商业性的网站的 LOGO 会使用 <code>&lt;h1&gt;</code> 标签来写，且需要在其中加一个 <code>title</code> 属性</li>
</ul>
<h3 id="1-关于官网右侧固定的回到顶部按钮"><a href="#1-关于官网右侧固定的回到顶部按钮" class="headerlink" title="(1).关于官网右侧固定的回到顶部按钮"></a>(1).关于官网右侧固定的回到顶部按钮</h3><ul>
<li><p>首先这个按钮不随窗口的移动而更改位置，那么这里就需要开启固定定位了</p>
</li>
<li><p>当开启固定定位以后，实际上垂直方向是不会随窗口变的，所以可以直接设置一个 <code>bottom: 105px;</code> 来控制距离底边的距离；但是水平方向不管窗口是左右缩放多少，都是紧紧挨着中间内容区不动的，所以并不能使用 <code>right: 50px;</code> 这样的参数来设置</p>
</li>
<li><p><font color=#F00>注意：关于布局的等式，在这里是 <code>left + margin-left + width + right + margin-right = 视口的宽度</code> </font><br>在这里即为：auto + 0 + 26 + 0 + right = 视口宽度</p>
</li>
<li><p>而当我把 right 值设置为 50% 时，该块元素将会自动移到该视口的正中间，具体可以看下图：<br><img src="https://s1.ax1x.com/2020/10/20/BSPlCV.png" alt="css11.png"></p>
</li>
<li><p>在这种情况下，想要将这个快移动到右边那里，就需要让 left 的值自动增大，从而减小上方的 <code>margin-left</code> 和 <code>margin-right</code> 的值了，不难看出，当修改左外边距时，因为与 left 同属一侧，一个正值一个负值，两个抵消没有变化，所以就需要改变右外边距了</p>
</li>
<li><p>根据上图可以看出，想要让该块元素移动到右边，则需要一个右蓝框的距离 + 该块元素的距离，而右蓝框的距离实际就是中间内容区的一半了，所以具体代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.back-top&#123;</span><br><span class="line">	width: 26px;</span><br><span class="line">	height: 206px;</span><br><span class="line">	background-color: #bfa;</span><br><span class="line">	box-shadow: 0 0 1px rgba(0,0,0,.3);</span><br><span class="line">	position: fixed;</span><br><span class="line">	bottom: 105px;</span><br><span class="line">	right: 50%;</span><br><span class="line">	margin-right: -639px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如下图：<br><img src="https://s1.ax1x.com/2020/10/20/BSP13T.png" alt="css12.png"></p>
</li>
</ul>
<h2 id="7-实战技巧"><a href="#7-实战技巧" class="headerlink" title="7.实战技巧"></a>7.实战技巧</h2><h3 id="1-关于CSS样式表"><a href="#1-关于CSS样式表" class="headerlink" title="(1).关于CSS样式表"></a>(1).关于CSS样式表</h3><ul>
<li>一般我们都引入网站的重置样式表来清除浏览器默认样式</li>
<li>一般我们都会创建一个公共的样式表 <code>base.css</code> 来存放公共样式，如：clearfix、body的字体样式等</li>
</ul>
<h3 id="2-关于布局"><a href="#2-关于布局" class="headerlink" title="(2).关于布局"></a>(2).关于布局</h3><ul>
<li>为了防止页面大小变化对 body 大小造成的影响，一般需要给 body 设置一个最小的宽度值，即 <code>min-width: xxxpx;</code> </li>
</ul>
<h3 id="3-关于下拉列表的过渡效果"><a href="#3-关于下拉列表的过渡效果" class="headerlink" title="(3).关于下拉列表的过渡效果"></a>(3).关于下拉列表的过渡效果</h3><ul>
<li>对于下拉列表一点一点的显示，是因为他显示的时候高度是一点一点的增加达到的过渡效果</li>
<li>所以，想要实现这种效果，就不能像以前一样给下拉列表使用 <code>display: none;</code> 来隐藏了。想要使其隐藏，需要给其设置高度为0，但此时其中的子元素会溢出，所以需要使用 <code>overflow: hidden;</code> 属性来隐藏，然后在 <code>hover</code> 中将其高度再重新写出来</li>
<li>而需要设置过渡效果，则需要给下拉列表设置一个 <code>transition: height 3s;</code> 的属性即可，这样下拉列表就会在设置的3s内高度从0增加到相应高度，从而达到过渡的效果</li>
<li>注意：过渡效果必须从一个值到另一个值，即起始位置</li>
</ul>
<h3 id="4-关于导航条的自动布局"><a href="#4-关于导航条的自动布局" class="headerlink" title="(4).关于导航条的自动布局"></a>(4).关于导航条的自动布局</h3><ul>
<li>当有的导航条并不固定内容，切不固定每项的宽度时，可以使用弹性布局，让其自动分配</li>
<li>使用该布局的好处就是——即使导航的内容项增加也不会导致整个导航条的大小发生变化</li>
</ul>
<h1 id="附、问题集合"><a href="#附、问题集合" class="headerlink" title="附、问题集合"></a>附、问题集合</h1><h2 id="1-相对路径问题"><a href="#1-相对路径问题" class="headerlink" title="1.相对路径问题"></a>1.相对路径问题</h2><ul>
<li>在 html 中调用css时使用 <code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;相对路径&quot;</code> 时，一直无法成功显示css样式</li>
<li>因为我用的是 HBuilder 创建的项目，所以 css 文件默认存放在了 css 文件夹中，所以相对路径的写法为 <code>css/style.css</code> 。</li>
</ul>
<h2 id="2-无序列表默认横排显示问题"><a href="#2-无序列表默认横排显示问题" class="headerlink" title="2.无序列表默认横排显示问题"></a>2.无序列表默认横排显示问题</h2><ul>
<li><p>在做导航实验时，发现创建的无序列表默认就是横排显示，而不是竖排显示</p>
</li>
<li><p>原因是我在一个 <code>li</code> 标签中写的无序列表，如果想要竖排显示的话，每一个列表项都需要使用一个 <code>li</code> 标签来修饰，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-在IE6中浮动元素出现双倍边距bug"><a href="#3-在IE6中浮动元素出现双倍边距bug" class="headerlink" title="3.在IE6中浮动元素出现双倍边距bug"></a>3.在IE6中浮动元素出现双倍边距bug</h2><ul>
<li>原因是浮动的时候，同时加了一个同方向的外边距，所以会出现双倍bug，只需要在这个元素的样式里增加 <code>display: inline</code> 即可解决</li>
</ul>
<h2 id="4-在其他浏览器显示正常，在IE6中显示不正常"><a href="#4-在其他浏览器显示正常，在IE6中显示不正常" class="headerlink" title="4.在其他浏览器显示正常，在IE6中显示不正常"></a>4.在其他浏览器显示正常，在IE6中显示不正常</h2><ul>
<li>可以给IE6单独重新设置一个样式，如：<code>_background-color: #bfa;</code> 这样就只会在IE6中解析了</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>新生常见问题解答</title>
    <url>/Freshman-question.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>总结一些2019级新生的一些问题</li>
<li>有任何一切问题，欢迎加入我们唯一官方新生群进行了解：799436445<span id="more"></span></li>
</ul>
<h1 id="目录（点击即可跳转到相应位置）"><a href="#目录（点击即可跳转到相应位置）" class="headerlink" title="目录（点击即可跳转到相应位置）"></a>目录（点击即可跳转到相应位置）</h1><ul>
<li>一、<a href="#a">开学时间</a></li>
<li>二、<a href="#b">宿舍</a></li>
<li>三、<a href="#c">餐厅</a></li>
<li>四、<a href="#d">军训情况</a></li>
<li>五、<a href="#e">洗浴中心</a></li>
<li>六、<a href="#f">快递</a></li>
<li>七、<a href="#g">学校周边环境</a></li>
<li>八、<a href="#h">校内购物场所</a></li>
<li>九、<a href="#i">贷款事项</a></li>
<li>十、<a href="#j">兵役登记</a></li>
<li>十一、<a href="#k">入学考试</a></li>
<li>十二、<a href="#l">校园一卡通</a></li>
<li>十三、<a href="#m">校园网</a></li>
<li>十四、<a href="#n">健身房</a></li>
<li>十五、<a href="#o">网上报到</a></li>
<li>十六、<a href="#p">网上缴费</a></li>
<li>十七、<a href="#q">杂类问题</a></li>
</ul>
<h1 id="一、开学时间"><a href="#一、开学时间" class="headerlink" title="一、开学时间"></a><span id="a">一、开学时间</span></h1><h2 id="1-报到时间"><a href="#1-报到时间" class="headerlink" title="1.报到时间"></a>1.报到时间</h2><ul>
<li>专升本新生: 8月31-9月1日</li>
<li>普高、对口新生: 9月4日14:00——6日19:00(上午完成所有现场报到的准备工作，下午2:00所有部门到指定接待点，开始接待工作)</li>
<li>火车站、客运站迎新安排:9月5一6日两天车站接车组早晨6:00到位，校内各接待点6:30到位</li>
<li>剩余时间安排：9月7日上午在御东校区举行开学典礼; 9月7日下午——9月20日进行军训; 9月23日正式上课。</li>
<li>2019级研究生9月17日报到</li>
<li>2020年1月18日放寒假</li>
</ul>
<h2 id="2-专升本新生31号可以报到吗？"><a href="#2-专升本新生31号可以报到吗？" class="headerlink" title="2.专升本新生31号可以报到吗？"></a>2.专升本新生31号可以报到吗？</h2><ul>
<li>答：这个不一定，可以提前一天去</li>
</ul>
<h2 id="3-本科新生4号可以报到吗？"><a href="#3-本科新生4号可以报到吗？" class="headerlink" title="3.本科新生4号可以报到吗？"></a>3.本科新生4号可以报到吗？</h2><ul>
<li>答：这个不一定，可以提前一天去</li>
</ul>
<h2 id="4-可以提前住宿舍吗？"><a href="#4-可以提前住宿舍吗？" class="headerlink" title="4.可以提前住宿舍吗？"></a>4.可以提前住宿舍吗？</h2><ul>
<li>答：这个不一定，如果可以问楼管要下钥匙，那就可以</li>
</ul>
<h1 id="二、宿舍"><a href="#二、宿舍" class="headerlink" title="二、宿舍"></a><span id="b">二、宿舍</span></h1><h2 id="1-宿舍主要情况"><a href="#1-宿舍主要情况" class="headerlink" title="1.宿舍主要情况"></a>1.宿舍主要情况</h2><ul>
<li>答：宿舍为上下铺，床位号都已由学校分配。不可以调换，可以和舍友商量调换。宿舍为6人间，无空调电扇，有暖气，有一张大桌子，每人有个柜子可以存放衣物。有的宿舍有独卫，有的宿舍有阳台，有的宿舍水泥地，有的宿舍是瓷砖地。宿舍可以自己“改造”（贴墙纸，挂床帘，买床上桌，黏粘钩等等）</li>
</ul>
<h2 id="2-为什么有人说有4人间宿舍？"><a href="#2-为什么有人说有4人间宿舍？" class="headerlink" title="2.为什么有人说有4人间宿舍？"></a>2.为什么有人说有4人间宿舍？</h2><ul>
<li>答：4人间是研究生宿舍，本科生用不上，不要轻信谣言。</li>
</ul>
<h2 id="3-宿舍床单被罩学校要求统一吗？"><a href="#3-宿舍床单被罩学校要求统一吗？" class="headerlink" title="3.宿舍床单被罩学校要求统一吗？"></a>3.宿舍床单被罩学校要求统一吗？</h2><ul>
<li>答：没有要求，可以买学校的，也可以自己带</li>
</ul>
<h2 id="4-宿舍床单尺寸多少？"><a href="#4-宿舍床单尺寸多少？" class="headerlink" title="4.宿舍床单尺寸多少？"></a>4.宿舍床单尺寸多少？</h2><ul>
<li>答：长2米宽0.9米，单人床规格</li>
</ul>
<h2 id="5-宿舍可以用吹风机吗？"><a href="#5-宿舍可以用吹风机吗？" class="headerlink" title="5.宿舍可以用吹风机吗？"></a>5.宿舍可以用吹风机吗？</h2><ul>
<li>答：不可以，大功率用电器学校不允许使用，包括吹风机、锅、饮水机、电磁炉、加热板、空调等等等等！如果需要吹头发，请去宿舍一楼，楼管那里有吹风机！</li>
</ul>
<h2 id="6-宿舍熄灯吗？"><a href="#6-宿舍熄灯吗？" class="headerlink" title="6.宿舍熄灯吗？"></a>6.宿舍熄灯吗？</h2><ul>
<li>答：周日到周四晚上十一点左右断电，周五周六不断电，节假日也是这样安排，全年如此。</li>
</ul>
<h2 id="7-宿舍楼的卫生间有几个？"><a href="#7-宿舍楼的卫生间有几个？" class="headerlink" title="7.宿舍楼的卫生间有几个？"></a>7.宿舍楼的卫生间有几个？</h2><ul>
<li>答：每层楼2个卫生间，洗漱间一般和厕所挨在一起，新正苑和清和苑洗漱间只有冷水，如月苑的洗漱间有热水器。</li>
</ul>
<h2 id="8-宿舍楼有洗衣房吗？"><a href="#8-宿舍楼有洗衣房吗？" class="headerlink" title="8.宿舍楼有洗衣房吗？"></a>8.宿舍楼有洗衣房吗？</h2><ul>
<li>答：每个宿舍楼的一层都有洗衣房，里面有滚筒机、烘干机、洗鞋机。可以投2，3，4元，就是洗衣服的时间长短的区别。</li>
</ul>
<h2 id="9-缴费系统中的宿舍楼号什么意思？"><a href="#9-缴费系统中的宿舍楼号什么意思？" class="headerlink" title="9.缴费系统中的宿舍楼号什么意思？"></a>9.缴费系统中的宿舍楼号什么意思？</h2><ul>
<li>答：这个宿舍楼的楼宇号还没有确定，不一定7#就是清和苑7号楼。这个先不要管，去了学校看</li>
</ul>
<h2 id="10-宿舍可以养宠物吗？"><a href="#10-宿舍可以养宠物吗？" class="headerlink" title="10.宿舍可以养宠物吗？"></a>10.宿舍可以养宠物吗？</h2><ul>
<li>答：学校规定不允许，且会有人查，如果没查住还好，查住就记过写检查。</li>
</ul>
<h2 id="11-宿舍楼里有小卖铺吗？"><a href="#11-宿舍楼里有小卖铺吗？" class="headerlink" title="11.宿舍楼里有小卖铺吗？"></a>11.宿舍楼里有小卖铺吗？</h2><ul>
<li>学校官方的没有，可能会有学长私自开小卖铺。每个宿舍楼的一层也有自动贩卖机，各种饮料矿泉水，有的宿舍楼还有零食贩卖机。</li>
</ul>
<h2 id="12-什么是混合宿舍？"><a href="#12-什么是混合宿舍？" class="headerlink" title="12.什么是混合宿舍？"></a>12.什么是混合宿舍？</h2><ul>
<li>答：就是一个宿舍里有两个班的学生或者两个不同专业的学生。</li>
</ul>
<h2 id="13-宿舍楼一共有几层？"><a href="#13-宿舍楼一共有几层？" class="headerlink" title="13.宿舍楼一共有几层？"></a>13.宿舍楼一共有几层？</h2><ul>
<li>答：一共6层，没有电梯。</li>
</ul>
<h2 id="14-宿舍床号怎么分配？"><a href="#14-宿舍床号怎么分配？" class="headerlink" title="14.宿舍床号怎么分配？"></a>14.宿舍床号怎么分配？</h2><ul>
<li>答：单号上铺，双号下铺</li>
</ul>
<h2 id="15-宿舍要求统一被褥吗？"><a href="#15-宿舍要求统一被褥吗？" class="headerlink" title="15.宿舍要求统一被褥吗？"></a>15.宿舍要求统一被褥吗？</h2><ul>
<li>答：不要求，可以自己带，也可以买学校的，只是军训期间会检查被褥的整齐度，而不是检查被褥的统一度。</li>
</ul>
<h1 id="三、餐厅"><a href="#三、餐厅" class="headerlink" title="三、餐厅"></a><span id="c">三、餐厅</span></h1><h2 id="1-餐厅情况"><a href="#1-餐厅情况" class="headerlink" title="1.餐厅情况"></a>1.餐厅情况</h2><ul>
<li>北区餐厅——东兴鼎昊大学食代餐厅</li>
<li>南区餐厅——奥宇餐厅、学苑餐厅、文瀛餐厅（包括幸福园、面食圆、菜肴园、桂香园）、宜宾苑、碧仓禾（教职工餐厅，菜好吃也不贵）</li>
<li>新平旺校区有三个餐厅，校外比较繁华，具体可以加新平旺校区群了解。</li>
</ul>
<h2 id="2-菜式有哪些？"><a href="#2-菜式有哪些？" class="headerlink" title="2.菜式有哪些？"></a>2.菜式有哪些？</h2><ul>
<li>答：八大餐厅主食主要是大米和山西面食，菜品从南到北各个菜系的基本上都有，都是自选式窗口，基本满足全国人民口味。</li>
</ul>
<h2 id="3-怎么收费？"><a href="#3-怎么收费？" class="headerlink" title="3.怎么收费？"></a>3.怎么收费？</h2><ul>
<li>答：基本都支持支付宝、微信扫码，很方便。</li>
</ul>
<h1 id="四、军训情况"><a href="#四、军训情况" class="headerlink" title="四、军训情况"></a><span id="d">四、军训情况</span></h1><h2 id="1-军训时间"><a href="#1-军训时间" class="headerlink" title="1.军训时间"></a>1.军训时间</h2><ul>
<li>9月7日开始到20日，为期13天。</li>
<li>每天大概从上午8:00到12:00，下午2:00到5:00，中间教官会让你休息，也不会太累，但比较晒，建议做好防晒工作。</li>
</ul>
<h2 id="2-专升本需要军训吗？"><a href="#2-专升本需要军训吗？" class="headerlink" title="2.专升本需要军训吗？"></a>2.专升本需要军训吗？</h2><ul>
<li>答：目前看来，应该是不需要</li>
</ul>
<h2 id="3-军训服包含哪些？"><a href="#3-军训服包含哪些？" class="headerlink" title="3.军训服包含哪些？"></a>3.军训服包含哪些？</h2><ul>
<li>答：军训服包括上衣、裤子、帽子、鞋子、腰带、白手套。</li>
</ul>
<h2 id="4-不能参加军训该怎么样？"><a href="#4-不能参加军训该怎么样？" class="headerlink" title="4.不能参加军训该怎么样？"></a>4.不能参加军训该怎么样？</h2><ul>
<li>答：如身体有异，需要开具二级医院证明和校医院证明，才可以在军训期间请假。</li>
</ul>
<h1 id="五、洗浴中心"><a href="#五、洗浴中心" class="headerlink" title="五、洗浴中心"></a><span id="e">五、洗浴中心</span></h1><h2 id="1-校内"><a href="#1-校内" class="headerlink" title="1.校内"></a>1.校内</h2><ul>
<li>校内有个大澡堂，在奥宇餐厅旁边，比较便宜，按水量收费，但环境较差，有隔板没有门。</li>
<li>校内有个洗浴中心，在校医院旁边，有单人、双人、三人间。办卡可以100元洗17次左右。</li>
</ul>
<h2 id="2-校外"><a href="#2-校外" class="headerlink" title="2.校外"></a>2.校外</h2><ul>
<li>校外有4家洗浴店：舒欣淋浴、豪华淋浴、阳光淋浴、爱尚淋浴。有单人、双人、三人间。环境不错，一次8块左右。</li>
<li>照片看群相册</li>
</ul>
<h2 id="3-开放时间几点到几点？"><a href="#3-开放时间几点到几点？" class="headerlink" title="3.开放时间几点到几点？"></a>3.开放时间几点到几点？</h2><ul>
<li>答：时间不定，去了自己询问</li>
</ul>
<h1 id="六、快递"><a href="#六、快递" class="headerlink" title="六、快递"></a><span id="f">六、快递</span></h1><h2 id="1-快递点都有哪些？"><a href="#1-快递点都有哪些？" class="headerlink" title="1.快递点都有哪些？"></a>1.快递点都有哪些？</h2><ul>
<li>天天快递——大南门右手边</li>
<li>百世快递——奥宇餐厅后面</li>
<li>顺丰快递——校医院后面洗浴中心</li>
<li>邮政快递——南区体育馆西侧邮政银行边</li>
<li>京东快递——南区西面家属楼7号楼2单元</li>
<li>国通、苏宁快递——打电话通知你去取</li>
<li>天猫超市快递——小南门外边鸿儒校区内</li>
<li>部分申通快递——小南门外的久雅妈妈驿站</li>
<li>其余快递基本都是发往菜鸟驿站，南校区东北角菜鸟驿站和小南门外边淘宝街菜鸟驿站</li>
<li>以上都为御东校区，且这些快递点基本都只能存放三天，超过时间就会被退回，你可以提前和对方联系让多存放几天</li>
</ul>
<h2 id="2-快递地址"><a href="#2-快递地址" class="headerlink" title="2.快递地址"></a>2.快递地址</h2><ul>
<li>御东校区：（邮编037009）山西省大同市平城区（南郊区）水泊寺乡大同大学御东校区</li>
<li>新平旺校区：（邮编037003）山西省大同市矿区新胜街道平泉路52号大同大学新平旺校区</li>
</ul>
<h1 id="七、学校周边环境"><a href="#七、学校周边环境" class="headerlink" title="七、学校周边环境"></a><span id="g">七、学校周边环境</span></h1><h2 id="1-环境介绍"><a href="#1-环境介绍" class="headerlink" title="1.环境介绍"></a>1.环境介绍</h2><ul>
<li>大同大学地处郊区，环境优美，交通便利，出校门向东几百米有大同市图书馆，大同市火山体育馆，大同市大剧院，大同市博物馆，大同市美术馆，都在同一块地方聚集，再向东一点有文瀛湖森林公园，风景不错，学校向南有方特欢乐世界，再向南一点有大同南站（新建成的高铁站，今年10月份通车），向西有御河生态园，风景优美，过了桥再向西是大同古城墙，还有九龙壁华严寺之类的景区。</li>
</ul>
<h2 id="2-大同旅游景点"><a href="#2-大同旅游景点" class="headerlink" title="2.大同旅游景点"></a>2.大同旅游景点</h2><ul>
<li>云冈石窟、悬空寺、恒山、方特欢乐世界、魏都水世界、华严寺、大同古城墙、九龙壁、善化寺、大同土林、大同博物馆、中国雕塑博物馆、大同鼓楼、九龙温泉度假村、大同火山群、清真大寺、纯阳宫、晋华宫国家矿山公园、万人坑、关帝庙、平城遗址、文瀛湖、平型关战役遗址、乌龙峡生态旅游度假区、汤头温泉、鲁班窟石窟、恒山九天宫、井下探秘游、万龙白登山滑雪场、卧龙山国际滑雪场、北魏明堂遗址、水神堂、七峰山、采凉山、慈云寺、玉安生态度假岛、大同龙壁、万佛洞、赵武灵王墓、凤凰国际游泳馆、灵丘古道、大同城墙遗址、云冈森林公园、采凉山古长城，等等，有点多，小地方就不列了。</li>
</ul>
<h1 id="八、校内购物场所"><a href="#八、校内购物场所" class="headerlink" title="八、校内购物场所"></a><span id="h">八、校内购物场所</span></h1><h2 id="1-超市小卖铺地点"><a href="#1-超市小卖铺地点" class="headerlink" title="1.超市小卖铺地点"></a>1.超市小卖铺地点</h2><ul>
<li>北区：水房那有个小卖铺</li>
<li>南区：奥宇那有个超市、学苑那有个小超市</li>
<li>学校外面有久雅超市，也有各种小卖铺</li>
</ul>
<h2 id="2-其余地方"><a href="#2-其余地方" class="headerlink" title="2.其余地方"></a>2.其余地方</h2><ul>
<li>每个宿舍楼的一层也有自动贩卖机，各种饮料矿泉水，有的宿舍楼还有零食贩卖机</li>
</ul>
<h1 id="九、贷款事项"><a href="#九、贷款事项" class="headerlink" title="九、贷款事项"></a><span id="i">九、贷款事项</span></h1><h2 id="1-贷款流程"><a href="#1-贷款流程" class="headerlink" title="1.贷款流程"></a>1.贷款流程</h2><ol>
<li>   助学贷款是国家对于贫困家庭的一项政策，随录取通知书一起发给大家一份相关介绍，有意向的可以在生源地申请助学贷款，各个地方贷款过程及资料不完全相同，具体咨询生源地资助中心。</li>
<li>   首先填写家庭情况调查表（录取通知书内包含）即认定表，本群文件有电子版，具体盖章与否各生源地要求不同。</li>
<li>   搜索“国家开发银行助学贷款信息网”，点击“生源地助学贷款学生在线系统”，首先注册，输入个人以及共同借款人信息，身份证照片上传（共同借款人是父母等都可以但有年龄限制），注册完毕打印出申请表。</li>
<li>   输入信息时注意贷款年限一般以大学年限+13，贷款额度要求为学费加住宿费（本科一般不超过8000），超过两个费用的可能被拒绝申请。</li>
<li>   首次贷款一般需要证件有：录取通知书，身份证，申请表，认定表，户口本，银行卡，各复印件等（具体以资助中心要求为准）。</li>
<li>   持相关证件资料去当地资助中心办理，办理后保存好受理证明，大学开学统一将受理证明下联交给老师（有的地方还有贷款合同也要保存好，否则贷款不能直接与高校对接打入账户）。</li>
</ol>
<h2 id="2-贷款可以贷款哪些？"><a href="#2-贷款可以贷款哪些？" class="headerlink" title="2.贷款可以贷款哪些？"></a>2.贷款可以贷款哪些？</h2><ul>
<li>答：只能贷学费和公寓费即住宿费这两种</li>
</ul>
<h1 id="十、兵役登记"><a href="#十、兵役登记" class="headerlink" title="十、兵役登记"></a><span id="j">十、兵役登记</span></h1><h2 id="1-具体情况"><a href="#1-具体情况" class="headerlink" title="1.具体情况"></a>1.具体情况</h2><ol>
<li>首先，是男生开学必带物品，不要问女生需不需要带了可以吗？第一句说的很清楚了，是“男生必带物品”！</li>
<li>去“全国征兵网”下载应征登记表和应征登记表存根，去打印店打印出来（不是强制打印，以你们当地为准，这里只是建议你们这样，不要嫌麻烦）</li>
<li>带着表前往户口所在地的武装部或者当地街道办事处领取兵役登记证，如果没有证那就让他开证明，如果证明也不开，那你只能啥也不带去学校了。</li>
<li>（声明：这里并不是指我说可以不用带，我并没有说这种话，而是你弄不下，那只能不带了）</li>
</ol>
<h2 id="2-丢了怎么办？"><a href="#2-丢了怎么办？" class="headerlink" title="2.丢了怎么办？"></a>2.丢了怎么办？</h2><ul>
<li>答：找武装部</li>
</ul>
<h2 id="3-没有证怎么办？"><a href="#3-没有证怎么办？" class="headerlink" title="3.没有证怎么办？"></a>3.没有证怎么办？</h2><ul>
<li>答：找武装部</li>
</ul>
<h2 id="4-怎么开证？"><a href="#4-怎么开证？" class="headerlink" title="4.怎么开证？"></a>4.怎么开证？</h2><ul>
<li>答：找武装部</li>
</ul>
<h1 id="十一、入学考试"><a href="#十一、入学考试" class="headerlink" title="十一、入学考试"></a><span id="k">十一、入学考试</span></h1><h2 id="1-考哪些？"><a href="#1-考哪些？" class="headerlink" title="1.考哪些？"></a>1.考哪些？</h2><ul>
<li>答：全校所有专业都考，只有一张卷子，考语数英，不重要，题也很简单。</li>
</ul>
<h2 id="2-重要吗？排名吗？"><a href="#2-重要吗？排名吗？" class="headerlink" title="2.重要吗？排名吗？"></a>2.重要吗？排名吗？</h2><ul>
<li>答：不重要，不排名，不重要！</li>
</ul>
<h2 id="3-考这个干嘛？"><a href="#3-考这个干嘛？" class="headerlink" title="3.考这个干嘛？"></a>3.考这个干嘛？</h2><ul>
<li>答：据说主要是为了对比高中笔迹，也许还会增加班主任的好感度？高层决定，谁能猜到！</li>
</ul>
<h1 id="十二、校园一卡通"><a href="#十二、校园一卡通" class="headerlink" title="十二、校园一卡通"></a><span id="l">十二、校园一卡通</span></h1><h2 id="1-具体情况-1"><a href="#1-具体情况-1" class="headerlink" title="1.具体情况"></a>1.具体情况</h2><ul>
<li>这个强烈建议各位办理，就相当于办一张手机卡，但价格十分实惠，以17年的为例，每月19块钱，套餐为移动38元套餐，还有30G流量，还有20M的校园网。一卡通主要可以打水，进出图书馆，校内无缝连接校园网。</li>
</ul>
<h2 id="2-这个必须办吗？"><a href="#2-这个必须办吗？" class="headerlink" title="2.这个必须办吗？"></a>2.这个必须办吗？</h2><ul>
<li>答：不是必须，视自己情况办理，只是学长这里推荐而已，比外面便宜很多</li>
</ul>
<h2 id="3-在哪里办理？"><a href="#3-在哪里办理？" class="headerlink" title="3.在哪里办理？"></a>3.在哪里办理？</h2><ul>
<li>答：开学报到持录取通知书、身份证、校园学子卡（即农行卡）到校体育馆南侧对应院系领取校园一卡通专用卡。</li>
</ul>
<h2 id="4-哪个运营商的？"><a href="#4-哪个运营商的？" class="headerlink" title="4.哪个运营商的？"></a>4.哪个运营商的？</h2><ul>
<li>答：移动</li>
</ul>
<h2 id="5-如果没有办理一卡通，怎么打水，怎么进图书馆？"><a href="#5-如果没有办理一卡通，怎么打水，怎么进图书馆？" class="headerlink" title="5.如果没有办理一卡通，怎么打水，怎么进图书馆？"></a>5.如果没有办理一卡通，怎么打水，怎么进图书馆？</h2><ul>
<li>打水只要拿上带有磁条的卡就可以打水，而且每层宿舍楼都有热水器，也不贵，一壶不到1元。</li>
<li>学校发下学生证以后，可以用学生证进出图书馆，但不可以借书，只能拿着同学的一卡通借书</li>
</ul>
<h1 id="十三、校园网"><a href="#十三、校园网" class="headerlink" title="十三、校园网"></a><span id="m">十三、校园网</span></h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li>如果你办理一卡通，校园网可以免费用，如果不办理，需要单另购买。</li>
<li>校园网有两种连接方式——有线连接和无线连接。有线是指电脑连接网线连接，无线是指手机和电脑通过无线连接。</li>
<li>校园网的网速为有线状态下为20M带宽，平均下载速度为7m/s；无线状态下为10M带宽，平均下载速度为1.2m/s。</li>
<li>每个人的账号都与自己的学号挂钩，且一个账号可以同时连接一台电脑和一台手机。一人一号一网，不存在别人抢占网络。</li>
</ul>
<h2 id="2-校园网速度快吗？玩游戏卡吗？"><a href="#2-校园网速度快吗？玩游戏卡吗？" class="headerlink" title="2.校园网速度快吗？玩游戏卡吗？"></a>2.校园网速度快吗？玩游戏卡吗？</h2><ul>
<li>答：速度可以，游戏基本没有延迟</li>
</ul>
<h2 id="3-哪里可以连校园网？"><a href="#3-哪里可以连校园网？" class="headerlink" title="3.哪里可以连校园网？"></a>3.哪里可以连校园网？</h2><ul>
<li>答：各大教学楼和宿舍都有，路上也有，只不过路上不太稳定</li>
</ul>
<h2 id="4-校园网有什么好处？"><a href="#4-校园网有什么好处？" class="headerlink" title="4.校园网有什么好处？"></a>4.校园网有什么好处？</h2><ul>
<li>答：学校机构无缝连接中国知网，大四查论文很方便</li>
<li>答：百度文库需要下载券的文档可以直接下载</li>
<li>答：还有好多网站与咱们学校都有合作，很通过学校内网连接，很方便</li>
</ul>
<h1 id="十四、健身房"><a href="#十四、健身房" class="headerlink" title="十四、健身房"></a><span id="n">十四、健身房</span></h1><h2 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1.简介"></a>1.简介</h2><ul>
<li>校内有个舞度健身</li>
<li>学校旁边有三个——力舒健身、钢铁时代健身和乐康游泳健身。</li>
</ul>
<h2 id="2-怎么办理"><a href="#2-怎么办理" class="headerlink" title="2.怎么办理?"></a>2.怎么办理?</h2><ul>
<li>答：自己去了了解，办卡比较优惠</li>
</ul>
<h1 id="十五、网上报到"><a href="#十五、网上报到" class="headerlink" title="十五、网上报到"></a><span id="o">十五、网上报到</span></h1><h2 id="1-怎么报到？"><a href="#1-怎么报到？" class="headerlink" title="1.怎么报到？"></a>1.怎么报到？</h2><ul>
<li>直接进入该地址登录：<a href="http://211.82.47.7:88/yxxt/web/xsLogin/login.zf">http://211.82.47.7:88/yxxt/web/xsLogin/login.zf</a></li>
<li>请选择身份证登录，用户名为身份证号，密码为身份证后六位，有X需大写。</li>
<li>网上报到可以用手机，也可以用电脑，建议用电脑，电脑传照片需要下载插件，手机端可以直接上传照片。</li>
</ul>
<h2 id="2-专升本需要网上报到吗？"><a href="#2-专升本需要网上报到吗？" class="headerlink" title="2.专升本需要网上报到吗？"></a>2.专升本需要网上报到吗？</h2><ul>
<li>答：专升本不可以网上报到，9月1日去了现场报到</li>
</ul>
<h2 id="3-可以用手机吗？"><a href="#3-可以用手机吗？" class="headerlink" title="3.可以用手机吗？"></a>3.可以用手机吗？</h2><ul>
<li>答：可以，最好用电脑</li>
</ul>
<h2 id="4-那4项填完就好了嘛？"><a href="#4-那4项填完就好了嘛？" class="headerlink" title="4.那4项填完就好了嘛？"></a>4.那4项填完就好了嘛？</h2><ul>
<li>答：对，填完以后等待学校审核，9月1日开放打印！</li>
</ul>
<h2 id="5-我进去一片空白怎么回事？"><a href="#5-我进去一片空白怎么回事？" class="headerlink" title="5.我进去一片空白怎么回事？"></a>5.我进去一片空白怎么回事？</h2><ul>
<li>答：系统卡了，等人少的时候再进去</li>
</ul>
<h2 id="6-照片传不进去怎么回事？"><a href="#6-照片传不进去怎么回事？" class="headerlink" title="6.照片传不进去怎么回事？"></a>6.照片传不进去怎么回事？</h2><ul>
<li>答：检查你的照片是不是超出了500——1500kb的大小，如果超出，按照这个链接修改：<a href="http://h5ip.cn/nnq5">http://h5ip.cn/nnq5</a></li>
<li>答：如果是手机端，试试电脑可以不；如果是电脑端，试试手机可以不</li>
<li>答：还不行就是系统卡了，过段时间再试</li>
</ul>
<h2 id="7-显示密码错误无法登陆怎么办？"><a href="#7-显示密码错误无法登陆怎么办？" class="headerlink" title="7.显示密码错误无法登陆怎么办？"></a>7.显示密码错误无法登陆怎么办？</h2><ul>
<li>答：用电脑登陆网址可以忘记密码进行重置</li>
</ul>
<h2 id="8-邮箱怎么一直显示错误？"><a href="#8-邮箱怎么一直显示错误？" class="headerlink" title="8.邮箱怎么一直显示错误？"></a>8.邮箱怎么一直显示错误？</h2><ul>
<li>QQ邮箱格式为 <a href="mailto:&#x31;&#x32;&#51;&#52;&#x35;&#54;&#55;&#56;&#x39;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#x31;&#x32;&#51;&#52;&#x35;&#54;&#55;&#56;&#x39;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a></li>
<li>网易邮箱格式为：<a href="mailto:&#x31;&#50;&#x33;&#x34;&#x35;&#54;&#x37;&#x38;&#57;&#64;&#49;&#x32;&#x36;&#x2e;&#99;&#x6f;&#109;">&#x31;&#50;&#x33;&#x34;&#x35;&#54;&#x37;&#x38;&#57;&#64;&#49;&#x32;&#x36;&#x2e;&#99;&#x6f;&#109;</a>或者<a href="mailto:&#x31;&#x32;&#x33;&#x34;&#53;&#54;&#x37;&#56;&#x39;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;">&#x31;&#x32;&#x33;&#x34;&#53;&#54;&#x37;&#56;&#x39;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;</a></li>
<li>注意艾特符号一定要写对，如果一直提示错误，从QQ资料直接复制过去</li>
</ul>
<h1 id="十六、网上缴费"><a href="#十六、网上缴费" class="headerlink" title="十六、网上缴费"></a><span id="p">十六、网上缴费</span></h1><h2 id="1-怎么缴费？"><a href="#1-怎么缴费？" class="headerlink" title="1.怎么缴费？"></a>1.怎么缴费？</h2><ul>
<li>直接登陆网址，地址为：<a href="http://211.82.40.150:8899。">http://211.82.40.150:8899。</a></li>
<li>用户名为：19+通知书左下角的5位编号，密码为：身份证后六位，有X需大写。</li>
<li>专升本学生可以进行缴费，且不需要交军训服的费用，但不可以网上报到。</li>
<li>网上缴费教程也已经上传到了群文件里，建议都看一看再缴费。目前缴费可能会出错，等待几个小时再搞！</li>
</ul>
<h2 id="2-目前绝对可以交学费的三种办法（这三种办法可以解决下面大部分问题）"><a href="#2-目前绝对可以交学费的三种办法（这三种办法可以解决下面大部分问题）" class="headerlink" title="2.目前绝对可以交学费的三种办法（这三种办法可以解决下面大部分问题）"></a>2.目前绝对可以交学费的三种办法（这三种办法可以解决下面大部分问题）</h2><h3 id="方法一：该方法的前提是你在银行办理了K令服务！"><a href="#方法一：该方法的前提是你在银行办理了K令服务！" class="headerlink" title="方法一：该方法的前提是你在银行办理了K令服务！"></a>方法一：该方法的前提是你在银行办理了K令服务！</h3><ol>
<li>百度搜索中国农业银行个人网银，或者直接进这个网址：<a href="https://perbank.abchina.com/EbankSite/startup.do?r=8381D7B5D9FEFF2E">https://perbank.abchina.com/EbankSite/startup.do?r=8381D7B5D9FEFF2E</a></li>
<li>用农行app账号和密码登陆，登录时候输密码需要下载控件</li>
<li>在设置-渠道登录-登陆信息设置中，设置用户名（提示不能纯数字，只能字母加数字，建议设置自己能记住的）</li>
<li>设置好后进缴费系统缴费，选择农业银行，选择下方的K宝/K令支付，输入刚刚设置的用户名和密码进行支付！</li>
<li>可能第一次会提示K令认证失败，确认一下银行有没有扣款，没有的话再试一次。</li>
</ol>
<h3 id="方法二：该方法的前提是你在银行办理了K宝服务！"><a href="#方法二：该方法的前提是你在银行办理了K宝服务！" class="headerlink" title="方法二：该方法的前提是你在银行办理了K宝服务！"></a>方法二：该方法的前提是你在银行办理了K宝服务！</h3><ol>
<li>去农行办k宝，然后让工作人员帮你弄好k宝的相关事项并用蓝牙连上手机。</li>
<li>用电脑登录网上缴费页面，选择农业银行，页面出现一个二维码，用农行掌银扫码支付，并最后在k宝上点击确认即可进行支付！</li>
<li>可能会出现支付错误，一定要检查银行有没有扣钱再重新缴费！</li>
</ol>
<h3 id="方法三：该方法的前提是你有其他银行卡且开通了网银功能"><a href="#方法三：该方法的前提是你有其他银行卡且开通了网银功能" class="headerlink" title="方法三：该方法的前提是你有其他银行卡且开通了网银功能"></a>方法三：该方法的前提是你有其他银行卡且开通了网银功能</h3><ol>
<li>在缴费系统的支付方式页面选择——银联支付</li>
<li>在弹出的页面下方有个“网银支付”，进入以后选择你现有的银行卡，点击下方的“到网上银行支付”</li>
<li>登录你自己的网银账户就可以进行缴费，网银限额5000，如果学费超过5000，就不可以用这种办法了，目前有三种银行卡缴费不了5000以上——农行、建行、中国银行。</li>
</ol>
<h2 id="3-提示商户限额怎么办？"><a href="#3-提示商户限额怎么办？" class="headerlink" title="3.提示商户限额怎么办？"></a>3.提示商户限额怎么办？</h2><ul>
<li>答：这是学校账户的原因，遇到就先等等，等学校修复好再缴费</li>
</ul>
<h2 id="4-提示未绑定动态介质怎么办？"><a href="#4-提示未绑定动态介质怎么办？" class="headerlink" title="4.提示未绑定动态介质怎么办？"></a>4.提示未绑定动态介质怎么办？</h2><ul>
<li>答：试试去银行搞一下那个绑定介质——K宝，群友反馈，办理K宝就可以成功缴费</li>
</ul>
<h2 id="5-提示判断卡号手机号匹配异常怎么办？"><a href="#5-提示判断卡号手机号匹配异常怎么办？" class="headerlink" title="5.提示判断卡号手机号匹配异常怎么办？"></a>5.提示判断卡号手机号匹配异常怎么办？</h2><ul>
<li>答：群友反馈，试试去银行开通短信提醒业务</li>
</ul>
<h2 id="6-提示金额超出商户交易模式单笔支付限额怎么办？"><a href="#6-提示金额超出商户交易模式单笔支付限额怎么办？" class="headerlink" title="6.提示金额超出商户交易模式单笔支付限额怎么办？"></a>6.提示金额超出商户交易模式单笔支付限额怎么办？</h2><ul>
<li>答：先去银行问问是不是你的银行卡最大支付额度低。实在不行就分开支付，不用一下子支付那么多。</li>
</ul>
<h2 id="7-提示无效的错误代码怎么办？"><a href="#7-提示无效的错误代码怎么办？" class="headerlink" title="7.提示无效的错误代码怎么办？"></a>7.提示无效的错误代码怎么办？</h2><ul>
<li>答：不清楚什么原因，过段时间再试</li>
</ul>
<h2 id="8-提示商户无可用的支付方式怎么办？"><a href="#8-提示商户无可用的支付方式怎么办？" class="headerlink" title="8.提示商户无可用的支付方式怎么办？"></a>8.提示商户无可用的支付方式怎么办？</h2><ul>
<li>答：检查是否开通农银快e付功能，或者网银功能，是否正常激活了农行卡</li>
</ul>
<h2 id="9-提示您未绑定有效的安全认证设备怎么办？"><a href="#9-提示您未绑定有效的安全认证设备怎么办？" class="headerlink" title="9.提示您未绑定有效的安全认证设备怎么办？"></a>9.提示您未绑定有效的安全认证设备怎么办？</h2><ul>
<li>答：群友反馈，按照群公告的方法去银行办理K宝业务然后按照群公告的方法进行缴费即可。</li>
</ul>
<h2 id="10-提示获取商户账户信息失败怎么办？"><a href="#10-提示获取商户账户信息失败怎么办？" class="headerlink" title="10.提示获取商户账户信息失败怎么办？"></a>10.提示获取商户账户信息失败怎么办？</h2><ul>
<li>答：这个应该是学校账户出现了问题，等学校修复完再试</li>
</ul>
<h2 id="11-进不去页面，页面显示空白怎么办？"><a href="#11-进不去页面，页面显示空白怎么办？" class="headerlink" title="11.进不去页面，页面显示空白怎么办？"></a>11.进不去页面，页面显示空白怎么办？</h2><ul>
<li>答：这是同时进入的人太多了，过段时间人少再试</li>
</ul>
<h2 id="12-如果任何方法都试了，没法缴费怎么办？"><a href="#12-如果任何方法都试了，没法缴费怎么办？" class="headerlink" title="12.如果任何方法都试了，没法缴费怎么办？"></a>12.如果任何方法都试了，没法缴费怎么办？</h2><ul>
<li>答：支付界面选择在线支付，然后用自己或者父母开通了网银的其他银行卡进行缴费</li>
</ul>
<h2 id="13-银行扣钱了但缴费失败怎么办？"><a href="#13-银行扣钱了但缴费失败怎么办？" class="headerlink" title="13.银行扣钱了但缴费失败怎么办？"></a>13.银行扣钱了但缴费失败怎么办？</h2><ul>
<li>答：这是学校的网慢，没有及时更新，等一两天即可，千万不要重复缴费</li>
</ul>
<h2 id="14-显示缴费失败怎么办？"><a href="#14-显示缴费失败怎么办？" class="headerlink" title="14.显示缴费失败怎么办？"></a>14.显示缴费失败怎么办？</h2><ul>
<li>答：先确认银行有没有扣钱，自己前往农行app查看，如果没有扣钱，等一两个小时再重新试；如果扣钱了，就不用管了，只要你扣钱了就缴费成功了</li>
</ul>
<h2 id="15-电子票据无法生成怎么办？"><a href="#15-电子票据无法生成怎么办？" class="headerlink" title="15.电子票据无法生成怎么办？"></a>15.电子票据无法生成怎么办？</h2><ul>
<li>答：目前学校不需要这个，可以暂时不用管</li>
</ul>
<h2 id="16-可以用手机进行缴费吗？"><a href="#16-可以用手机进行缴费吗？" class="headerlink" title="16.可以用手机进行缴费吗？"></a>16.可以用手机进行缴费吗？</h2><ul>
<li>答：最好不用手机支付，现在群友反馈，用电脑加K宝绝对可以支付成功！操作方法看群公告！！！！</li>
</ul>
<h1 id="十七、杂类问题"><a href="#十七、杂类问题" class="headerlink" title="十七、杂类问题"></a><span id="q">十七、杂类问题</span></h1><h2 id="1-学校有双学位吗？"><a href="#1-学校有双学位吗？" class="headerlink" title="1.学校有双学位吗？"></a>1.学校有双学位吗？</h2><ul>
<li>答：大同大学目前不支持双学位</li>
</ul>
<h2 id="2-学校考研率高吗？"><a href="#2-学校考研率高吗？" class="headerlink" title="2.学校考研率高吗？"></a>2.学校考研率高吗？</h2><ul>
<li>答：目前考研率挺高，在山西省排名算靠前的了</li>
</ul>
<h2 id="3-考四级有要求吗？"><a href="#3-考四级有要求吗？" class="headerlink" title="3.考四级有要求吗？"></a>3.考四级有要求吗？</h2><ul>
<li>答：大一不允许考四级，只有大一两学期的英语成绩都在75分以上时才可以在大二上学期参加四级考试，否则只能在大二下学期和大家一起考。</li>
</ul>
<h2 id="4-咱们学校有晚自习吗？"><a href="#4-咱们学校有晚自习吗？" class="headerlink" title="4.咱们学校有晚自习吗？"></a>4.咱们学校有晚自习吗？</h2><ul>
<li>答：大一有些专业是会有晚自习的哦，具体还是要看自己专业的。时间是晚上7点到9点。</li>
</ul>
<h2 id="5-缴费单怎么打印？"><a href="#5-缴费单怎么打印？" class="headerlink" title="5.缴费单怎么打印？"></a>5.缴费单怎么打印？</h2><ul>
<li>答：自己仔细看通知书，这里只是让教你们怎么去搞电子票据，并不是说要打印票据，请认真区分好吗？</li>
<li>需要打印的是网上报到单，这个9月1日才会开放打印，到时候群里会通知的！！！</li>
</ul>
<h2 id="6-智慧团建需要转吗？"><a href="#6-智慧团建需要转吗？" class="headerlink" title="6.智慧团建需要转吗？"></a>6.智慧团建需要转吗？</h2><ul>
<li>答：各学院智慧团建负责人：接团省委重要消息，日前发现部分高校、地区出现限时要求升学的团员必须在8月底转接团关系的错误安排。再次重申：目前“学社衔接”主要进行的是非升学、非参军的团员，升学的团员关系转接在9月份开始，10月基本结束。请严格按照通知文件进行操作，避免出现舆情。各地、各高校发现有问题的及时上报团省委基层组织建设部！</li>
</ul>
]]></content>
      <categories>
        <category>新生攻略</category>
      </categories>
      <tags>
        <tag>新生</tag>
      </tags>
  </entry>
  <entry>
    <title>玩机：巧妙压缩照片大小</title>
    <url>/52621.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>网上报到时需要上传学籍照片（即一寸蓝底白衣照片）</li>
<li>系统都限制文件大小不超过1.5M，接下来就列举几个方法来教大家压缩照片<span id="more"></span></li>
</ul>
<h1 id="如何查看文件大小？"><a href="#如何查看文件大小？" class="headerlink" title="如何查看文件大小？"></a>如何查看文件大小？</h1><h2 id="电脑端查看法"><a href="#电脑端查看法" class="headerlink" title="电脑端查看法"></a>电脑端查看法</h2><ul>
<li>在你的照片上右击-最下边有个属性，打开如下<img src="https://i.loli.net/2019/08/19/xqLA6ZHnOoTbGag.png" width="400px" /></li>
<li>如上图，这里1.51M，超了</li>
</ul>
<h2 id="手机端查看法"><a href="#手机端查看法" class="headerlink" title="手机端查看法"></a>手机端查看法</h2><ul>
<li>相册中打开你的照片，一般在右上角有三个点，点进去有详细信息（不同手机，方法不同，自己摸索）<img src="https://i.loli.net/2019/08/19/nFiuPw1vykAfpMh.jpg" width="400px" /></li>
<li>这里显示1.74M，也超了</li>
</ul>
<h1 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h1><h2 id="1-最省力的方法"><a href="#1-最省力的方法" class="headerlink" title="1.最省力的方法"></a>1.最省力的方法</h2><ul>
<li>找电脑铺帮忙</li>
<li>找照相馆帮忙</li>
</ul>
<h2 id="2-最粗暴的方法"><a href="#2-最粗暴的方法" class="headerlink" title="2.最粗暴的方法"></a>2.最粗暴的方法</h2><ul>
<li>将这张图片用QQ随便发给一个好友，不用发原图，然后把发出去的图片保存在本地</li>
<li>如果还是超出大小，继续上面操作把新保存的图片发送再保存，直到你满意为止</li>
<li>记得发送的时候千万不要选原图发送！！！</li>
<li>该方法有一个缺点，不能进行分辨率的调节，压缩率较高，较影响图片的质量，可能最后图片会模糊，不建议使用该方法。</li>
</ul>
<h2 id="3-在线压缩法"><a href="#3-在线压缩法" class="headerlink" title="3.在线压缩法"></a>3.在线压缩法</h2><ul>
<li>这个网址可以解放双手，将照片上传上去，轻轻一点，即可压缩</li>
<li>网址链接，点击<a href="https://tinypng.com/">这里</a>，或者复制链接（<a href="https://tinypng.com/%EF%BC%89">https://tinypng.com/）</a> 进入浏览器进入。</li>
<li>首先进入网页之后，把照片拖入红框或者点击一下找到你的照片<img src="https://i.loli.net/2019/08/19/AmafglHU2Be4ItZ.png" width="400px" /></li>
<li>然后网页会自动压缩图片，会有一点慢，等待一会就好了<img src="https://i.loli.net/2019/08/19/UtjfA39uyVeBWKv.png" width="400px" /></li>
<li>最后，点击右边的 <code>download</code> 按钮进行下载即可</li>
<li>还有其余网址，可自己搜寻，不保证安全性，自行考虑</li>
</ul>
<h2 id="4-针对于png格式图片的压缩"><a href="#4-针对于png格式图片的压缩" class="headerlink" title="4.针对于png格式图片的压缩"></a>4.针对于png格式图片的压缩</h2><ul>
<li>如果你的图片是png格式，那么你可以用电脑自带的画图工具打开<img src="https://i.loli.net/2019/08/20/8vzQjZAluH5WIXR.png" width="400px" /></li>
<li>然后在右上角选择文件另存为jpeg格式，即可大幅度压缩照片<img src="https://i.loli.net/2019/08/20/QqkC7NTFoDaVL35.png" width="400px" /></li>
</ul>
<h2 id="5-win10系统下针对于jpg格式图片的压缩"><a href="#5-win10系统下针对于jpg格式图片的压缩" class="headerlink" title="5.win10系统下针对于jpg格式图片的压缩"></a>5.win10系统下针对于jpg格式图片的压缩</h2><ul>
<li>如果你原本为jpg格式或者由png格式转换过来以后依然大于1.5M，试试下面</li>
<li>用win10自带的图片查看器打开图片，在图片右上角有三个点，找到调整大小<img src="https://i.loli.net/2019/08/20/VMSceKdpO2jqLzJ.png" width="400px" /></li>
<li>不用管上面三个，直接选择 <code>自定义尺寸</code> 即可<img src="https://i.loli.net/2019/08/20/XzhVg2tEwxcUbQA.png" width="400px" /></li>
<li>拉动横杆向低调整质量然后保存就可以压缩了<img src="https://i.loli.net/2019/08/20/5Q9HSBnpTWJ8Gs6.png" width="400px" /></li>
<li>注意：该方法只适用于Windows 10系统！！！</li>
</ul>
<h2 id="6-使用格式工厂软件进行压缩"><a href="#6-使用格式工厂软件进行压缩" class="headerlink" title="6.使用格式工厂软件进行压缩"></a>6.使用格式工厂软件进行压缩</h2><ul>
<li>该方法适用于任何格式的图片</li>
<li>自行在软件应用商店或浏览器下载 <code>格式工厂</code> 软件</li>
<li>打开软件后，找到图片栏里的第二个——转为JPG<img src="https://i.loli.net/2019/08/20/6Lt78PuR2UVrNnT.png" width="400px" /></li>
<li>在弹出的页面选择 添加文件，找到你需要压缩的文件，点击确定</li>
<li>在最上边有个开始按钮，点击以后稍待片刻，就完成了压缩<img src="https://i.loli.net/2019/08/20/F5e1gqjkbBzG9aD.png" width="400px" /></li>
<li>点击一下完成，右上角黄色按钮可以打开所在文件夹<img src="https://i.loli.net/2019/08/20/WXc78eJuwjRpyMV.png" width="400px" /></li>
</ul>
<h2 id="7-利用电脑自带的画图工具修改"><a href="#7-利用电脑自带的画图工具修改" class="headerlink" title="7.利用电脑自带的画图工具修改"></a>7.利用电脑自带的画图工具修改</h2><ul>
<li>该方法适用于任何格式的图片</li>
<li>鼠标右击用电脑自带的画图工具打开<img src="https://i.loli.net/2019/08/20/8vzQjZAluH5WIXR.png" width="400px" /></li>
<li>然后点击重新调整大小，并且修改水平值或垂直值为100以下<img src="https://i.loli.net/2019/08/20/mbVDTAIC4WE85jS.png" width="400px" /></li>
<li>因为保持了纵横比，所以修改一项即可，这里默认最高100，修改完以后另存为jpg格式即可</li>
</ul>
<h2 id="8-利用系统自带的Microsoft-Word软件修改"><a href="#8-利用系统自带的Microsoft-Word软件修改" class="headerlink" title="8.利用系统自带的Microsoft Word软件修改"></a>8.利用系统自带的Microsoft Word软件修改</h2><ul>
<li>该方法适用于任何格式的图片</li>
<li>先在word中插入图片，在图片格式选项卡中找到 <code>压缩图片</code> 选项<img src="https://i.loli.net/2019/08/20/s5YdRobnIucgWkx.png" width="400px" /></li>
<li>这两个分辨率都可以，自行选择<img src="https://i.loli.net/2019/08/20/jioEslt5xbTBhcy.png" width="400px" /></li>
<li>然后右击这个图片，选择另存为图片即可</li>
</ul>
<h2 id="9-利用PhotoShop（即PS）修改"><a href="#9-利用PhotoShop（即PS）修改" class="headerlink" title="9.利用PhotoShop（即PS）修改"></a>9.利用PhotoShop（即PS）修改</h2><ul>
<li>步骤繁琐，且需要下载PS，想尝试的自行百度吧</li>
</ul>
<h2 id="10-利用压缩软件进行修改"><a href="#10-利用压缩软件进行修改" class="headerlink" title="10.利用压缩软件进行修改"></a>10.利用压缩软件进行修改</h2><ul>
<li>大部分软件收费，有时候压缩一次就不能了，必须充钱才可以压缩</li>
<li>且需要下载，所以这里不赘述，自行百度吧</li>
</ul>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li>我这里只是列举了电脑端的压缩方法，手机端的自行解决吧，方法很雷同，无非就是另存为和修改分辨率。</li>
<li>本来是打算写几种自己知道的方法来着，没想到百度了一下后，找到了这么多方法，get到了很多。</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>玩机技巧</tag>
        <tag>照片</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：HTML（尚硅谷）</title>
    <url>/Learn-HTML.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 HTML 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-软件架构"><a href="#1-软件架构" class="headerlink" title="1.软件架构"></a>1.软件架构</h2><ul>
<li>分为 C/S 架构和 B/S 架构</li>
<li>两者区别如下：<br><img src="https://s1.ax1x.com/2020/10/20/0zXjC4.png" alt="html01.png"></li>
</ul>
<h2 id="2-W3C-标准"><a href="#2-W3C-标准" class="headerlink" title="2.W3C 标准"></a>2.W3C 标准</h2><ul>
<li>网页主要有以下三个部分组成<br><img src="https://s1.ax1x.com/2020/10/20/0zXv8J.png" alt="html02.png"></li>
</ul>
<h1 id="二、HTML-基础"><a href="#二、HTML-基础" class="headerlink" title="二、HTML 基础"></a>二、HTML 基础</h1><h2 id="1-标签"><a href="#1-标签" class="headerlink" title="1.标签"></a>1.标签</h2><ul>
<li>使用尖括号 <code>&lt;&gt;</code> 表示，一般成对出现，结束标签在尖括号中加入 <code>/</code></li>
<li>书写时换行加 tab 来使层次分明</li>
</ul>
<h2 id="2-常用标签"><a href="#2-常用标签" class="headerlink" title="2.常用标签"></a>2.常用标签</h2><h3 id="（1）根标签"><a href="#（1）根标签" class="headerlink" title="（1）根标签"></a>（1）根标签</h3><ul>
<li><code>&lt;html&gt;</code> 标签，所有网页内容都得写到根标签里面</li>
</ul>
<h3 id="（2）子标签"><a href="#（2）子标签" class="headerlink" title="（2）子标签"></a>（2）子标签</h3><ul>
<li><code>&lt;head&gt;</code> <code>&lt;body&gt;</code> 标签，是根标签内部<font color=#F00>必须有的两个标签</font></li>
<li><code>&lt;head&gt;</code> 标签是网页的头部信息，不会在网页中显示，为了让浏览器解析网页。</li>
<li><code>&lt;body&gt;</code> 标签表示网页的主体，所有可见内容都得写到 <code>&lt;body&gt;</code> 里面。</li>
</ul>
<h3 id="（3）head-的子标签"><a href="#（3）head-的子标签" class="headerlink" title="（3）head 的子标签"></a>（3）head 的子标签</h3><ul>
<li><code>&lt;title&gt;</code> 标签，是 <code>&lt;head&gt;</code>内部的标签</li>
<li><code>&lt;title&gt;</code> 中的内容会显示在网页的标题栏里。</li>
<li>搜索引擎在检索页面时，会首先检索 <code>&lt;title&gt;</code> 标签中的内容。</li>
</ul>
<h3 id="（4）字体标签"><a href="#（4）字体标签" class="headerlink" title="（4）字体标签"></a>（4）字体标签</h3><ul>
<li><code>&lt;font&gt;</code> 标签，用来修改字体相关样式</li>
<li><font color=#FF0000>注意：这里不赞成使用 <code>&lt;font&gt;</code> 标签，因为在某些浏览器上并不兼容，应使用 CSS 来进行相关解释。</font></li>
</ul>
<h3 id="（5）meta-标签"><a href="#（5）meta-标签" class="headerlink" title="（5）meta 标签"></a>（5）meta 标签</h3><ul>
<li><code>&lt;meta /&gt;</code> 标签，为自结束标签</li>
<li>用法如下：<br>(1).用来设置网页的一些元数据，即 <code>&lt;meta charset=&quot;utf-8&quot; /&gt;</code><br>(2).用来设置网页的关键字，即 <code>&lt;meta name=&quot;keywords&quot; content=&quot;HTML5,前端&quot; /&gt;</code><br>(3).用来指定网页的描述，即 <code>&lt;meta name=&quot;description&quot; content=&quot;发布关于h5等前端的相关信息&quot; /&gt;</code><br>(4).用来做请求的重定向，即5秒后跳转到对应 URL  <code>&lt;meta http-equivalent=&quot;refresh&quot; content=&quot;5;url=www.wrysmile.cn&quot; /&gt;</code> </li>
</ul>
<h3 id="（6）标题标签"><a href="#（6）标题标签" class="headerlink" title="（6）标题标签"></a>（6）标题标签</h3><ul>
<li><code>&lt;h1&gt;</code> 标签，总共有6级标题，修改相应数字即可</li>
<li>6级标题中，<code>&lt;h1&gt;</code> 最重要且表示一个网页中的主要内容；其余重要性依次降低。</li>
<li>对于搜索引擎来说，<code>&lt;h1&gt;</code> 重要性仅次于 <code>&lt;title&gt;</code> ，搜索引擎检索完 <code>&lt;title&gt;</code> 后会立即查看 <code>&lt;h1&gt;</code> 中的内容。</li>
<li><font color=#FF0000>注意：页面只能写一个 <code>&lt;h1&gt;</code> ，且一般页面中只使用h1~h3。</font></li>
</ul>
<h3 id="（7）标题分组标签"><a href="#（7）标题分组标签" class="headerlink" title="（7）标题分组标签"></a>（7）标题分组标签</h3><ul>
<li><code>&lt;hgroup&gt;&lt;/hgroup&gt;</code> 标签可以为标题分组，可以将一组相关的标题同时放入其中</li>
</ul>
<h3 id="（8）段落标签"><a href="#（8）段落标签" class="headerlink" title="（8）段落标签"></a>（8）段落标签</h3><ul>
<li><code>&lt;p&gt;</code> 标签，用来表示内容中的一个自然段</li>
<li><code>&lt;p&gt;</code> 标签中的文字会默认独占一行，且段与段之间会有间距。</li>
</ul>
<h3 id="（9）换行标签"><a href="#（9）换行标签" class="headerlink" title="（9）换行标签"></a>（9）换行标签</h3><ul>
<li><code>&lt;br /&gt;</code> 标签，可以实现换行，为自结束标签</li>
<li>在 HTML 中，不论写多少空格和换行，浏览器都解析为一个空格解析，故换行需采用换行标签。</li>
</ul>
<h3 id="（10）水平线标签"><a href="#（10）水平线标签" class="headerlink" title="（10）水平线标签"></a>（10）水平线标签</h3><ul>
<li><code>&lt;hr /&gt;</code> 标签，可以在页面中生成一条水平线，为自结束标签</li>
</ul>
<h3 id="（11）图片标签"><a href="#（11）图片标签" class="headerlink" title="（11）图片标签"></a>（11）图片标签</h3><ul>
<li><code>&lt;img /&gt;</code> 标签，向网页中引入一个外部的图片，为自结束标签</li>
<li>属性:<br>(1).<code>src</code> 设置图片的路径。<font color=#F00>注意：这里路径是指相对路径，即相对于当前资源所在目录的位置， <code>../</code> 指返回上一级；</font><br>(2).<code>alt</code> 设置在图片没有显示时的描述，搜索引擎可以通过该属性来识别不同的图片，如果不写该属性，则搜索引擎不会对该图片进行收录；<br>(3).<code>width</code> 修改图片的宽度，一般使用 px 作为单位；<br>(4).<code>height</code> 修改图片的高度，一般使用 px 作为单位，宽高只修改一项会等比例修改。</li>
</ul>
<h3 id="（12）居中标签"><a href="#（12）居中标签" class="headerlink" title="（12）居中标签"></a>（12）居中标签</h3><ul>
<li><code>&lt;center&gt;</code> 标签，可以使内容居中显示</li>
</ul>
<h3 id="（13）input-标签"><a href="#（13）input-标签" class="headerlink" title="（13）input 标签"></a>（13）input 标签</h3><ul>
<li><code>&lt;input type=&quot;text&quot; /&gt;</code> 标签，可以创建一个文本输入框</li>
</ul>
<h3 id="（14）表格标签"><a href="#（14）表格标签" class="headerlink" title="（14）表格标签"></a>（14）表格标签</h3><ul>
<li><p>用来表示格式化的数据</p>
</li>
<li><p>父标签是 <code>&lt;table&gt;&lt;/table&gt;</code> </p>
</li>
<li><p>其子标签中的 <code>&lt;tr&gt;&lt;/tr&gt;</code> 表示一行，行的子标签 <code>&lt;td&gt;&lt;/td&gt;</code> 表示一个单元格，行的子标签 <code>&lt;th&gt;&lt;/th&gt;</code> 表示一个表头</p>
</li>
</ul>
<h2 id="3-文本标签"><a href="#3-文本标签" class="headerlink" title="3.文本标签"></a>3.文本标签</h2><h3 id="（1）强调标签"><a href="#（1）强调标签" class="headerlink" title="（1）强调标签"></a>（1）强调标签</h3><ul>
<li><code>&lt;em&gt;</code> 标签：表示一段内容中的着重点，默认以斜体显示，主要是指语气上的强调</li>
<li><code>&lt;strong&gt;</code> 标签：表示一个内容中的重要性，默认以粗体显示，主要是指内容上的强调</li>
</ul>
<h3 id="（2）斜体标签"><a href="#（2）斜体标签" class="headerlink" title="（2）斜体标签"></a>（2）斜体标签</h3><ul>
<li><code>&lt;i&gt;</code> 标签，可以让指定内容斜体显示，<font color=#FF0000>该标签并不常用</font></li>
</ul>
<h3 id="（3）粗体标签"><a href="#（3）粗体标签" class="headerlink" title="（3）粗体标签"></a>（3）粗体标签</h3><ul>
<li><code>&lt;b&gt;</code> 标签，可以让指定内容粗体显示，<font color=#FF0000>该标签并不常用</font></li>
</ul>
<h3 id="（4）小字标签"><a href="#（4）小字标签" class="headerlink" title="（4）小字标签"></a>（4）小字标签</h3><ul>
<li><code>&lt;small&gt;</code> 标签，该标签中的内容会比父元素中的文字小一些，用来表示细则、合同、版权声明等内容</li>
<li>注意：与该标签相对应的 <code>&lt;big&gt;</code> 标签已经被淘汰</li>
</ul>
<h3 id="（5）引用标签"><a href="#（5）引用标签" class="headerlink" title="（5）引用标签"></a>（5）引用标签</h3><ul>
<li><code>&lt;cite&gt;</code> 标签，可以用在所有加书名号的内容（书名、歌名、话剧名、电影名等）处，表示参考的内容</li>
<li><code>&lt;q&gt;</code> 标签，表示一个短引用，即行内引用，使用时会自动给所选内容加上引号，<font color=#FF0000>并不推荐使用，因为有些浏览器不支持该标签</font></li>
<li><code>&lt;blockquote&gt;</code> 标签，表示一个长引用，即块级的引用，<font color=#FF0000>该标签不能放在 <code>&lt;p&gt;</code> 标签中</font></li>
</ul>
<h3 id="（6）角标标签"><a href="#（6）角标标签" class="headerlink" title="（6）角标标签"></a>（6）角标标签</h3><ul>
<li><code>&lt;sup&gt;</code> 标签，用来设置上标</li>
<li><code>&lt;sub&gt;</code> 标签，用来设置下标</li>
</ul>
<h3 id="（7）代码标签"><a href="#（7）代码标签" class="headerlink" title="（7）代码标签"></a>（7）代码标签</h3><ul>
<li><code>&lt;code&gt;</code> 标签，表示该标签中的内容是代码，注意：<font color=#FF0000>该标签并不会保留代码的原本格式</font></li>
<li><code>&lt;pre&gt;</code> 标签，即预格式标签，表示该标签中的内容是代码，<font color=#FF0000>且会保留代码的原本格式</font></li>
</ul>
<h2 id="4-列表标签"><a href="#4-列表标签" class="headerlink" title="4.列表标签"></a>4.列表标签</h2><ul>
<li><font color=#FF0000>注意：列表之间可以互相嵌套</font></li>
</ul>
<h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="(1).无序列表"></a>(1).无序列表</h3><ul>
<li><code>&lt;ul&gt;&lt;/ul&gt;</code> 标签，用来创建无序列表，在该标签中使用 <code>&lt;li&gt;&lt;/li&gt;</code> 标签来创建一个一个的列表项</li>
<li>列表项前面默认显示 <code>·</code> 的项目符号，但一般不使用，可以用 CSS 来去掉符号，代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">  list-style: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果需要项目符号，则需要给 <code>&lt;li&gt;</code> 设置背景图片，来使得每一个浏览器显示效果都一样</li>
</ul>
<h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="(2).有序列表"></a>(2).有序列表</h3><ul>
<li><code>&lt;ol&gt;&lt;/ol&gt;</code> 标签，用来创建有序列表，该列表默认，用有序序号作为项目符号</li>
<li>列表项前面默认显示有序数对，但一般不使用，去除方法见上面</li>
<li>可以通过该标签的 <code>type</code> 属性来修改项目符号：<br>默认：阿拉伯数字<br>a/A：小写或大写字母<br>i/I：小写或大写罗马数字</li>
</ul>
<h3 id="3-定义列表"><a href="#3-定义列表" class="headerlink" title="(3).定义列表"></a>(3).定义列表</h3><ul>
<li><code>&lt;dl&gt;&lt;/dl&gt;</code> 标签，用来创建定义列表，对词汇或内容进行定义</li>
<li>在该标签中使用 <code>&lt;dt&gt;&lt;/dt&gt;</code> 标签表示被定义的内容，用 <code>&lt;dd&gt;&lt;/dd&gt;</code> 表示对定义内容的描述</li>
</ul>
<h2 id="5-语义化标签"><a href="#5-语义化标签" class="headerlink" title="5.语义化标签"></a>5.语义化标签</h2><ul>
<li>以下部分为 H5 新增的标签，并不怎么常用</li>
</ul>
<h3 id="1-网页布局标签"><a href="#1-网页布局标签" class="headerlink" title="(1).网页布局标签"></a>(1).网页布局标签</h3><ul>
<li><code>&lt;header&gt;&lt;/header&gt;</code> 表示网页的头部</li>
<li><code>&lt;main&gt;&lt;/main&gt;</code> 表示网页的主体部分，一个页面中只会有一个 <code>&lt;main&gt;</code> 标签</li>
<li><code>&lt;footer&gt;&lt;/footer&gt;</code> 表示网页的底部</li>
</ul>
<h3 id="2-导航标签"><a href="#2-导航标签" class="headerlink" title="(2).导航标签"></a>(2).导航标签</h3><ul>
<li><code>&lt;nav&gt;&lt;/nav&gt;</code> 表示网页中的导航</li>
</ul>
<h3 id="3-aside-标签"><a href="#3-aside-标签" class="headerlink" title="(3).aside 标签"></a>(3).aside 标签</h3><ul>
<li><code>&lt;aside&gt;&lt;/aside&gt;</code> 表示和主体相关的其他内容（侧边栏）</li>
</ul>
<h3 id="4-文章标签"><a href="#4-文章标签" class="headerlink" title="(4).文章标签"></a>(4).文章标签</h3><ul>
<li><code>&lt;article&gt;&lt;/article&gt;</code> 表示一个独立文章</li>
</ul>
<h3 id="5-section-标签"><a href="#5-section-标签" class="headerlink" title="(5).section 标签"></a>(5).section 标签</h3><ul>
<li><code>&lt;section&gt;&lt;/section&gt;</code> 表示一个独立的区块，上边的标签都不能使用 <code>&lt;section&gt;</code> 标签</li>
</ul>
<h2 id="6-注释"><a href="#6-注释" class="headerlink" title="6.注释"></a>6.注释</h2><ul>
<li>格式： <code>&lt;!-- 中间写注释 --&gt;</code></li>
<li>注释只在源码中显示，起提示作用</li>
</ul>
<h2 id="7-属性"><a href="#7-属性" class="headerlink" title="7.属性"></a>7.属性</h2><ul>
<li>可以通过属性来设置标签来处理标签中的内容</li>
<li>用法：在开始标签中添加属性，且需写成—— <code>属性名=&quot;属性值&quot;</code></li>
<li>一个标签可以使用多个属性，且每个属性之间需要空格隔开。</li>
<li>相应标签有哪些属性可以从 W3School 离线手册中查询。</li>
</ul>
<h2 id="8-文档声明"><a href="#8-文档声明" class="headerlink" title="8.文档声明"></a>8.文档声明</h2><ul>
<li>当前市面上流行三个版本的 html ，分别为 h4、h5、xthml1.0，为了让浏览器区分版本，需要在网页最上边引入文档声明。</li>
<li>h4 和 xthml 的太麻烦，不引用，直接使用 h5 的 <code>&lt;!doctype html&gt;</code></li>
<li>如果不写文档声明，则会导致某些浏览器进入怪异模式，导致页面无法显示。</li>
</ul>
<h2 id="9-乱码"><a href="#9-乱码" class="headerlink" title="9.乱码"></a>9.乱码</h2><ul>
<li><p>产生原因：计算机底层只认识0和1，根本上是指编码和解码采用的字符集不同</p>
</li>
<li><p>编码：依据一定的规则，将字符转换为二进制编码</p>
</li>
<li><p>解码：依据一定的规则，将二进制编码转换为字符</p>
</li>
<li><p>字符集：编码和解码所采用的规则<br><img src="https://s1.ax1x.com/2020/10/20/0zXO5F.png" alt="html03.png"></p>
</li>
<li><p>注意：在中文系统的浏览器中，默认都是使用GB2312进行解码，为了避免手动修改编码解码格式，需要告诉浏览器网页所采用的编码格式是什么。即采用 <code>&lt;meta&gt;</code> 标签来设置网页的字符集。</p>
</li>
<li><p>在 <code>&lt;head&gt;</code> 标签中加入，书写格式为 <code>&lt;meta charset=&quot;utf-8&quot; /&gt;</code>（在写这个网页时用的哪种字符集，双引号中就写哪种）</p>
</li>
</ul>
<h2 id="10-实体"><a href="#10-实体" class="headerlink" title="10.实体"></a>10.实体</h2><ul>
<li>在 HTML 中，一些如 <code>&lt;</code> <code>&gt;</code> 特殊字符是不能直接使用的，需使用一些特殊的符号来表示这些特殊字符，而这些特殊符号就是实体（又称转义字符）。</li>
<li>语法： <code>&amp;实体的名字;</code></li>
<li>举例： <code>&lt; 为 &amp;lt;</code> <code>&gt; 为 &amp;gt;</code> <code>空格 为 &amp;nbsp;</code> <code>版权符号 为 &amp;copy;</code></li>
<li>其余实体可以去 W3C 离线手册查找。</li>
</ul>
<h2 id="11-图片使用原则"><a href="#11-图片使用原则" class="headerlink" title="11.图片使用原则"></a>11.图片使用原则</h2><ul>
<li><p>在 <code>&lt;img&gt;</code> 标签中常用到jpg、png、gif格式的图0片，三者比较如下：<br><img src="https://s1.ax1x.com/2020/10/20/0zXx29.png" alt="html04.png"></p>
</li>
<li><p>webp：谷歌新推出的专门用来表示网页中的一种格式<br>优点：具备其他图片格式的所有优点，而且文件还特别小<br>缺点：兼容性不好</p>
</li>
<li><p>base64：将图片使用 base64 来编码，这样可以将图片转换为字符，通过字符的形式来引入图片，一般用在需要和网页一起加载的图片上</p>
</li>
</ul>
<h2 id="12-内联框架"><a href="#12-内联框架" class="headerlink" title="12.内联框架"></a>12.内联框架</h2><ul>
<li><p>可以引入一个外部的页面</p>
</li>
<li><p>使用 <code>&lt;iframe&gt;&lt;/iframe&gt;</code> 标签来创建一个内联框架</p>
</li>
<li><p>属性：<br><code>src</code> 设置图片的路径，可以使用相对路径<br><code>name</code> 设置一个 name 属性<br><code>width</code> 修改框架的宽度<br><code>height</code> 修改框架的高度<br><code>frameborder</code> 指定框架的边框</p>
</li>
<li><p><font color=#F00>注意：在现实开发中不推荐使用内联框架，因为内联框架中的内容不会被搜索引擎所检索</font></p>
</li>
</ul>
<h2 id="13-框架集"><a href="#13-框架集" class="headerlink" title="13.框架集"></a>13.框架集</h2><ul>
<li>和内联框架的作用类似，可以引入多个外部的页面</li>
<li>使用 <code>&lt;frameset&gt;</code> 标签来创建一个框架集，但是不能和 <code>&lt;body&gt;</code> 出现在同一个页面中，两者只能取一个<br>该标签中有个 rows 属性来指定所有的框架以行显示，有个 cols 属性来指定所有的框架以列显示<br>这两个属性必须选择一个，并且需要在属性中指定每一部分的大小</li>
<li>子标签是 <code>&lt;frame&gt;</code> 用来指定要引入的页面，该标签中有个 src 属性用来指定要引入的链接路径，引入几个页面就写几个 <code>&lt;frame&gt;</code> 标签</li>
<li>在 <code>&lt;frameset&gt;</code> 也可以再嵌套 <code>&lt;frameset&gt;</code></li>
<li><font color=#F00>注意：框架集中的内容不会被搜索引擎所检索，且每单独加载一个页面，浏览器都需要重新发送一个请求，但在h5标准中，推荐使用框架集而不使用内联框架</font><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;frameset cols=&quot;30%, 40%, 30%&quot;&gt;</span><br><span class="line">	&lt;frame src=&quot;1.html&quot; /&gt;</span><br><span class="line">	&lt;frame src=&quot;2.html&quot; /&gt;</span><br><span class="line">	&lt;frameset rows=&quot;30%, 50%, *&quot;&gt;</span><br><span class="line">		&lt;frame src=&quot;3.html&quot; /&gt;</span><br><span class="line">		&lt;frame src=&quot;4.html&quot; /&gt;</span><br><span class="line">		&lt;frame src=&quot;5.html&quot; /&gt;</span><br><span class="line">	&lt;/frameset&gt;</span><br><span class="line">&lt;/frameset&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-超链接"><a href="#14-超链接" class="headerlink" title="14.超链接"></a>14.超链接</h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="(1).介绍"></a>(1).介绍</h3><ul>
<li>作用：可以从一个页面跳转到另一个页面</li>
<li>使用 <code>&lt;a&gt;&lt;/a&gt;</code> 标签来创建超链接</li>
</ul>
<h4 id="a-属性"><a href="#a-属性" class="headerlink" title="a).属性"></a>a).属性</h4><ul>
<li><code>href</code> 指向链接跳转的目标，可以写相对路径，也可以写完整的地址</li>
<li><code>target</code> 规定在何处打开链接，属性值如下：<br><code>_self</code> 为在当前窗口打开<br><code>_blank</code> 为在新窗口中打开，若将其设置为内联框架的 <code>name</code> 属性值，可以实现在内联框架中打开链接</li>
</ul>
<h3 id="2-超链接的用处"><a href="#2-超链接的用处" class="headerlink" title="(2).超链接的用处"></a>(2).超链接的用处</h3><ol>
<li><p>回到顶部：在 <code>href</code> 属性中设置#号来作为一个属性值，可以<font color=#F00>自动跳转到当前页面的顶部</font></p>
</li>
<li><p>跳转到任意地方：html 中有个属性，每个元素都可以设置，该属性可以作为标签的唯一标识—— <code>id</code> 属性，id名在同一个页面只能有一个且不能重复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;#bottom&quot;&gt;跳转到底部&lt;/a&gt;</span><br><span class="line">	正文</span><br><span class="line">&lt;a id=&quot;bottom&quot; href=&quot;#&quot;&gt;这里id名为bottom底部，且可以跳转到顶部&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>发送邮件：点击超链接可以打开默认邮件程序来发送邮件——在 <code>href</code> 属性中设置 <code>mailto</code> 属性值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;mailto:邮件地址&quot;&gt;联系我们&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>作为占位符使用：在 <code>href</code> 属性中写一个属性值为 <code>javascript:;</code> 时，点击这个超链接没有任何变化，也不会跳转到其他页面，也不会回到顶部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:;&quot;&gt;这是一个用于占位的超链接&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在 js 中绑定了单击相应函数时，可以在响应函数的最后添加如下一句来取消默认跳转行为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return false;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-相对路径"><a href="#3-相对路径" class="headerlink" title="(3).相对路径"></a>(3).相对路径</h3><ul>
<li>一般会使用 ./ 或者 ../ 开头，也可省略不写，不写的时候相当于默认 ./ 了</li>
<li>./ 表示当前文件所在的目录</li>
<li>../ 表示当前文件所在目录的上一级目录</li>
</ul>
<h2 id="15-音视频的引入"><a href="#15-音视频的引入" class="headerlink" title="15.音视频的引入"></a>15.音视频的引入</h2><ul>
<li>音视频文件引入时，默认是不允许用户自己控制播放停止的</li>
</ul>
<h3 id="1-音频"><a href="#1-音频" class="headerlink" title="(1).音频"></a>(1).音频</h3><ul>
<li><p>使用 <code>&lt;audio&gt;&lt;/audio&gt;</code> 标签来向页面中引入外部的音频文件</p>
</li>
<li><p>属性：<br><code>src</code> 设置音频文件的路径，可以使用相对路径<br><code>controls</code> 是否允许用户控制播放，不需要给值，想要控制写上该属性即可<br><code>autoplay</code> 音频文件是否自动播放，不需要给值，想要自动播放写上该属性即可，但是大部分浏览器都不会自动播放<br><code>loop</code> 开启是否循环播放，不需要给值，想要循环播放写上该属性即可</p>
</li>
<li><p>IE9 以下不支持该标签，可以使用 <code>&lt;audio&gt;</code> 的子标签 <code>&lt;source&gt;</code> 来解决这个问题，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;audio controls&gt;</span><br><span class="line">	对不起，您的浏览器不支持播放音频，请升级浏览器！</span><br><span class="line">	&lt;source src=&quot;audio.mp3&quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>或者在 IE8 浏览器中使用 <code>&lt;embed&gt;</code> 来引入音频，且会默认自动播放，且必须规定长宽才能显示，为了让所有浏览器都兼容，可以像下边这样做，这样其他浏览器使用 <code>&lt;audio&gt;</code> ，而 IE9 以下使用 <code>&lt;embed&gt;</code> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;audio controls&gt;</span><br><span class="line">	&lt;source src=&quot;audio.mp3&quot;&gt;</span><br><span class="line">	&lt;embed src=&quot;audio.mp3&quot; type=&quot;audio/mp3&quot; width=&quot;300px&quot; height=&quot;100px&quot;&gt;</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-视频"><a href="#2-视频" class="headerlink" title="(2).视频"></a>(2).视频</h3><ul>
<li>使用 <code>&lt;video&gt;&lt;/video&gt;</code> 标签来向页面中引入外部的视频文件</li>
<li>使用方式和 <code>&lt;audio&gt;</code> 基本都一样</li>
<li>IE9 以下同样不支持，方法同上</li>
</ul>
<h1 id="三、XHTML语法规范"><a href="#三、XHTML语法规范" class="headerlink" title="三、XHTML语法规范"></a>三、XHTML语法规范</h1><ol>
<li><p>HTML 中不区分大小写，一般使用小写</p>
</li>
<li><p>HTML 中的注释不能嵌套</p>
</li>
<li><p>HTML 的标签必须结构完整，要么承兑出现、要么自结束标签<br>所有不符合规范的标签，浏览器会自动补全，但有时会修正错粗。查看方法就是：下载 firebug 插件（火狐浏览器），即可在浏览器中查看缺少内容。或者 F12 也可以查看。</p>
</li>
<li><p>HTML 的标签可以嵌套，但不可以交叉嵌套</p>
</li>
<li><p>HTML 标签中的属性必须有值，且值必须加引号（单引号和双引号都可以）</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器：各浏览器的兼容模式修改</title>
    <url>/2286.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>由于兼容性原因，可能会导致进入某些网站时显示内容不全或者无法进行点击，这时就需要进行浏览器的兼容模式的修改了。</li>
<li>本篇主要介绍了主流浏览器的修改方法，其余浏览器大同小异，如有需要，请进行百度。</li>
<li>这里就以学校教务处网站为例，进行修改了。<span id="more"></span></li>
</ul>
<h1 id="一、IE浏览器"><a href="#一、IE浏览器" class="headerlink" title="一、IE浏览器"></a>一、IE浏览器</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>IE浏览器是每个电脑必备的，如果想要图省事，可以直接用它，但日用不建议用。</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>点击桌面右下角的开始按钮，找到 Windows 附件 中的“Internet Explorer”<br><img src="https://s1.ax1x.com/2020/10/20/BSEmtA.png" alt="IE01.png"></p>
</li>
<li><p>在右上角的齿轮按钮的下拉栏中找到 <code>兼容性视图设置</code><br><img src="https://s1.ax1x.com/2020/10/20/BSEE0e.png" alt="IE02.png"></p>
</li>
<li><p>在弹出的对话框中把你需要修改兼容性的网站添加进去即可，这里添加了教务处学生端口的两个网站，总共有4个，分别为 <del><code>211.82.47.2</code></del> <del><code>211.82.47.3</code></del> <code>211.82.47.6</code> <code>211.82.47.7</code>(前两个网站现在已经进不去，只能用后边两个——2019.10.7)<br><img src="https://s1.ax1x.com/2020/10/20/BSEKpt.png" alt="IE03.png"></p>
</li>
<li><p>直接在地址栏里输入你刚刚添加的地址，回车进入<br><img src="https://s1.ax1x.com/2020/10/20/BSEM1P.png" alt="IE04.png"></p>
</li>
<li><p>这时你登录后就会发现，困扰你多年的选课点了没反应的问题终于解决了<br><img src="https://s1.ax1x.com/2020/10/20/BSEQ6f.png" alt="IE05.png"></p>
</li>
</ol>
<h1 id="二、Microsoft-Edge"><a href="#二、Microsoft-Edge" class="headerlink" title="二、Microsoft Edge"></a>二、Microsoft Edge</h1><h2 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>作为微软的亲儿子，我相信大部分人的win10电脑上肯定有这个浏览器，不过这个浏览器貌似也挺不错的，日用足够了</li>
<li>但是，说实话，用这个浏览器实属多此一举，因为后边还是需要用到IE浏览器</li>
</ul>
<h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>在你的桌面或者开始菜单中找到Edge<br><img src="https://s1.ax1x.com/2020/10/20/BSEekd.png" alt="Edge01.png"></p>
</li>
<li><p>重点来了，点击右上三点里的 <code>使用IE打开</code>，然后你会发现，又回到了IE这个操蛋的玩意了<br><img src="https://s1.ax1x.com/2020/10/20/BSEnfI.png" alt="Edge02.png"></p>
</li>
<li><p>之后步骤请参照上边的2~5点。</p>
</li>
</ol>
<h1 id="三、QQ浏览器"><a href="#三、QQ浏览器" class="headerlink" title="三、QQ浏览器"></a>三、QQ浏览器</h1><h2 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>现在大部分软件都是腾讯一家独大，所以难免有用QQ浏览器的。</li>
</ul>
<h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>在地址栏先输入网址进入该网站</p>
</li>
<li><p>在地址栏的右侧你会发现一个闪电图标，点击它修改为<code>兼容模式</code><br><img src="https://s1.ax1x.com/2020/10/20/BSElX8.png" alt="QQ01.png"></p>
</li>
<li><p>然后重新登录即可</p>
</li>
</ol>
<h1 id="四、360浏览器"><a href="#四、360浏览器" class="headerlink" title="四、360浏览器"></a>四、360浏览器</h1><h2 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>现在难免有人喜欢360全家桶，360也很简单</li>
</ul>
<h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>在地址栏先输入网址进入该网站</p>
</li>
<li><p>在地址栏的第二个图标即闪电图标那点击一下，修改为<code>兼容模式</code><br><img src="https://s1.ax1x.com/2020/10/20/BSEVTH.png" alt="36001.png"></p>
</li>
<li><p>然后重新登录即可</p>
</li>
</ol>
<h1 id="五、谷歌浏览器"><a href="#五、谷歌浏览器" class="headerlink" title="五、谷歌浏览器"></a>五、谷歌浏览器</h1><ul>
<li>这里谷歌浏览器需要使用插件才可以，所以这里没有写出，如果有人有需要，可以百度，也可以评论区找我。</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器：谷歌浏览器截取长屏方法</title>
    <url>/42761.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>该文介绍了一种对谷歌网页进行全部截屏的方法</li>
<li>注意：该方法有些网站截取并不完整，望知悉<span id="more"></span></li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li><p>在需要截取内容的页面按下F12</p>
</li>
<li><p>按快捷键 <code>ctrl+shift+p</code> 进入搜索模式</p>
</li>
<li><p>搜索 <code>screenshot</code> 出现如下图<br><img src="https://s1.ax1x.com/2020/10/20/BSuwcR.png" alt="screenshot01.png"></p>
</li>
<li><p>四个选项分别代表——区域截屏、自动截取全部网页、截取当前节点、截取当前屏幕</p>
</li>
<li><p>选择以后就会选择保存文件位置，在相应位置即可找到截取的图片。效果如下图：<br><img src="https://s1.ax1x.com/2020/10/20/BSuDnx.png" alt="screenshot02.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>干货</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：存储</title>
    <url>/Learn-storage.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>该篇记录了关于存储方向的某些重要知识点</li>
<li>如有任何问题，欢迎指出<span id="more"></span></li>
</ul>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>华为官网注册账号</li>
<li>华为技术支持网下载安装HedEx</li>
<li>产品文档及软件获取——技术支持-产品支持-软件下载-企业存储</li>
</ul>
<h1 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h1><ol>
<li><p>入门级存储：2000+的产品</p>
</li>
<li><p>中端存储：5000/6000+的产品(重点——53、55、56)</p>
</li>
<li><p>高端存储：6000/18000+的产品</p>
</li>
<li><p>控制框：包含控制器，来提供存储的接入，进行存储设备的管理。高度为2U/3U/6U，U为标准单位，1U约等于4.445cm</p>
<blockquote>
<p>连接方法：服务器-交换机-控制框-硬盘框<br>所有数据的读和写都要经过控制框</p>
</blockquote>
</li>
<li><p>硬盘框：存放大量硬盘</p>
</li>
<li><p>存储网络：光交换、以太网交换、FCOE及换季、IB交换机</p>
</li>
<li><p>硬盘：机械、固态</p>
</li>
<li><p>I/O模块：</p>
</li>
</ol>
<h1 id="RAID——磁盘阵列基础"><a href="#RAID——磁盘阵列基础" class="headerlink" title="RAID——磁盘阵列基础"></a>RAID——磁盘阵列基础</h1><ol>
<li>传统RAID：以盘为单位</li>
<li>校验方法：异或校验——相同为假，相异为真</li>
<li>常见RAID级别<br>RAID 0：无校验、无镜像、利用率最高、性能最好、安全性最低<br>RAID 1：无校验、有镜像、利用率最低、性能最差、安全性最高<br>RAID 3：单独校验盘、一个校验坏一个盘、性能受影响<br>RAID 5：分布式校验盘、一个校验坏一个盘、性能受影响<br>RAID 6：DP——两个独立的校验盘；P+Q——两个校验盘。允许坏两个盘。<br>RAID 10：1和0的组合<br>RAID 50：5和0的组合</li>
<li>重构：坏盘后的数据的恢复过程，需要消耗大量的计算资源</li>
<li>预拷贝：拷贝即将故障的盘的数据到新的磁盘（热备盘）</li>
<li>热备盘：重构用或预拷贝用</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>华为ICT</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：大数据</title>
    <url>/Learn-Bigdate.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>该篇记录了关于大数据方向的某些重要知识点</li>
<li>如有任何问题，欢迎指出<span id="more"></span></li>
</ul>
<h1 id="一、基本概念和定义"><a href="#一、基本概念和定义" class="headerlink" title="一、基本概念和定义"></a>一、基本概念和定义</h1><h2 id="1-大数据"><a href="#1-大数据" class="headerlink" title="1.大数据"></a>1.大数据</h2><ul>
<li>可以理解为多个数据集</li>
</ul>
<h2 id="2-大数据的工作内容："><a href="#2-大数据的工作内容：" class="headerlink" title="2.大数据的工作内容："></a>2.大数据的工作内容：</h2><ul>
<li>数据获取——传统互联网厂商通过底层用户反馈得到数据；传统行业可以通过传感器来进行获取数据；个人使用python爬虫获取数据。</li>
<li>数据存储——将获取到的数据存储在本地。存储设备、HDFS、Hbase、Hive。</li>
<li>数据分析——对数据进行表象性的进行分析操作</li>
<li>数据挖掘——对数据进行深入的挖掘操作，找到数据与数据、类别与类别、属性与属性之间的深层次的关联。</li>
</ul>
<h2 id="3-数据发展阶段："><a href="#3-数据发展阶段：" class="headerlink" title="3.数据发展阶段："></a>3.数据发展阶段：</h2><ul>
<li>数据早期形态——上游向低位向下流</li>
<li>数据发展时期——即时通信出现，冲击短信行业</li>
<li>数据推送阶段——底层一对多辐射</li>
<li>数据反向流通阶段———上游收到下游的信息</li>
</ul>
<h2 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4.基本概念"></a>4.基本概念</h2><ul>
<li>结构化数据——数据能够以二维表格表示的数据（文本。数据库）</li>
<li>非结构化数据——数据无法以二维表格表示的数据（图片、视频）</li>
<li>半结构化数据——具有一定结构化数据，但又不能全部表示的数据（xml网页）</li>
<li>集群——（厨师与厨师枝江的关系）</li>
<li>分布式——（厨师与小工的关系）</li>
</ul>
<h1 id="二、大数据存储技术"><a href="#二、大数据存储技术" class="headerlink" title="二、大数据存储技术"></a>二、大数据存储技术</h1><h2 id="1-集群NAS"><a href="#1-集群NAS" class="headerlink" title="1.集群NAS"></a>1.集群NAS</h2><ul>
<li>发展——DAS（维护操作、文件、存储系统）-SAN（维护操作和文件系统）-NAS（只维护操作系统）</li>
<li>优势——采用双工模式</li>
<li>NAS的组件——存储、引擎、网络协议</li>
</ul>
<h2 id="2-HDFS分布式文件系统"><a href="#2-HDFS分布式文件系统" class="headerlink" title="2.HDFS分布式文件系统"></a>2.HDFS分布式文件系统</h2><ul>
<li>特性——高容错性（认为硬件是不可靠的）、高吞吐量、大文件存储（HDFS的元数据是固定大小150bit）、支持流式数据访问</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>华为ICT</tag>
      </tags>
  </entry>
  <entry>
    <title>玩机：油猴插件实现超星自动刷课</title>
    <url>/12726.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>手机端教程来自酷安 @祥林嫂 ，如需转载请注明出处</li>
<li>PC端教程是个人根据手机端教程模仿出来的（<font color=#FF0000>新增</font>）</li>
<li>该教程所述方法有可能会造成不良记录，介意请勿尝试</li>
<li>该刷课助手中有些章节的问题还会出错，一般也就一道题，无伤大雅，介意勿用（<font color=#FF0000>新增</font>）<span id="more"></span></li>
</ul>
<h1 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h1><ul>
<li>2019.11.11日，本人在刷网课时发现，自动提交有时会出现问题——即超星现在上线了验证码功能，可能提交过快就会让你输入验证码进行验证，目前该问题并不影响该插件的使用，请放心食用</li>
<li>2019.11.14日，进行内容修改完善，增加了PC端谷歌浏览器的方法</li>
</ul>
<h1 id="手机端方法步骤"><a href="#手机端方法步骤" class="headerlink" title="手机端方法步骤"></a>手机端方法步骤</h1><h2 id="一-下载浏览器"><a href="#一-下载浏览器" class="headerlink" title="一.下载浏览器"></a>一.下载浏览器</h2><ul>
<li>可以用火狐浏览器，也可以使用谷歌浏览器（这里以火狐浏览器为例）</li>
<li>你可从各大应用商店或网页端下载</li>
</ul>
<h2 id="二-加入油猴脚本"><a href="#二-加入油猴脚本" class="headerlink" title="二.加入油猴脚本"></a>二.加入油猴脚本</h2><ol>
<li><p>用火狐浏览器打开网址 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/tampermonkey/">点击这里</a>（谷歌浏览器请自行百度下载脚本，毕竟属于墙外的世界）</p>
<blockquote>
<p>无法转到的请复制这里的网址：<a href="https://addons.mozilla.org/zh-CN/firefox/addon/tampermonkey/">https://addons.mozilla.org/zh-CN/firefox/addon/tampermonkey/</a></p>
</blockquote>
</li>
<li><p>点击 添加到Firefox</p>
</li>
<li><p>如果添加以后一直在某个页面刷新，可去 <font color=$FF0000>右上角三点-附加组件</font> 中看是否有Tampermonkey组件，如果有直接无视前面的页面即可</p>
</li>
</ol>
<h2 id="三-加入油猴刷课脚本"><a href="#三-加入油猴刷课脚本" class="headerlink" title="三.加入油猴刷课脚本"></a>三.加入油猴刷课脚本</h2><ol>
<li><p>用火狐浏览器打开网址 <a href="https://greasyfork.org/zh-CN/scripts/369625-%E8%B6%85%E6%98%9F%E7%BD%91%E8%AF%BE%E5%8A%A9%E6%89%8B">点击这里</a></p>
<blockquote>
<p>无法转到的请复制这里的网址：<a href="https://greasyfork.org/zh-CN/scripts/369625-%E8%B6%85%E6%98%9F%E7%BD%91%E8%AF%BE%E5%8A%A9%E6%89%8B">https://greasyfork.org/zh-CN/scripts/369625-%E8%B6%85%E6%98%9F%E7%BD%91%E8%AF%BE%E5%8A%A9%E6%89%8B</a></p>
</blockquote>
</li>
<li><p>点击 安装此脚本-安装</p>
</li>
<li><p>此时在 <font color=#FF0000>附加组件-tampermonkey-选项-已安装脚本</font> 就可以看到 <font color=#FF0000>超星网课助手</font> 了</p>
</li>
</ol>
<h2 id="四-进入超星学习通页面刷课"><a href="#四-进入超星学习通页面刷课" class="headerlink" title="四.进入超星学习通页面刷课"></a>四.进入超星学习通页面刷课</h2><ol>
<li>自行网页搜索超星网页并登陆</li>
<li>找到你要刷的网课点进去，这时会提醒你下载App，点击 <font color=#FF0000>右上角三点-要求桌面版网站</font> ，这时就进入了网页端的课程内容处</li>
<li>点击你要刷的章节，这时会自动播放视频并自动答题，如果想要取消声音可以直接点击播放窗口的音量图标进行静音<blockquote>
<p>如果是电脑端，这里直接进入超星界面打开课程就可以刷课了！</p>
</blockquote>
</li>
</ol>
<h2 id="五-放入手机后台，解放双手（因为验证码原因，这步失效）"><a href="#五-放入手机后台，解放双手（因为验证码原因，这步失效）" class="headerlink" title="五.放入手机后台，解放双手（因为验证码原因，这步失效）"></a><del>五.放入手机后台，解放双手</del>（因为验证码原因，这步失效）</h2><ol>
<li><del>将火狐浏览器在后台上锁定住</del></li>
<li><del>在电池优化中允许火狐浏览器后台运行</del></li>
</ol>
<hr>
<h1 id="电脑端（谷歌浏览器）方法步骤"><a href="#电脑端（谷歌浏览器）方法步骤" class="headerlink" title="电脑端（谷歌浏览器）方法步骤"></a>电脑端（谷歌浏览器）方法步骤</h1><h2 id="一、加入油猴脚本"><a href="#一、加入油猴脚本" class="headerlink" title="一、加入油猴脚本"></a>一、加入油猴脚本</h2><ol>
<li>用谷歌浏览器打开网址 <a href="https://www.tampermonkey.net/">点击这里</a></li>
<li>点击黑色图标下方的下载，等待其安装（如果下载不下，或上方的链接打不开可能需要翻墙，自行解决）</li>
</ol>
<h2 id="二、加入油猴刷课脚本"><a href="#二、加入油猴刷课脚本" class="headerlink" title="二、加入油猴刷课脚本"></a>二、加入油猴刷课脚本</h2><ol>
<li>用火狐浏览器打开网址 <a href="https://greasyfork.org/zh-CN/scripts/369625-%E8%B6%85%E6%98%9F%E7%BD%91%E8%AF%BE%E5%8A%A9%E6%89%8B">点击这里</a></li>
<li>点击 安装此脚本-安装</li>
<li>此时在 <font color=#FF0000>附加组件-tampermonkey-选项-已安装脚本</font> 就可以看到 <font color=#FF0000>超星网课助手</font> 了</li>
</ol>
<h2 id="三、进入超星学习通页面刷课"><a href="#三、进入超星学习通页面刷课" class="headerlink" title="三、进入超星学习通页面刷课"></a>三、进入超星学习通页面刷课</h2><ol>
<li>打开视频就会自动观看且自动答题</li>
<li>注意：因为有验证码了，所以一定要时刻注意看看是否需要你输入验证码</li>
</ol>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>玩机技巧</tag>
        <tag>网课</tag>
        <tag>油猴插件</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记：Linux（尚硅谷）</title>
    <url>/Learn-Linux.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本文主要记录在学习尚硅谷的 Linux 课程时的一些笔记</li>
<li>尚硅谷前端学科全套课程请点击<a href="https://pan.baidu.com/s/1BM_OKMXXAGxMNqaBN_7tRg">这里</a>进行下载，提取码：afyt<span id="more"></span></li>
</ul>
<h1 id="一、基础部分"><a href="#一、基础部分" class="headerlink" title="一、基础部分"></a>一、基础部分</h1><h2 id="1-学习内容"><a href="#1-学习内容" class="headerlink" title="1.学习内容"></a>1.学习内容</h2><ul>
<li><p>基础 &amp; 实操篇<br><img src="https://s1.ax1x.com/2020/10/20/0zHuDO.png" alt="linux01.png"></p>
</li>
<li><p>定制篇<br><img src="https://s1.ax1x.com/2020/10/20/0zHQVe.png" alt="linux02.png"></p>
</li>
</ul>
<h2 id="2-学习方向"><a href="#2-学习方向" class="headerlink" title="2.学习方向"></a>2.学习方向</h2><ul>
<li>Linux 运维工程师：服务器的规划、调试优化、日常监控、故障处理、数据备份、日志分析</li>
<li>Linux 嵌入式工程师：掌握Linux下各种驱动程序开发、在嵌入式系统中进行程序开发</li>
<li>Linux 下开发项目：JavaEE、大数据、Python、PHP、C、C++</li>
</ul>
<h2 id="3-进阶之路"><a href="#3-进阶之路" class="headerlink" title="3.进阶之路"></a>3.进阶之路</h2><ul>
<li>主要有6个阶段：<br><img src="https://s1.ax1x.com/2020/10/20/0zHKbD.png" alt="linux03.png"></li>
</ul>
<h2 id="4-VM虚拟机相关知识"><a href="#4-VM虚拟机相关知识" class="headerlink" title="4.VM虚拟机相关知识"></a>4.VM虚拟机相关知识</h2><ul>
<li>桥接模式：Linux系统可以与其他系统通信，但会占用真实网络中的ip地址，而一个网段的ip地址是有限的，所以一般不使用该模式</li>
<li>NAT 模式：该模式会在真实主机上新建一个ip地址，然后在这个ip地址下划分子网给虚拟机中的Linux，这样子外部主机无法访问到Linux，但Linux可以使用主机真实ip代理访问其他主机</li>
<li>装Linux系统时，自定义分区为：<br>标准分区/boot ：200M左右<br>交换分区swap ：该分区没有挂载点，一般为物理内存的1.5-2倍之间<br>根分区/ ：剩余所有空间</li>
<li>共享文件夹会默认放在 centos 下的 <code>/mnt/hgfs</code> </li>
</ul>
<h2 id="5-目录结构"><a href="#5-目录结构" class="headerlink" title="5.目录结构"></a>5.目录结构</h2><ul>
<li>在linux中，一切都是文件</li>
<li>/ ：根目录<br>/bin ：存放命令<br>/boot ：存放启动linux时的核心文件<br>/dev ：管理设备<br>/etc ：存放配置文件<br>/home ：普通用户对应的文件<br>/lib ：存放库文件<br>/lost+found ：系统非法关机后存放文件<br>/media ：外接设备<br>/mnt ：为了让用户临时挂载别的文件系统<br>/opt ：放置需要安装的软件<br>/proc ：有关内核的文件<br>/sbin ：存放系统管理员使用的系统管理程序<br>/selinux ：安全目录，类似于windows下的360<br>/srv ：存放服务启动后需要提取的数据<br>/sys ：linux2.6内核以后会生成该文件夹<br>/tmp ：存放临时文件<br>/usr ：用户安装的文件和应用程序<br>/var ：存放日志</li>
</ul>
<h2 id="6-远程登录"><a href="#6-远程登录" class="headerlink" title="6.远程登录"></a>6.远程登录</h2><ul>
<li>使用 Xshell 和 Xftp 远程登录 Linux 系统</li>
<li>实现远程登录时，需要 Linux 系统开启一个 sshd 的服务，该服务会监听22号端口。该服务一般是默认打开的，检查是否打开需要在终端输入 <code>setup</code> -&gt; 系统服务 -&gt; sshd -&gt; *号代表已经打开 </li>
<li><font color=#F00>注意：端口开的越多，安全性就越弱</font></li>
</ul>
<h2 id="7-用户管理"><a href="#7-用户管理" class="headerlink" title="7.用户管理"></a>7.用户管理</h2><ul>
<li>Linux的用户至少要属于一个组</li>
</ul>
<h3 id="1-添加用户"><a href="#1-添加用户" class="headerlink" title="(1).添加用户"></a>(1).添加用户</h3><ul>
<li><code>useradd [选项] 用户名</code> ：会自动创建和用户同名的家目录</li>
<li><code>useradd -d 指定目录 用户名</code> ：创建用户并指定家目录</li>
<li><code>useradd -g 用户组 用户名</code> ：创建用户并指定用户组（该组存在才可以指定）</li>
</ul>
<h3 id="2-添加密码"><a href="#2-添加密码" class="headerlink" title="(2).添加密码"></a>(2).添加密码</h3><ul>
<li><code>passwd  用户名</code> ：为该用户添加密码</li>
</ul>
<h3 id="3-删除用户"><a href="#3-删除用户" class="headerlink" title="(3).删除用户"></a>(3).删除用户</h3><ul>
<li><code>userdel 用户名</code> ：删除用户但保留家目录</li>
<li><code>userdel -r 用户名</code> ：删除用户及家目录</li>
</ul>
<h3 id="4-查询用户"><a href="#4-查询用户" class="headerlink" title="(4).查询用户"></a>(4).查询用户</h3><ul>
<li><code>id</code></li>
</ul>
<h3 id="5-切换用户"><a href="#5-切换用户" class="headerlink" title="(5).切换用户"></a>(5).切换用户</h3><ul>
<li><code>su - 用户名</code> </li>
<li>高权限用户切换到低权限用户时，不需要密码，但权限会降低，使用 <code>exit</code> 可以退出当前用户退回到原来用户</li>
</ul>
<h3 id="6-相关文件"><a href="#6-相关文件" class="headerlink" title="(6).相关文件"></a>(6).相关文件</h3><ul>
<li><code>/etc/passwd</code> ：用户信息文件（用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell）</li>
<li><code>/etc/shadow</code> ：用户密码文件（登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志）</li>
<li><code>/etc/group</code> ：用户组配置文件（组名：口令：组标识号：组内用户列表）</li>
</ul>
<h2 id="8-用户组"><a href="#8-用户组" class="headerlink" title="8.用户组"></a>8.用户组</h2><h3 id="1-增加组"><a href="#1-增加组" class="headerlink" title="(1).增加组"></a>(1).增加组</h3><ul>
<li><code>groupadd 组名</code> </li>
</ul>
<h3 id="2-删除组"><a href="#2-删除组" class="headerlink" title="(2).删除组"></a>(2).删除组</h3><ul>
<li><code>groudel 组名</code> </li>
</ul>
<h3 id="3-修改组"><a href="#3-修改组" class="headerlink" title="(3).修改组"></a>(3).修改组</h3><ul>
<li><code>usermod -g 用户组 用户名</code> </li>
</ul>
<h1 id="二、指令部分"><a href="#二、指令部分" class="headerlink" title="二、指令部分"></a>二、指令部分</h1><h2 id="1-帮助类"><a href="#1-帮助类" class="headerlink" title="1.帮助类"></a>1.帮助类</h2><h3 id="1-man"><a href="#1-man" class="headerlink" title="(1).man"></a>(1).man</h3><ul>
<li>作用：manual（手册），包含了linux中全部命令手册</li>
<li><code>man 命令</code> ：退出按q即可</li>
</ul>
<h3 id="2-help"><a href="#2-help" class="headerlink" title="(2).help"></a>(2).help</h3><ul>
<li>语法：<code>help 指令</code> </li>
</ul>
<h2 id="2-压缩类"><a href="#2-压缩类" class="headerlink" title="2.压缩类"></a>2.压缩类</h2><h3 id="1-gzip-gunzip"><a href="#1-gzip-gunzip" class="headerlink" title="(1).gzip/gunzip"></a>(1).gzip/gunzip</h3><ul>
<li>作用：前者为压缩文件，后者为解压缩文件</li>
<li><code>gzip 文件名</code> ：会直接删除源文件</li>
</ul>
<h3 id="2-zip-unzip"><a href="#2-zip-unzip" class="headerlink" title="(2).zip/unzip"></a>(2).zip/unzip</h3><ul>
<li>作用：前者为压缩文件，后者为解压缩文件</li>
<li><code>zip 选项 文件名 存放路径</code> ：选项如下：<br>-r：递归压缩</li>
<li><code>unzip 选项 存放目录 压缩文件名</code> ：选项如下：<br>-d：指定解压后文件的存放目录</li>
</ul>
<h3 id="3-tar"><a href="#3-tar" class="headerlink" title="(3).tar"></a>(3).tar</h3><ul>
<li>作用：打包指令，文件后缀为 <code>tar.gz</code> </li>
<li><code>tar 选项 打包后的文件名 打包的内容</code> ，选项如下：<br>-c：产生.tar打包文件<br>-v：显示详细信息<br>-f：指定压缩后的文件名<br>-z：打包同时压缩<br>-x：解包.tar文件</li>
<li>zcvf为压缩，zxvf为解压</li>
<li>注意：指定解压到某个目录，需要在目录前面使用 -C 才可以成功</li>
</ul>
<h2 id="3-用户类"><a href="#3-用户类" class="headerlink" title="3.用户类"></a>3.用户类</h2><h3 id="1-id"><a href="#1-id" class="headerlink" title="(1).id"></a>(1).id</h3><ul>
<li>作用：查看一个用户的基本信息（用户，用户组，附加组id）</li>
<li><code>id</code> ：默认显示当前执行命令的用户的基本信息</li>
<li><code>id 用户名</code> ：显示指定用户的基本信息</li>
</ul>
<h4 id="！如何验证信息是否正确"><a href="#！如何验证信息是否正确" class="headerlink" title="！如何验证信息是否正确"></a>！如何验证信息是否正确</h4><ul>
<li>验证用户信息通过文件 <code>/etc/passwd</code></li>
<li>验证用户组信息通过文件 <code>/etc/group</code></li>
</ul>
<h3 id="2-whoami"><a href="#2-whoami" class="headerlink" title="(2).whoami"></a>(2).whoami</h3><ul>
<li>作用：显示当前登陆的用户名，一般用于 shell 脚本，来获取当前登陆的用户名方便记录日志</li>
<li><code>whoami</code> </li>
</ul>
<h2 id="4-系统类"><a href="#4-系统类" class="headerlink" title="4.系统类"></a>4.系统类</h2><h3 id="1-logout"><a href="#1-logout" class="headerlink" title="(1).logout"></a>(1).logout</h3><ul>
<li>作用：注销当前用户，减少服务器开销</li>
<li><code>logout</code> </li>
<li><font color=#F00>注意：该命令在图形化界面无效，只在命令行模式下有效</font></li>
</ul>
<h3 id="2-reboot"><a href="#2-reboot" class="headerlink" title="(2).reboot"></a>(2).reboot</h3><ul>
<li>作用：重新启动计算机</li>
<li><code>reboot</code> </li>
<li><code>reboot -w</code> ：模拟重启但是不重启（只写关机与开机的日志信息）</li>
<li><code>shutdown -r now</code> ：立即重启</li>
</ul>
<h3 id="3-shutdown"><a href="#3-shutdown" class="headerlink" title="(3).shutdown"></a>(3).shutdown</h3><ul>
<li>作用：关机（慎用）</li>
<li><code>shutdown -h now</code> ：立即关机</li>
<li><code>shutdown -h now &quot;提示文字&quot;</code> ：立即关机并带有提示性文字</li>
<li><code>shutdown -h 1</code> ：1分钟后关机</li>
<li><code>shutdown -h 12:00</code> ：12:00关机</li>
<li><code>shutdown -h 12:00 &quot;提示文字&quot;</code> ：12:00关机并带有提示性文字</li>
<li><font color=#F00>注意：在centos 7之前，取消关机计划需要使用 <code>ctrl+c</code> 命令；在centos7 及之后可以使用 <code>shutdown -c</code> 命令</font></li>
</ul>
<h3 id="4-关机"><a href="#4-关机" class="headerlink" title="(4).关机"></a>(4).关机</h3><ul>
<li><code>shutdown -h now</code> ：正常关机</li>
<li><code>halt</code> ：关闭内存</li>
<li><code>poweroff</code> ：关闭电源</li>
<li><code>init 0</code> ：以后版本不一定能用</li>
</ul>
<h3 id="5-root"><a href="#5-root" class="headerlink" title="(5).root"></a>(5).root</h3><ul>
<li><code> sudo passwd root</code> ：设置密码</li>
<li><code>su</code> ：切换root用户</li>
</ul>
<h3 id="6-clear"><a href="#6-clear" class="headerlink" title="(6).clear"></a>(6).clear</h3><ul>
<li>作用：用来清除终端中已经存在的命令和结果，快捷键为ctrl+L</li>
<li><code>clear</code></li>
</ul>
<h3 id="7-hostname"><a href="#7-hostname" class="headerlink" title="(7).hostname"></a>(7).hostname</h3><ul>
<li>作用：操作服务器的主机名（读取，设置），这里设置的主机名是临时的，所以一般不使用该命令来设置主机名，只用作读取</li>
<li><code>hostname</code> ：输出完整的主机名</li>
<li><code>hostname -f</code> ：输出当前主机名的FQDN（全限定域名）</li>
</ul>
<h3 id="8-uptime"><a href="#8-uptime" class="headerlink" title="(8).uptime"></a>(8).uptime</h3><ul>
<li>作用：输出计算机的持续在线时间</li>
<li><code>uptime</code> </li>
</ul>
<h3 id="9-uname"><a href="#9-uname" class="headerlink" title="(9).uname"></a>(9).uname</h3><ul>
<li>作用：获取操作系统的相关信息</li>
<li><code>uname</code> ：获取操作系统的类型</li>
<li><code>uname -a</code> ：获取全部的系统信息（类型、全部的主机名、内核版本、发布时间、开源计划）</li>
</ul>
<h3 id="10-sync"><a href="#10-sync" class="headerlink" title="(10).sync"></a>(10).sync</h3><ul>
<li>作用：把内存的数据同步到磁盘</li>
<li><code>sync</code> </li>
<li><font color=#F00>注意：当我们关机或者重启时，都应该执行以下这个命令，防止数据丢失</font></li>
</ul>
<h3 id="11-free"><a href="#11-free" class="headerlink" title="(11).free"></a>(11).free</h3><ul>
<li>作用：查看内存使用情况，主要看第二行内容，swap 用于临时内存</li>
<li><code>free</code> ：以默认单位进行查看</li>
<li><code>free -m</code> ：以 mb 为单位进行查看</li>
</ul>
<h2 id="5-运行级别类"><a href="#5-运行级别类" class="headerlink" title="5.运行级别类"></a>5.运行级别类</h2><ul>
<li>开机的流程：开机 - BIOS - /boot - init进程1 - 运行级别 - 运行级对应的服务</li>
<li>系统的运行级别配置文件在 <code>/etc/inittab</code> 目录下</li>
<li>运行级别有如下：<br>0：关机<br>1：单用户<br>2：多用户状态没有网络服务<br>3：多用户状态有网络服务<br>4：系统未使用保留给用户<br>5：图形界面<br>6：系统重启</li>
<li>常用运行级别是3和5</li>
<li>切换到指定运行级别的指令：<code>init [012356]</code> </li>
<li>查看或修改默认级别：<code>vi /etc/init.d</code> </li>
</ul>
<h3 id="！引申：面试题之怎样找回root密码"><a href="#！引申：面试题之怎样找回root密码" class="headerlink" title="！引申：面试题之怎样找回root密码"></a><font color=#F00>！引申：面试题之怎样找回root密码</font></h3><ul>
<li>在开机进入引导时，按下回车键，进入一个代码界面，按e键进入后选择第二行（编辑内核）然后再按e键</li>
<li>输入1按回车键再输入b进入单用户模式</li>
<li>使用 <code>passwd</code> 指令进行修改密码</li>
</ul>
<h2 id="6-文件目录类"><a href="#6-文件目录类" class="headerlink" title="6.文件目录类"></a>6.文件目录类</h2><h3 id="0-vi-amp-vim"><a href="#0-vi-amp-vim" class="headerlink" title="(0).vi &amp; vim"></a>(0).vi &amp; vim</h3><ul>
<li>作用：文本编辑器</li>
<li>三种常见模式：<br>正常模式：使用命令进入后的界面<br>插入模式（编辑模式）：可以输入内容<br>命令行模式：可以输入相关的命令</li>
<li><code>vim 文件的路径</code> ：进入编辑器</li>
</ul>
<h4 id="！常用命令："><a href="#！常用命令：" class="headerlink" title="！常用命令："></a>！常用命令：</h4><ul>
<li><code>i、I、o、O、a、A、r、R</code> ：进入编辑模式</li>
<li><code>Esc</code> ：退出编辑模式或命令模式</li>
<li><code>:或/</code> ：进入命令行模式</li>
<li><code>q</code> ：没有修改时直接退出</li>
<li><code>wq</code> ：保存并退出</li>
<li><code>!q</code> ：强制退出</li>
</ul>
<h4 id="！快捷键"><a href="#！快捷键" class="headerlink" title="！快捷键"></a>！快捷键</h4><ul>
<li><code>p</code> ：粘贴</li>
<li><code>u</code> ：撤销</li>
<li><code>yy</code> ：拷贝当前行     <code>5yy</code> ：拷贝当前行向下的5行</li>
<li><code>dd</code> ：删除当前行     <code>5dd</code> ：删除当前行向下的5行</li>
<li><code>G</code> ：跳转到文档的最</li>
<li>末行     <code>gg</code> ：跳转到文档的首行</li>
<li><code>/关键字</code> ：命令行下输入按回车可以查找，输入n就是查找下一个</li>
<li><code>:set nu</code> ：命令行下输入可以设置文件的行号     <code>set nonu</code> ：取消文件的行号</li>
<li>跳转到某一行：先设置行号，然后在正常模式下输入需要跳转的行号，然后按 <code>shift+g</code></li>
<li><strong>其余快捷键可以查看<a href="https://www.runoob.com/linux/linux-vim.html">菜鸟教程</a>中的内容</strong></li>
</ul>
<h4 id="！注释"><a href="#！注释" class="headerlink" title="！注释"></a>！注释</h4><ul>
<li><p>单行注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#这个是单行注释</span><br></pre></td></tr></table></figure></li>
<li><p>多行注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">A=100</span><br><span class="line">echo $A</span><br><span class="line">!</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-ls"><a href="#1-ls" class="headerlink" title="(1).ls"></a>(1).ls</h3><ul>
<li>作用：列出所有文件和文件夹</li>
<li><code>ls</code></li>
<li><code>ls 路径</code></li>
<li><code>ls 选项 路径</code><br>ls -l 路径：以详细列表显示所有文件<br>ls -la 路径：以详细列表显示所有文件和隐藏文件<br>ls -lh 路径：以合适的大小显示所有文件</li>
</ul>
<h3 id="2-pwd"><a href="#2-pwd" class="headerlink" title="(2).pwd"></a>(2).pwd</h3><ul>
<li>作用：打印当前工作目录</li>
<li><code>pwd</code></li>
</ul>
<h3 id="3-cd"><a href="#3-cd" class="headerlink" title="(3).cd"></a>(3).cd</h3><ul>
<li>作用：改变或切换当前工作目录</li>
<li><code>cd 路径</code></li>
<li><code>cd ~</code> ：切换到当前用户的家目录</li>
<li><code>cd ..</code> ：切换到当前用户的上一级目录</li>
</ul>
<h3 id="4-mkdir"><a href="#4-mkdir" class="headerlink" title="(4).mkdir"></a>(4).mkdir</h3><ul>
<li>作用：创建目录</li>
<li><code>mkdir [选项] 路径</code></li>
<li><code>mkdir -p 路径</code> ：进行多层目录的创建</li>
<li><code>mkdir 路径1 路径2 路径3</code> ：同时创建多个目录</li>
</ul>
<h3 id="5-touch"><a href="#5-touch" class="headerlink" title="(5).touch"></a>(5).touch</h3><ul>
<li>作用：创建文件</li>
<li><code>touch 路径</code> ：同上</li>
<li><code>touch 路径1 路径2 路径3</code> ：同上</li>
</ul>
<h3 id="6-cp"><a href="#6-cp" class="headerlink" title="(6).cp"></a>(6).cp</h3><ul>
<li>作用：复制文件或文件夹</li>
<li><code>cp 复制前的路径 复制后的路径</code> ：复制文件</li>
<li><code>cp 复制前的路径 复制后的路径 -r</code> ：复制文件夹包含文件，-r表示递归</li>
<li><code>\cp -r 路径 路径</code> ：当目标目录下有相同文件，可以强制覆盖</li>
</ul>
<h3 id="7-mv"><a href="#7-mv" class="headerlink" title="(7).mv"></a>(7).mv</h3><ul>
<li>作用：移动、剪切文档到新的位置</li>
<li><code>mv 旧路径/文件名 新路径/原文件名</code> ：移动但不重命名</li>
<li><code>mv 旧路径/文件名 新路径/新文件名</code> ：移动并重命名</li>
<li><code>mv 旧路径/文件夹 新路径/原文件夹</code> ：移动但不重命名，移动文件夹无需写-r</li>
<li><code>mv 旧路径/文件夹 新路径/新文件夹</code> ：移动并重命名，移动文件夹无需写-r</li>
</ul>
<h3 id="8-rm"><a href="#8-rm" class="headerlink" title="(8).rm"></a>(8).rm</h3><ul>
<li>作用：删除文档</li>
<li><code>rm 选项 需要移除的路径</code><br><code>rm -f 路径</code> ：强制删除，不提示<br><code>rm -rf 路径</code> ：强制递归删除非空目录，不提示<br><code>rm -f linux*</code> ：删除以linux开头的文件，星号为通配符</li>
<li><code>rm 路径1 路径2 路径3</code></li>
</ul>
<h3 id="9-cat"><a href="#9-cat" class="headerlink" title="(9).cat"></a>(9).cat</h3><ul>
<li>作用：打开文件（只能浏览）或者合并文件</li>
<li><code>cat 文件的路径</code> ：直接打开一个文件，为了浏览方便，一般会在后面使用管道连接 —— <code>| more</code> </li>
<li><code>cat 待合并的文件路径1 待合并的路径2 &gt; 合并之后的文件路径</code> ：合并文件</li>
</ul>
<h3 id="10-more"><a href="#10-more" class="headerlink" title="(10).more"></a>(10).more</h3><ul>
<li>作用：以全屏的方式按页显示文本文件的内容</li>
<li><code>more 要查看的文件</code> </li>
<li>enter：一行一行的翻<br>空格：一页一页的翻<br>Ctrl+b：上一页<br>Ctrl+f：下一页<br>q：退出</li>
</ul>
<h3 id="11-less"><a href="#11-less" class="headerlink" title="(11).less"></a>(11).less</h3><ul>
<li>作用：分屏查看文件内容，以较少的内容输出</li>
<li><code>less 要查看的文件</code></li>
<li>enter：一行一行的翻<br>空格：一页一页的翻<br>Ctrl+b：上一页<br>Ctrl+f：下一页<br>q：退出</li>
</ul>
<h3 id="12-gt-amp-gt-gt"><a href="#12-gt-amp-gt-gt" class="headerlink" title="(12).&gt; &amp; &gt;&gt;"></a>(12).&gt; &amp; &gt;&gt;</h3><ul>
<li>作用：可以重定向文件或者新建文件</li>
<li><code>&gt;</code> ：输出重定向，覆盖输出，会覆盖原先文件内容</li>
<li><code>&gt;&gt;</code> ：追加，追加输出，不会覆盖，会在文件末尾继续添加</li>
<li>基本语法：<br><code>ls -l &gt; a.txt</code>：将前面的输出内容覆盖写入到a.txt文件<br><code>cat /etc/profile &gt;&gt; a.txt</code>：将固定文件内容追加输出到a.txt<br><code>echo &quot;Hello,world!&quot; &gt; a.txt</code>：将固定语句覆盖写入到a.txt</li>
</ul>
<h3 id="13-echo"><a href="#13-echo" class="headerlink" title="(13).echo"></a>(13).echo</h3><ul>
<li>作用：输出内容到控制台</li>
<li><code>echo $PATH</code> ：输出环境变量到控制台</li>
<li><code>echo &quot;Hello&quot;</code> </li>
</ul>
<h3 id="14-head"><a href="#14-head" class="headerlink" title="(14).head"></a>(14).head</h3><ul>
<li>作用：查看一个文件的前n行</li>
<li><code>head 需要查看文件的路径</code> ：默认显示前10行</li>
<li><code>head -n 需要查看文件的路径</code> ：查看一个文件的前n行</li>
</ul>
<h3 id="15-tail"><a href="#15-tail" class="headerlink" title="(15).tail"></a>(15).tail</h3><ul>
<li>作用：查看文件末n行或者动态变化</li>
<li><code>tail 需要查看文件的路径</code> ：默认显示末10行</li>
<li><code>tail -n 需要查看文件的路径</code> ：查看一个文件的末n行</li>
<li><code>tail -f 文件的路径</code> ：查看文件动态变化，<font color=#F00>常用！</font></li>
</ul>
<h3 id="16-ln"><a href="#16-ln" class="headerlink" title="(16).ln"></a>(16).ln</h3><ul>
<li>作用：软链接指令，主要存放了链接其他文件的路径</li>
<li><code>ln -s 原文件或目录 软链接名字</code> </li>
<li><code>rm -rf 软链接名字</code>：删除软链接，后面加斜杠会删除原文件内容！</li>
</ul>
<h3 id="17-history"><a href="#17-history" class="headerlink" title="(17).history"></a>(17).history</h3><ul>
<li>作用：查看已经执行过的历史命令，也可以执行历史命令</li>
<li><code>history</code> </li>
<li><code>!数字</code> ：直接执行历史编号的命令</li>
</ul>
<h3 id="18-wc"><a href="#18-wc" class="headerlink" title="(18).wc"></a>(18).wc</h3><ul>
<li>作用：统计文件内容信息（行数、单词数、字节数）</li>
<li><code>wc -lwc 需要统计的文件路径</code></li>
</ul>
<h3 id="19-du"><a href="#19-du" class="headerlink" title="(19).du"></a>(19).du</h3><ul>
<li>作用：查看目录的真实大小</li>
<li><code>du -sh 路径</code> ：-s表示只显示汇总的大小，-h表示以较高可读性的形式进行显示</li>
</ul>
<h2 id="7-时间日期类"><a href="#7-时间日期类" class="headerlink" title="7.时间日期类"></a>7.时间日期类</h2><h3 id="1-date"><a href="#1-date" class="headerlink" title="(1).date"></a>(1).date</h3><ul>
<li>作用：进行时间日期等相应的读取和设置</li>
<li><code>date</code> ：显示当前时间</li>
<li><code>date +%F</code> 与 <code>date &quot;+%Y-%m-%d&quot;</code>：显示年月日，如：2019-01-02</li>
<li><code>date &quot;+%F %T&quot;</code> 与 <code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>  ：显示年月日时分秒，如：2018-12-28 23:40:16（引号表示让年月日与时分秒成为不可分割的整体）</li>
<li><code>data -d &quot;-1 day&quot; &quot;+%Y-%m-%d %H:%M:%S&quot;</code> ：获取之前或者之后（+1）的某个时间（年月日）</li>
<li><code>date -s 字符串时间</code> ：设置系统当前时间，<font color=#F00><strong>！重点！</strong></font></li>
</ul>
<h3 id="2-cal"><a href="#2-cal" class="headerlink" title="(2).cal"></a>(2).cal</h3><ul>
<li>作用：进行日历相应的操作</li>
<li><code>cal -1</code> ：直接输出当前月份的日历</li>
<li><code>cal -3</code> ：输出上一个月，当月和下一个月的日历</li>
<li><code>cal -y 2018</code> ：输出一年的日历</li>
</ul>
<h2 id="8-搜索查找类"><a href="#8-搜索查找类" class="headerlink" title="8.搜索查找类"></a>8.搜索查找类</h2><h3 id="1-find"><a href="#1-find" class="headerlink" title="(1).find"></a>(1).find</h3><ul>
<li>作用：用于查找文件，从指定目录向下递归地遍历查找（参数有55个）</li>
<li><code>find 路径范围 选项 选项的值</code> ，选项有：<br>-name ：按照文档名称进行搜索（支持模糊搜索）<br>-user ：按照文档用户名进行搜索<br>-size ：按照文档大小进行搜索，后面跟+20M（大于20M）<br>-type ：按照文档的类型进行搜索（-为文件，这里使用f来替换；d表示文件夹）</li>
<li><font color=#F00>注意：尽量不要在根目录下进行查找</font></li>
</ul>
<h3 id="2-locate"><a href="#2-locate" class="headerlink" title="(2).locate"></a>(2).locate</h3><ul>
<li>作用：可以快速定位文件路径，其无需遍历整个文件系统，查询速度比较快</li>
<li>由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建其的数据库</li>
<li><code>locate 文件名</code> </li>
</ul>
<h3 id="3-grep-与"><a href="#3-grep-与" class="headerlink" title="(3).grep 与 |"></a>(3).grep 与 |</h3><ul>
<li>作用：管道一般可以用于 “过滤，特殊，扩展处理”</li>
<li>注意：不能单独使用，必须配合其他命令使用，主要起辅助作用</li>
<li><code>grep 选项 查找内容 源文件</code> ：选项如下：</li>
<li>n：显示匹配行及行号</li>
<li>i：忽略字母大小写</li>
<li><code>ls / | grep y</code> ：过滤功能</li>
<li><code>ls / l wc -l</code> ：统计某个目录下的文档总个数</li>
</ul>
<h2 id="9-工作常用类"><a href="#9-工作常用类" class="headerlink" title="9.工作常用类"></a>9.工作常用类</h2><ul>
<li>统计/home文件夹下文件的个数：<code>ls -l /home | grep &quot;^-&quot; | wc -l</code></li>
<li>统计/home文件夹下目录的个数：<code>ls -l /home | grep &quot;^d&quot; | wc -l</code></li>
<li>统计/home文件夹下文件的个数，包括子文件里的：<code>ls -lR /home | grep &quot;^-&quot; | wc -l</code></li>
<li>统计文件夹下目录的个数，包括子文件夹里的：<code>ls -lR /home | grep &quot;^d&quot; | wc -l</code></li>
<li>以树状显示目录结构：<code>tree</code> （如果没有该命令可以使用yum进行安装）</li>
</ul>
<h1 id="三、实操部分"><a href="#三、实操部分" class="headerlink" title="三、实操部分"></a>三、实操部分</h1><h2 id="1-组管理和权限管理"><a href="#1-组管理和权限管理" class="headerlink" title="1.组管理和权限管理"></a>1.组管理和权限管理</h2><h3 id="1-查看文件所有者-所在组"><a href="#1-查看文件所有者-所在组" class="headerlink" title="(1).查看文件所有者/所在组"></a>(1).查看文件所有者/所在组</h3><ul>
<li><code>ls -ahl</code> </li>
</ul>
<h3 id="2-修改文件所有者"><a href="#2-修改文件所有者" class="headerlink" title="(2).修改文件所有者"></a>(2).修改文件所有者</h3><ul>
<li><code>chown 用户名 文件名</code> ：改变文件的所有者</li>
<li><code>chown newowner:newgroup 文件名</code> ：改变文件的所有者和所有组</li>
<li><code>chown -R tom kkk/</code> ：将 kkk 目录下的所有的文件（子目录及其下边的文件），递归的将所有者改成tom</li>
</ul>
<h3 id="3-修改文件所在组"><a href="#3-修改文件所在组" class="headerlink" title="(3).修改文件所在组"></a>(3).修改文件所在组</h3><ul>
<li><code>chgrp 组名 文件名</code> </li>
</ul>
<h3 id="4-修改用户所在组"><a href="#4-修改用户所在组" class="headerlink" title="(4).修改用户所在组"></a>(4).修改用户所在组</h3><ul>
<li><code>usermod -g 组名 用户名</code></li>
<li><code>usermod -d 目录名 用户名</code> ：改变该用户登录的初始目录</li>
</ul>
<h3 id="5-权限介绍"><a href="#5-权限介绍" class="headerlink" title="(5).权限介绍"></a>(5).权限介绍</h3><ul>
<li>使用 <code>ls -l</code> 可以查看权限</li>
<li>文件的类型：<code>-</code> 为普通文件、<code>d</code> 为目录、<code>l</code> 为软链接、<code>c</code> 为字符设备、<code>b</code> 为块文件</li>
<li>文件所有者（所在组、其他组）权限：<code>r</code> 为读权限（4）、<code>w</code> 为写权限（2）、<code>x</code> 为执行权限（1） 、<code>-</code> 为没有权限</li>
</ul>
<h3 id="6-修改权限"><a href="#6-修改权限" class="headerlink" title="(6).修改权限"></a>(6).修改权限</h3><ul>
<li>u：所有者；g：所有组；o：其他人；a：所有人</li>
<li><code>chmod u=rwx,g=rw,o=x 文件目录名</code> 或 <code>chmod 751 文件目录名</code> </li>
<li><code>chmod 0+w 文件目录名</code> </li>
<li><code>chmod a-x 文件目录名</code> </li>
</ul>
<h2 id="2-crond任务调度"><a href="#2-crond任务调度" class="headerlink" title="2.crond任务调度"></a>2.crond任务调度</h2><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="(1).基础"></a>(1).基础</h3><ul>
<li>作用：crontab 进行定时任务的设置</li>
<li><code>crontab 选项</code> ，选项如下：</li>
<li>e：编辑 crontab 定时任务</li>
<li>l：查询 crontab 任务</li>
<li>r：删除当前用户所有的 crontab 任务</li>
<li><code>service cround restart</code> ：重启任务调度</li>
<li>简单的任务，可以不用写脚本，直接在 crontab 中直接编写即可；复杂任务，需要使用 shell 脚本编写</li>
</ul>
<h3 id="2-步骤"><a href="#2-步骤" class="headerlink" title="(2).步骤"></a>(2).步骤</h3><ol>
<li>crontab -e</li>
<li>*/1 * * * * ls -l /etc &gt;&gt; /tmp/to.txt</li>
<li>当程序退出后就生效</li>
</ol>
<h3 id="3-占位符说明"><a href="#3-占位符说明" class="headerlink" title="(3).占位符说明"></a>(3).占位符说明</h3><ul>
<li>如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zHk59.png" alt="linux06.png"></li>
</ul>
<h3 id="4-特殊符号说明"><a href="#4-特殊符号说明" class="headerlink" title="(4).特殊符号说明"></a>(4).特殊符号说明</h3><ul>
<li>如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zHECR.png" alt="linux07.png"></li>
</ul>
<h3 id="5-特定时间执行任务案例"><a href="#5-特定时间执行任务案例" class="headerlink" title="(5).特定时间执行任务案例"></a>(5).特定时间执行任务案例</h3><ul>
<li>如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zHV81.png" alt="linux08.png"></li>
</ul>
<h2 id="3-磁盘管理"><a href="#3-磁盘管理" class="headerlink" title="3.磁盘管理"></a>3.磁盘管理</h2><h3 id="1-分区"><a href="#1-分区" class="headerlink" title="(1).分区"></a>(1).分区</h3><ul>
<li>mbr分区：<br>最多支持四个主分区<br>系统只能装在主分区<br>扩展分区要占一个主分区<br>mbr最大只支持2TB，但拥有最好的兼容性</li>
<li>gpt分区：<br>支持无限多个主分区<br>最大支持18EB的大容量<br>win7 64位以后支持gpt</li>
<li><font color=#F00>Linux中无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分</font></li>
<li>Linux采用了一种“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来<br>mount：挂载<br>umount：卸载</li>
<li>使用 <code>lsblk</code> （老师不离开首字母）命令查看系统的分区和挂载的情况（加-f选项也可以）</li>
</ul>
<h3 id="2-硬盘"><a href="#2-硬盘" class="headerlink" title="(2).硬盘"></a>(2).硬盘</h3><ul>
<li><p>Linux硬盘分为 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘</p>
</li>
<li><p>对于 IDE 硬盘，驱动器标识符为 <code>hdx~</code><br>hd：指该硬盘为 IDE 硬盘<br>x：为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）<br>~：为分区，1-4表示为主分区或扩展分区，从5开始表示逻辑分区</p>
</li>
<li><p>对于 SCSI 硬盘，驱动器标识符为 <code>sdx~</code><br>sd：指该硬盘为 SCSI 硬盘<br>x：为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘）<br>~：为分区，1-4表示为主分区或扩展分区，从5开始表示逻辑分区</p>
</li>
</ul>
<h3 id="3-挂载案例——增加一块硬盘"><a href="#3-挂载案例——增加一块硬盘" class="headerlink" title="(3).挂载案例——增加一块硬盘"></a>(3).挂载案例——增加一块硬盘</h3><h4 id="1-虚拟机添加硬盘"><a href="#1-虚拟机添加硬盘" class="headerlink" title="1).虚拟机添加硬盘"></a>1).虚拟机添加硬盘</h4><ul>
<li>在虚拟机菜单中，选择<strong>设置</strong>，然后添加硬盘，下一步，修改磁盘大小，重启系统</li>
</ul>
<h4 id="2-分区"><a href="#2-分区" class="headerlink" title="2).分区"></a>2).分区</h4><ul>
<li><p>使用分区命令 <code>fdisk /dev/sdb</code> ，分区时有如下命令：<br>m：显示命令列表<br>p：显示磁盘分区，同 <code>fdisk -l</code><br>n：新增分区<br>d：删除分区<br>w：写入并退出</p>
</li>
<li><p>开始分区后输入n来新增分区，然后选择p，分区类型为主分区即1。两次回车默认剩余全部空间。最后输入w写入分区并退出，若不保存退出输入q</p>
</li>
</ul>
<h4 id="3-格式化"><a href="#3-格式化" class="headerlink" title="3).格式化"></a>3).格式化</h4><ul>
<li>使用 <code>mkfs -t ext4 /dev/sdb1</code> 命令来执行，其中ext4为分区类型</li>
<li><font color=#F00>注意：这里的分区类型可能需要视不同版本或不同系统而定</font></li>
</ul>
<h4 id="4-挂载"><a href="#4-挂载" class="headerlink" title="4).挂载"></a>4).挂载</h4><ul>
<li>挂载可以使一个分区与一个目录联系起来</li>
<li>命令为：<code>mount 设备名称 挂载目录</code>。例如：<code>mount /dev/sdb1 /home/newdisk</code> </li>
<li>卸载命令为：<code>umount 设备名称/挂载目录</code> </li>
<li><font color=#F00>注意：这部分的挂载在系统重启以后会失效，所以需要使用下一步永久挂载</font></li>
</ul>
<h4 id="5-设置可以自动挂载"><a href="#5-设置可以自动挂载" class="headerlink" title="5).设置可以自动挂载"></a>5).设置可以自动挂载</h4><ul>
<li>修改 <code>/etc/fstab</code> 文件可实现挂载</li>
<li>将最上边有UUID部分的复制一行以后进行修改，第一部分修改为设备名称，第二部分为挂载目录，第三部分为分区类型，第四部分为默认，第五部分按00即可</li>
<li>添加完成后，执行 <code>mount -a</code> 即刻生效</li>
</ul>
<h3 id="4-df"><a href="#4-df" class="headerlink" title="(4).df"></a>(4).df</h3><ul>
<li><p><code>df</code> ：直接查看磁盘空间</p>
</li>
<li><p><code>df -h</code> ：查询系统整体磁盘使用情况</p>
</li>
<li><p><code>du -ach --max-depth=1 /目录</code> ：查询指定目录的磁盘占用情况，默认为当前目录</p>
</li>
<li><p>s：指定目录占用大小汇总</p>
</li>
<li><p>h：带计量单位</p>
</li>
<li><p>a：含文件</p>
</li>
<li><p>c：列出明细的同时，增加汇总值</p>
</li>
<li><p>-max-depth=1：子目录深度</p>
</li>
</ul>
<h2 id="4-网络配置与管理"><a href="#4-网络配置与管理" class="headerlink" title="4.网络配置与管理"></a>4.网络配置与管理</h2><h3 id="1-查看网络IP和网关"><a href="#1-查看网络IP和网关" class="headerlink" title="(1).查看网络IP和网关"></a>(1).查看网络IP和网关</h3><ul>
<li>查看虚拟网络编辑器：虚拟机编辑菜单-虚拟网络编辑器-VMnet8</li>
<li>在这里还可以修改虚拟机的ip地址</li>
<li>查看网关：虚拟机编辑菜单-虚拟网络编辑器-VMnet8-NAT设置</li>
</ul>
<h3 id="2-自动获取IP"><a href="#2-自动获取IP" class="headerlink" title="(2).自动获取IP"></a>(2).自动获取IP</h3><ul>
<li>Linux系统中：系统-首选项-网络连接-点击相应网卡-编辑-自动连接</li>
<li>然后重启一下即可</li>
<li><font color=#F00>缺点：每次自动获取的IP地址可能不一样，服务器上不适用</font></li>
</ul>
<h3 id="3-修改配置文件指定IP"><a href="#3-修改配置文件指定IP" class="headerlink" title="(3).修改配置文件指定IP"></a>(3).修改配置文件指定IP</h3><ul>
<li><p>编辑 <code>/etc/sysconfig/network-scripts/ifcfg-eth0</code> 文件，对于最后是网关文件可能不一定是0</p>
</li>
<li><p>设置为静态获取ip，并配置IP、网关、DNS，如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zHZgx.png" alt="linux09.png"></p>
</li>
<li><p>重启网络服务：<code>service network restart</code> </p>
</li>
</ul>
<h3 id="4-netstat"><a href="#4-netstat" class="headerlink" title="(4).netstat"></a>(4).netstat</h3><ul>
<li>作用：查看网络的连接状态</li>
<li><code>netstat -tnlp</code> ：<br>-t表示只列出tcp协议的连接<br>-n表示将字母组合转化成ip地址，将协议转换成端口号<br>-l表示过滤出”state”列中其值为 LISTEN 的连接<br>-p表示显示发起连接的pid和进程名称</li>
</ul>
<h3 id="5-ifconfig"><a href="#5-ifconfig" class="headerlink" title="(5).ifconfig"></a>(5).ifconfig</h3><ul>
<li>作用：操作网卡的相关的指令</li>
<li><code>ifconfig</code> ；获取网卡信息</li>
</ul>
<h2 id="5-进程管理"><a href="#5-进程管理" class="headerlink" title="5.进程管理"></a>5.进程管理</h2><h3 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="(1).基础"></a>(1).基础</h3><ul>
<li>在 Linux 中，每个执行的程序都称为一个进程，且分配一个 ID 号</li>
<li>一个进程 ——&gt; 一个父进程<br>一个父进程 ——&gt; 多个子进程</li>
<li>进程分为前台进程和后台进程（又称守护进程）</li>
</ul>
<h3 id="2-ps"><a href="#2-ps" class="headerlink" title="(2).ps"></a>(2).ps</h3><ul>
<li>作用：查看服务器的进程信息</li>
<li>注意：使用该命令至少会出现一个进程，因为自身命令也算一次进程</li>
</ul>
<h4 id="！命令1："><a href="#！命令1：" class="headerlink" title="！命令1："></a>！命令1：</h4><ul>
<li><code>ps -aux</code> ，选项如下：</li>
<li>a：显示当前终端的所有进程信息</li>
<li>u：以用户的格式显示进程信息</li>
<li>x：显示后台进程运行的参数</li>
<li>为了查看方便，这里建议与 more 指令一起使用，即 <code>ps -aux | more</code> </li>
<li>关于每一列的含义，如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zHev6.png" alt="linux10.png"></li>
</ul>
<h4 id="！命令2："><a href="#！命令2：" class="headerlink" title="！命令2："></a>！命令2：</h4><ul>
<li><p><code>ps -ef</code> ：主要用来查看父进程</p>
</li>
<li><p>e：列出全部的进程</p>
</li>
<li><p>f：显示全部的列（显示全字段）</p>
</li>
<li><p>进程的主要参数如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zHiE4.png" alt="linux04.png"></p>
</li>
<li><p><font color=#F00>注意：如果一个程序的父级进程找不到，则为僵尸进程（STAT为Z），需要进行处理</font></p>
</li>
</ul>
<h4 id="！进阶（100-使用）"><a href="#！进阶（100-使用）" class="headerlink" title="！进阶（100%使用）"></a>！进阶（100%使用）</h4><ul>
<li>基础方法会查看所有的进程，然后在实际中并不需要，所以可以用管道进行过滤</li>
<li><code>ps -ef | grep 进程名字</code> 与 <code>ps -aux | grep 进程名字</code> </li>
</ul>
<h3 id="3-kill"><a href="#3-kill" class="headerlink" title="(3).kill"></a>(3).kill</h3><ul>
<li>作用：用于杀死进程（当遇到僵尸进程或者需要关闭进程的时候）</li>
<li><code>kill 选项 进程id（pid）</code> ：通过进程号杀死进程<br>常用选项：-9表示强迫进程立即停止</li>
<li><code>killall 进程名称</code> ：通过进程名称杀死进程，也支持通配符，在系统因负载过大而变得很慢时很有用</li>
</ul>
<h4 id="！案例演示："><a href="#！案例演示：" class="headerlink" title="！案例演示："></a>！案例演示：</h4><ul>
<li><p>踢出非法登录用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux | grep sshd		//查看非法登录用户的PID</span><br><span class="line">kill 4010 				//踢出非法用户</span><br></pre></td></tr></table></figure></li>
<li><p>终止远程服务 sshd，在适当的时候再次重启 sshd 服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux | grep sshd</span><br><span class="line">kill 2221	//杀掉第一个sshd服务，此时所有的用户都不可以从sshd上进行连接</span><br><span class="line">service sshd start	//重启sshd服务，此时所有用户可以进行sshd连接</span><br></pre></td></tr></table></figure></li>
<li><p>终止多个 gedit 编辑器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">killall gedit</span><br></pre></td></tr></table></figure></li>
<li><p>强制杀掉一个终端，终端对应一个 bash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux | gerp bash</span><br><span class="line">kill -9 4147	//因为系统会忽略杀掉终端命令，所以只能强制杀</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-pstree"><a href="#4-pstree" class="headerlink" title="(4).pstree"></a>(4).pstree</h3><ul>
<li>作用：用树状来查看进程信息</li>
<li><code>pstree 选项</code>，常用选项如下：</li>
<li>p：显示进程的PID</li>
<li>u：显示进程的所属用户</li>
</ul>
<h3 id="5-Service"><a href="#5-Service" class="headerlink" title="(5).Service"></a>(5).Service</h3><ul>
<li>服务本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其他程序的请求，因此又称为守护进程</li>
<li>作用：控制一些软件的服务启动/停止/重启/重载/状态</li>
<li><code>service 服务名 start/stop/restart/reload/status</code> </li>
<li>注意：在 Centos7.0 以后不再使用 service 命令，而是使用 systemctl 命令</li>
<li>注意：使用该命令执行以后会立即生效，但重启失效</li>
</ul>
<h4 id="！案例分析"><a href="#！案例分析" class="headerlink" title="！案例分析"></a>！案例分析</h4><ul>
<li>查看当前防火墙状况<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service iptables status</span><br><span class="line">centos7下：systemctl status firewalld</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="！检测端口号是否被监听"><a href="#！检测端口号是否被监听" class="headerlink" title="！检测端口号是否被监听"></a>！检测端口号是否被监听</h4><ul>
<li>在 Windows 端使用 Telnet客户端来检测</li>
<li>需要先在 程序和功能-启用或关闭Windows功能-Telnet 打钩</li>
<li>然后在 cmd 命令行中输入以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet ip地址 端口号</span><br><span class="line">如：</span><br><span class="line">telnet 192.168.2.142 22</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="！查看服务名"><a href="#！查看服务名" class="headerlink" title="！查看服务名"></a>！查看服务名</h4><ul>
<li>使用 setup 命令-&gt;系统服务</li>
<li><code>ls -l /etc/init.d/</code> 查看</li>
</ul>
<h3 id="6-chkconfig"><a href="#6-chkconfig" class="headerlink" title="(6).chkconfig"></a>(6).chkconfig</h3><ul>
<li>作用：可以给各个运行级别设置自启动/关闭</li>
<li><code>chkconfig --list</code> ：查看全部服务</li>
<li><code>chkconfig --list | grep xxx</code> 或 <code>chkconfig 服务名 --list</code> ：查看具体某一个服务</li>
<li><code>chkconfig --level 运行级别 服务名 on/off</code> ：设置某个服务的运行级别自启动</li>
</ul>
<h3 id="7-top（动态监控进程）"><a href="#7-top（动态监控进程）" class="headerlink" title="(7).top（动态监控进程）"></a>(7).top（动态监控进程）</h3><ul>
<li><p>作用：查看服务器的进程占的资源，且会自动更新</p>
</li>
<li><p><code>top</code> ：进入命令，动态显示<br><code>u</code> ：回车后输入用户名查看该用户下的进程<br><code>k</code> ：回车后输入进程ID号可以终止指定的进程<br><code>M</code> ：将结果按照内存（MER）从高到低进行排列<br><code>N</code> ：将结果按照PID排序<br><code>P</code> ：将结果按照CPU从高到低进行排列<br><code>1</code> ：当服务器拥有多个cpu的时候，使用1来切换是否展示显示cpu的详细信息<br><code>q</code>：退出命令</p>
</li>
<li><p>详细信息如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zHnKK.png" alt="linux11.png"></p>
</li>
<li><p>进程所占资源如下图：<br><img src="https://s1.ax1x.com/2020/10/20/0zHFUJ.png" alt="linux05.png"></p>
</li>
<li><p><code>top 选项</code> ，具体选项如下：</p>
</li>
<li><p>d 10：指定10秒刷新一次</p>
</li>
<li><p>i：不显示任何闲置或者僵死进程</p>
</li>
<li><p>p：通过指定监控进程ID来仅仅监控某个进程的状态</p>
</li>
<li><p>计算一个进程实际使用的内存 = 常驻内存 - 共享内存</p>
</li>
</ul>
<h3 id="8-netstat（监控网络状态）"><a href="#8-netstat（监控网络状态）" class="headerlink" title="(8).netstat（监控网络状态）"></a>(8).netstat（监控网络状态）</h3><ul>
<li>作用：查看系统网络情况</li>
<li><code>netstat -anp</code> ，选项如下：</li>
<li>an：按一定顺序排列输出</li>
<li>p：显示哪个进程在调用</li>
</ul>
<h2 id="6-RPM包管理"><a href="#6-RPM包管理" class="headerlink" title="6.RPM包管理"></a>6.RPM包管理</h2><ul>
<li><code>rpm 选项</code> 选项如下：</li>
<li>qa：查询所安装的所有软件包</li>
<li>q 软件包名：查询软件包是否安装</li>
<li>qa | grep 软件包名：查询软件包是否安装</li>
<li>qi 软件包名：查询软件包信息</li>
<li>ql 软件包名：查询软件包中的文件</li>
<li>qf 文件全路径名：查询文件所属的软件包</li>
<li><code>rpm -e 软件包名</code> ：删除该软件包</li>
<li><code>rpm -e -nodeps 软件包名</code> ：强制删除某软件包</li>
<li><code>rpm -ivh RPM包全路径名称</code> ：安装某软件包</li>
<li>i：安装</li>
<li>v：提示</li>
<li>h：进度条</li>
<li>安装时候需要先挂载安装系统的ISO文件，然后去 <code>/media/Packages</code> 下找到包，将其复制到 <code>/opt/</code> 中，再进行安装</li>
</ul>
<h2 id="7-yum包管理"><a href="#7-yum包管理" class="headerlink" title="7.yum包管理"></a>7.yum包管理</h2><ul>
<li>yum 是一个 Shell 前端软件包管理器，基于 RPM包管理，可以从指定的服务器自动下载 RPM包并进行安装，还可以自动处理依赖关系</li>
<li><code>yum list | grep xx</code> ：查询软件列表中是否有这个软件</li>
<li><code>yum install xxx</code> ：下载并安装</li>
</ul>
<h1 id="四、JavaEE定制部分"><a href="#四、JavaEE定制部分" class="headerlink" title="四、JavaEE定制部分"></a>四、JavaEE定制部分</h1><h2 id="1-准备文件"><a href="#1-准备文件" class="headerlink" title="1.准备文件"></a>1.准备文件</h2><ul>
<li>在 Linux 上开发 Java 程序需要安装以下4个软件：jdk、tomcat、eclipse、MySQL</li>
<li>下载好以后使用 Xftp 上传到服务器的 <code>/opt/</code> 目录下</li>
</ul>
<h2 id="2-安装-jdk"><a href="#2-安装-jdk" class="headerlink" title="2.安装 jdk"></a>2.安装 jdk</h2><ul>
<li><p>将 jdk 安装包解压到 <code>/opt/</code> 目录下</p>
</li>
<li><p>配置环境变量 <code>vim /etc/profile</code> ，在最后一行添加如下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/opt/jdk1.7.0_79		//解压后的文件夹名</span><br><span class="line">PATH=/opt/jdk1.7.0_79/bin:$PATH	//后面一定要加上原始PATH</span><br><span class="line">export JAVA_HOME PATH			//输出变量，使环境变量生效</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>source /etc/profile</code> 命令来使环境变量生效，也可以直接注销重新登录</p>
</li>
</ul>
<h2 id="3-安装-Tomcat"><a href="#3-安装-Tomcat" class="headerlink" title="3.安装 Tomcat"></a>3.安装 Tomcat</h2><ul>
<li>将 Tomcat 安装包解压到 <code>/opt/</code> 目录下</li>
<li>切入到解压后文件夹的 <code>/bin</code> 目录</li>
<li>执行 <code>./startup.sh</code> 命令来运行 Tomcat</li>
<li>在服务器的浏览器中输入 <code>http://localhost:8080</code> 来检测是否成功启用 Tomcat</li>
<li>但是本地电脑却无法访问是因为防火墙没有让8080端口通过，所以可以修改 <code>/etc/sysconfig/iptables</code> 文件来让8080端口通过，将其中含有22端口的一行复制并粘贴修改为8080，然后使用 <code>service iptables restart</code> 来重启防火墙就可以了</li>
</ul>
<h2 id="4-安装-Eclipse"><a href="#4-安装-Eclipse" class="headerlink" title="4.安装 Eclipse"></a>4.安装 Eclipse</h2><ul>
<li>将 Eclipse 安装包解压到 <code>/opt/</code> 目录下</li>
<li>进入解压后的文件夹，使用 <code>./eclipse</code> 命令启动 eclipse，注意配置jre与Tomcat</li>
</ul>
<h2 id="5-安装-MySQL"><a href="#5-安装-MySQL" class="headerlink" title="5.安装 MySQL"></a>5.安装 MySQL</h2><h3 id="1-卸载旧版本"><a href="#1-卸载旧版本" class="headerlink" title="(1).卸载旧版本"></a>(1).卸载旧版本</h3><ul>
<li>使用 <code>rpm -qa | grep mysql</code> 命令检查是否安装有 MySQL Server</li>
<li>如果有的话通过 <code>rpm -e mysql-libs</code> 或 <code>rpm -e --nodeps mysql-libs</code> 命令来卸载掉 </li>
</ul>
<h3 id="2-安装编译代码需要的包"><a href="#2-安装编译代码需要的包" class="headerlink" title="(2).安装编译代码需要的包"></a>(2).安装编译代码需要的包</h3><ul>
<li><p>使用 <code>yum -y install make gcc-c++ cmake bison-devel ncurses-devel</code> 命令来安装编译代码需要的包</p>
</li>
<li><p>将 MySQL 安装包解压到 <code>/opt/</code> 目录下</p>
</li>
<li><p>进入解压后的文件夹后输入以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/data -DSYSCONFDIR=/etc -DWITH_MYISAM_STORAGE_ENGINE=1 -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 -DWITH_READLINE=1 -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock -DMYSQL_TCP_PORT=3306 -DENABLED_LOCAL_INFILE=1 -DWITH_PARTITION_STORAGE_ENGINE=1 -DEXTRA_CHARSETS=all -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>make &amp;&amp; make install</code> 命令编译并安装</p>
</li>
</ul>
<h2 id="6-配置-MySQL"><a href="#6-配置-MySQL" class="headerlink" title="6.配置 MySQL"></a>6.配置 MySQL</h2><ul>
<li><p>使用下面的命令查看是否有 mysql 用户及用户组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/passwd 查看用户列表</span><br><span class="line">cat /etc/group  查看用户组列表</span><br></pre></td></tr></table></figure></li>
<li><p>如果没有的话就创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd mysql</span><br><span class="line">useradd -g mysql mysql</span><br></pre></td></tr></table></figure></li>
<li><p>修改 <code>/usr/local/mysql</code> 权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown -R mysql:mysql /usr/local/mysql</span><br></pre></td></tr></table></figure></li>
<li><p>初始化配置，<font color=#F00>进入安装路径（再执行下面的指令）</font>，执行初始化配置脚本，创建系统自带的数据库和表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql</span><br><span class="line">scripts/mysql_install_db --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql</span><br></pre></td></tr></table></figure></li>
<li><p>注：在启动 MySQL 服务时，会按照一定次序搜索 <code>my.cnf</code>，先在 <code>/etc</code> 目录下找，找不到则会搜索 <code>$basedir/my.cnf</code> ，在本例中就是 <code>/usr/local/mysql/my.cnf</code>，这是新版 MySQL 的配置文件的默认位置！</p>
</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>在 CentOS 6.8 版操作系统的最小安装完成后，在 <code>/etc</code> 目录下会存在一个 <code>my.cnf</code>，需要将此文件更名为其他的名字，如：<code>/etc/my.cnf.bak</code>，否则，该文件会干扰源码安装的 MySQL 的正确配置，造成无法启动</li>
<li>因此，需要修改名称，防止干扰：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /etc/my.cnf /etc/my.cnf.bak</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-启动-MySQL"><a href="#7-启动-MySQL" class="headerlink" title="7.启动 MySQL"></a>7.启动 MySQL</h2><ul>
<li><p>添加服务，拷贝服务脚本到 <code>init.d</code> 目录，并设置开机启动，在 <code>/usr/local/mysql</code> 下执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp support-files/mysql.server /etc/init.d/mysql</span><br><span class="line">chkconfig mysql on</span><br><span class="line">service mysql start</span><br></pre></td></tr></table></figure></li>
<li><p>执行下面的命令修改 root 密码，也可以将该路径增添到 PATH 路径中（即在冒号后面再添加路径和冒号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/mysql/bin</span><br><span class="line">./mysql -u root -p					//第一次进入没有密码，直接回车</span><br><span class="line">SET PASSWORD = PASSWORD(&#x27;root&#x27;);	//单引号中是需要修改为的密码</span><br></pre></td></tr></table></figure></li>
<li><p>重新进入以后就可以执行数据库相关操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;</span><br><span class="line">create database testDB;</span><br><span class="line">use testDB;</span><br><span class="line">create table user(id int,name varchar(32));</span><br><span class="line">insert into user values(1,&#x27;cat&#x27;);</span><br><span class="line">insert into user values(2,&#x27;dog&#x27;);</span><br><span class="line">select * from user;</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></li>
<li><p>备份 MySQL 的指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -u用户名 -p密码 --host=主机名 数据库名 &gt; /backup/db/xxx.sql</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、大数据定制部分"><a href="#五、大数据定制部分" class="headerlink" title="五、大数据定制部分"></a>五、大数据定制部分</h1><h2 id="1-Shell-简介"><a href="#1-Shell-简介" class="headerlink" title="1.Shell 简介"></a>1.Shell 简介</h2><ul>
<li>Shell 是一个命令行解释器，为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序</li>
<li>脚本格式要求：</li>
</ul>
<p>1.脚本中以 <code>#!/bin/bash</code> 开头<br>2.脚本是个以 <code>.sh</code> 为后缀名的文件<br>3.脚本需要有可执行权限（一般来说）</p>
<ul>
<li>内容编写格式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#! /bin/sh</span><br><span class="line">#指定脚本的解析器，必须在第一行指定</span><br><span class="line">#注释用井号来表示</span><br><span class="line">echo #后面什么都不加时打印空行</span><br><span class="line">echo &quot;后面加字符串会打印字符串&quot;</span><br><span class="line">echo &quot;&quot; #打印空行</span><br><span class="line">/bin/pwd</span><br><span class="line">echo</span><br><span class="line">echo &quot;abc.&quot;</span><br><span class="line">/bin/ls</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-Shell-执行方式"><a href="#2-Shell-执行方式" class="headerlink" title="2.Shell 执行方式"></a>2.Shell 执行方式</h2><h3 id="1-赋予权限执行"><a href="#1-赋予权限执行" class="headerlink" title="(1).赋予权限执行"></a>(1).赋予权限执行</h3><ul>
<li><p>给已经写好的脚本赋予所有者的执行权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 744 myShell.sh</span><br><span class="line">或</span><br><span class="line">chmod u+x myShell.sh</span><br></pre></td></tr></table></figure></li>
<li><p>相对路径执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./myShell.sh</span><br></pre></td></tr></table></figure></li>
<li><p>绝对路径执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/shell/myShell.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-不赋予权限执行"><a href="#2-不赋予权限执行" class="headerlink" title="(2).不赋予权限执行"></a>(2).不赋予权限执行</h3><ul>
<li><p>相对路径执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh ./myShell.sh</span><br></pre></td></tr></table></figure></li>
<li><p>绝对路径执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh /root/shell/myShell.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h2><ul>
<li>变量变量分为：<strong>系统变量（环境变量）</strong>与<strong>用户自定义变量（本地变量）</strong></li>
</ul>
<h3 id="1-系统变量"><a href="#1-系统变量" class="headerlink" title="(1).系统变量"></a>(1).系统变量</h3><ul>
<li><p>有：<code>$PATH</code> 、 <code>$PWD</code> 、 <code>$SHELL</code> 、 <code>$USER</code> </p>
</li>
<li><p>所有系统变量都是键值对的格式，系统变量查看命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br><span class="line">或者：</span><br><span class="line">env | grep $PATH</span><br></pre></td></tr></table></figure></li>
<li><p>显示当前 Shell 中所有的变量：<code>set</code> </p>
</li>
</ul>
<h3 id="2-用户自定义变量"><a href="#2-用户自定义变量" class="headerlink" title="(2).用户自定义变量"></a>(2).用户自定义变量</h3><ul>
<li><p>定义变量：<code>变量=值</code></p>
</li>
<li><p>撤销变量：<code>unset 变量</code> </p>
</li>
<li><p>声明静态变量：<code>readonly 变量</code> ，但是静态变量不能使用撤销操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=100			//声明普通变量</span><br><span class="line">echo &quot;A=$A&quot;		//打印变量A，后面必须使用 `$` 符号</span><br><span class="line">unset A			//撤销变量A</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line">readonly B=99	//声明静态变量</span><br><span class="line">echo &quot;B=$B&quot;		//打印变量B，后面必须使用 `$` 符号</span><br><span class="line">unset B			//撤销变量B，出错</span><br><span class="line">echo &quot;B=$B&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>定义变量的规则:<br>可以由字母、数字和下划线组成，但是不能以数字开头<br>等号两侧不能有空格<br>变量名称一般习惯大写</p>
</li>
</ul>
<h3 id="3-将命令的返回值赋值给变量"><a href="#3-将命令的返回值赋值给变量" class="headerlink" title="(3).将命令的返回值赋值给变量"></a>(3).将命令的返回值赋值给变量</h3><ul>
<li><p>使用反引号，将命令写入反引号中来然后赋值给变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=`ls -l`</span><br><span class="line">echo $A</span><br></pre></td></tr></table></figure></li>
<li><p>使用括号，将命令写入括号中来然后赋值给变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B=$(date)</span><br><span class="line">echo &quot;$B&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="(4).设置环境变量"></a>(4).设置环境变量</h3><ul>
<li><p>在配置文件 <code>/etc/profile</code> 中使用如下语法来将 Shell 变量输出为环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TOMCAT_HOME=/opt/tomcat</span><br><span class="line">export TOMCAT_HOME</span><br></pre></td></tr></table></figure></li>
<li><p>使用如下命令让修改后的配置信息立即生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li>
<li><p>在 Shell 脚本中查询环境变量的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $TOMCAT_HOME</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-位置变量参数"><a href="#4-位置变量参数" class="headerlink" title="4.位置变量参数"></a>4.位置变量参数</h2><p>当执行 Shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量</p>
<h3 id="1-语法"><a href="#1-语法" class="headerlink" title="(1).语法"></a>(1).语法</h3><ul>
<li><code>$n</code> ：n为数字，<code>$0</code> 代表命令本身，<code>$1-$9</code> 代表1-9个参数，10以上的参数需要 <code>$&#123;10&#125;</code> 这样使用</li>
<li><code>$*</code> ：这个变量代表命令行中的所有的参数，而 <code>$*</code> 把所有的参数看成一个整体</li>
<li><code>$@</code> ：这个变量也代表命令行中的所有的参数，不过 <code>$@</code> 把每个参数区分对待</li>
<li><code>$#</code> ：这个变量代表命令行中所有参数的个数</li>
</ul>
<h3 id="2-案例"><a href="#2-案例" class="headerlink" title="(2).案例"></a>(2).案例</h3><ul>
<li><p>编写 positionPara.sh ，获取到命令行中的各个参数信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;$0 $1 $2&quot;</span><br><span class="line">echo &quot;$*&quot;</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;$#&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>执行 <code>./positionPara.sh 30 60</code> 命令，得到结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./positionPara.sh 30 60</span><br><span class="line">30 60</span><br><span class="line">30 60</span><br><span class="line">2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-预定义变量"><a href="#5-预定义变量" class="headerlink" title="5.预定义变量"></a>5.预定义变量</h2><p>即事先定义好的变量，可直接在 Shell 中使用</p>
<h3 id="1-语法-1"><a href="#1-语法-1" class="headerlink" title="(1).语法"></a>(1).语法</h3><ul>
<li><code>$$</code> ：当前进程的进程号</li>
<li><code>$!</code> ：后台运行的最后一个进程的进程号</li>
<li><code>$?</code> ：最后一次执行的命令的返回状态<br>如果这个变量的值为0，则上一个命令正确执行<br>如果这个变量的值为非0（具体有命令自己决定），则上一个命令未正确执行</li>
</ul>
<h3 id="2-案例-1"><a href="#2-案例-1" class="headerlink" title="(2).案例"></a>(2).案例</h3><ul>
<li><p>在脚本中简单实用一下预定义变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;当前的进程号=$$&quot;</span><br><span class="line">#以后台的方式运行 myShell.sh</span><br><span class="line">./myShell.sh &amp;</span><br><span class="line">echo &quot;最后的进程号=$!&quot;</span><br><span class="line">echo &quot;执行得值=$?&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>执行后的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当前的进程号=28088</span><br><span class="line">最后的进程号=28089</span><br><span class="line">执行得值=0</span><br><span class="line">[root@hadoop1 shell]# /opt/tomcat</span><br></pre></td></tr></table></figure></li>
<li><p>因为这里后台运行了一个脚本，所以需要使用 ctrl+c 来暂停</p>
</li>
</ul>
<h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="(1).基本语法"></a>(1).基本语法</h3><ul>
<li><code>$((运算式))</code> 或 <code>$[运算式]</code></li>
<li>expr 语法，注意这里的运算符之间要有空格<br>求和：<code>expr m + n</code><br>求差：<code>expr m - n</code><br>求乘：<code>expr \*</code><br>求除：<code>expr /</code><br>求余：<code>expr %</code> </li>
</ul>
<h3 id="2-案例-2"><a href="#2-案例-2" class="headerlink" title="(2).案例"></a>(2).案例</h3><ul>
<li><p>求(2+3)*4的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#括号法</span><br><span class="line">RESULT1=$(((2+3)*4))</span><br><span class="line">echo &quot;result1=$RESULT1&quot;</span><br><span class="line">#中括号法</span><br><span class="line">RESULT2=$[(2+3)*4]</span><br><span class="line">echo &quot;result2=$RESULT2&quot;</span><br><span class="line">#分步法，需要将第一步的值使用反引号引起以后传给TEMP</span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RESULT3=`expr $TEMP \* 4`</span><br><span class="line">echo &quot;result3=$RESULT3&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>求命令行里的两个参数的和</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#命令行中传入10和8求和</span><br><span class="line">RESULT4=$[$1+$2]</span><br><span class="line">echo &quot;result4=$RESULT4&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-流程控制语句"><a href="#7-流程控制语句" class="headerlink" title="7.流程控制语句"></a>7.流程控制语句</h2><h3 id="1-条件判断语法"><a href="#1-条件判断语法" class="headerlink" title="(1).条件判断语法"></a>(1).条件判断语法</h3><ul>
<li><code>[ 判断内容 ]</code> ，在判断内容前后各有一个空格</li>
<li>该条件判断为非空时返回 true，为空时返回 false </li>
<li>也可以使用 <code>$?</code> 来验证，0为 true，1为 false</li>
</ul>
<h3 id="2-常用判断条件"><a href="#2-常用判断条件" class="headerlink" title="(2).常用判断条件"></a>(2).常用判断条件</h3><ul>
<li><p>两个字符串的比较<br><code>[ &quot;ok&quot; = &quot;ok&quot; ]</code></p>
</li>
<li><p>两个整数的比较：<br><code>[ 0 -lt 0 ]</code> ：小于<br><code>[ 0 -le 0 ]</code> ：小于等于<br><code>[ 0 -eq 0 ]</code> ：等于<br><code>[ 0 -gt 0 ]</code> ：大于<br><code>[ 0 -ge 0 ]</code> ：大于等于<br><code>[ 0 -ne 0 ]</code> ：不等于</p>
</li>
<li><p>按照文件权限进行判断：<br><code>[ -r 文件名 ]</code> ：有读的权限<br><code>[ -w 文件名 ]</code> ：有写的权限<br><code>[ -x 文件名 ]</code> ：有执行的权限</p>
</li>
<li><p>按照文件类型进行判断：<br><code>[ -f 文件名 ]</code> ：文件存在并且是一个常规的文件<br><code>[ -e 文件名 ]</code> ：文件存在<br><code>[ -d 文件名 ]</code> ：文件存在并是一个目录</p>
</li>
</ul>
<h3 id="3-if-判断语句"><a href="#3-if-判断语句" class="headerlink" title="(3).if 判断语句"></a>(3).if 判断语句</h3><ul>
<li><p>推荐语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">        程序语句</span><br><span class="line">elif [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">        程序语句</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li><p>不推荐语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">        程序语句</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
<li><p>编写一个Shell程序，如果输入的参数大于等于60输出“ggg及格了”；小于60输出“不及格”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ $1 -ge 60 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;及格了&quot;</span><br><span class="line">elif [ $1 -lt 60 ]</span><br><span class="line">then</span><br><span class="line">        echo &quot;不及格&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-case-判断语句"><a href="#4-case-判断语句" class="headerlink" title="(4).case 判断语句"></a>(4).case 判断语句</h3><ul>
<li><p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">满足则执行该程序语句</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">满足则执行该程序语句</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">以上都不满足则执行该程序语句</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
<li><p>当命令行参数是1时，输出周一；是2时，输出周二；其余输出other</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case $1 in</span><br><span class="line">&quot;1&quot;)</span><br><span class="line">echo &quot;周一&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;2&quot;)</span><br><span class="line">echo &quot;周二&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;other&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-for-循环语句"><a href="#5-for-循环语句" class="headerlink" title="(5).for 循环语句"></a>(5).for 循环语句</h3><ul>
<li><p>语法1如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 变量 in &quot;值1 值2 值3···&quot;</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure></li>
<li><p>语法2如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ((初始值;循环控制条件;变量变化))</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="a-案例"><a href="#a-案例" class="headerlink" title="a).案例"></a>a).案例</h4><ul>
<li><p>打印命令行输入的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#将参数作为一个整体输出</span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">do</span><br><span class="line">        echo &quot;the number is $i&quot;</span><br><span class="line">done</span><br><span class="line">#将参数分别输出</span><br><span class="line">for j in &quot;$@&quot;</span><br><span class="line">do</span><br><span class="line">        echo &quot;the number is $j&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>从1加到100的值输出显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUM=0</span><br><span class="line">for ((i=1;i&lt;=100;i++))</span><br><span class="line">do</span><br><span class="line">        SUM=$[SUM+i]</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-while-循环语句"><a href="#6-while-循环语句" class="headerlink" title="(6).while 循环语句"></a>(6).while 循环语句</h3><ul>
<li><p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">	程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li>
<li><p>从命令行中输入一个数n，统计从1+··+n的值是多少</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUM=0</span><br><span class="line">i=0</span><br><span class="line">while [ $i -le $1 ]</span><br><span class="line">do</span><br><span class="line">        SUM=$[$SUM+$i]</span><br><span class="line">        i=$[$i+1]</span><br><span class="line">done</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-读取控制台输入"><a href="#8-读取控制台输入" class="headerlink" title="8.读取控制台输入"></a>8.读取控制台输入</h2><ul>
<li><p>使用 read 命令可以读取控制台的输入</p>
</li>
<li><p><code>read 选项 参数</code> ，选项如下：</p>
</li>
<li><p>p：指定读取值时的提示符</p>
</li>
<li><p>t：指定读取值时的等待的时间（秒），如果没有在指定的时间内输入，就不等待了<br>参数：指定读取值的变量名</p>
</li>
<li><p>读取控制台输入两个num值，另一个在10秒内输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read -p &quot;请输入数字1：&quot; NUM1</span><br><span class="line">echo &quot;你输入的数字1是：$NUM1&quot;</span><br><span class="line">read -t 10 -p &quot;请输入数字2：&quot; NUM2</span><br><span class="line">echo &quot;你输入的数字2是：$NUM2&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9.函数"></a>9.函数</h2><ul>
<li>shell编程和其他编程语言一样，有系统函数，也可以自定义函数</li>
</ul>
<h3 id="1-系统函数"><a href="#1-系统函数" class="headerlink" title="(1).系统函数"></a>(1).系统函数</h3><h4 id="a-basename"><a href="#a-basename" class="headerlink" title="a).basename"></a>a).basename</h4><ul>
<li>作用：返回完整路径最后/的部分，常用于获取文件名</li>
<li>语法：<br><code>basename [pathname] [suffix]</code> ：<br><code>basename [string] [suffix]</code> ：</li>
<li>如果上面指定了 suffix ，那么就不会显示文件后缀名；不指定则会显示<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hadoop1 ~]# basename /home/test.txt</span><br><span class="line">test.txt</span><br><span class="line">[root@hadoop1 ~]# basename /home/test.txt .txt</span><br><span class="line">test</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-dirname"><a href="#b-dirname" class="headerlink" title="b).dirname"></a>b).dirname</h4><ul>
<li><p>作用：返回完整路径最后/的<font color=#F00>前面的部分</font>，常用于返回路径部分</p>
</li>
<li><p>语法：<br><code>dirname 文件的绝对路径</code></p>
</li>
<li><p>从给定的包含绝对路径的文件名中去除文件名，然后返回剩下的路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@hadoop1 ~]# dirname /home/aaa/test.txt</span><br><span class="line">/home/aaa</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="(2).自定义函数"></a>(2).自定义函数</h3><ul>
<li><p>基本语法（中括号中代表可选的）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[function] 函数名[()]</span><br><span class="line">&#123;</span><br><span class="line">	程序语句;</span><br><span class="line">	[return int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用时直接写 <code>函数名 值</code></p>
</li>
<li><p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#计算输入两个参数的和</span><br><span class="line">function getSum()</span><br><span class="line">&#123;</span><br><span class="line">        SUM=$[$n1+$n2];</span><br><span class="line">        echo &quot;这两个数的和是：$SUM&quot;;</span><br><span class="line">&#125;</span><br><span class="line">#从控制台输入两个数字</span><br><span class="line">read -p &quot;请输入第一个数字：&quot; n1</span><br><span class="line">read -p &quot;请输入第二个数字：&quot; n2</span><br><span class="line">#调用函数</span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-综合案例之定期备份数据库"><a href="#10-综合案例之定期备份数据库" class="headerlink" title="10.综合案例之定期备份数据库"></a>10.综合案例之定期备份数据库</h2><h3 id="1-需求分析"><a href="#1-需求分析" class="headerlink" title="(1).需求分析"></a>(1).需求分析</h3><ul>
<li>每天凌晨2:10分备份数据库 testDB 到 <code>/data/backup/db</code></li>
<li>备份开始和备份结束时能够给出相应的提示信息</li>
<li>备份后的文件要求以备份时间为文件名，并打包成 <code>.tar.gz</code> 的形式，比如：<code>2020_08_22_190501.tar.gz</code></li>
<li>在备份的同时，检查是否有10天前备份的数据库文件，如果有就将其删除</li>
</ul>
<h3 id="2-思路分析"><a href="#2-思路分析" class="headerlink" title="(2).思路分析"></a>(2).思路分析</h3><ul>
<li>第一点可以使用 crond 来实现</li>
<li>第二点在 shell 脚本中输出提示信息即可</li>
<li>第三点可以先使用一个临时文件夹来存放 <code>.gz</code> 文件，然后最后进行打包成 <code>.tar.gz</code> 文件并删除临时文件</li>
<li>第四点需要使用固定指令来删除10天前数据库文件</li>
<li>将 shell 脚本放在 <code>/usr/sbin</code> 目录下，将备份文件放置在 <code>/data/backup/db</code> 下</li>
</ul>
<h3 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="(3).代码实现"></a>(3).代码实现</h3><ul>
<li><p>shell 脚本代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#完成数据库的备份</span><br><span class="line">#定义备份的路径</span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line">#使用当前时间作为文件名</span><br><span class="line">DATETIME=$(date +%Y_%m_%d_%H%M%S)</span><br><span class="line">#测试文件名是否准确</span><br><span class="line">#echo &quot;$DATETIME&quot;</span><br><span class="line">#也可以用中括号包起来</span><br><span class="line">#echo $&#123;DATETIME&#125;</span><br><span class="line">echo &quot;============开始备份============&quot;</span><br><span class="line">echo &quot;== 备份路径为 $BACKUP ==&quot;</span><br><span class="line">#定义数据库的主机</span><br><span class="line">HOST=localhost</span><br><span class="line">#定义数据库的用户名与密码</span><br><span class="line">DB_USER=root</span><br><span class="line">DB_PWD=root</span><br><span class="line">#定义备份数据库名</span><br><span class="line">DATABASE=testDB</span><br><span class="line">#创建备份的路径，如果路径存在则直接使用，不过不存在就创建</span><br><span class="line">if [ ! -d &quot;$BACKUP/$DATETIME&quot; ]</span><br><span class="line">then</span><br><span class="line">        mkdir -p &quot;$BACKUP/$DATETIME&quot;</span><br><span class="line">fi</span><br><span class="line">#执行mysql备份数据库的指令</span><br><span class="line">mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PWD&#125; --host=$HOST $DATABASE | gzip &gt; $BACKUP/$DATETIME/$DATETIME.sql.gz</span><br><span class="line">#打包备份文件</span><br><span class="line">cd $BACKUP</span><br><span class="line">tar -zcvf $DATETIME.tar.gz $DATETIME</span><br><span class="line">#删除临时目录</span><br><span class="line">rm -rf $BACKUP/$DATETIME</span><br><span class="line">#删除10天前的备份文件</span><br><span class="line">find $BACKUP -mtime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line">echo &quot;============备份成功============&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>cront 代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 2 * * * /usr/sbin/mysql_db_backup.sh</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="1-”-etc-profile”-is-read-only"><a href="#1-”-etc-profile”-is-read-only" class="headerlink" title="1.”/etc/profile” is read-only"></a>1.”/etc/profile” is read-only</h2><p>使用sudo、使用su、修改文件权限</p>
<h2 id="2-bash-vim-command-not-found"><a href="#2-bash-vim-command-not-found" class="headerlink" title="2.-bash: vim: command not found"></a>2.-bash: vim: command not found</h2><p>使用sudo yum -y install vim*安装</p>
<h2 id="3-bin-bash-q-command-not-found"><a href="#3-bin-bash-q-command-not-found" class="headerlink" title="3./bin/bash: q: command not found"></a>3./bin/bash: q: command not found</h2><p>退出时使用了错误的!q而不是q!</p>
<h2 id="4-bash-wget-command-not-found"><a href="#4-bash-wget-command-not-found" class="headerlink" title="4.-bash: wget: command not found"></a>4.-bash: wget: command not found</h2><p>使用yum -y install wget安装</p>
<h2 id="5-gzip-stdin-not-in-gzip-format"><a href="#5-gzip-stdin-not-in-gzip-format" class="headerlink" title="5.gzip: stdin: not in gzip format"></a>5.gzip: stdin: not in gzip format</h2><p>这个压缩包没有用gzip格式压缩，所以不用加z指令就可以了，即 <code>tar -xvf 压缩包</code></p>
<h2 id="6-安装python3提示configure-error-no-acceptable-C-compiler-found-in-PATH"><a href="#6-安装python3提示configure-error-no-acceptable-C-compiler-found-in-PATH" class="headerlink" title="6.安装python3提示configure: error: no acceptable C compiler found in $PATH"></a>6.安装python3提示configure: error: no acceptable C compiler found in $PATH</h2><p>没有安装gcc编译器，使用yum install gcc -y安装即可</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>U盘向：启动盘恢复为普通U盘</title>
    <url>/53581.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>在重装系统时，我们会将U盘做成系统启动盘，本篇教程就是如何将启动盘恢复成普通U盘。</li>
<li>如果U盘内含有重要资料，请提前备份到电脑上，因为下面的步骤将会格式化你的U盘。<span id="more"></span></li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="cmd命令行方法"><a href="#cmd命令行方法" class="headerlink" title="cmd命令行方法"></a>cmd命令行方法</h2><ul>
<li>此电脑右击-管理-磁盘管理，在这里先确定好你的U盘是在哪个磁盘上，例如：我这里是在磁盘2<br><img src="https://i.loli.net/2019/04/07/5ca9b302066a7.png" alt="磁盘 2"></li>
<li>使用Win+R组合键，输入 <code>cmd</code> 并回车</li>
<li>输入 <code>diskpart</code> 并回车</li>
<li>在新弹出的页面输入 <code>select disk 2</code> 并回车（这里的2就是指的磁盘2，请根据自己电脑自行修改数字）</li>
<li>输入 <code>clean</code> 并回车，直到提示你清除完毕</li>
<li>在第一步的磁盘管理中找到你的U盘，右键-新建简单卷-一直下一步-直到新建完成</li>
<li>这时候你的U盘就恢复为普通U盘了</li>
</ul>
<h2 id="制做启动盘工具恢复法"><a href="#制做启动盘工具恢复法" class="headerlink" title="制做启动盘工具恢复法"></a>制做启动盘工具恢复法</h2><ul>
<li>找到你当初制作启动盘的软件，部分软件含有恢复功能，直接傻瓜式操作即可</li>
<li>如果你制盘工具没有该功能，请参照上面的方法</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>干货</tag>
        <tag>U盘</tag>
      </tags>
  </entry>
  <entry>
    <title>玩机：巧妙激活Microsoft Office2019</title>
    <url>/office2019.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>当前比较方便的一个激活Microsoft office2019版的方法</li>
<li>该方法来自国外论坛，可以激活180天，<del>但据说180天后会自动激活，待测</del>。已测试，可以自动激活。<span id="more"></span></li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="一、下载并安装"><a href="#一、下载并安装" class="headerlink" title="一、下载并安装"></a>一、下载并安装</h2><ul>
<li>这里可以去TechBench网站下载，该网站支持直接浏览器满速下载。地址：<a href="https://tb.rg-adguard.net/public.php?lang=zh-CN&extract">查看链接</a></li>
<li>完整卸载电脑内其余版本office，以防出现不兼容情况。</li>
<li>如果你是win10用户，可以直接打开 .img 文件进行安装。</li>
<li>如果你不是win10用户，请先将 .img 文件解压后再安装。</li>
</ul>
<h2 id="二、激活Office套件"><a href="#二、激活Office套件" class="headerlink" title="二、激活Office套件"></a>二、激活Office套件</h2><ul>
<li>在桌面新建一个 .txt 文档。</li>
<li>在里面写入以下内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">(cd /d &quot;%~dp0&quot;)&amp;&amp;(NET FILE||(powershell start-process -FilePath &#x27;%0&#x27; -verb runas)&amp;&amp;(exit /B)) &gt;NUL 2&gt;&amp;1</span><br><span class="line">title Office 2019 Activator r/Piracy</span><br><span class="line">echo Converting... &amp; mode 40,25</span><br><span class="line">(if exist &quot;%ProgramFiles%\Microsoft Office\Office16\ospp.vbs&quot; cd /d &quot;%ProgramFiles%\Microsoft Office\Office16&quot;)&amp;(if exist &quot;%ProgramFiles(x86)%\Microsoft Office\Office16\ospp.vbs&quot; cd /d &quot;%ProgramFiles(x86)%\Microsoft Office\Office16&quot;)&amp;(for /f %%x in (&#x27;dir /b ..\root\Licenses16\ProPlus2019VL*.xrm-ms&#x27;) do cscript ospp.vbs /inslic:&quot;..\root\Licenses16\%%x&quot; &gt;nul)&amp;(for /f %%x in (&#x27;dir /b ..\root\Licenses16\ProPlus2019VL*.xrm-ms&#x27;) do cscript ospp.vbs /inslic:&quot;..\root\Licenses16\%%x&quot; &gt;nul)</span><br><span class="line">cscript //nologo ospp.vbs /unpkey:6MWKP &gt;nul&amp;cscript //nologo ospp.vbs /inpkey:NMMKJ-6RK4F-KMJVX-8D9MJ-6MWKP &gt;nul&amp;set i=1</span><br><span class="line">:server</span><br><span class="line">if %i%==1 set KMS_Sev=kms7.MSGuides.com</span><br><span class="line">if %i%==2 set KMS_Sev=kms8.MSGuides.com</span><br><span class="line">if %i%==3 set KMS_Sev=kms9.MSGuides.com</span><br><span class="line">cscript //nologo ospp.vbs /sethst:%KMS_Sev% &gt;nul</span><br><span class="line">echo %KMS_Sev% &amp; echo Activating...</span><br><span class="line">cscript //nologo ospp.vbs /act | find /i &quot;successful&quot; &amp;&amp; (echo Complete) || (echo Trying another KMS Server &amp; set /a i+=1 &amp; goto server)</span><br><span class="line">pause &gt;nul</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li>
<li>保存退出后将 .txt 改为 .bat 并右键以管理员身份运行。</li>
<li>等待数分钟，出现complete字样代表激活成功。</li>
</ul>
<h2 id="激活Office-Visio-软件"><a href="#激活Office-Visio-软件" class="headerlink" title="激活Office Visio 软件"></a>激活Office Visio 软件</h2><ul>
<li>在桌面新建一个 .txt 文档。</li>
<li>在里面写入以下内容<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title Activate Microsoft Visio 2019&amp;cls&amp;echo ============================================================================&amp;echo #Visio: Activating Microsoft software products for FREE without software&amp;echo ============================================================================&amp;echo.&amp;echo #Supported products:&amp;echo - Microsoft Visio Standard 2019&amp;echo - Microsoft Visio Professional Plus 2019&amp;echo.&amp;echo.&amp;(if exist &quot;%ProgramFiles%\Microsoft Office\Office16\ospp.vbs&quot; cd /d &quot;%ProgramFiles%\Microsoft Office\Office16&quot;)&amp;(if exist &quot;%ProgramFiles(x86)%\Microsoft Office\Office16\ospp.vbs&quot; cd /d &quot;%ProgramFiles(x86)%\Microsoft Office\Office16&quot;)&amp;cscript //nologo ospp.vbs /inslic:&quot;..\root\Licenses16\pkeyconfig-office.xrm-ms&quot; &gt;nul&amp;(for /f %%x in (&#x27;dir /b ..\root\Licenses16\client-issuance*.xrm-ms&#x27;) do cscript ospp.vbs /inslic:&quot;..\root\Licenses16\%%x&quot; &gt;nul)&amp;(for /f %%x in (&#x27;dir /b ..\root\Licenses16\visioprovl_kms*.xrm-ms&#x27;) do cscript ospp.vbs /inslic:&quot;..\root\Licenses16\%%x&quot; &gt;nul)&amp;(for /f %%x in (&#x27;dir /b ..\root\Licenses16\visiopro2019vl_kms*.xrm-ms&#x27;) do cscript ospp.vbs /inslic:&quot;..\root\Licenses16\%%x&quot; &gt;nul)&amp;echo.&amp;echo ============================================================================&amp;echo 正在尝试激活...&amp;cscript //nologo ospp.vbs /unpkey:7VCBB &gt;nul&amp;cscript //nologo ospp.vbs /inpkey:9BGNQ-K37YR-RQHF2-38RQ3-7VCBB &gt;nul&amp;set i=1</span><br><span class="line">:server</span><br><span class="line">if %i%==1 set KMS_Sev=kms8.MSGuides.com</span><br><span class="line">if %i%==2 set KMS_Sev=kms9.MSGuides.com</span><br><span class="line">if %i%==3 set KMS_Sev=kms7.MSGuides.com</span><br><span class="line">if %i%==4 goto notsupported</span><br><span class="line">cscript //nologo ospp.vbs /sethst:%KMS_Sev% &gt;nul&amp;echo ============================================================================&amp;echo.&amp;echo.</span><br><span class="line">cscript //nologo ospp.vbs /act | find /i &quot;successful&quot; &amp;&amp; (echo 已完成，按任意键退出) || (echo 连接KMS服务器失败! 试图连接到另一个… &amp; echo 请等待... &amp; echo. &amp; echo. &amp; set /a i+=1 &amp; goto server)</span><br><span class="line">pause &gt;nul</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></li>
<li>保存退出后将 .txt 改为 .bat 并右键以管理员身份运行。</li>
<li>等待数分钟，出现complete字样代表激活成功。</li>
</ul>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>玩机技巧</tag>
        <tag>office</tag>
        <tag>软件破解</tag>
      </tags>
  </entry>
  <entry>
    <title>玩机：手机端破解百度云限速</title>
    <url>/Down-baiduyun.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>该篇介绍了某些通过第三方软件来进行下载百度云文件的方法</li>
<li>该篇所述内容并不一定适用于所有人、所有情况，望知悉</li>
<li>如果有钱的话，当然还是建议入正百度云会员的，毕竟充钱可以解决任何事<span id="more"></span></li>
</ul>
<h1 id="利用命令行软件来进行下载"><a href="#利用命令行软件来进行下载" class="headerlink" title="利用命令行软件来进行下载"></a>利用命令行软件来进行下载</h1><blockquote>
<p>该方法可以解决百度云账号被限速问题。亲测，被限速账号平均下载速度为1M/s，正常账号4M/s。该方法由酷安@谷花泰 提供。查看原文请点击<a href="https://www.coolapk.com/feed/9778859?shareKey=M2Y4YWYwMmFkOGM1NWM3Mzc4MWY~&shareUid=1519576&shareFrom=com.coolapk.market_9.0.2">此处</a></p>
</blockquote>
<ol>
<li><p>下载termux软件。直通车：<a href="https://www.coolapk.com/apk/com.termux">查看链接</a><br>软件刚打开时需要自动下载安装，如果无法安装可能需要翻墙，方法自寻，随便找一个临时免费VPN即可</p>
</li>
<li><p>授权存储权限，执行完后请允许授权<br>执行命令为：<code>termux-setup-storage</code></p>
</li>
<li><p>添加软件源<br>执行命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;deb [trusted=yes] http://termux.iikira.com stable main&quot; &gt;&gt; /data/data/com.termux/files/usr/etc/apt/sources.list</span><br></pre></td></tr></table></figure></li>
<li><p>更新软件源<br>执行命令为：<code>apt update</code></p>
</li>
<li><p>安装BaiduPCS-Go<br>执行命令为：<code>apt install baidupcs-go</code></p>
</li>
<li><p>开始运行BaiduPCS-Go<br>执行命令为：<code>BaiduPCS-Go</code></p>
</li>
<li><p>登录百度云账号<br>执行命令为：<code>login</code></p>
</li>
<li><p>输入账号密码，并验证手机或邮箱</p>
<blockquote>
<p>为了安全起见，密码是不会显示的。如果登录失败，可以输入 <code>login</code> 重新登录</p>
</blockquote>
</li>
<li><p>配置appid<br>执行命令为：<code>config set --appid 265486</code></p>
</li>
<li><p>配置下载位置，若保存在 <code>/sdcard/百度云</code> 文件下（这里的sdcard指的是手机内存默认目录。请确保你的/sdcard下有这个文件夹，若没有，请自行创建）<br>执行命令为：<code>config set --savedir &#39;/sdcard/百度云&#39;</code></p>
</li>
<li><p>配置下载线程，官方默认100，可以设置50~500，这里设置为300（理论上线程越大下载速度越快）<br>执行命令为：<code>config set --max_parallel 300</code></p>
</li>
<li><p>配置并行下载数量，可以设置1~5，这里设置为3<br>执行命令为：<code>config set --max_download_load 3</code></p>
</li>
<li><p>配置完成后，将termux强行关闭，即清理掉后台。<br>打开浏览器，进入百度云<a href="http://pan.baidu.com/">官网</a>并登陆账号。<br>复制下面网址，在登陆过账号的浏览器中粘贴并访问。<br><code>http://pcs.baidu.com/rest/2.0/pcs/file?app_id=265486&amp;method=list&amp;path=%2F</code></p>
</li>
<li><p>访问完后，不管页面显示什么，打开手机版百度云<br>在 <code>/我的应用数据</code> 文件夹下会多出一个名为 <code>baidu_shurufa</code> 的文件夹，如果没有，请自建。</p>
<img src="https://s1.ax1x.com/2020/10/20/BS1gl4.jpg" width="360" height="640" /></li>
<li><p>将需要下载的文件复制或移动到 <code>/我的应用数据/baidu_shurufa/</code> 目录下，比如我这里要下载 <code>动图抓取工具.rar</code> 文件</p>
<img src="https://s1.ax1x.com/2020/10/20/BS126J.jpg" width="360" height="640" /></li>
<li><p>打开termux，进入BaiduPCS-Go<br>执行命令为：<code>BaiduPCS-Go</code></p>
</li>
<li><p>进入 <code>baidu_shurufa</code> 文件夹（若下载多级文件夹下的文件，按此方法递归进入最后一个文件夹即可）<br>执行命令为：<code>cd /apps/baidu_shurufa</code></p>
</li>
<li><p>下载所需文件即可<br>执行命令为：<code>d &#39;动图抓取工具.rar&#39;</code></p>
<img src="https://s1.ax1x.com/2020/10/20/BS1RX9.jpg" width="360" height="640" /></li>
<li><p>注意，这里下载速度会有浮动，但平均下来也就4M多左右，还是可以接受的。以后下载文件，从第15点开始即可</p>
</li>
<li><p>如果有什么问题，可以参考作者的文档。直通车：<a href="https://shimo.im/docs/DkiAbUs9etAFqR3T/read">查看链接</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>实用教程</category>
      </categories>
      <tags>
        <tag>玩机技巧</tag>
        <tag>百度云</tag>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客之NexT配置教程</title>
    <url>/Hexo-02.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>在看本篇之前，请确保你已成功搭建好个人博客。如没有，请移步：<a href="/Hexo-01.html" title="[博客搭建教程]">[博客搭建教程]</a></li>
<li>该教程中的所有链接均指向为官方链接，望知悉。</li>
<li>该教程为我上一篇教程的后续教程，即 Hexo 的主题配置及修改。</li>
<li>该教程主要是针对 NexT 主题，其他主题略有出入，如有需要请自行百度。<span id="more"></span></li>
</ul>
<h1 id="一、注意事项"><a href="#一、注意事项" class="headerlink" title="一、注意事项"></a>一、注意事项</h1><ul>
<li><font color=#FF0000>所有配置内容在冒号后边均有一个空格（划重点！！！）</font></li>
<li>请区分好这两个概念，以后会以这两个名词来代指配置文件<br><img src="https://i.loli.net/2019/04/03/5ca44c8e6e491.png" alt="配置文件区分"></li>
<li>如果你修改某些配置后，没有效果，请先执行清理缓存操作，再开本地服务</li>
<li><strong style="color:red;">（2021.06.03更新）Next 主题在 7.3.0 开始，官方推荐采用数据文件将配置与主题分离，这样我们可以在不修改主题源码的同时完成选项配置、自定义布局、自定义样式，便于后续 NexT 版本更新。</strong>请点击<a href="#dataFile">这里</a>进行设置后在进行基础选项的配置。</li>
</ul>
<h1 id="二、常用指令"><a href="#二、常用指令" class="headerlink" title="二、常用指令"></a>二、常用指令</h1><h2 id="1-创建文章或页面"><a href="#1-创建文章或页面" class="headerlink" title="1.创建文章或页面"></a>1.创建文章或页面</h2><ul>
<li><code>hexo new [layout] &lt;title&gt;</code> ，layout 属性如下：<br>post：新建文章，存放路径于 <code>source/_posts</code><br>page：新建页面，如404，分类等，存放路径于 <code>source/</code><br>draft：新建草稿，存放路径于 <code>source/_drafts</code></li>
<li>上面的 <code>&lt;title&gt;</code> 属性是博文 Markdown 文件的名字，一般也会自动生成为博客文章的标题，也是博文链接的后缀（如 <a href="https://www.wrysmile.cn/2020/03/22/hexo-tutorial/">https://www.wrysmile.cn/2020/03/22/hexo-tutorial/</a> 中的<code>hexo-tutorial</code>）</li>
<li>新建文章可以使用简写命令，如本文的创建即可以用 <code>hexo n Hexo博客之NexT配置教程</code> </li>
<li>新建草稿也可以用另一个命令 <code>hexo publish [layout] &lt;title&gt;</code></li>
</ul>
<h2 id="2-上传仓库"><a href="#2-上传仓库" class="headerlink" title="2.上传仓库"></a>2.上传仓库</h2><ul>
<li><code>hexo clean</code> 清理缓存文件——db.json和已生成的静态文件——public</li>
<li><code>hexo g</code> 生成网站静态文件到默认设置的 public 文件夹</li>
<li><code>hexo s</code> 启动本地服务器，用于预览主题。默认地址：<a href="http://localhost:4000/">http://localhost:4000/</a></li>
<li><code>hexo d</code> 自动生成网站静态文件，并部署到设定的仓库</li>
</ul>
<h1 id="三、相关链接"><a href="#三、相关链接" class="headerlink" title="三、相关链接"></a>三、相关链接</h1><ul>
<li>Next主题：你可以去 NexT 官网下载，官网有下载链接、下载方法以及安装方法。<a href="http://theme-next.iissnan.com/">查看链接</a></li>
<li>Next插件：这里总结了 Next 部分插件地址。<a href="https://github.com/next-theme/awesome-next#comment">查看链接</a></li>
<li>Next更新：该地址总结了 Next 各版本更新日志。<a href="https://theme-next.js.org/">查看链接</a></li>
</ul>
<h1 id="四、基础配置"><a href="#四、基础配置" class="headerlink" title="四、基础配置"></a>四、基础配置</h1><h2 id="1-切换主题"><a href="#1-切换主题" class="headerlink" title="1.切换主题"></a>1.切换主题</h2><ul>
<li>将解压好的主题放入数据目录下的 themes 文件夹下，并改名为 next</li>
<li>打开 <font color=#1E90FF><em>站点配置文件</em></font> ，找到 theme 字段，将其改为 next<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: next          //直接把后边修改为主题名就行</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-选择-Scheme"><a href="#2-选择-Scheme" class="headerlink" title="2.选择 Scheme"></a>2.选择 Scheme</h2><ul>
<li>Scheme 这里可以理解为网站的整体布局或方案</li>
<li>NexT 内置了四种样式，在<font color=#9932CC> <em>主题配置文件</em> </font>中搜索 Schemes，然后将下面四个中任意一个前面的注释符号”#”去掉即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse        //默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span><br><span class="line">#scheme: Mist        //Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">#scheme: Pisces      //双栏 Scheme，小家碧玉似的清新</span><br><span class="line">#scheme: Gemini      //Pisces的宽松版本，看起来比较更美观</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-设置网站语言"><a href="#3-设置网站语言" class="headerlink" title="3.设置网站语言"></a>3.设置网站语言</h2><ul>
<li><p>在<font color=#1E90FF> <em>站点配置文件</em> </font>中搜索 language，在后边填入你想设置的语言即可<br><img src="https://i.loli.net/2019/04/03/5ca44ce471738.png" alt="语言"></p>
</li>
<li><p><strong style="color:red;">新版本中官方将中文的语言命名由 zh-Hans 改为了 zh-CN</strong></p>
</li>
</ul>
<h2 id="4-菜单设置"><a href="#4-菜单设置" class="headerlink" title="4.菜单设置"></a>4.菜单设置</h2><blockquote>
<p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大多数的场景，同时无须担心在 Retina 屏幕下图标模糊的问题。</p>
</blockquote>
<ul>
<li>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 menu，需要开启哪个选项就把其前面的注释符号”#”去掉即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                     //首页</span><br><span class="line">  #about: /about/ || user             //关于</span><br><span class="line">  #tags: /tags/ || tags               //标签</span><br><span class="line">  #categories: /categories/ || th     //分类</span><br><span class="line">  archives: /archives/ || archive     //归档</span><br><span class="line">  #schedule: /schedule/ || calendar   //日程表</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap   //站点地图</span><br><span class="line">  #commonweal: /404/ || heartbeat     //公益404</span><br></pre></td></tr></table></figure></li>
<li>而图标按以下内容设置，需要用哪个就去掉其前面的注释符号”#”即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  #Icon Mapping</span><br><span class="line">  #home: home</span><br><span class="line">  #about: user</span><br><span class="line">  #categories: th</span><br><span class="line">  #tags: tags</span><br><span class="line">  #archives: archive</span><br><span class="line">  #schedule: calendar</span><br><span class="line">  #sitemap: sitemap</span><br><span class="line">  #commonweal: heartbeat</span><br></pre></td></tr></table></figure></li>
<li>如需对这些页面进行配置，请<a href="#jump">点击这里</a>跳转到进阶配置</li>
</ul>
<h2 id="5-开启侧栏功能"><a href="#5-开启侧栏功能" class="headerlink" title="5.开启侧栏功能"></a>5.开启侧栏功能</h2><ul>
<li>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 sidebar，position 是指侧栏的位置，display 是指侧栏显示的时机。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line">  #position: left     //靠左放置</span><br><span class="line">  #position: right    //靠右放置（只针对于Pisces、Gemini这两个Scheme）</span><br><span class="line"></span><br><span class="line"> //（display只针对于Muse、Mist这两个Scheme）</span><br><span class="line">  #display: post      //默认行为，在文章页面（拥有目录列表）时显示</span><br><span class="line">  #display: always    //在所有页面中都显示</span><br><span class="line">  #display: hide      //在所有页面中都隐藏（可以手动展开）</span><br><span class="line">  #display: remove    //完全移除</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-修改头像"><a href="#6-修改头像" class="headerlink" title="6.修改头像"></a>6.修改头像</h2><ul>
<li>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 avatar，将值设置为头像链接地址<br><img src="https://i.loli.net/2019/04/03/5ca44d2ca5ed3.png" alt="头像修改"></li>
</ul>
<h2 id="7-修改站点标题、副标题、昵称、描述等信息"><a href="#7-修改站点标题、副标题、昵称、描述等信息" class="headerlink" title="7.修改站点标题、副标题、昵称、描述等信息"></a>7.修改站点标题、副标题、昵称、描述等信息</h2><ul>
<li>在<font color=#1E90FF> <em>站点配置文件</em> </font>中搜 Site，按需修改内容即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title:            //标题</span><br><span class="line">subtitle:         //副标题</span><br><span class="line">description:      //站点描述</span><br><span class="line">keywords:         //关键字</span><br><span class="line">author:           //作者</span><br><span class="line">language:         //语言</span><br><span class="line">timezone:         //时区</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-开启友链"><a href="#8-开启友链" class="headerlink" title="8.开启友链"></a>8.开启友链</h2><ul>
<li><p>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 Blog rolls，修改相应参数即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">links_icon: link               //友链的图标</span><br><span class="line">links_title: Links             //友链的标题</span><br><span class="line">links_layout: block            //友链的布局</span><br><span class="line">#links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  Title: http://example.com/   //显示名称：网址链接</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版更新如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_settings:</span><br><span class="line">  icon: fa fa-globe</span><br><span class="line">  title: 标题</span><br><span class="line">  # Available values: block | inline</span><br><span class="line">  layout: block</span><br><span class="line">links:</span><br><span class="line">  #Title: https://example.com</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="9-开启分享功能"><a href="#9-开启分享功能" class="headerlink" title="9.开启分享功能"></a>9.开启分享功能</h2><h3 id="1-百度分享"><a href="#1-百度分享" class="headerlink" title="(1).百度分享"></a>(1).百度分享</h3><ul>
<li><p>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 baidushare，将前边的注释符号去掉，按下边代码修改即可开启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#baidushare:</span><br><span class="line">  type: slide</span><br><span class="line">  baidushare: true</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版已移除</strong></p>
</li>
</ul>
<h3 id="2-NeedMoreShare2"><a href="#2-NeedMoreShare2" class="headerlink" title="(2).NeedMoreShare2"></a>(2).NeedMoreShare2</h3><ul>
<li><p>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中搜 needmoreshare，修改相应参数为 true 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">needmoreshare2:</span><br><span class="line">  enable: false                         //这个指全局开关</span><br><span class="line">  postbottom:                           //在文章底部显示</span><br><span class="line">    enable: true</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: default                //这里指图标风格</span><br><span class="line">      boxForm: horizontal               //这里指分享框的样式</span><br><span class="line">      position: bottomCenter            //这里位置可以根据上边注释进行自己调试</span><br><span class="line">      networks: Weibo,Wechat,QQZone     //这里需要哪些网站根据上边注释自己添加</span><br><span class="line">  float:                                //在博客中漂浮显示</span><br><span class="line">    enable: false</span><br><span class="line">    options:</span><br><span class="line">      iconStyle: default</span><br><span class="line">      boxForm: horizontal</span><br><span class="line">      position: middleRight</span><br><span class="line">      networks: Weibo,Wechat,QQZone</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版已移除</strong></p>
</li>
</ul>
<h3 id="3-jiathis"><a href="#3-jiathis" class="headerlink" title="(3).jiathis"></a>(3).jiathis</h3><ul>
<li>未收录</li>
</ul>
<h3 id="4-duoshuo-share"><a href="#4-duoshuo-share" class="headerlink" title="(4).duoshuo_share"></a>(4).duoshuo_share</h3><ul>
<li>未收录</li>
</ul>
<h2 id="10-开启”回到顶部”百分比显示"><a href="#10-开启”回到顶部”百分比显示" class="headerlink" title="10.开启”回到顶部”百分比显示"></a>10.开启”回到顶部”百分比显示</h2><ul>
<li><p>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中搜 b2t，修改相应参数为 true 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b2t: true              //是否在侧栏中开启回到顶部开关</span><br><span class="line">scrollpercent: true    //是否以百分比形式显示</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版更新如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 回到顶部按钮设置</span><br><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: true</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-开启文章内打赏功能"><a href="#11-开启文章内打赏功能" class="headerlink" title="11.开启文章内打赏功能"></a>11.开启文章内打赏功能</h2><ul>
<li><p>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中搜 reward_comment，去掉前面注释符号并修改相应内容参数即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#reward_comment: Donate comment here  //打赏内容显示</span><br><span class="line">#wechatpay: /images/wechatpay.jpg     //微信打赏图片/地址</span><br><span class="line">#alipay: /images/alipay.jpg           //支付宝打赏图片/地址</span><br><span class="line">#bitcoin: /images/bitcoin.png         //比特币打赏图片/地址</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版更新如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Donate (Sponsor) settings</span><br><span class="line"># Front-matter variable (unsupport animation).</span><br><span class="line">reward_settings:</span><br><span class="line">  # If true, a donate button will be displayed in every article by default.</span><br><span class="line">  enable: true</span><br><span class="line">  animation: true</span><br><span class="line">  comment: 介绍</span><br><span class="line">reward:</span><br><span class="line">  wechatpay: /images/wechatpay.png</span><br><span class="line">  alipay: /images/alipay.png</span><br><span class="line">  #paypal: /images/paypal.png</span><br><span class="line">  #bitcoin: /images/bitcoin.png</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="12-开启侧栏社交功能"><a href="#12-开启侧栏社交功能" class="headerlink" title="12.开启侧栏社交功能"></a>12.开启侧栏社交功能</h2><ul>
<li><p>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中搜 social，需要哪个去掉哪个前面的注释符号，并修改网址为自己的网址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#social:</span><br><span class="line">  #GitHub: https://github.com/yourname || github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || facebook</span><br><span class="line">  #VK Group: https://vk.com/yourname || vk</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || skype</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版更新如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Social Links</span><br><span class="line"># Usage: `Key: permalink || icon`</span><br><span class="line"># Key is the link label showing to end users.</span><br><span class="line"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span><br><span class="line">social:</span><br><span class="line">  #GitHub: https://github.com/yourname || fab fa-github</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || fa fa-envelope</span><br><span class="line">  #weibo: https://weibo.com/u/yoururl || fab fa-weibo</span><br><span class="line">  #Google: https://plus.google.com/yourname || fab fa-google</span><br><span class="line">  #Twitter: https://twitter.com/yourname || fab fa-twitter</span><br><span class="line">  #FB Page: https://www.facebook.com/yourname || fab fa-facebook</span><br><span class="line">  #StackOverflow: https://stackoverflow.com/yourname || fab fa-stack-overflow</span><br><span class="line">  #YouTube: https://youtube.com/yourname || fab fa-youtube</span><br><span class="line">  #Instagram: https://instagram.com/yourname || fab fa-instagram</span><br><span class="line">  #Skype: skype:yourname?call|chat || fab fa-skype</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-博客主页开启”阅读全文”功能"><a href="#13-博客主页开启”阅读全文”功能" class="headerlink" title="13.博客主页开启”阅读全文”功能"></a>13.博客主页开启”阅读全文”功能</h2><ul>
<li>博客主页默认显示所有文章内容，看起来有些冗杂，故开启”阅读全文”开关可以进行适当控制</li>
<li>这里有三种方法，自行选取适合自己的</li>
<li>第一种最为推荐，可以自己控制显示多少；<br>第二种也推荐，可以自行更改显示内容；<br>第三种不推荐，这种排版显示不美观，但可以进行全局控制。</li>
</ul>
<h3 id="1-文章截断"><a href="#1-文章截断" class="headerlink" title="(1).文章截断"></a>(1).文章截断</h3><ul>
<li><code>&lt;!-- more --&gt;</code> 语法，在文章开头适当位置插入 <code>&lt;!-- more --&gt;</code> 即可进行首页内容控制</li>
</ul>
<h3 id="2-描述"><a href="#2-描述" class="headerlink" title="(2).描述"></a>(2).描述</h3><ul>
<li>在文章中的 <code>front-matter</code> 中添加 description ，并插入你想要显示的内容摘要即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: Hello world</span><br><span class="line">data: 2019-02-02 20:33:56</span><br><span class="line">tags: 标签</span><br><span class="line">categories: 分类</span><br><span class="line">description: //这里填写对该篇文章的描述，该描述仅在首页显示，进入文章后不显示</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-主题自带"><a href="#3-主题自带" class="headerlink" title="(3).主题自带"></a>(3).主题自带</h3><ul>
<li><p>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 auto_excerpt，对相应参数进行修改即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto_excerpt:     //自动形成摘要</span><br><span class="line">  enable: false   //选择是否开启</span><br><span class="line">  length: 150     //对文章开头的截取长度，默认150个字符</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版更新如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Automatically excerpt description in homepage as preamble text.</span><br><span class="line">excerpt_description: true</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-修改网站图标"><a href="#14-修改网站图标" class="headerlink" title="14.修改网站图标"></a>14.修改网站图标</h2><ul>
<li>找一些自己心仪的图标，并下载 16x16/32x32 且格式为 png 的图标图片</li>
<li>将这两张图片分别改名为 <code>favicon-16x16.png</code> <code>favicon-32x32.png</code>并放置在 <code>themes\next\source\images\</code> 目录下</li>
<li>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 favicon，修改相应的图片即可</li>
</ul>
<h2 id="15-开启网站顶部刷新进度加载条"><a href="#15-开启网站顶部刷新进度加载条" class="headerlink" title="15.开启网站顶部刷新进度加载条"></a>15.开启网站顶部刷新进度加载条</h2><ul>
<li><p>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 pace，对相应参数进行修改，需要哪种样式就去掉前面的注释符号即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pace: true</span><br><span class="line"># Themes list:</span><br><span class="line">#pace-theme-big-counter</span><br><span class="line">#pace-theme-bounce</span><br><span class="line">#pace-theme-center-atom</span><br><span class="line">#pace-theme-center-circle</span><br><span class="line">#pace-theme-center-radar</span><br><span class="line">#pace-theme-center-simple</span><br><span class="line">#pace-theme-flash</span><br><span class="line">#pace-theme-loading-bar</span><br><span class="line">#pace-theme-mac-osx</span><br><span class="line">#pace-theme-minimal</span><br><span class="line">#For example</span><br><span class="line">pace_theme: pace-theme-flash</span><br><span class="line">#pace_theme: pace-theme-minimal</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版已移除，只有一种默认进度条，如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Progress bar in the top during page loading.</span><br><span class="line"># For more information: https://github.com/rstacruz/nprogress</span><br><span class="line">nprogress:</span><br><span class="line">  enable: true</span><br><span class="line">  spinner: false</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="16-开启网站动态背景效果"><a href="#16-开启网站动态背景效果" class="headerlink" title="16.开启网站动态背景效果"></a>16.开启网站动态背景效果</h2><ul>
<li><p>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 canvas_nest，之后的四行代码对应动态背景的配置，NexT 中内置了四种动态背景，对相应的参数进行修改即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: false</span><br><span class="line"># three_waves</span><br><span class="line">three_waves: false</span><br><span class="line"># canvas_lines</span><br><span class="line">canvas_lines: true</span><br><span class="line"># canvas_sphere</span><br><span class="line">canvas_sphere: false</span><br></pre></td></tr></table></figure></li>
<li><p>这里可以同时开启多个特效，但容易对网站造成相应的<font color=#ff0000>资源损耗</font>，建议不要这样做</p>
</li>
<li><p><strong style="color:red;">新版已移除，解决办法请 <a href="#canvas">移步</a> 到这里进行查看</strong></p>
</li>
</ul>
<h2 id="17-Front-matter-的设置"><a href="#17-Front-matter-的设置" class="headerlink" title="17.Front-matter 的设置"></a>17.Front-matter 的设置</h2><h3 id="1-什么是-Front-matter"><a href="#1-什么是-Front-matter" class="headerlink" title="(1).什么是 Front-matter"></a>(1).什么是 Front-matter</h3><ul>
<li>就是博文最上方以 <code>---</code> 分隔的那部分，主要用来对文章进行一些修饰</li>
</ul>
<h3 id="2-默认可以使用的参数"><a href="#2-默认可以使用的参数" class="headerlink" title="(2).默认可以使用的参数"></a>(2).默认可以使用的参数</h3><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">layout</td>
<td align="center">布局</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">title</td>
<td align="center">标题</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">date</td>
<td align="center">建立日期</td>
<td align="center">文件建立日期</td>
</tr>
<tr>
<td align="center">updated</td>
<td align="center">更新日期</td>
<td align="center">文件更新日期</td>
</tr>
<tr>
<td align="center">comments</td>
<td align="center">开启文章的评论功能</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">tags</td>
<td align="center">标签（不适用于分页）</td>
<td align="center">多个标签用[,]分隔</td>
</tr>
<tr>
<td align="center">categories</td>
<td align="center">分类（不适用于分页）</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">permalink</td>
<td align="center">覆盖文章网址</td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="3-怎么修改"><a href="#3-怎么修改" class="headerlink" title="(3).怎么修改"></a>(3).怎么修改</h3><ul>
<li>打开你 Hexo 的根目录，找到 <code>scaffolds</code> 文件中的 <code>post.md</code>文件，并用 VScode，记事本等软件打开</li>
<li>需要添加哪些功能，按格式添加即可，注意每个参数后面都需要加一个空格</li>
</ul>
<h1 id="五、进阶配置"><a href="#五、进阶配置" class="headerlink" title="五、进阶配置"></a>五、进阶配置</h1><h2 id="1-添加标签、分类、关于、归档等页面"><a href="#1-添加标签、分类、关于、归档等页面" class="headerlink" title="1.添加标签、分类、关于、归档等页面"></a>1.<span id="jump">添加标签、分类、关于、归档等页面</span></h2><ul>
<li>在基础配置中我们已经开启了这三个页面，但当你实际去点这些页面时，你会发现跳转页面显示404错误，这是因为我们还没有创建这些页面，通过下面指令来进行创建。</li>
</ul>
<h3 id="1-创建"><a href="#1-创建" class="headerlink" title="(1).创建"></a>(1).创建</h3><ul>
<li>在 hexo 的根目录打开 git 命令行</li>
<li>分别输入以下命令即可：<br>新建标签页——输入命令 <code>hexo new page &quot;tags&quot;</code><br>新建分类页——输入命令 <code>hexo new page &quot;categories&quot;</code><br>新建关于页——输入命令 <code>hexo new page &quot;about&quot;</code><br>新建归档页——输入命令 <code>hexo new page &quot;archives&quot;</code></li>
</ul>
<h3 id="2-修改内容"><a href="#2-修改内容" class="headerlink" title="(2).修改内容"></a>(2).修改内容</h3><ul>
<li><p>在 Hexo 的根目录下找到 <code>source</code> 文件夹，新建好的页面就在里面，用 Markdown 编辑器打开 .md 文件进行编写，内容如下：</p>
</li>
<li><p>标签页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 标签                 //这里为你在主页想要显示的文字</span><br><span class="line">date: 2019-01-23 14:39:14   //这里为日期，默认，无需改动</span><br><span class="line">type: &quot;tags&quot;                //这里的类型一定要和基础配置中的菜单中的英文对应</span><br></pre></td></tr></table></figure></li>
<li><p>分类页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 分类                 //这里为你在主页想要显示的文字</span><br><span class="line">date: 2019-01-23 14:45:41   //这里为日期，默认，无需改动</span><br><span class="line">type: &quot;categories&quot;          //这里的类型一定要和基础配置中的菜单中的英文对应</span><br></pre></td></tr></table></figure></li>
<li><p>关于页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 关于                 //这里为你在主页想要显示的文字</span><br><span class="line">date: 2019-01-23 14:47:58   //这里为日期，默认，无需改动</span><br><span class="line">type: &quot;about&quot;               //这里的类型一定要和基础配置中的菜单中的英文对应</span><br><span class="line">//关于页面三个横线下边可以写你关于自己的描述，语法为Markdown语法</span><br></pre></td></tr></table></figure></li>
<li><p>归档页</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 归档                 //这里为你在主页想要显示的文字</span><br><span class="line">date: 2019-01-23 14:50:49   //这里为日期，默认，无需改动</span><br><span class="line">type: &quot;archives&quot;            //这里的类型一定要和基础配置中的菜单中的英文对应</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-添加评论功能"><a href="#2-添加评论功能" class="headerlink" title="2.添加评论功能"></a>2.添加评论功能</h2><h3 id="1-来必力评论"><a href="#1-来必力评论" class="headerlink" title="(1).来必力评论"></a>(1).来必力评论</h3><blockquote>
<p>使用社交网站账户登录，免去注册过程。<br>提高用户的参与和沟通意愿。<br>管理/删除我的评论内容。<br>提供管理页面，管理网站文章及评论内容。</p>
</blockquote>
<ol>
<li>去来必力官网注册账号。直达链接：<a href="https://www.livere.com/">查看链接</a></li>
<li>进入管理页面<br><img src="https://i.loli.net/2019/04/03/5ca44d6fa5c18.png" alt="管理页面"></li>
<li>选择 City 免费版本<br><img src="https://i.loli.net/2019/04/03/5ca44dd6b89b2.png" alt="City版"></li>
<li>选择一般网站，找到 uid 这一行，复制后面的值<br><img src="https://i.loli.net/2019/04/03/5ca44e0a6000f.png" alt="uid"></li>
<li>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中搜 livere_uid，粘贴刚刚复制的 uid 的值即可<br><img src="https://i.loli.net/2019/04/03/5ca44e9be7598.png" alt="粘贴uid"></li>
<li>进入博客可以看到，来必力评论功能已添加<br><img src="https://i.loli.net/2019/04/03/5ca44ed1a37d9.png" alt="评论功能"></li>
</ol>
<h3 id="2-Waline评论"><a href="#2-Waline评论" class="headerlink" title="(2).Waline评论"></a>(2).Waline评论</h3><ul>
<li><p>前面的来比力评论加载速度总是很慢，所以之后打算换为 Valine 评论，结果发现在 Next8.2.0 版本中移除了对 Valine 的支持，查阅后发现是因为安全问题，可<a href="https://imnerd.org/valine-may-not-so-good.html">查看</a>这里进行了解</p>
</li>
<li><p>根据上文可得知 Waline 解决了 Valine 安全问题</p>
</li>
<li><p>配置方法可<a href="https://waline.js.org/guide/get-started.html#leancloud-%E8%AE%BE%E7%BD%AE-%E6%95%B0%E6%8D%AE%E5%BA%93">查看</a>该链接进行配置</p>
</li>
</ul>
<h2 id="3-添加网页在线联系功能"><a href="#3-添加网页在线联系功能" class="headerlink" title="3.添加网页在线联系功能"></a>3.添加网页在线联系功能</h2><ol>
<li>去 DaoVoice 官网注册一个账号。<del>直达链接：<a href="http://www.daovoice.io/">查看链接</a></del><ul>
<li><strong style="color:red;">经读者2021.3.17日反映上面链接已经失效，现已更新请<a href="http://dashboard.daovoice.io/">点击这里</a></strong></li>
</ul>
</li>
<li>在这里填入此邀请码——13e39436<br> <img src="https://i.loli.net/2019/04/03/5ca44f03d659a.png" alt="DaoVoice"></li>
<li>找到这段中的 app_id，以后会用到<br> <img src="https://i.loli.net/2019/04/03/5ca44f33072b4.png" alt="app_id"></li>
<li>找到 <code>/themes/next/layout/_partials/head.swig</code> 这个文件，在这两段中间插入这段代码<br> <img src="https://i.loli.net/2019/04/03/5ca44f58de91d.png" alt="插入位置"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&#x27;https:&#x27; == document.location.protocol ? &#x27;https:&#x27; : &#x27;http:&#x27;) + &quot;//widget.daovoice.io/widget/2e5d695d.js&quot;,&quot;daovoice&quot;)</span><br><span class="line">  daovoice(&#x27;init&#x27;, &#123;</span><br><span class="line">      app_id: &quot;theme.daovoice_app_id&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(&#x27;update&#x27;);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：将第三行后边的 <code>//widget.daovoice.io/widget/2e5d695d.js</code> 中js文件名改成自己的id就行（即2e5d695d改为自己的id）；将第五行的 <code>theme.daovoice_app_id</code> 部分换为自己的id。</p>
</blockquote>
</li>
</ol>
<ul>
<li><strong style="color:red;">新版 Next 优化：</strong>将以上代码直接粘贴到 <code>source\_data\head.njk</code> 中即可</li>
</ul>
<ol start="5">
<li>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中添加以下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Online contact</span><br><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id:     //这里填你刚才获得的 app_id</span><br></pre></td></tr></table></figure></li>
<li>然后去 DaoVoice 控制台中的应用设置-聊天设置中进行个性化设置</li>
</ol>
<h2 id="4-设置-RSS-订阅"><a href="#4-设置-RSS-订阅" class="headerlink" title="4.设置 RSS 订阅"></a>4.设置 RSS 订阅</h2><blockquote>
<p>RSS 订阅是站点用来和其他站点之间共享内容的一种简易方式，即 Really Simple Syndication(简易信息聚合)，使用这个东西就可以把自己写的博客推送给读者。</p>
</blockquote>
<ol>
<li>在 Git 中安装 hexo-generator-feed 插件<br>命令为： <code>npm install hexo-generator-feed --save</code></li>
<li>在 <font color=#1E90FF> <em>站点配置文件</em> </font> 中在最后一行写入以下代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">feed:</span><br><span class="line"> type: atom</span><br><span class="line"> path: atom.xml</span><br><span class="line"> limit: 20</span><br><span class="line"> hub:</span><br><span class="line"> content:</span><br><span class="line"> content_limit: 140</span><br><span class="line"> content_limit_delim: &#x27; &#x27;</span><br></pre></td></tr></table></figure></li>
<li>各参数的含义如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type:    RSS的类型(atom/rss2)</span><br><span class="line">path:    文件路径,默认是atom.xml/rss2.xml</span><br><span class="line">limit:   展示文章的数量,使用0或则false代表展示全部</span><br><span class="line">hub:</span><br><span class="line">content: 在RSS文件中是否包含内容 ,有3个值 true/false默认不填为false</span><br><span class="line">content_limit: 指定内容的长度作为摘要,仅仅在上面content设置为false和没有自定义的描述出现</span><br><span class="line">content_limit_delim: 上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断.</span><br></pre></td></tr></table></figure></li>
<li>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中搜 rss，按以下设置即可开启 RSS 功能<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5-添加网页标题崩溃欺骗搞怪特效"><a href="#5-添加网页标题崩溃欺骗搞怪特效" class="headerlink" title="5.添加网页标题崩溃欺骗搞怪特效"></a>5.添加网页标题崩溃欺骗搞怪特效</h2><ul>
<li>该特效来自一位博主的教程。直达链接：<a href="https://asdfv1929.github.io/2018/01/25/crash-cheat/">查看链接</a></li>
<li>旧版 Next 无法生效，新版 Next 将以下代码粘贴到 <code>source\_data\footer.njk</code> 文件中即可：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;# 崩溃欺骗 #&#125;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"> var OriginTitle = document.title;</span><br><span class="line"> var titleTime;</span><br><span class="line"> document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123;</span><br><span class="line">     if (document.hidden) &#123;</span><br><span class="line">         $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/img/TEP.ico&quot;);</span><br><span class="line">         document.title = &#x27;╭(°A°`)╮ 页面崩溃啦 ~&#x27;;</span><br><span class="line">         clearTimeout(titleTime);</span><br><span class="line">     &#125;</span><br><span class="line">     else &#123;</span><br><span class="line">         $(&#x27;[rel=&quot;icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/favicon.ico&quot;);</span><br><span class="line">         document.title = &#x27;(ฅ&gt;ω&lt;*ฅ) 噫又好了~&#x27; + OriginTitle;</span><br><span class="line">         titleTime = setTimeout(function () &#123;</span><br><span class="line">             document.title = OriginTitle;</span><br><span class="line">         &#125;, 2000);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-添加动态二次元人物"><a href="#6-添加动态二次元人物" class="headerlink" title="6.添加动态二次元人物"></a>6.添加动态二次元人物</h2><ol>
<li><p>Git 端安装 hexo-helper-live2d 插件<br>命令为： <code>npm install --save hexo-helper-live2d</code></p>
</li>
<li><p>在<font color=#1E90FF> <em>站点配置文件</em> </font>中添加以下代码，详细配置请参考 <a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md">文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true                  //控制开关</span><br><span class="line">  scriptFrom: local             //默认</span><br><span class="line">  pluginRootPath: live2dw/      //插件在站点上的根目录(相对路径)</span><br><span class="line">  pluginJsPath: lib/            //脚本文件相对与插件根目录路径</span><br><span class="line">  pluginModelPath: assets/      //模型文件相对与插件根目录路径</span><br><span class="line">  tagMode: false       //标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span><br><span class="line">  debug: false         //调试, 是否在控制台输出日志</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-koharu     //使用的模型名字</span><br><span class="line">  display:</span><br><span class="line">    position: right    //放置位置</span><br><span class="line">    width: 150         //调整宽度</span><br><span class="line">    height: 300        //调整高度</span><br><span class="line">    #hOffset: 0        //调整水平位置，如需要请去掉注释</span><br><span class="line">    #vOffset: -20      //调整垂直位置，如需要请去掉注释</span><br><span class="line">  mobile:</span><br><span class="line">    show: true         //是否在手机端显示，为了不影响观看效果，建议关闭该选项</span><br></pre></td></tr></table></figure></li>
<li><p>下载模型，模型名称可以去 <a href="https://github.com/xiazeyu/live2d-widget-models">这里</a> 参考，命令为：<code>npm install live2d-widget-model-koharu</code></p>
<blockquote>
<p>live2d-widget-model-koharu 即为模型名字，只需修改这里就行，这个模型就是我当前博客正在使用的，请将目光移到左下角。</p>
</blockquote>
</li>
<li><p>下载完成后，在 Hexo 的根目录新建一个名为 <code>live2d_models</code> 的文件夹，在 <code>node_modules</code> 文件夹中找到刚刚下载的 live2d 模型，并将其复制到刚刚新建的文件夹内</p>
</li>
<li><p>修改第3步的代码 use 段，将其改为你下载的模型名称即可</p>
</li>
</ol>
<h2 id="7-开启爱心点击效果"><a href="#7-开启爱心点击效果" class="headerlink" title="7.开启爱心点击效果"></a>7.开启爱心点击效果</h2><ol>
<li>在 <code>themes\next\source\js\src\</code> 目录下新建 <code>clicklove.js</code> 文件，在其中添加以下代码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br></pre></td></tr></table></figure></li>
<li>在 <code>themes\next\layout\_layout.swig</code> 文件末尾添加以下代码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clicklove.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><del>目前无效，正在寻找解决方法</del></li>
<li><font color=#FF0000>无效原因已找到：之前因为是将博客部署在了 Gitee 上，这个上边不显示，后来我把博客部署在了 Github 上，发现这个特效突然出现了，初步猜测是这个原因。</font></li>
</ol>
<h3 id="新版-Next-设置"><a href="#新版-Next-设置" class="headerlink" title="!!!新版 Next 设置"></a>!!!新版 Next 设置</h3><ul>
<li>只需要将以下代码粘贴到 <code>source\_data\footer.njk</code> 文件中即可（没有请新建）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;# 页面点击小红心 #&#125;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    !function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="8-修改文章内链接文本的样式"><a href="#8-修改文章内链接文本的样式" class="headerlink" title="8.修改文章内链接文本的样式"></a>8.修改文章内链接文本的样式</h2><ul>
<li><p>打开 <code>themes\next\source\css\_custom\</code> 目录下的 <code>custom.styl</code> 文件，在第一行 <code>\\Custom styles</code> 后边插入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if hexo-config(&quot;custom_css.post_body_a.enable&quot;)</span><br><span class="line">  .post-body</span><br><span class="line">    a:not(.btn)&#123;</span><br><span class="line">      color: convert(hexo-config(&quot;custom_css.post_body_a.normal_color&quot;));</span><br><span class="line">      border-bottom: none;</span><br><span class="line">      &amp;:hover &#123;</span><br><span class="line">        color: convert(hexo-config(&quot;custom_css.post_body_a.hover_color&quot;));</span><br><span class="line">        text-decoration: underline;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的 <code>a:not(.btn)</code> 是为了不影响首页的“阅读全文”按钮。这里，我们用了 <code>hexo-config()</code> 函数读取配置，用 stylus 的内建函数 <code>convert()</code> 转换成 stylus 需要的颜色格式。</p>
</blockquote>
</li>
<li><p>在<font color=##9932CC> <em>主题配置文件</em> </font>的末尾填上如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">custom_css:</span><br><span class="line">  # the style of post body link</span><br><span class="line">  post_body_a:</span><br><span class="line">    enable: true                //是否开启</span><br><span class="line">    normal_color: &quot;#4D4DFF&quot;     //原始链接的颜色，这里是蓝色(颜色可自己修改)</span><br><span class="line">    hover_color: &quot;#fc6423&quot;      //鼠标经过时的颜色，这里是橙色(颜色可自己修改)</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版 Next 优化：</strong>将第一段代码粘贴到 <code>source\_data\styles.styl</code> 文件中即可</p>
</li>
</ul>
<h2 id="9-修改文章底部标签前面的图标"><a href="#9-修改文章底部标签前面的图标" class="headerlink" title="9.修改文章底部标签前面的图标"></a>9.修改文章底部标签前面的图标</h2><blockquote>
<p>文章下边标签的图标默认为 “#” 号，并不美观。通过修改代码可以改为比较好看的图标</p>
</blockquote>
<ul>
<li><p>在 <code>themes\next\layout\_macro\</code> 文件夹下的 <code>post.swig</code> 文件中搜 <code>rel=&quot;tag&gt;#&quot;</code> ，将#号换为 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code> ，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>然后就换为比较美观的一个小图标了<br><img src="https://i.loli.net/2019/04/03/5ca44fcab9b8d.png" alt="实用技巧"></p>
</li>
<li><p><strong style="color:red;">新版 Next 优化：</strong>在<font color=##9932CC> <em>主题配置文件</em> </font>将 <code>tag_icon</code> 改为true即可</p>
</li>
</ul>
<h2 id="10-自定义代码块样式"><a href="#10-自定义代码块样式" class="headerlink" title="10.自定义代码块样式"></a>10.自定义代码块样式</h2><ul>
<li><p>打开 <code>themes\next\source\css\_custom\</code> 目录下的 <code>custom.styl</code> 文件，向里面加入以下代码（颜色可以自定义）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Custom styles.</span><br><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br><span class="line">// 大代码块的自定义样式</span><br><span class="line">.highlight, pre &#123;</span><br><span class="line">    margin: 5px 0;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">.highlight, code, pre &#123;</span><br><span class="line">    border: 1px solid #d6d6d6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版 Next 优化：</strong>将以上代码粘贴到 <code>source\_data\styles.styl</code> 文件中即可</p>
</li>
</ul>
<h2 id="11-隐藏网站底部的驱动信息"><a href="#11-隐藏网站底部的驱动信息" class="headerlink" title="11.隐藏网站底部的驱动信息"></a>11.隐藏网站底部的驱动信息</h2><blockquote>
<p>创建好博客后，页面底部会有“由Hexo强力驱动”字样，如果不想要这部分信息，可按以下操作进行</p>
</blockquote>
<ul>
<li><p>打开 <code>themes\next\layout\_partials\</code> 文件夹下的 <code>footer.swig</code> 文件，使用注释符号 <code>&lt;!-- 示例 --&gt;</code> 注释掉以下代码即可<br><img src="https://i.loli.net/2019/04/03/5ca4503a5af22.png" alt="去除驱动"></p>
</li>
<li><p><strong style="color:red;">新版 Next</strong> 只需要在<font color=##9932CC> <em>主题配置文件</em> </font>中 <code>footer</code> 字段中的 <code>powered</code> 值改为 false即可</p>
</li>
</ul>
<h2 id="12-在网站底部添加访客量、总访问量"><a href="#12-在网站底部添加访客量、总访问量" class="headerlink" title="12.在网站底部添加访客量、总访问量"></a>12.在网站底部添加访客量、总访问量</h2><ul>
<li><p>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 busuanzi_count，对相应参数进行修改即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true                                       //是否开启不蒜子统计功能</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true                                      //是否开启统计访客数</span><br><span class="line">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访客数   //前半部分为图标，后半部分为显示的文字</span><br><span class="line">  site_uv_footer:</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true                                      //是否开启统计总访问量</span><br><span class="line">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量  //前半部分为图标，后半部分为显示的文字</span><br><span class="line">  site_pv_footer:</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: false                                      //是否开启博文阅读量</span><br><span class="line">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读数 //前半部分为图标，后半部分为显示的文字</span><br><span class="line">  page_pv_footer:</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版更新如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Show Views / Visitors of the website / page with busuanzi.</span><br><span class="line"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="13-添加字数统计、阅读时长统计功能"><a href="#13-添加字数统计、阅读时长统计功能" class="headerlink" title="13.添加字数统计、阅读时长统计功能"></a>13.添加字数统计、阅读时长统计功能</h2><ol>
<li>Git端安装 <code>hexo-wordcount</code> 插件，命令为：<code>npm install hexo-wordcount --save</code></li>
<li>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 post_wordcount，对相应参数进行修改即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true      #单篇 字数统计</span><br><span class="line">  min2read: true       #单篇 阅读时长</span><br><span class="line">  totalcount: false    #网站 字数统计</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure></li>
<li>如需修改显示格式，打开 <code>themes\next\layout\_macro\</code> 文件夹中的 <code>post.swig</code> 文件，按下图修改即可<br><img src="https://i.loli.net/2019/04/03/5ca4507aa422e.png" alt="字数统计"></li>
</ol>
<ul>
<li><strong style="color:red;">新版已移除，推荐使用 <strong>symbols_count_time</strong> ，方法在下面</strong></li>
</ul>
<h3 id="symbols-count-time方法"><a href="#symbols-count-time方法" class="headerlink" title="!symbols_count_time方法"></a>!symbols_count_time方法</h3><ul>
<li><p>在 git 命令行执行以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 卸载原有依赖 不卸载对新插件有影响</span><br><span class="line">npm uninstall hexo-wordcount</span><br><span class="line"># 安装新依赖</span><br><span class="line">npm i hexo-symbols-count-time</span><br></pre></td></tr></table></figure></li>
<li><p>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 symbols_count_time，对相应参数进行修改即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  # 换行显示字数统计和阅读时长</span><br><span class="line">  separated_meta: true</span><br><span class="line">  # 文章底部显示</span><br><span class="line">  item_text_post: true</span><br><span class="line">  # 博客底部显示 默认为false</span><br><span class="line">  item_text_total: true</span><br></pre></td></tr></table></figure></li>
<li><p>在<font color=#1E90FF> <em>站点配置文件</em> </font>中可以设置显示哪些内容和一些统计维度（没有该字段自行添加即可）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  # 文章字数</span><br><span class="line">  symbols: true</span><br><span class="line">  # 阅读时长</span><br><span class="line">  time: true</span><br><span class="line">  # 总文章字数</span><br><span class="line">  total_symbols: true</span><br><span class="line">  # 阅读总时长</span><br><span class="line">  total_time: true</span><br><span class="line">  # 是否排除代码统计</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  # 平均字长 即将多少个字符统计为1个字数</span><br><span class="line">  awl: 4</span><br><span class="line">  # 每分钟的字数 阅读速度</span><br><span class="line">  wpm: 275</span><br><span class="line">  # 统计单位 这里是分钟</span><br><span class="line">  suffix: &quot;mins.&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="14-用-LeanCloud-添加阅读次数统计功能"><a href="#14-用-LeanCloud-添加阅读次数统计功能" class="headerlink" title="14.用 LeanCloud 添加阅读次数统计功能"></a>14.用 LeanCloud 添加阅读次数统计功能</h2><blockquote>
<p>该功能在第十二点的 busuanzi 配置中已有，但其在博客首页并不显示，且不能管理相关博文的阅读量（我认为是缺点），所以我选择 LeanCloud。</p>
</blockquote>
<ol>
<li>先去 LeanCloud 官网注册。直达链接：<a href="https://leancloud.cn/">查看链接</a></li>
<li>在控制台创建一个新应用，名称随便起，选开发版<br><img src="https://i.loli.net/2019/04/03/5ca450ae44f79.png" alt="创建新应用"></li>
<li>点击新创建好的应用的右上角，找到“应用key”选项，之后会用到这些信息<br><img src="https://i.loli.net/2019/04/03/5ca450d6bc1cb.png" alt="应用key"></li>
<li>点击存储-创建class，这里的 class 名称为了不出错，最好用 <code>Counter</code><br><img src="https://i.loli.net/2019/04/03/5ca451072702d.png" alt="创建class"></li>
<li>在设置-安全中心-Web安全域名处填入自己的博客地址<br><img src="https://i.loli.net/2019/04/03/5ca45138828ed.png" alt="安全域名"></li>
<li>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中搜 leancloud_visitors，修改相应配置为 true ，再把第三步的信息填入即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: #你的app_id</span><br><span class="line">  app_key: #你的的app_key</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="15-设置文章置顶功能"><a href="#15-设置文章置顶功能" class="headerlink" title="15.设置文章置顶功能"></a>15.设置文章置顶功能</h2><ul>
<li><p>安装支持文章置顶的插件<br>先移除旧插件，命令为：<code>npm uninstall hexo-generator-index --save</code><br>再安装新插件，命令为：<code>npm install hexo-generator-index-pin-top --save</code></p>
</li>
<li><p>设置置顶标志<br>打开 <code>themes\next\layout\_macro</code> 目录下的 <code>post.swig</code> 文件，定位到 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 字段，在该行下边加入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">  &lt;font color=&quot;red&quot;&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版 Next 不建议修改主题源文件，而是在数据文件中进行修改，方法如下：</strong></p>
<ul>
<li>在 <code>source\_data\</code> 下打开 <code>post-meta.njk</code> 文件（没有则新建）</li>
<li>在该文件中新增如下字段：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot; style=&quot;margin: 0 5px;&quot;&gt; | &lt;/span&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">    &lt;i class=&quot;fa fa-thumbtack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">  &lt;font color=&quot;red&quot; style=&quot;margin: 0 3px;&quot;&gt;置顶&lt;/font&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>开启置顶功能</p>
<ul>
<li>想要某篇文章置顶，就去该篇文章的 <code>Front-matter</code> 中加入 <code>top: true</code> 字样。这里 true 可以换为数字，多篇文章置顶情况下，数字越大的越在最上边</li>
<li><code>Front-matter</code> 即为每篇文章最前面部分，如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 个人博客搭建入门教程</span><br><span class="line">date: 2019-01-26 23:31:51</span><br><span class="line">tags: 实用技巧</span><br><span class="line">categories: 博客搭建</span><br><span class="line">copyright: true</span><br><span class="line">top: true</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果想要将 top 预置入 <code>Front-matter</code> 将前往<a href="#jumpp">这里</a></p>
</li>
</ul>
<h2 id="16-插入网易云音乐"><a href="#16-插入网易云音乐" class="headerlink" title="16.插入网易云音乐"></a>16.插入网易云音乐</h2><h3 id="1-在侧栏中插入网易云音乐接口"><a href="#1-在侧栏中插入网易云音乐接口" class="headerlink" title="(1).在侧栏中插入网易云音乐接口"></a>(1).在侧栏中插入网易云音乐接口</h3><ol>
<li>打开 <code>themes\next\layout\_macro</code> 目录下的 <code>sidebar.swig</code> 文件，定位到 <code>include &#39;../_custom/sidebar.swig&#39;</code> 这一长串代码，在 <code>&lt;/div&gt;</code> 下边加入这一段代码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=86 height=86 src=&quot;&#123;&#123; theme.background_music &#125;&#125;&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></li>
<li>如下图：<br><img src="https://i.loli.net/2019/04/03/5ca45176524e6.png" alt="sidebar添加网易云"></li>
<li>打开网页端网易云音乐，找到你想要插的歌曲，进入播放页面点击“生成外链播放器”<br><img src="https://i.loli.net/2019/04/03/5ca451a159d5b.png" alt="找歌"></li>
<li>在这个界面找到框住的内容<br><img src="https://i.loli.net/2019/04/03/5ca451f436083.png" alt="斜杠后内容"></li>
<li>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中适当位置增加网易云入口<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 侧栏网易云音乐链接</span><br><span class="line">background_music:      //这里填写上一步红框中的内容,冒号后边有空格</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>图片如下：<br><img src="https://i.loli.net/2019/04/03/5ca45221501d1.png" alt="添加网易云链接"></li>
</ul>
<h3 id="2-在文章中插入网易云链接"><a href="#2-在文章中插入网易云链接" class="headerlink" title="(2).在文章中插入网易云链接"></a>(2).在文章中插入网易云链接</h3><ol>
<li>打开网页端网易云音乐，找到你想要插的歌曲，进入播放页面点击“生成外链播放器”<br><img src="https://i.loli.net/2019/04/03/5ca451a159d5b.png" alt="找歌"></li>
<li>将以下代码直接插入文章中即可<br><img src="https://i.loli.net/2019/04/03/5ca4526c790d2.png" alt="修改播放器样式"><blockquote>
<p>想要将歌曲改为歌单的请百度：怎么把自己的歌单做成外链</p>
</blockquote>
</li>
</ol>
<h2 id="17-在文章底部增加版权信息"><a href="#17-在文章底部增加版权信息" class="headerlink" title="17.在文章底部增加版权信息"></a>17.在文章底部增加版权信息</h2><h3 id="1-NexT内置的Copyright功能"><a href="#1-NexT内置的Copyright功能" class="headerlink" title="(1).NexT内置的Copyright功能"></a>(1).NexT内置的Copyright功能</h3><ul>
<li>在 <font color=##9932CC> <em>主题配置文件</em> </font> 中 post_copyright，将 false 改为 true<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 3.0</span><br><span class="line">  license_url: https://creativecommons.org/licenses/by-nc-sa/3.0/</span><br></pre></td></tr></table></figure></li>
<li>之后所有文章都会带有版权信息</li>
</ul>
<h3 id="2-个性化配置版权信息"><a href="#2-个性化配置版权信息" class="headerlink" title="(2).个性化配置版权信息"></a>(2).个性化配置版权信息</h3><ol>
<li><p>在 <code>themes\next\layout\_macro\</code> 目录下新建名为 <code>my-copyright.swig</code> 文件，向其中插入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line">&lt;div class=&quot;my_post_copyright&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &lt;span class=&quot;copy-path&quot;  title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;  aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt;  </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var clipboard = new Clipboard(&#x27;.fa-clipboard&#x27;);</span><br><span class="line">    $(&quot;.fa-clipboard&quot;).click(function()&#123;</span><br><span class="line">      clipboard.on(&#x27;success&#x27;, function()&#123;</span><br><span class="line">        swal(&#123;   </span><br><span class="line">          title: &quot;&quot;,   </span><br><span class="line">          text: &#x27;复制成功&#x27;,</span><br><span class="line">          icon: &quot;success&quot;,</span><br><span class="line">          showConfirmButton: true</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中间的标题、作者、时间，最后更新、原始链接、许可协议等都可以自己修改</p>
</blockquote>
</li>
<li><p>在 <code>themes\next\source\css\_common\components\post\</code> 目录下新建名为 <code>my-post-copyright.styl</code> 文件，向其中插入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.my_post_copyright &#123;</span><br><span class="line">  width: 85%;</span><br><span class="line">  max-width: 45em;</span><br><span class="line">  margin: 2.8em auto 0;</span><br><span class="line">  padding: 0.5em 1.0em;</span><br><span class="line">  border: 1px solid #d3d3d3;</span><br><span class="line">  font-size: 0.93rem;</span><br><span class="line">  line-height: 1.6em;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  background: rgba(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class="line">.my_post_copyright span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 5.2em;</span><br><span class="line">  color: #b5b5b5;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .raw &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  border-bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a:hover &#123;</span><br><span class="line">  color: #a3d2a3;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .post-url:hover &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 1em;</span><br><span class="line">  +mobile()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path:hover &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>themes\next\layout\_macro\post.swig</code> 文件中，定位到 <code>theme.wechat_subscriber.enabled</code> 这里，在这一行上边插入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &#x27;my-copyright.swig&#x27; %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在 <code>themes\next\source\css\_common\components\post\post.styl</code> 文件的最后加入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@import &quot;my-post-copyright&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><span id="jumpp">在博客数据文件的根目录下有 <code>scaffolds\post.md</code> 文件，在三条横线上边加入 copyright 即可（置顶 top 类似），如下：</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">description:</span><br><span class="line">top:</span><br><span class="line">copyright:</span><br></pre></td></tr></table></figure></li>
<li><p>这样每篇新建的文章都有 copyright 了，如果想要开启版权信息，只要在 copyright 后面写上 true 即可，<font color=#FF0000>注意空格</font>!</p>
</li>
</ol>
<h3 id="3-新版Next优化"><a href="#3-新版Next优化" class="headerlink" title="(3).新版Next优化"></a>(3).新版Next优化</h3><ul>
<li><p><strong style="color:red;">新版 Next 不推荐直接修改主题源文件，所以可以按如下方法进行配置：</strong></p>
</li>
<li><p>打开 <code>source\_data\post-body-end.njk</code> 文件（没有请新建），将如下代码复制进去（可以自行修改）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line">&lt;div class=&quot;my_post_copyright&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class="line">  &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; author &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fab fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;注意事项:&lt;/span&gt;转载请保留原文链接及作者，请尊重作者的劳动成果&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &lt;span class=&quot;copy-path&quot;  title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;  aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">    var clipboard = new Clipboard(&#x27;.fa-clipboard&#x27;);</span><br><span class="line">	  $(&quot;.fa-clipboard&quot;).click(function()&#123;</span><br><span class="line">      clipboard.on(&#x27;success&#x27;, function()&#123;</span><br><span class="line">        swal(&#123;   </span><br><span class="line">          title: &quot;&quot;,   </span><br><span class="line">          text: &#x27;复制成功&#x27;,</span><br><span class="line">          icon: &quot;success&quot;, </span><br><span class="line">          showConfirmButton: true</span><br><span class="line">          &#125;);</span><br><span class="line">	    &#125;);</span><br><span class="line">    &#125;);  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>打开 <code>source\_data\styles.styl</code> 文件（没有请新建），将如下代码复制进去（可以自行修改）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.my_post_copyright &#123;</span><br><span class="line">  width: 85%;</span><br><span class="line">  max-width: 45em;</span><br><span class="line">  margin: 2.8em auto 0;</span><br><span class="line">  padding: 0.5em 1.0em;</span><br><span class="line">  border: 1px solid #d3d3d3;</span><br><span class="line">  font-size: 0.93rem;</span><br><span class="line">  line-height: 1.6em;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  background: rgba(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class="line">.my_post_copyright span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 5.2em;</span><br><span class="line">  color: #b5b5b5;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .raw &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  border-bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a:hover &#123;</span><br><span class="line">  color: #a3d2a3;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .post-url:hover &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 1em;</span><br><span class="line">  +mobile()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path:hover &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将<font color=##9932CC> <em>主题配置文件</em> </font>中的 <code>custom_file_path</code> 字段中的这两个文件取消注释即可</p>
</li>
<li><p>接着执行旧版的5、6操作即可</p>
</li>
</ul>
<h2 id="18-搜索服务"><a href="#18-搜索服务" class="headerlink" title="18.搜索服务"></a>18.搜索服务</h2><ul>
<li>NexT 官网给出了四种搜索——Swiftype、微搜索、Local Search以及Algolia。直达链接：<a href="http://theme-next.iissnan.com/getting-started.html">查看链接</a></li>
<li>个人认为第三个即本地搜索比较方便一些，这里只说一下本地搜索的设置</li>
<li>安装 <code>hexo-generator-search</code> 插件<br>命令为：<code>npm install hexo-generator-search --save</code></li>
<li>安装 <code>hexo-generator-searchdb</code> 插件<br>命令为：<code>npm install hexo-generator-searchdb --save</code></li>
<li>在<font color=#1E90FF> <em>站点配置文件</em> </font>最下边添加以下代码：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#搜索功能</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure></li>
<li>在<font color=##9932CC> <em>主题配置文件</em> </font>中搜 local_search，将 enable 改为 true 即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="19-为博客添加背景图"><a href="#19-为博客添加背景图" class="headerlink" title="19.为博客添加背景图"></a>19.为博客添加背景图</h2><blockquote>
<p>可能有人会觉得博客背景太白并不怎么好看，可以通过以下方法来修改背景图</p>
</blockquote>
<ul>
<li><p>在 <code>themes\next\source\css\_custom\custom.styl</code> 文件中添加以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//背景图片相关</span><br><span class="line">@media screen and (min-width:1200px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">		background-image:url(/images/background.jpg);</span><br><span class="line">		background-repeat: no-repeat;</span><br><span class="line">		background-attachment:fixed;</span><br><span class="line">		background-position:50% 50%;</span><br><span class="line">		background-size: cover</span><br><span class="line">    &#125;</span><br><span class="line">    #footer a &#123;</span><br><span class="line">        color:#eee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将你的背景图命名为 <code>background.jpg</code> 放入 <code>themes\next\source\images\</code> 目录下，然后重新上传博客即可</p>
</li>
<li><p>我这里上传无效，所以就把上面的url部分换成了图床外链（方法请百度），如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-image:url(https://s1.ax1x.com/2020/10/15/0oUEQK.jpg);</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">新版Next优化：只需要将以上的代码直接添加到 <code>source\_data\styles.styl</code> 文件里即可</strong></p>
</li>
</ul>
<h2 id="20-隐藏首页部分文章-新版Next不支持"><a href="#20-隐藏首页部分文章-新版Next不支持" class="headerlink" title="20.隐藏首页部分文章(新版Next不支持)"></a>20.<del>隐藏首页部分文章</del>(新版Next不支持)</h2><blockquote>
<p>有的时候我们并不想让某些文章出现在首页上，但在归档中还是可以找到的，这时就需要下方的方法了，该方法出自CSDN，转载请声明：<a href="https://blog.csdn.net/m0_37323771/article/details/80672271">原文</a></p>
</blockquote>
<h3 id="1-修改主题的index-swig"><a href="#1-修改主题的index-swig" class="headerlink" title="(1).修改主题的index.swig"></a>(1).修改主题的index.swig</h3><ul>
<li>路径在 <code>Hexo\themes\next\layout\index.swig</code></li>
<li>将这段<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt;</span><br><span class="line">    &#123;% for post in page.posts %&#125;</span><br><span class="line">        &#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  &lt;/section&gt;</span><br></pre></td></tr></table></figure></li>
<li>改成<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &lt;section id=&quot;posts&quot; class=&quot;posts-expand&quot;&gt;</span><br><span class="line">    &#123;% for post in page.posts %&#125;</span><br><span class="line">        &#123;% if post.notshow != true %&#125;</span><br><span class="line">            &#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  &lt;/section&gt;</span><br></pre></td></tr></table></figure></li>
<li>注意：上边在 for 循环中判断文章中的属性 notshow，如果不为 true 就打印出文章。所以在需要隐藏的文章 front-matter 中添加 notshow:true 就会隐藏。</li>
<li>!!!注意：最新版</li>
</ul>
<h3 id="2-将notshow直接写入front-matter中"><a href="#2-将notshow直接写入front-matter中" class="headerlink" title="(2).将notshow直接写入front-matter中"></a>(2).将notshow直接写入front-matter中</h3><ul>
<li>打开你 Hexo 的根目录，找到 <code>scaffolds</code> 文件中的 <code>post.md</code>文件，并用 VScode，记事本等软件打开</li>
<li>按下方的格式插入即可<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">description:</span><br><span class="line">top:</span><br><span class="line">notshow:</span><br><span class="line">copyright:</span><br></pre></td></tr></table></figure></li>
<li>注意：notshow: 后面有一个空格</li>
</ul>
<h3 id="3-进行设置"><a href="#3-进行设置" class="headerlink" title="(3).进行设置"></a>(3).进行设置</h3><ul>
<li>如果需要在你的以前的文章中设置隐藏，打开你的那篇文章的 .md 文件，按我上方的格式插入并在后面表明<code>true</code>即可</li>
<li>如果是新发表的文章，只要你进行过刚刚的设置，那么在你新建一个文档时，自动会补充 notshow 属性，你只要在后面填写 <code>true</code> 即可</li>
</ul>
<h2 id="21-网站底部添加已运行时间"><a href="#21-网站底部添加已运行时间" class="headerlink" title="21.网站底部添加已运行时间"></a>21.网站底部添加已运行时间</h2><ul>
<li>正在咕咕咕~ ~ ~</li>
</ul>
<h1 id="六、拓展配置"><a href="#六、拓展配置" class="headerlink" title="六、拓展配置"></a>六、拓展配置</h1><h2 id="1-使用插件在文章中插入图片"><a href="#1-使用插件在文章中插入图片" class="headerlink" title="1.使用插件在文章中插入图片"></a>1.使用插件在文章中插入图片</h2><ul>
<li><p>在<font color=#1E90FF> <em>站点配置文件</em> </font>中搜 post_asset_folder，将值改为 true</p>
</li>
<li><p>安装 <code>hexo-asset-image</code> 插件<br>命令为：<code>npm install hexo-asset-image --save</code></p>
</li>
<li><p>安装好后，只要你每次新建文章之时，在文章所在目录（即\source_posts）下会自动生成同名文件夹，只要把该篇文章中所需要的图片放在该文件夹内，然后在文章中使用 <code>![](该文件夹名字/图片名字)</code> 即可在文章中插入该图片<br><img src="https://i.loli.net/2019/04/03/5ca452b973cbf.png" alt="插入图片"></p>
</li>
</ul>
<h2 id="2-使用图床在文章中插入图片"><a href="#2-使用图床在文章中插入图片" class="headerlink" title="2.使用图床在文章中插入图片"></a>2.使用图床在文章中插入图片</h2><ul>
<li><p>使用图床外链插入图片链接<br>优点：占用空间少，GitHub 的仓库容量仅有200M，使用图床可以减少空间的使用量<br>缺点：图床一但被墙或关闭服务，可能会导致图片全部失效，所以建议将图片备份好，一旦图床失效，可以立即上传到其他图床上</p>
</li>
<li><p>这里我使用的是 SM.MS 图床，点击<a href="https://sm.ms/">这里</a>跳转。该图床上传上去以后有多种格式选择，你如果需要在本博客中添加，直接选择 Markdown 即可，如下：<br><img src="https://i.loli.net/2020/03/21/zv7R2LQlUwpGaSF.png" alt="Markdown图床.png"></p>
</li>
<li><p>然后在文章的适当位置插入 Markdown 语句即可，格式为：<code>![图片名](图片链接)</code> </p>
</li>
</ul>
<h2 id="3-首页页面优化"><a href="#3-首页页面优化" class="headerlink" title="3.首页页面优化"></a>3.首页页面优化</h2><ul>
<li><p>本人不是太喜欢 Next 主题的默认样式，有一种死气沉沉的感觉，所以对首页进行了相关的优化</p>
</li>
<li><p>本套配置基于 NexT 主题的 Gemini 的风格，主要包含了全局圆角化、文章透明、左上角颜色修改、去除网站顶部小黑条、手机端优化，可以自行进行修改，效果如下图：<br><img src="https://i.loli.net/2020/04/02/CsTO5NphBlgmd67.png" alt="全局圆角.png"></p>
</li>
<li><p>打开 <code>source\_data\styles.styl</code> 文件（没有请新建），粘贴以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 左上角分类栏相关修改</span><br><span class="line">// 修改背景颜色与手机端阴影</span><br><span class="line">.site-brand-container &#123;</span><br><span class="line">  background:none;</span><br><span class="line">  border-radius: 15px;</span><br><span class="line">  .site-nav-on &amp; &#123;</span><br><span class="line">    +tablet-mobile() &#123;</span><br><span class="line">      box-shadow: none;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 修改左上角标题颜色</span><br><span class="line">.site-brand-container .site-meta .brand&#123;</span><br><span class="line">  color: black;  </span><br><span class="line">&#125;</span><br><span class="line">.site-brand-container .site-meta .site-subtitle&#123;</span><br><span class="line">  color: gray;</span><br><span class="line">&#125;</span><br><span class="line">// 修改手机端按钮颜色</span><br><span class="line">.site-nav-right .toggle, .site-nav-toggle .toggle&#123;</span><br><span class="line">  color: gray;</span><br><span class="line">&#125;</span><br><span class="line">.site-nav-right .toggle .toggle-line, .site-nav-toggle .toggle .toggle-line&#123;</span><br><span class="line">  background: gray; </span><br><span class="line">&#125;</span><br><span class="line">// 修改手机端顶部栏圆角</span><br><span class="line">.header-inner&#123;</span><br><span class="line">  background: rgba(255,255,255,.9);</span><br><span class="line">  border-radius: 15px;</span><br><span class="line">&#125;</span><br><span class="line">// 回到顶部圆角</span><br><span class="line">.back-to-top&#123;</span><br><span class="line">  border-radius: 15px;</span><br><span class="line">&#125;</span><br><span class="line">// 去除首页文章与文章之间的背景色</span><br><span class="line">.main-inner&#123;</span><br><span class="line">  background: none;  </span><br><span class="line">&#125;</span><br><span class="line">// 消除顶部黑条</span><br><span class="line">.headband&#123;</span><br><span class="line">    background: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>打开 <code>source\_data\variables.styl</code> 文件（没有请新建），粘贴以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 修改圆角</span><br><span class="line">$border-radius           = 15px;</span><br><span class="line">$border-radius-inner     = 15px;</span><br><span class="line">// 修改背景透明度</span><br><span class="line">$content-bg-color        = rgba(255,255,255,.9);</span><br></pre></td></tr></table></figure></li>
<li><p>将<font color=#9932CC> <em>主题配置文件</em> </font>中的 <code>custom_file_path</code> 相应文件取消注释即可</p>
</li>
</ul>
<h2 id="4-数据文件功能设置"><a href="#4-数据文件功能设置" class="headerlink" title="4.数据文件功能设置"></a>4.<span id="dataFile">数据文件功能设置</span></h2><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="(1).介绍"></a>(1).介绍</h3><ul>
<li><p>自从 NexT-7.3.0 开始，官方推荐采用数据文件将配置与主题分离，这样我们可以在不修改主题源码的同时完成选项配置、自定义布局、自定义样式，便于后续 NexT 版本更新。</p>
</li>
<li><p><strong style="color:red;">推荐先进行该步操作后再进行以上的选项配置</strong></p>
</li>
</ul>
<h3 id="2-next-yml-已废弃"><a href="#2-next-yml-已废弃" class="headerlink" title="(2).next.yml(已废弃)"></a>(2).<del>next.yml</del>(已废弃)</h3><ul>
<li>老版本的 NexT 主题还提供了另一种配置方法，就是将主题配置放在 <code>/source/_data/next.yml</code> 文件. 此方法已弃用。</li>
<li>如果 <code>/source/_data/next.yml</code> 文件存在，请删除它，然后下面两种方法二选一，<a href="https://theme-next.js.org/docs/getting-started/configuration.html?highlight=data+file">这里</a>是官方文档的解释</li>
</ul>
<h3 id="3-config-name-yml方式"><a href="#3-config-name-yml方式" class="headerlink" title="(3)._config.[name].yml方式"></a>(3)._config.[name].yml方式</h3><ul>
<li>好处：<font color=#1E90FF><em>站点配置文件</em></font> 和<font color=#9932CC> <em>主题配置文件</em> </font>分离，便于设置</li>
<li>版本：确保 Hexo 为5.0或更高版本</li>
<li>要求：删除 <code>/source/_data/next.yml</code> 文件</li>
<li>方法：<ul>
<li>在站点根目录创建 <code>_config.[name].yml</code> 文件，其中[name]字段为 <font color=#1E90FF><em>站点配置文件</em></font> 中 theme 字段内容</li>
<li>将<font color=#9932CC> <em>主题配置文件</em> </font>中的内容全部复制到上面的文件中</li>
<li>重新上传博客即可应用以上配置</li>
</ul>
</li>
</ul>
<h3 id="4-theme-config方式"><a href="#4-theme-config方式" class="headerlink" title="(4).theme_config方式"></a>(4).theme_config方式</h3><ul>
<li>好处：<font color=#1E90FF><em>站点配置文件</em></font> 和<font color=#9932CC> <em>主题配置文件</em> </font>不分离，一个配置文件即可设置所有选项</li>
<li>版本：确保 Hexo 为5.0或更高版本</li>
<li>要求：删除 <code>/source/_data/next.yml</code> 文件</li>
<li>方法：<ul>
<li>在 <font color=#1E90FF><em>站点配置文件</em></font> 的最下面追加 <code>theme_config:</code> 字段</li>
<li>将<font color=#9932CC> <em>主题配置文件</em> </font>中的内容全部复制到该字段下面</li>
<li>将复制的所有内容全部向后缩进两个空格（VS Code的快捷键是选中之后按下 <code>Ctrl + ]</code> 即可快速缩进）</li>
<li>重新上传博客即可应用以上配置</li>
</ul>
</li>
</ul>
<h2 id="5-关于npm插件"><a href="#5-关于npm插件" class="headerlink" title="5.关于npm插件"></a>5.关于npm插件</h2><ul>
<li>本文的配置中很多地方都通过 npm 命令进行了插件的安装，这里写一些相关知识</li>
</ul>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="(1).安装"></a>(1).安装</h3><ul>
<li><p>全局与局部安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install xxx		//利用 npm 安装xxx模块到当前命令行所在目录</span><br><span class="line">npm install -g xxx	//利用 npm 安装xxx模块到全局目录</span><br></pre></td></tr></table></figure></li>
<li><p>局部安装时将模块写入 <code>package.json</code> 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install xxx				//安装但不将依赖写入 package.json 中</span><br><span class="line">npm install xxx –-save		//安装并将依赖写入 package.json 的 &quot;dependencies&quot; 中</span><br><span class="line">npm install xxx -–save-dev	//安装并将依赖写入 package.json 的 &quot;devDependencies&quot; 中</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-卸载"><a href="#2-卸载" class="headerlink" title="(2).卸载"></a>(2).卸载</h3><ul>
<li><p>全局与局部卸载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall xxx      //删除xxx模块</span><br><span class="line">npm uninstall -g xxx   //删除全局模块xxx</span><br></pre></td></tr></table></figure></li>
<li><p>局部安装时将 <code>package.json</code> 中内容删去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall xxx				//删除模块但不删除留在 package.json 中的对应依赖</span><br><span class="line">npm uninstall xxx --save		//删除模块同时删除留在 package.json 中 &quot;dependencies&quot; 下的对应依赖</span><br><span class="line">npm uninstall xxx --save-dev	//删除模块同时删除留在 package.json 中 &quot;devDependencies&quot; 下的对应依赖</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-使用批处理命令部署博客"><a href="#6-使用批处理命令部署博客" class="headerlink" title="6.使用批处理命令部署博客"></a>6.使用批处理命令部署博客</h2><ul>
<li><p>虽然在上传 Hexo 博客时的命令只有3条，但是本着能懒就懒的原则，使用一个命令完成岂不美哉？</p>
</li>
<li><p>在桌面新建一个 .txt 文档，将如下内容填写进去，使用时请把后面的注释去掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off					//关闭回显</span><br><span class="line">H:							//切换到博客站点目录所在的盘符，我这里是H盘</span><br><span class="line">cd H:\Github-blog			//进入站点目录，我这里是H:\Github-blog</span><br><span class="line">hexo clean&amp;&amp;hexo g&amp;&amp;hexo d	//Hexo 命令一键部署</span><br></pre></td></tr></table></figure></li>
<li><p>保存以后将这个文件改名为 <code>自动部署.bat</code> ，双击即可执行</p>
</li>
</ul>
<h2 id="7-在博客中插入自己本地文件且不渲染"><a href="#7-在博客中插入自己本地文件且不渲染" class="headerlink" title="7.在博客中插入自己本地文件且不渲染"></a>7.在博客中插入自己本地文件且不渲染</h2><ul>
<li><p>在博客目录下的 <code>source</code> 目录中新建一个 <code>demo</code> 文件夹，并将自己的 HTML 本地网页存放在此处</p>
<ul>
<li>因为 <code>source</code> 目录在 <code>hexo g</code> 时会生成到托管网站的 <code>/public</code> 目录下</li>
</ul>
</li>
<li><p>在自己的博客文章中，使用如下两个例子进行引入，这里使用的是相对路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[例子1](/demo/index.html)</span><br><span class="line">&lt;a href=&quot;/demo/index.html&quot;&gt;例子2&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;/demo/index.html&quot; target=&quot;_blank&quot;&gt;例子3&lt;/a&gt; </span><br><span class="line">解释：</span><br><span class="line">例子1是使用了Markdown写法，直接在当前窗口打开该页面</span><br><span class="line">例子2是使用了HTML标签，直接在当前窗口打开该页面</span><br><span class="line">例子3是使用了HTML标签和target属性，此时在新的窗口打开该页面，不影响当前页面</span><br></pre></td></tr></table></figure></li>
<li><p>因为该页面是属性自己本地页面，不和博客同框架样式的，所以需要取消渲染</p>
</li>
<li><p>打开 <font color=#1E90FF><em>站点配置文件</em></font> ，找到 <code>skip_render</code> 字段，按如下格式，如果有多个文件换行对照写即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">  - &#x27;demo/index.html&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>如果你进行了 <code>hexo-neat</code> 压缩，还需要在 <code>neat_html</code> 字段中，按如下填写（如果没有请无视）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;demo/index.html&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>重新执行 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 操作即可</p>
</li>
</ul>
<h1 id="七、问题集合"><a href="#七、问题集合" class="headerlink" title="七、问题集合"></a>七、问题集合</h1><h2 id="1-关于本地搜索框被置于最底层的问题"><a href="#1-关于本地搜索框被置于最底层的问题" class="headerlink" title="1.关于本地搜索框被置于最底层的问题"></a>1.关于本地搜索框被置于最底层的问题</h2><ul>
<li>之前在改变全局圆角的时候，因为考虑到背景图片问题，所以我顺便给每个部分设置了一个透明度，使用的是 <code>opacity: 0.9;</code> 这个属性，效果也十分显著</li>
<li>但第二天我就发现，本地搜索框突然不能正常使用，具体表现为：点击搜索有反应，但弹出的搜索框却被置于了网页的最下面一层，且无法进行点击</li>
<li>在我查了一下 GitHub 的 issue 时（点<a href="https://github.com/theme-next/hexo-theme-next/issues/914">这里</a>查看），发现原来是因为 opacity 的原因，把这个注释掉就好了，但这样就不可以实现透明效果了，所以你可以这样做：</li>
<li>在 background-color 处使用 rgba 来实现，如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">background-color: rgba(255,255,255,.8);</span><br><span class="line">//前面三个值为你的颜色的rgb值，后面那个值是透明度，值为0-1中间的数</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-关于错误代码问题"><a href="#2-关于错误代码问题" class="headerlink" title="2.关于错误代码问题"></a>2.关于错误代码问题</h2><h3 id="1-Template-render-error"><a href="#1-Template-render-error" class="headerlink" title="(1).Template render error"></a>(1).Template render error</h3><ul>
<li>在执行 <code>hexo g</code> 的命令时提示该代码</li>
<li>经过排查，发现是由于我写的一篇 md 文档导致的，说明里面有部分特殊符号被网页进行了解析</li>
<li>如下图，这里的 import 标签我虽然用的单行代码引用的方法，但被浏览器解析了，而换成代码块的方式，就不会出现错误了<br><img src="https://i.loli.net/2020/04/18/jQ1xMPGotEaSeVc.png" alt="代码问题01 .png"></li>
</ul>
<h3 id="2-FATAL-Port-4000-has-been-used"><a href="#2-FATAL-Port-4000-has-been-used" class="headerlink" title="(2).FATAL Port 4000 has been used"></a>(2).FATAL Port 4000 has been used</h3><ul>
<li><p>在执行 <code>hexo -s</code> 的命令时提示该代码</p>
</li>
<li><p>经过排查，是因为我在上次执行该命令时没有及时终止进程导致的，按如下步骤杀死进程即可成功执行</p>
</li>
<li><p>在 Windows 命令行窗口分别执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -ano						// 查看系统当前所有窗口占用状况</span><br><span class="line">netstat -ano | findstr &quot;4000&quot;		// 查看4000端口被哪个应用占用</span><br><span class="line">tasklist | findstr &quot;进程id号&quot;		// 通过id查找对应的进程名称</span><br></pre></td></tr></table></figure></li>
<li><p><strong style="color:red;">注意：如果此时进程名称为 <code>node.exe</code> 即代表是因为 <code>hexo -s</code> 命令没有终止导致的。如果显示为其他名字，代表是其他软件端口与 hexo 的端口冲突，此时应该更换 hexo 端口号，方法自行百度</strong></p>
</li>
<li><p>确认进程名称为 <code>node.exe</code> 时执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">taskkill /f /t /im &quot;进程id或者进程名称&quot;		// 杀掉当前进程</span><br></pre></td></tr></table></figure></li>
<li><p>然后再执行 <code>hexo -s</code> 即可成功打开博客了</p>
</li>
</ul>
<h2 id="3-关于git-bash无法终止hexo-s"><a href="#3-关于git-bash无法终止hexo-s" class="headerlink" title="3.关于git bash无法终止hexo s"></a>3.关于git bash无法终止hexo s</h2><ul>
<li>在 Windows 的 cmd 窗口执行该命令即可：<code>taskkill /F /IM node.exe</code> </li>
</ul>
<h2 id="4-关于博客整体的升级问题"><a href="#4-关于博客整体的升级问题" class="headerlink" title="4.关于博客整体的升级问题"></a>4.关于博客整体的升级问题</h2><ul>
<li>升级之前最好查看下 Node.js 、Hexo、Next 之前的版本匹配问题</li>
<li>这里是官方给的版本对照图：<table>
<thead>
<tr>
<th align="center">Hexo 版本</th>
<th align="center">最低兼容 Node.js 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">5.0+</td>
<td align="center">10.13.0</td>
</tr>
<tr>
<td align="center">4.1 - 4.2</td>
<td align="center">8.10</td>
</tr>
<tr>
<td align="center">4.0</td>
<td align="center">8.6</td>
</tr>
<tr>
<td align="center">3.3 - 3.9</td>
<td align="center">6.9</td>
</tr>
<tr>
<td align="center">3.2 - 3.3</td>
<td align="center">0.12</td>
</tr>
<tr>
<td align="center">3.0 - 3.1</td>
<td align="center">0.10 or iojs</td>
</tr>
<tr>
<td align="center">0.0.1 - 2.8</td>
<td align="center">0.10</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-NodeJS升级"><a href="#1-NodeJS升级" class="headerlink" title="(1).NodeJS升级"></a>(1).NodeJS升级</h3><ul>
<li><p>Windows 可直接下载最新稳定版并安装</p>
</li>
<li><p>更新 npm 使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -g install npm ( 官方最新稳定版 )</span><br><span class="line">npm -g install npm@6.1.0 ( 自己需要的版本 )</span><br></pre></td></tr></table></figure></li>
<li><p>此时可通过执行如下命令查看 Node.js和npm 是否更新成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-Hexo升级"><a href="#2-Hexo升级" class="headerlink" title="(2).Hexo升级"></a>(2).Hexo升级</h3><ul>
<li><p>在博客的目录下执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g			//全局升级hexo</span><br><span class="line">npm install -g npm-check		//安装npm-check</span><br><span class="line">npm-check						//查看系统插件是否需要升级</span><br><span class="line">npm install -g npm-upgrade		//安装npm-upgrade</span><br><span class="line">npm-upgrade						//更新package.json</span><br><span class="line">//在执行npm-upgrade命令后会要求输入yes或者no，直接输入Yes或Y即可</span><br><span class="line">npm update -g					//更新全局插件</span><br><span class="line">npm update --save				//更新系统插件</span><br></pre></td></tr></table></figure></li>
<li><p>此时可通过执行如下命令查看 Hexo 是否更新成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Next升级"><a href="#3-Next升级" class="headerlink" title="(3).Next升级"></a>(3).Next升级</h3><ul>
<li><p>若你的主题版本很老，建议对自己的主题文件夹进行备份</p>
</li>
<li><p>在博客根目录打开 git bash 窗口，输入以下命令（next-8.4.0可以自行更改）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next-8.4.0</span><br></pre></td></tr></table></figure></li>
<li><p>在主题配置文件中更换主题为 next-8.4.0</p>
</li>
</ul>
<h3 id="4-更新后的问题"><a href="#4-更新后的问题" class="headerlink" title="(4).更新后的问题"></a>(4).更新后的问题</h3><h4 id="a-博客主页无法进入且乱码"><a href="#a-博客主页无法进入且乱码" class="headerlink" title="a).博客主页无法进入且乱码"></a>a).博客主页无法进入且乱码</h4><ul>
<li><p>报错信息为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>原因为：<br>hexo 在5.0之后把 swig 给删除了，此时需要自己手动安装</p>
</li>
<li><p>修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i hexo-renderer-swig</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="b-博客主页的首页跳转404"><a href="#b-博客主页的首页跳转404" class="headerlink" title="b).博客主页的首页跳转404"></a>b).博客主页的首页跳转404</h4><ul>
<li><p>报错信息为：<br>点击首页等导航时链接地址为：<a href="https://xxx.github.io/%20%EF%BC%8C%E4%B8%94%E8%B7%B3%E8%BD%AC%E5%88%B0404%E9%A1%B5%E9%9D%A2">https://xxx.github.io/%20，且跳转到404页面</a></p>
</li>
<li><p>原因为：<br>所有导航路径后都有 %20，%20 代表空格，而这个一部分又是 next 主题中生成的，只要将主题配置文件里 || 之前所有的空格删掉即可</p>
</li>
<li><p>修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /|| home</span><br><span class="line">  about: /about/|| user</span><br><span class="line">  tags: /tags/|| tags</span><br><span class="line">  categories: /categories/|| th</span><br><span class="line">  archives: /archives/|| archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="c-页面特效失效"><a href="#c-页面特效失效" class="headerlink" title="c).页面特效失效"></a>c).<span id="canvas">页面特效失效</span></h4><ul>
<li><p>Next 主题从6.0版本开始就移除了原本关于页面特效的一部分依赖（可比对next/soure/lib下文件），导致新版本无法直接生效相关配置，如果需要安装可以在 <a href="https://github.com/theme-next">theme-next</a> 仓库中搜索主题字段并按文档安装</p>
</li>
<li><p>主题有：<code>canvas_nest</code>、<code>three_waves</code>、<code>canvas_lines</code>、<code>canvas_sphere</code></p>
</li>
<li><p>这里以 Windows 环境下配置 <code>canvas_nest</code> 为例：</p>
<ul>
<li><p>在 <code>hexo/source/_data</code> 下创建 <code>footer.swig</code> 文件（如果有则追加内容）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script color=&quot;0,0,255&quot; opacity=&quot;0.5&quot; zIndex=&quot;-1&quot; count=&quot;99&quot; src=&quot;https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>修改主题配置文件中的如下字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Define custom file paths.</span><br><span class="line"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.swig</span><br><span class="line">  #header: source/_data/header.swig</span><br><span class="line">  #sidebar: source/_data/sidebar.swig</span><br><span class="line">  #postMeta: source/_data/post-meta.swig</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.swig</span><br><span class="line">  footer: source/_data/footer.swig</span><br><span class="line">  #bodyEnd: source/_data/body-end.swig</span><br><span class="line">  #variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="d-网站语言问题"><a href="#d-网站语言问题" class="headerlink" title="d).网站语言问题"></a>d).网站语言问题</h4><ul>
<li>官方将中文的语言命名由 zh-Hans 改为了 zh-CN</li>
<li>在 <font color=#1E90FF><em>站点配置文件</em></font> 中修改语言字段：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="e-字体大小问题"><a href="#e-字体大小问题" class="headerlink" title="e).字体大小问题"></a>e).字体大小问题</h4><ul>
<li>更新至新版以后字体默认大小比原先大了些，需要调整可以在 font 配置下进行修改，如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line">  # 字体地址</span><br><span class="line">  host:</span><br><span class="line">  # 正文字体</span><br><span class="line">  global:</span><br><span class="line">    # 拓展字体库，设置为 true 将从hosts中加载字体</span><br><span class="line">    external: true</span><br><span class="line">    # 字体族</span><br><span class="line">    family: Lato</span><br><span class="line">    # 大小：size=1 为默认大小，0.8将缩小为80%</span><br><span class="line">    size: 0.9</span><br><span class="line">  title:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">    size:</span><br><span class="line">  # 正文标题字体大小</span><br><span class="line">  headings:</span><br><span class="line">    external: true</span><br><span class="line">    family: Lato</span><br><span class="line">    size:</span><br><span class="line">  posts:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br><span class="line">  codes:</span><br><span class="line">    external: true</span><br><span class="line">    family:</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="八、该系列文章"><a href="#八、该系列文章" class="headerlink" title="八、该系列文章"></a>八、该系列文章</h1><ul>
<li>想要了解基础搭建教程请移步这里：<a href="/Hexo-01.html" title="[Hexo博客之基础搭建教程]">[Hexo博客之基础搭建教程]</a></li>
<li>想要了解高级优化教程请移步这里：<a href="/Hexo-03.html" title="[Hexo博客之高级优化教程]">[Hexo博客之高级优化教程]</a></li>
<li>想要了解Markdown教程请移步这里：<a href="/Hexo-04.html" title="[Hexo博客之Markdown教程]">[Hexo博客之Markdown教程]</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客之Markdown教程</title>
    <url>/Hexo-04.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本篇整合了使用 Markdown 编写博客时遇到的一些问题</li>
<li>如有补充或疑惑请在评论区留言<span id="more"></span></li>
</ul>
<h1 id="一、文本类"><a href="#一、文本类" class="headerlink" title="一、文本类"></a>一、文本类</h1><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><ul>
<li>删除线：在加删除线的文字左右分别用两个 <code>~~</code> 号包起来</li>
<li>斜体：在倾斜的文字左右分别用一个 <code>*</code> 号包起来</li>
<li>加粗：在加粗的文字左右分别用两个 <code>**</code> 号包起来</li>
<li>斜体加粗：在倾斜和加粗的文字左右分别用三个 <code>***</code> 号包起来</li>
<li>分割线：三个或者三个以上的 <code>---</code> 或者 <code>***</code> 都可以。</li>
</ul>
<h2 id="2-字体颜色及大小"><a href="#2-字体颜色及大小" class="headerlink" title="2.字体颜色及大小"></a>2.字体颜色及大小</h2><ul>
<li>使用以下代码，修改相应内容就可以修改字体了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=#这里写字体颜色的代码 face=&quot;这里写你想修改的字体&quot; size=这里写你想修改的大小&gt;这里为你要修改的字&lt;/font&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-文章文字居中显示"><a href="#3-文章文字居中显示" class="headerlink" title="3.文章文字居中显示"></a>3.文章文字居中显示</h2><ul>
<li>使用 html 标签对文本进行注释就行，用法如下：<code>&lt; center&gt;需要居中显示的文本&lt; /center&gt;</code></li>
<li>我这里为了防止 center 标签被浏览器解析，在两个小于号那加了个空格，实际使用没有空格，请注意！</li>
</ul>
<h2 id="4-自定义目录结构"><a href="#4-自定义目录结构" class="headerlink" title="4.自定义目录结构"></a>4.自定义目录结构</h2><ul>
<li>我们可以在文章首部给用户列出当前文章的目录结构，只需要使用 <code>@[TOC](自定义目录标题)</code> </li>
</ul>
<h2 id="5-计划任务"><a href="#5-计划任务" class="headerlink" title="5.计划任务"></a>5.计划任务</h2><ul>
<li><code>- [] 未完成任务</code>：表示未完成的任务</li>
<li><code>- [x] 已完成任务</code>：表示已完成的任务</li>
</ul>
<h1 id="二、表格类"><a href="#二、表格类" class="headerlink" title="二、表格类"></a>二、表格类</h1><h2 id="1-不带对齐方式的表格"><a href="#1-不带对齐方式的表格" class="headerlink" title="1.不带对齐方式的表格"></a>1.不带对齐方式的表格</h2><ul>
<li><p>即默认左对齐表格</p>
</li>
<li><p>用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure></li>
<li><p>显示如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody></table>
<h2 id="2-带对齐方式的表格"><a href="#2-带对齐方式的表格" class="headerlink" title="2.带对齐方式的表格"></a>2.带对齐方式的表格</h2><ul>
<li><p><code>-:</code> 设置内容和标题栏居右对齐<br><code>:-</code> 设置内容和标题栏居左对齐<br><code>:-:</code> 设置内容和标题栏居中对齐</p>
</li>
<li><p>用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure></li>
<li><p>显示如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">左对齐</th>
<th align="right">右对齐</th>
<th align="center">居中对齐</th>
</tr>
</thead>
<tbody><tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
<tr>
<td align="left">单元格</td>
<td align="right">单元格</td>
<td align="center">单元格</td>
</tr>
</tbody></table>
<h2 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3.注意事项"></a>3.注意事项</h2><ul>
<li>在表格代码的上下方最好留一个空行，实验证明，当表格和上下方正文的内容挨着时，很难解析成表格</li>
<li>当然，这个问题我只在该博客中遇到过，至于其他支持 Markdown 写法的网站是否会出现该情况，例如：CSDN、简书等，目前并不明确</li>
<li><code>|、-、:</code> 之间的多余空格会被忽略，不影响布局，且每行第一个 <code>|</code> 和最后一个 <code>|</code> 可以省略，<code>-</code> 的数量至少有一个</li>
</ul>
<h1 id="三、图片类"><a href="#三、图片类" class="headerlink" title="三、图片类"></a>三、图片类</h1><h2 id="1-插入图片"><a href="#1-插入图片" class="headerlink" title="1.插入图片"></a>1.插入图片</h2><h3 id="1-使用图床"><a href="#1-使用图床" class="headerlink" title="(1).使用图床"></a>(1).使用图床</h3><ul>
<li><p>使用图床外链插入图片链接<br>优点：占用空间少，GitHub 的仓库容量仅有200M，使用图床可以减少空间的使用量<br>缺点：图床一但被墙或关闭服务，可能会导致图片全部失效，所以建议将图片备份好，一旦图床失效，可以立即上传到其他图床上</p>
</li>
<li><p>这里我使用的是 SM.MS 图床，点击<a href="https://sm.ms/">这里</a>跳转。该图床上传上去以后有多种格式选择，你如果需要在本博客中添加，直接选择 Markdown 即可，如下：<br><img src="https://i.loli.net/2020/03/21/zv7R2LQlUwpGaSF.png" alt="Markdown图床.png"></p>
</li>
</ul>
<h3 id="2-使用插件"><a href="#2-使用插件" class="headerlink" title="(2).使用插件"></a>(2).使用插件</h3><ul>
<li><p>在<font color=#1E90FF> <em>站点配置文件</em> </font>中搜 post_asset_folder，将值改为 true</p>
</li>
<li><p>安装 <code>hexo-asset-image</code> 插件<br>命令为：<code>npm install hexo-asset-image --save</code></p>
</li>
<li><p>安装好后，只要你每次新建文章之时，在文章所在目录（即\source_posts）下会自动生成同名文件夹，只要把该篇文章中所需要的图片放在该文件夹内，然后在文章中使用 <code>![](该文件夹名字/图片名字)</code> 即可在文章中插入该图片<br><img src="https://i.loli.net/2019/04/03/5ca452b973cbf.png" alt="插入图片"></p>
</li>
</ul>
<h3 id="3-绝对路径"><a href="#3-绝对路径" class="headerlink" title="(3).绝对路径"></a>(3).绝对路径</h3><ul>
<li>使用绝对路径存放图片</li>
<li>例如： <code>C:\picture\1.jpg</code> ——<del>不建议使用，具体原因尚不了解，日后修改</del></li>
</ul>
<blockquote>
<p>使用绝对路径时，本地有C盘而服务器端没有C盘，将导致路径错误，<font color=#F00>所以强烈不建议使用</font></p>
</blockquote>
<h3 id="4-相对路径"><a href="#4-相对路径" class="headerlink" title="(4).相对路径"></a>(4).相对路径</h3><ul>
<li>使用相对路径来存放图片</li>
<li>当图片与 .md 文档在同一文件夹下时使用——<code>![](图片名字)</code>（注意符号都是英文状态）；当图片是在与 .md 文档同路径的一个文件夹内时使用——<code>![](文件夹名字/图片名字)</code></li>
</ul>
<h2 id="2-修改图片位置"><a href="#2-修改图片位置" class="headerlink" title="2.修改图片位置"></a>2.修改图片位置</h2><ul>
<li>在图片信息前面加 <code>&lt;div align=center&gt;</code>(左 left 右 right 中 center)</li>
</ul>
<h2 id="3-使用-HTML-标签修改图片大小及位置"><a href="#3-使用-HTML-标签修改图片大小及位置" class="headerlink" title="3.使用 HTML 标签修改图片大小及位置"></a>3.使用 HTML 标签修改图片大小及位置</h2><ul>
<li>在文章中插入下面代码<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;http://7xqoji.com1.z0.glb.clouddn.com/mytest.jpg&quot; width=&quot;500&quot; height=&quot;313&quot; align=center /&gt;</span><br></pre></td></tr></table></figure></li>
<li>将 src 双引号中的网址改为你图片的网址即可，当然，理论上相对路径也可以</li>
<li>想要修改图片大小，即修改上述代码中的 width 和 height 的值即可</li>
<li>想要修改图片位置，即修改上述代码中的 align 即可</li>
</ul>
<h1 id="四、代码段"><a href="#四、代码段" class="headerlink" title="四、代码段"></a>四、代码段</h1><ul>
<li>如上的 <code>&lt;div align=center&gt;</code> 字段，可以使用锐音符来显示代码段</li>
<li>写法：锐音符 + 需要展示的代码 + 锐音符（短代码用一个锐音符，长代码用三个锐音符）</li>
<li>锐音符在键盘数字1的左边，tab 键的上边，且需要在英文状态下输入<br><img src="https://i.loli.net/2019/04/07/5ca9b1b823251.png" alt="锐音符"></li>
</ul>
<h1 id="五、跳转"><a href="#五、跳转" class="headerlink" title="五、跳转"></a>五、跳转</h1><h2 id="1-实现页内跳转之HTML锚点跳转"><a href="#1-实现页内跳转之HTML锚点跳转" class="headerlink" title="1.实现页内跳转之HTML锚点跳转"></a>1.实现页内跳转之HTML锚点跳转</h2><ul>
<li>在需要跳转到的位置添加锚点，语法如下：<code>&lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt;</code></li>
<li>在需要点击跳转的地方使用上面的 id，语法如下：<code>[点击跳转](#jump)</code></li>
</ul>
<h2 id="2-实现不同文章之间的跳转"><a href="#2-实现不同文章之间的跳转" class="headerlink" title="2.实现不同文章之间的跳转"></a>2.实现不同文章之间的跳转</h2><ul>
<li>该方法支持于博客撰写，其他用途请自测</li>
<li>比如我曾写过一篇 <a href="/web-nav.html" title="[网站聚合]">[网站聚合]</a> ，在这里你直接点击即可跳转</li>
<li>实现代码为：<code>&#123; % post_link 这里改为你那篇文章的名字 [这里改为你想要显示的名字] %&#125;</code></li>
<li>注意！我这里为了防止被网页解析，在第一个百分号前面加了个空格，在使用时请注意去除</li>
</ul>
<h1 id="六、树形结构"><a href="#六、树形结构" class="headerlink" title="六、树形结构"></a>六、树形结构</h1><p><a href="https://www.cnblogs.com/abc-x/p/13470575.html">https://www.cnblogs.com/abc-x/p/13470575.html</a></p>
<h1 id="六、该系列文章"><a href="#六、该系列文章" class="headerlink" title="六、该系列文章"></a>六、该系列文章</h1><ul>
<li>想要了解基础搭建教程请移步这里：<a href="/Hexo-01.html" title="[Hexo博客之基础搭建教程]">[Hexo博客之基础搭建教程]</a></li>
<li>想要了解主题配置教程请移步这里：<a href="/Hexo-02.html" title="[Hexo博客之NexT配置教程]">[Hexo博客之NexT配置教程]</a></li>
<li>想要了解高级优化教程请移步这里：<a href="/Hexo-03.html" title="[Hexo博客之高级优化教程]">[Hexo博客之高级优化教程]</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客之基础搭建教程</title>
    <url>/Hexo-01.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>本教程是采用 <font color=#FF0000><strong>Gitee或GitHub</strong></font> 和 <font color=#FF0000><strong>Hexo</strong></font> 框架来搭建个人博客的</li>
<li>本教程中的所有链接均指向为官方链接，望知悉</li>
<li>本教程中的部分内容是借鉴 <a href="https://www.coolapk.com/feed/9577774?shareKey=ZTM4NWRlNzk4OTY1NWM0ODQ3YTI~&shareUid=1519576&shareFrom=com.coolapk.market_9.0">酷安教程</a> 所写，如需转载请注明</li>
<li>本教程中的所有软件的安装与调试都不赘述，望您多动手百度<span id="more"></span></li>
</ul>
<h1 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h1><h2 id="1-为什么用-Gitee？"><a href="#1-为什么用-Gitee？" class="headerlink" title="1.为什么用 Gitee？"></a>1.为什么用 Gitee？</h2><ul>
<li>众所周知，GitHub 在国内访问速度慢，还有可能被墙。而 Gitee 作为国内版的 “GitHub”，速度快还不用担心后台可能会挂，也不用自己花钱买域名，相对于稳定。</li>
</ul>
<h2 id="2-为什么用-GitHub？"><a href="#2-为什么用-GitHub？" class="headerlink" title="2.为什么用 GitHub？"></a>2.为什么用 GitHub？</h2><ul>
<li>虽然 GitHub 在国内访问速度慢，还有可能被墙，但如果你想要提升自己博客的搜索排名，或者说让你的博客在外网也可以被别人看到的话，建议使用 GitHub。</li>
</ul>
<h2 id="3-为什么用-Hexo？"><a href="#3-为什么用-Hexo？" class="headerlink" title="3.为什么用 Hexo？"></a>3.为什么用 Hexo？</h2><ul>
<li>官网直达车：<a href="https://hexo.io/zh-cn/">查看链接</a></li>
<li>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <font color=#FF0000>Markdown</font>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</li>
</ul>
<h1 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h1><h2 id="1-托管仓库"><a href="#1-托管仓库" class="headerlink" title="1.托管仓库"></a>1.托管仓库</h2><ul>
<li><p>Gitee。直达链接：<a href="https://gitee.com/">查看链接</a></p>
</li>
<li><p>GitHub。直达链接：<a href="https://github.com/">查看链接</a></p>
</li>
</ul>
<h2 id="2-环境安装"><a href="#2-环境安装" class="headerlink" title="2.环境安装"></a>2.环境安装</h2><ul>
<li><p>安装Git（用来从本地传到 Gitee 和 GitHub 端）。直达链接：<a href="https://git-scm.com/">查看链接</a></p>
</li>
<li><p>安装Node.js（用来本地编译生成静态网页）。直达链接：<a href="https://nodejs.org/en/">查看链接</a></p>
</li>
</ul>
<h2 id="3-软件安装"><a href="#3-软件安装" class="headerlink" title="3.软件安装"></a>3.软件安装</h2><ul>
<li><p>文件编辑器，用来修改博客的配置文件，本人使用的是 VS code。直达链接：<a href="https://code.visualstudio.com/">查看链接</a></p>
</li>
<li><p>Atom（GitHub 自家的 Markdown 编辑器，主要写博客时使用）。直达链接：<a href="https://atom.io/">查看链接</a></p>
</li>
<li><p>小书匠编辑器（Markdown 编辑器，写博客时使用）。直达链接：<a href="https://github.com/suziwen/markdownxiaoshujiang/releases/tag/v6.7.0">查看链接</a></p>
</li>
<li><p>Typora（一个比较轻便简洁的 Markdown 编辑器，支持大纲查看，<font color=#F00>强烈推荐</font>）。直达链接：<a href="https://typora.io/">查看链接</a></p>
</li>
</ul>
<h1 id="三、本地安装-Hexo-框架"><a href="#三、本地安装-Hexo-框架" class="headerlink" title="三、本地安装 Hexo 框架"></a>三、本地安装 Hexo 框架</h1><ol>
<li><p>打开 Node.js 的命令行窗口<br><img src="https://i.loli.net/2019/04/01/5ca20dabda81a.png" alt="Node.js命令行"></p>
</li>
<li><p>用一键安装命令安装 Hexo，命令为：<code>npm install -g hexo-cli</code><br><img src="https://i.loli.net/2019/04/01/5ca20deba17af.png" alt="安装Hexo"></p>
</li>
<li><p>使用 <code>hexo v</code> 命令可以查看已安装的版本号</p>
</li>
<li><p>初始化 Hexo，即在本地创建 Hexo 文件，命令为： <code>hexo init &quot;D:\My Hexo&quot;</code>，建议将该文件夹放在常用盘符下，后续操作均在该文件夹内操作<br><img src="https://i.loli.net/2019/04/01/5ca20e3182c2c.png" alt="初始化Hexo"></p>
<blockquote>
<p>注意：如果一直卡在箭头这里，请移步<a href="#katiao">这里</a>，之后重复该命令即可正常解决。</p>
</blockquote>
</li>
<li><p>进入你的数据目录，命令为： <code>cd &quot;D:\My Hexo&quot;</code><br><img src="https://i.loli.net/2019/04/01/5ca20e70202ac.png" alt="进入目录"></p>
</li>
<li><p>再次初始化安装 Hexo，命令为： <code>npm install</code>（我这里已经装过了，可能界面显示内容和你们不一样，别急，先进行下一步。如果不对再返回来重试）<br><img src="https://i.loli.net/2019/04/01/5ca20eaec93bc.png" alt="再次安装"></p>
</li>
<li><p>打开 My Hexo 目录，发现有以下文件即为正确<br><img src="https://i.loli.net/2019/04/01/5ca20f09bd5ec.png" alt="数据目录"></p>
</li>
<li><p>检测本地 Hexo 是否安装成功，先在该目录右键进入 Git 的命令行模式<br><img src="https://i.loli.net/2019/04/01/5ca20f5348958.png" alt="进入git界面"></p>
</li>
<li><p>输入 <code>hexo s</code> 开启本地服务<br><img src="https://i.loli.net/2019/04/01/5ca20f89d7627.png" alt="本地服务"></p>
</li>
<li><p>复制上图选框内容，去浏览器打开<br><img src="https://i.loli.net/2019/04/01/5ca20fb996f46.png" alt="本地网站"></p>
</li>
<li><p>至此，本地 Hexo 框架已安装成功</p>
</li>
</ol>
<h1 id="四、配置仓库与上传服务"><a href="#四、配置仓库与上传服务" class="headerlink" title="四、配置仓库与上传服务"></a>四、配置仓库与上传服务</h1><ul>
<li>这里仓库选择有两个，根据自己需要选择即可</li>
</ul>
<h2 id="1-Gitee"><a href="#1-Gitee" class="headerlink" title="1.Gitee"></a>1.Gitee</h2><ol>
<li><p>登入 Gitee 后先新建一个仓库<br><img src="https://i.loli.net/2019/04/01/5ca211053e086.png" alt="新建仓库"></p>
</li>
<li><p>下边选项默认即可</p>
</li>
<li><p>开启 Gitee Pages 服务来托管你的博客<br><img src="https://i.loli.net/2019/04/01/5ca20cc67809f.png" alt="Gitee Pages服务"></p>
</li>
<li><p><span id="jump">在该页面内启用，显示如下：</span><br><img src="https://i.loli.net/2019/04/01/5ca20d26323dd.png" alt="网站链接"></p>
</li>
<li><p>至此，Gitee 仓库完成创建且已开启服务，<font color=#FF0000>请牢记上面这个网址，该网址即为你的博客链接，后续会用到</font></p>
</li>
<li><p>找到码云设置界面的这两处信息<br><img src="https://i.loli.net/2019/04/01/5ca20fe7a9d92.png" alt="昵称和邮箱"></p>
</li>
<li><p>在 Git 界面配置 Git 全局信息<br>命令为： <code>git config --global user.name &quot;你的昵称&quot;</code><br>命令为： <code>git config --global user.email &quot;你的邮箱&quot;</code><br><img src="https://i.loli.net/2019/04/01/5ca21014da328.png" alt="配置git"></p>
</li>
<li><p>修改本地配置文件，在你的数据目录内找到这个文件 <code>_config.yml</code> 并打开<br><img src="https://i.loli.net/2019/04/01/5ca20c113bd6e.png" alt="config文件"></p>
</li>
<li><p>找到 <font color=#FF0000>URL</font> 一行，修改 url 和 root。url 即为<a href="#jump">这里</a>的博客地址，root 为什么这样写绿字已经解释了，之后按 ctrl+ S 保存<br><img src="https://i.loli.net/2019/04/01/5ca2118aee0fb.png" alt="修改URL"></p>
</li>
<li><p>设置 Git 路径，进入你创建的仓库，在右边克隆那复制 HTTPS 地址<br><img src="https://i.loli.net/2019/04/01/5ca211c23bb74.png" alt="仓库HTTPS"></p>
</li>
<li><p>打开 <code>_config.yml</code> 配置文件，修改最下边 deploy 区域，按图增加一个 repo，之后按 ctrl+S 保存<br><img src="https://i.loli.net/2019/04/01/5ca211f1ef66e.png" alt="deploy"></p>
<blockquote>
<p>注意：图中红线框着的地方有空格，千万不要忘记。这里是博主遇到的最大的坑。Hexo 中和 Markdown 中最要注意的就是空格了。</p>
</blockquote>
</li>
</ol>
<ol start="12">
<li><p>安装 hexo-deployer-git 插件，命令为： <code>npm install hexo-deployer-git --save</code><br><img src="https://i.loli.net/2019/04/01/5ca21222a87c4.png" alt="安装deployer插件"></p>
</li>
<li><p>生成静态文件并上传至 Gitee 端，将博客部署到服务器，命令为： <code>hexo g &amp;&amp; hexo d</code>，中途会让你输入 Gitee 的账户密码<br><img src="https://i.loli.net/2019/04/01/5ca21252b42ff.png" alt="登陆账户"></p>
</li>
<li><p>这就代表上传完毕了<br><img src="https://i.loli.net/2019/04/01/5ca21275b5736.png" alt="部署"></p>
</li>
<li><p>进入仓库检查是否上传成功，这就代表已成功传入仓库中<br><img src="https://i.loli.net/2019/04/01/5ca212a2b72a6.png" alt="对接成功"></p>
</li>
<li><p>浏览器登录博客地址查看博客<br><img src="https://i.loli.net/2019/04/01/5ca212d9c794e.png" alt="查看博客"></p>
</li>
<li><p>至此，博客搭建完毕</p>
</li>
</ol>
<h2 id="2-GitHub"><a href="#2-GitHub" class="headerlink" title="2.GitHub"></a>2.GitHub</h2><ul>
<li>这里的步骤有些图我是用的上面 Gitee 的，方法类似，各位注意区别一下就行</li>
</ul>
<ol>
<li><p>登入 GitHub 后点击 Start project 或者下面的 new repository 创建一个新的仓库。</p>
</li>
<li><p>仓库名格式为 <code>用户名.github.io</code>，<font color=#F00>注意：GitHub 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到</font><br><img src="https://i.loli.net/2020/03/19/m71zvaliD3dQnOP.png" alt="Github01.png"></p>
</li>
<li><p>开启 GitHub Pages服务来托管你的博客，进入仓库，点击 Settings，往下翻，找到 GitHub Pages 区域<br><img src="https://i.loli.net/2020/03/19/AmyjLe5N4EBaqWf.png" alt="Github02.png"></p>
</li>
<li><p>将 none 改为 master branch<br><img src="https://i.loli.net/2020/03/19/liMIRtykqbdsNXu.png" alt="Github03.png"></p>
</li>
<li><p><span id="github">等待网页自动刷新就开启了该功能，上边即是你的网页链接</span><br><img src="https://i.loli.net/2020/03/19/lk8v3uBrKiGo2pH.png" alt="Github04.png"></p>
</li>
<li><p>至此，GitHub 仓库完成创建且已开启服务，<font color=#FF0000>请牢记上面这个网址，该网址即为你的博客链接，后续会用到</font></p>
</li>
<li><p>在 Git 界面配置 Git 全局信息，昵称即为你 GitHub 的用户名，邮箱是自己的注册邮箱<br>命令为： <code>git config --global user.name &quot;你的昵称&quot;</code><br>命令为： <code>git config --global user.email &quot;你的邮箱&quot;</code><br><img src="https://i.loli.net/2019/04/01/5ca21014da328.png" alt="配置git"></p>
</li>
<li><p>生成密匙，命令为：<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>，连续按三下回车，最后会获得一长串的 public key，复制好备用<br><img src="https://i.loli.net/2020/03/19/WKUFPvS42zjNBmX.png" alt="Github05.png"></p>
</li>
<li><p>首次使用还需要确认并添加主机到本机 SSH 可信列表，命令为：<code>ssh -T git@github.com</code>。若返回 <code>Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code> 内容，则证明添加成功<br><img src="https://i.loli.net/2020/03/19/QqdBSe3vVxnckDj.png" alt="Github06.png"></p>
</li>
<li><p>在 GitHub 的设置处找到 <code>SSH and GPG keys</code><br><img src="https://i.loli.net/2020/03/19/IXPfat3AknF9ZBH.png" alt="Github07.png"></p>
</li>
<li><p>点击添加，Title 随便填，然后把刚刚复制的内容填到 Key 处然后确认就成功添加好 SSH 了</p>
</li>
<li><p>修改本地配置文件，在你的数据目录内找到这个文件 <code>_config.yml</code> 并打开<br><img src="https://i.loli.net/2019/04/01/5ca20c113bd6e.png" alt="config文件"></p>
</li>
<li><p>找到 <font color=#FF0000>URL</font> 一行，修改 url 和 root。url 即为<a href="#github">这里</a>的博客地址，root 这里只需要写一个 / 即可，之后按 ctrl+ S 保存<br><img src="https://i.loli.net/2020/03/19/BlkZIsPWDwg5Qi9.png" alt="Github08.png"></p>
</li>
<li><p>设置 Git 路径，进入你创建的仓库，在右边这里切换为 SSH，复制以 git 开头的那一段内容<br><img src="https://i.loli.net/2020/03/19/vNdxURhbiStZfu7.png" alt="Github09.png"></p>
</li>
<li><p>打开 <code>_config.yml</code> 配置文件，修改最下边 deploy 区域，按图增加一个 repo，之后按 ctrl+S 保存<br><img src="https://i.loli.net/2020/03/19/Q7PWJHSMya4Nq8n.png" alt="Github10.png"></p>
<blockquote>
<p>注意：图中红线框着的地方有空格，千万不要忘记。这里是博主遇到的最大的坑。Hexo 中和 Markdown 中最要注意的就是空格了。</p>
</blockquote>
</li>
<li><p>安装 hexo-deployer-git 插件，命令为： <code>npm install hexo-deployer-git --save</code><br><img src="https://i.loli.net/2019/04/01/5ca21222a87c4.png" alt="安装deployer插件"></p>
</li>
<li><p>生成静态文件并上传至 GitHub 端，将博客部署到服务器，命令为： <code>hexo g &amp;&amp; hexo d</code>，中途会让你输入 GitHub 的账户密码（我这里的图是 Gitee 的，GitHub 类似）<br><img src="https://i.loli.net/2019/04/01/5ca21252b42ff.png" alt="登陆账户"></p>
</li>
<li><p>这就代表上传完毕了（我这里的图是 Gitee 的，GitHub 类似）<br><img src="https://i.loli.net/2019/04/01/5ca21275b5736.png" alt="部署"></p>
</li>
<li><p>进入仓库检查是否上传成功，这就代表已成功传入仓库中（我这里的图是 Gitee 的，GitHub 类似）<br><img src="https://i.loli.net/2019/04/01/5ca212a2b72a6.png" alt="对接成功"></p>
</li>
<li><p>浏览器登录博客地址（这里换成你 GitHub 的地址即可）查看博客<br><img src="https://i.loli.net/2019/04/01/5ca212d9c794e.png" alt="查看博客"></p>
</li>
<li><p>至此，博客搭建完毕</p>
</li>
</ol>
<h1 id="五、绑定域名"><a href="#五、绑定域名" class="headerlink" title="五、绑定域名"></a>五、绑定域名</h1><ul>
<li>在使用 Gitee 或者 GitHub 部署自己博客时，会发现链接很长，一方面别人并不好记，另一方面也并不太好看，所以可以自己买个心仪的域名，然后使用域名解析到你的博客的链接上去</li>
<li>我这里买的是阿里云的域名，新用户首次购买有优惠，当然你们也可以使用其他的，原理类似</li>
</ul>
<h2 id="1-GitHub-Pages-域名"><a href="#1-GitHub-Pages-域名" class="headerlink" title="1.GitHub Pages + 域名"></a>1.GitHub Pages + 域名</h2><ul>
<li>在上面第四大点中的 GitHub 上传服务搭建好后，自己购买一个域名</li>
<li>在系统的 cmd 窗口 ping 一下你的 GitHub 的博客地址，记录下实际的ip地址<br><img src="https://i.loli.net/2020/03/21/lBsL42PG58CXWi3.png" alt="解析域名3.png"></li>
<li>在域名的管理台界面找到域名解析，点击添加第一条记录：<br><img src="https://i.loli.net/2020/03/21/qZN1lJQM8YkExn5.png" alt="解析域名1.png"></li>
<li>保存后点击添加第二条记录：<br><img src="https://i.loli.net/2020/03/21/dxIgOAFE3H9a5bD.png" alt="解析域名2.png"></li>
<li>进入 GitHub 的设置界面找到 GitHub Pages 处，在 Custom domain 处填入自己的域名地址<br><img src="https://i.loli.net/2020/03/21/LUlumibBJKZrVgy.png" alt="域名解析4.png"></li>
<li>访问你的博客在 GitHub上的项目仓库，点击 Create new file 新建文件，命名为 CNAME，内容写上你的域名，不要http等，如下图：<br><img src="https://i.loli.net/2020/03/21/eB4FXnmZksrSgiA.png" alt="域名解析5.png"></li>
<li>但是每次使用 Git 同步的时候，CNAME 文件都会从仓库中消失，这时候我们需要在本地博客的 /source 目录里新建个同样的 CNAME 文件，使用记事本打开，填写内容也与上边一致，如下图：<br><img src="https://i.loli.net/2020/03/21/wmSWkBCbQZnuTG1.png" alt="域名解析6.png"></li>
<li>重新使用 Hexo 命令上传到仓库，等待几分钟，即可使用域名访问自己的博客了</li>
</ul>
<h2 id="2-Gitee-Pages-域名"><a href="#2-Gitee-Pages-域名" class="headerlink" title="2.Gitee Pages + 域名"></a>2.Gitee Pages + 域名</h2><ul>
<li>方法和 GitHub 类似，自行摸索即可</li>
</ul>
<h1 id="六、常用指令"><a href="#六、常用指令" class="headerlink" title="六、常用指令"></a>六、常用指令</h1><h2 id="1-创建文章或页面"><a href="#1-创建文章或页面" class="headerlink" title="1.创建文章或页面"></a>1.创建文章或页面</h2><ul>
<li><p><code>hexo new [layout] &lt;title&gt;</code> ，layout 属性如下：<br>post：新建文章，存放路径于 <code>source/_posts</code> ，新建文章可以使用简写命令，如本文的创建即可以用 <code>hexo n Hexo博客之NexT配置教程</code><br>page：新建页面，如404，分类等，存放路径于 <code>source/</code><br>draft：新建草稿，存放路径于 <code>source/_drafts</code>，这里也可以用另一个命令新建草稿 <code>hexo publish [layout] &lt;title&gt;</code></p>
</li>
<li><p>上面的 <code>&lt;title&gt;</code> 属性是博文 Markdown 文件的名字，一般也会自动生成为博客文章的标题，也是博文链接的后缀（如 <a href="https://www.wrysmile.cn/2020/03/22/hexo-tutorial/">https://www.wrysmile.cn/2020/03/22/hexo-tutorial/</a> 中的<code>hexo-tutorial</code>）</p>
</li>
</ul>
<h2 id="2-上传仓库"><a href="#2-上传仓库" class="headerlink" title="2.上传仓库"></a>2.上传仓库</h2><ul>
<li><code>hexo clean</code> 清理缓存文件——db.json和已生成的静态文件——public</li>
<li><code>hexo g</code> 生成网站静态文件到默认设置的 public 文件夹</li>
<li><code>hexo s</code> 启动本地服务器，用于预览主题。默认地址：<a href="http://localhost:4000/">http://localhost:4000/</a></li>
<li><code>hexo d</code> 自动生成网站静态文件，并部署到设定的仓库</li>
</ul>
<h1 id="七、常见问题"><a href="#七、常见问题" class="headerlink" title="七、常见问题"></a>七、常见问题</h1><h2 id="1-初始化-Hexo-时卡条"><a href="#1-初始化-Hexo-时卡条" class="headerlink" title="1.初始化 Hexo 时卡条"></a>1.<span id="katiao">初始化 Hexo 时卡条</span></h2><ul>
<li>很多人在初始化 Hexo 的过程中，总是在 init 这一步卡在 20%/30% 这里就不动了，博主也遇到了这个问题，最后发现是因为这里需要从 GitHub 端进行下载相关的配置。</li>
<li>查阅网上资料，有以下两种方法，请自行选择。</li>
</ul>
<h3 id="方法1：科学上网"><a href="#方法1：科学上网" class="headerlink" title="方法1：科学上网"></a>方法1：科学上网</h3><ul>
<li>毕竟 GitHub 是国外网站，可能下载数据时会有延迟等等问题，故可尝试科学上网方法</li>
<li>博主试了，用的临时下载的 <strong>微屁恩</strong> ，没有成功，只好选用第二种方法</li>
</ul>
<h3 id="方法2：ping-github-com"><a href="#方法2：ping-github-com" class="headerlink" title="方法2：ping github.com"></a>方法2：ping github.com</h3><ul>
<li>先查询 github.com 的 ip：<a href="http://github.com.ipaddress.com/">查看链接</a><br><img src="https://i.loli.net/2019/04/07/5ca9b3520e4db.png" alt="ip查询"></li>
<li>打开 <code>C:\Windows\System32\divers\etc</code> 目录下的 hosts 文件，用记事本以管理员身份运行打开，在最后一行添加 <code>192.30.253.112 github.com</code> 即可<br><img src="https://i.loli.net/2019/04/07/5ca9b3a974244.png" alt="修改hosts"></li>
<li>Windows下按 <code>win+R</code> 进入 cmd 命令行，输入 <code>ping github.com</code> 可看见收到 github 站点的反馈，说明 ping 成功<br><img src="https://i.loli.net/2019/04/07/5ca9b380a9578.png" alt="ping"></li>
<li>再次执行初始化 Hexo 命令即可正常初始化安装</li>
<li>该方法来自这位老哥给的方法，实验证明 win10 下也同样适用。<a href="https://blog.csdn.net/qq_37253988/article/details/79286489">查看链接</a></li>
<li>解决 ping github.com 超时的方法来自这位老哥。<a href="https://blog.csdn.net/ShelleyLittlehero/article/details/81428613?utm_source=blogxgwz8">查看链接</a></li>
</ul>
<h2 id="2-部署到-Gitee-后博客内容无变化"><a href="#2-部署到-Gitee-后博客内容无变化" class="headerlink" title="2.部署到 Gitee 后博客内容无变化"></a>2.部署到 Gitee 后博客内容无变化</h2><ul>
<li>正常执行上传部署操作，即 <code>hexo g &amp;&amp; hexo d</code></li>
<li>进入 Gitee 官网找到放博客的仓库</li>
<li>找到服务-Gitee Pages，点击更新</li>
<li>此时会重新部署，完成后博客网站就更新了</li>
</ul>
<h1 id="八、该系列文章"><a href="#八、该系列文章" class="headerlink" title="八、该系列文章"></a>八、该系列文章</h1><ul>
<li>想要了解主题配置教程请移步这里：<a href="/Hexo-02.html" title="[Hexo博客之NexT配置教程]">[Hexo博客之NexT配置教程]</a></li>
<li>想要了解高级优化教程请移步这里：<a href="/Hexo-03.html" title="[Hexo博客之高级优化教程]">[Hexo博客之高级优化教程]</a></li>
<li>想要了解Markdown教程请移步这里：<a href="/Hexo-04.html" title="[Hexo博客之Markdown教程]">[Hexo博客之Markdown教程]</a></li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>前端：面试与笔试经验总结</title>
    <url>/Web-Interview.html</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul>
<li>主要总结了各个公司的面试与笔试时的一些内容<span id="more"></span></li>
</ul>
<h1 id="一、字节跳动"><a href="#一、字节跳动" class="headerlink" title="一、字节跳动"></a>一、字节跳动</h1><h2 id="1-一面"><a href="#1-一面" class="headerlink" title="1.一面"></a>1.一面</h2><h3 id="1-讲述一下计算机网络的七层"><a href="#1-讲述一下计算机网络的七层" class="headerlink" title="(1).讲述一下计算机网络的七层"></a>(1).讲述一下计算机网络的七层</h3><ul>
<li>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</li>
</ul>
<h3 id="2-TCP、UDP、HTTP分别处于哪一层？"><a href="#2-TCP、UDP、HTTP分别处于哪一层？" class="headerlink" title="(2).TCP、UDP、HTTP分别处于哪一层？"></a>(2).TCP、UDP、HTTP分别处于哪一层？</h3><ul>
<li>传输层、传输层、应用层</li>
<li>HTTP与TCP的关系：</li>
</ul>
<h3 id="3-TCP和UDP的区别"><a href="#3-TCP和UDP的区别" class="headerlink" title="(3).TCP和UDP的区别"></a>(3).TCP和UDP的区别</h3><ul>
<li><p>TCP：面向连接、传输可靠(保证数据正确性,保证数据顺序)、用于传输大量数据(流模式)、速度慢，建立连接需要开销较多(时间，系统资源)</p>
</li>
<li><p>UDP：面向非连接、传输不可靠、用于传输少量数据(数据包模式)、速度快</p>
</li>
<li><p>TCP和UDP协议的一些应用例子：</p>
<ul>
<li>TCP一般用于文件传输（FTP HTTP 对数据准确性要求高，速度可以相对慢），发送或接收邮件（POP IMAP SMTP 对数据准确性要求高，非紧急应用），远程登录（TELNET SSH 对数据准确性有一定要求，有连接的概念）等等</li>
<li>UDP一般用于即时通信（QQ聊天 对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP 速度一定要快，保证视频连续，但是偶尔花了一个图像帧，人们还是能接受的），网络语音电话（VoIP 语音数据包一般比较小，需要高速发送，偶尔断音或串音也没有问题）等等。</li>
</ul>
</li>
</ul>
<h3 id="4-JS中有几种数据类型？"><a href="#4-JS中有几种数据类型？" class="headerlink" title="(4).JS中有几种数据类型？"></a>(4).JS中有几种数据类型？</h3><ul>
<li></li>
</ul>
<h3 id="5-JS中有几种判断数据类型的方法，有什么区别？"><a href="#5-JS中有几种判断数据类型的方法，有什么区别？" class="headerlink" title="(5).JS中有几种判断数据类型的方法，有什么区别？"></a>(5).JS中有几种判断数据类型的方法，有什么区别？</h3><ul>
<li>typeof和instanceof</li>
<li>区别：</li>
</ul>
<h3 id="6-JS中判断两个数据相等的方法"><a href="#6-JS中判断两个数据相等的方法" class="headerlink" title="(6).JS中判断两个数据相等的方法"></a>(6).JS中判断两个数据相等的方法</h3><ul>
<li></li>
<li><code>NAN === NAN</code> 成立吗？</li>
<li><code>0.1 === 0.1</code> 成立吗？</li>
</ul>
<h3 id="7-以下代码的输出结果是什么？涉及什么知识点？"><a href="#7-以下代码的输出结果是什么？涉及什么知识点？" class="headerlink" title="(7).以下代码的输出结果是什么？涉及什么知识点？"></a>(7).以下代码的输出结果是什么？涉及什么知识点？</h3><ul>
<li><p>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setTimeout(()=&gt;&#123;log(1)&#125;, 0);</span><br><span class="line">Promise.resolve().then(e=&gt;&#123;log(2)&#125;);</span><br><span class="line">setTimeout(()=&gt;&#123;log(3)&#125;, 0);</span><br><span class="line">let p = new Promise((res)=&gt;&#123;</span><br><span class="line">    log(4);</span><br><span class="line">    setTimeout(</span><br><span class="line">        ()=&gt;&#123;</span><br><span class="line">            Promise.resolve().then(e=&gt;&#123;log(7)&#125;);</span><br><span class="line">            res(6)</span><br><span class="line">            log(5)</span><br><span class="line">        &#125;</span><br><span class="line">    ,0);</span><br><span class="line">    setTimeout(()=&gt;&#123;log(8)&#125;, 0);</span><br><span class="line">&#125;)</span><br><span class="line">p.then(e=&gt;&#123;log(e)&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>输出结果为：4 2 7 6 1 3 5 8</p>
</li>
<li><p>涉及知识点：js异步中的两种队列（微、宏）、promise异步编程</p>
</li>
</ul>
<h3 id="8-BFC是什么？"><a href="#8-BFC是什么？" class="headerlink" title="(8).BFC是什么？"></a>(8).BFC是什么？</h3><ul>
<li></li>
</ul>
<h3 id="9-JSON数据格式是什么？"><a href="#9-JSON数据格式是什么？" class="headerlink" title="(9).JSON数据格式是什么？"></a>(9).JSON数据格式是什么？</h3><ul>
<li><p>键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;wrysmile&quot;,</span><br><span class="line">	age: 25</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组/集合：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	[1,2,3],</span><br><span class="line">	[4,5,6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="10-如何实现-JSON-深拷贝？"><a href="#10-如何实现-JSON-深拷贝？" class="headerlink" title="(10).如何实现 JSON 深拷贝？"></a>(10).如何实现 JSON 深拷贝？</h3><ul>
<li>例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = &#123;b:1, c: &#123;d:3&#125;, e:[2,3,4]&#125;</span><br><span class="line">var copy = clone(a)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-let、const、var的区别是什么？"><a href="#11-let、const、var的区别是什么？" class="headerlink" title="(11).let、const、var的区别是什么？"></a>(11).let、const、var的区别是什么？</h3><ul>
<li><p>区别：</p>
</li>
<li><p>以下代码输出什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(true)&#123;</span><br><span class="line">	console.log(a)</span><br><span class="line">	let a = 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以下代码输出什么？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const  a = &#123;b: 2&#125;</span><br><span class="line">a.b = 4</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12-事件冒泡和事件委托分别是什么？"><a href="#12-事件冒泡和事件委托分别是什么？" class="headerlink" title="(12).事件冒泡和事件委托分别是什么？"></a>(12).事件冒泡和事件委托分别是什么？</h3><ul>
<li></li>
</ul>
<h3 id="13-如何判断是那个子元素发生事件冒泡？"><a href="#13-如何判断是那个子元素发生事件冒泡？" class="headerlink" title="(13).如何判断是那个子元素发生事件冒泡？"></a>(13).如何判断是那个子元素发生事件冒泡？</h3><ul>
<li></li>
</ul>
<h3 id="14-前端中是如何发送请求的？"><a href="#14-前端中是如何发送请求的？" class="headerlink" title="(14).前端中是如何发送请求的？"></a>(14).前端中是如何发送请求的？</h3><ul>
<li><code>&lt;link&gt;</code>、<code>&lt;a&gt;</code> 标签中的 href 属性</li>
<li><code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code> 的 src属性</li>
<li>通过表单提交来发送请求</li>
<li>ajax、axios、jquery 调用 ajax 方法</li>
</ul>
<h3 id="15-用css2和css3分别写一下垂直居中和水平居中"><a href="#15-用css2和css3分别写一下垂直居中和水平居中" class="headerlink" title="(15).用css2和css3分别写一下垂直居中和水平居中"></a>(15).用css2和css3分别写一下垂直居中和水平居中</h3><ul>
<li>css3新增了一些属性，像flex，这是css3中很重要的改变，所以除了flex以外的垂直水平居中的技巧都是属于css2的。</li>
<li>水平居中：<ul>
<li>css2<br>将元素display为行内元素，再text-align:center;即可或者将块级元素定义一个宽度，再margin: 0 auto;即可</li>
<li>css3<br>将元素display设为flex，再通过justify-content: center; 实现居中。</li>
</ul>
</li>
<li>垂直居中<ul>
<li>css2<br>单行内容的垂直居中可以通过设置相同height值和line-height值来实现。<br>多行内容的垂直居中且高度可变可以通过设置上下相同的padding值来实现。<br>行级盒子：小图标和标题对齐设置vertical-align: middle。<br>绝对定位：top:50%; left:50%;的方法，需要已知块级的宽高</li>
<li>css3<br>将元素display设为flex，再通过align-items:center;来实现。</li>
</ul>
</li>
</ul>
<h3 id="16-闭包是什么？"><a href="#16-闭包是什么？" class="headerlink" title="(16).闭包是什么？"></a>(16).闭包是什么？</h3><ul>
<li>函数嵌套且内层函数调用外层函数的变量就会形成闭包</li>
</ul>
<h2 id="！建议"><a href="#！建议" class="headerlink" title="！建议"></a>！建议</h2><ul>
<li>学习好计算机网络、数据结构、JS基础内容</li>
<li>建议多端学习，如 Web、小程序、客户端</li>
</ul>
<h1 id="二、北京校萌科技有限公司"><a href="#二、北京校萌科技有限公司" class="headerlink" title="二、北京校萌科技有限公司"></a>二、北京校萌科技有限公司</h1><h2 id="1-http状态码含义"><a href="#1-http状态码含义" class="headerlink" title="1.http状态码含义"></a>1.http状态码含义</h2><ul>
<li>点击 <a href="https://www.runoob.com/http/http-status-codes.html">这里</a> 进行查看</li>
</ul>
<h2 id="2-浏览器存储的几种方式"><a href="#2-浏览器存储的几种方式" class="headerlink" title="2.浏览器存储的几种方式"></a>2.浏览器存储的几种方式</h2><ul>
<li>分别为：cookie、localStorage、sessionStorage、indexedDB</li>
<li>区别：第一个属于文档对象模型DOM树根节点document，后者属于浏览器对象模型BOM的对象window</li>
</ul>
<h2 id="3-数组的各种方法"><a href="#3-数组的各种方法" class="headerlink" title="3.数组的各种方法"></a>3.数组的各种方法</h2><ul>
<li></li>
</ul>
<h2 id="4-基本数据类型和引用数据类型"><a href="#4-基本数据类型和引用数据类型" class="headerlink" title="4.基本数据类型和引用数据类型"></a>4.基本数据类型和引用数据类型</h2><ul>
<li></li>
</ul>
<h2 id="5-小程序的生命周期"><a href="#5-小程序的生命周期" class="headerlink" title="5.小程序的生命周期"></a>5.小程序的生命周期</h2><ul>
<li>小程序的生命周期如下：<ul>
<li>onLunch()：小程序首次加载初始化</li>
<li>onShow()：小程序进入前台的时候</li>
<li>onHide()：小程序进入后台的时候</li>
<li>onError()：发生脚本错误时</li>
</ul>
</li>
<li>页面的生命周期如下：<ul>
<li>onLoad()：页面加载</li>
<li>onReady()：页面初次渲染完成</li>
<li>onShow()：页面显示</li>
<li>onHide()：页面隐藏</li>
<li>onUnload()：页面卸载</li>
</ul>
</li>
</ul>
<h1 id="三、润尼尔科技有限公司"><a href="#三、润尼尔科技有限公司" class="headerlink" title="三、润尼尔科技有限公司"></a>三、润尼尔科技有限公司</h1><h2 id="1-sessionStorage、localStorage与cookie的区别"><a href="#1-sessionStorage、localStorage与cookie的区别" class="headerlink" title="1.sessionStorage、localStorage与cookie的区别"></a>1.sessionStorage、localStorage与cookie的区别</h2><ul>
<li></li>
</ul>
<h2 id="2-jQuery与其他框架相比的优势"><a href="#2-jQuery与其他框架相比的优势" class="headerlink" title="2.jQuery与其他框架相比的优势"></a>2.jQuery与其他框架相比的优势</h2><ul>
<li>轻量级</li>
<li>强大的选择器</li>
<li>出色的DOM操作的封装</li>
<li>可靠的事件处理机制</li>
<li>完善的Ajax</li>
<li>不污染顶级变量</li>
<li>出色的浏览器兼容性</li>
<li>链式操作方式</li>
<li>隐式迭代</li>
<li>行为层与结构层的分离</li>
<li>丰富的插件支持</li>
</ul>
<h2 id="3-http与https的区别"><a href="#3-http与https的区别" class="headerlink" title="3.http与https的区别"></a>3.http与https的区别</h2><ul>
<li>https 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用</li>
<li>http 是超文本传输协议，信息是明文传输；https 则是具有安全性的 ssl 加密传输协议</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>
<li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全</li>
</ul>
<h2 id="4-什么是跨域"><a href="#4-什么是跨域" class="headerlink" title="4.什么是跨域"></a>4.什么是跨域</h2><ul>
<li>违背同源策略的都可以认为是跨域，即协议、url、端口等都不相同</li>
<li>解决跨域：jsonp 与 CORS</li>
</ul>
<h2 id="5-了解canvas吗？"><a href="#5-了解canvas吗？" class="headerlink" title="5.了解canvas吗？"></a>5.了解canvas吗？</h2><ul>
<li><strong>Canvas API</strong> 提供了一个通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">JavaScript</a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML</a>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas">canvas</a>元素来绘制图形的方式</li>
<li>它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面</li>
</ul>
<h2 id="6-用网页播放过视频或音频吗？"><a href="#6-用网页播放过视频或音频吗？" class="headerlink" title="6.用网页播放过视频或音频吗？"></a>6.用网页播放过视频或音频吗？</h2><ul>
<li></li>
</ul>
<h2 id="7-Linux命令有哪些，简要说明一下"><a href="#7-Linux命令有哪些，简要说明一下" class="headerlink" title="7.Linux命令有哪些，简要说明一下"></a>7.Linux命令有哪些，简要说明一下</h2><ul>
<li></li>
</ul>
<h1 id="四、中科聚网"><a href="#四、中科聚网" class="headerlink" title="四、中科聚网"></a>四、中科聚网</h1><h2 id="1-编写一个方法，进行数组去重"><a href="#1-编写一个方法，进行数组去重" class="headerlink" title="1.编写一个方法，进行数组去重"></a>1.编写一个方法，进行数组去重</h2><ul>
<li></li>
</ul>
<h2 id="2-如何阻止默认事件？"><a href="#2-如何阻止默认事件？" class="headerlink" title="2.如何阻止默认事件？"></a>2.如何阻止默认事件？</h2><ul>
<li>在IE浏览器中通过 <code>e.returnValue=false;</code> </li>
<li>在其他浏览器中调用方法 <code>e.preventDefault();</code></li>
<li><code>return false</code> 实现阻止事件的默认行为；禁止冒泡，同时取消默认行为</li>
</ul>
<h2 id="3-同步和异步的区别"><a href="#3-同步和异步的区别" class="headerlink" title="3.同步和异步的区别"></a>3.同步和异步的区别</h2><ul>
<li>同步：提交请求 -&gt; 等待服务器处理 -&gt; 处理完毕返回（这个期间客户端浏览器不能干任何事）</li>
<li>异步: 请求通过事件触发 -&gt; 服务器处理（这时浏览器仍然可以做其他事情）-&gt; 处理完毕</li>
</ul>
<h2 id="4-ES6的新特性有哪些？"><a href="#4-ES6的新特性有哪些？" class="headerlink" title="4.ES6的新特性有哪些？"></a>4.ES6的新特性有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="5-vue的指令有哪些？"><a href="#5-vue的指令有哪些？" class="headerlink" title="5.vue的指令有哪些？"></a>5.vue的指令有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="6-vue的生命周期有哪些？"><a href="#6-vue的生命周期有哪些？" class="headerlink" title="6.vue的生命周期有哪些？"></a>6.vue的生命周期有哪些？</h2><ul>
<li>beforeCreate（创建前）</li>
<li>created（创建后）</li>
<li>beforeMount（载入前）</li>
<li>mounted（载入后）</li>
<li>beforeUpdate（更新前）</li>
<li>updated（更新后）</li>
<li>beforeDestroy（销毁前）</li>
<li>destroyed（销毁后）</li>
</ul>
<h2 id="7-前端性能优化的方法"><a href="#7-前端性能优化的方法" class="headerlink" title="7.前端性能优化的方法"></a>7.前端性能优化的方法</h2><ul>
<li>七大手段：减少请求数量、减小资源大小、优化网络连接、优化资源加载、减少重绘回流、使用性能更好的 API 和构建优化</li>
<li>可以查看 <a href="https://www.cnblogs.com/xiaohuochai/p/9178390.html">这里</a></li>
</ul>
<h2 id="8-谈谈你对MVC与MVVM的理解"><a href="#8-谈谈你对MVC与MVVM的理解" class="headerlink" title="8.谈谈你对MVC与MVVM的理解"></a>8.谈谈你对MVC与MVVM的理解</h2><ul>
<li>可以查看 <a href="https://www.cnblogs.com/keitsi/p/5764785.html">这里</a></li>
</ul>
<h2 id="9-微信小程序的优劣有哪些？"><a href="#9-微信小程序的优劣有哪些？" class="headerlink" title="9.微信小程序的优劣有哪些？"></a>9.微信小程序的优劣有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="10-什么是响应式开发？"><a href="#10-什么是响应式开发？" class="headerlink" title="10.什么是响应式开发？"></a>10.什么是响应式开发？</h2><ul>
<li>定义：Ethan Marcotte 在 2010 年 5 月份提出的一个概念，旨在让一个网站同时兼容多种设备，而不是为不同设备定制不同的版本</li>
<li>主要有如下几部分：<ul>
<li>字体大小响应</li>
<li>屏幕尺寸响应</li>
<li>屏幕精度响应</li>
<li>交互方式响应</li>
<li>网络状况响应</li>
<li>其他功能响应</li>
<li>使用场景响应</li>
<li>用户偏好响应</li>
</ul>
</li>
<li>具体内容可以查看 <a href="https://www.cnblogs.com/flash3d/archive/2013/09/28/3343877.html">这里</a></li>
</ul>
<h1 id="五、北京丰升"><a href="#五、北京丰升" class="headerlink" title="五、北京丰升"></a>五、北京丰升</h1><h2 id="1-什么是跨域？"><a href="#1-什么是跨域？" class="headerlink" title="1.什么是跨域？"></a>1.什么是跨域？</h2><ul>
<li></li>
</ul>
<h2 id="2-浏览器存储有哪些？"><a href="#2-浏览器存储有哪些？" class="headerlink" title="2.浏览器存储有哪些？"></a>2.浏览器存储有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="3-清除浮动的方式有哪些？"><a href="#3-清除浮动的方式有哪些？" class="headerlink" title="3.清除浮动的方式有哪些？"></a>3.清除浮动的方式有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="4-get与post的区别有哪些？"><a href="#4-get与post的区别有哪些？" class="headerlink" title="4.get与post的区别有哪些？"></a>4.get与post的区别有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="5-HTTP状态码有哪些？"><a href="#5-HTTP状态码有哪些？" class="headerlink" title="5.HTTP状态码有哪些？"></a>5.HTTP状态码有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="6-ES6新特性有哪些？"><a href="#6-ES6新特性有哪些？" class="headerlink" title="6.ES6新特性有哪些？"></a>6.ES6新特性有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="7-var、let、const的区别有哪些？"><a href="#7-var、let、const的区别有哪些？" class="headerlink" title="7.var、let、const的区别有哪些？"></a>7.var、let、const的区别有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="8-高维数组如何转化为一维数组？"><a href="#8-高维数组如何转化为一维数组？" class="headerlink" title="8.高维数组如何转化为一维数组？"></a>8.高维数组如何转化为一维数组？</h2><ul>
<li></li>
</ul>
<h2 id="9-输入一个对象如何输出为另一个对象？"><a href="#9-输入一个对象如何输出为另一个对象？" class="headerlink" title="9.输入一个对象如何输出为另一个对象？"></a>9.输入一个对象如何输出为另一个对象？</h2><ul>
<li></li>
</ul>
<h2 id="10-vue中的data为什么是函数？"><a href="#10-vue中的data为什么是函数？" class="headerlink" title="10.vue中的data为什么是函数？"></a>10.vue中的data为什么是函数？</h2><ul>
<li></li>
</ul>
<h2 id="11-如何将一个链接解析成一个对象？"><a href="#11-如何将一个链接解析成一个对象？" class="headerlink" title="11.如何将一个链接解析成一个对象？"></a>11.如何将一个链接解析成一个对象？</h2><ul>
<li></li>
</ul>
<h1 id="六、简巨科技"><a href="#六、简巨科技" class="headerlink" title="六、简巨科技"></a>六、简巨科技</h1><h2 id="1-想找一家什么样的公司呢？"><a href="#1-想找一家什么样的公司呢？" class="headerlink" title="1.想找一家什么样的公司呢？"></a>1.想找一家什么样的公司呢？</h2><ul>
<li></li>
</ul>
<h2 id="2-公司从事的行业有考虑过吗？"><a href="#2-公司从事的行业有考虑过吗？" class="headerlink" title="2.公司从事的行业有考虑过吗？"></a>2.公司从事的行业有考虑过吗？</h2><ul>
<li></li>
</ul>
<h2 id="3-对自己的职业规划有什么想法？"><a href="#3-对自己的职业规划有什么想法？" class="headerlink" title="3.对自己的职业规划有什么想法？"></a>3.对自己的职业规划有什么想法？</h2><ul>
<li></li>
</ul>
<h2 id="4-接受加班-出差-驻场吗？"><a href="#4-接受加班-出差-驻场吗？" class="headerlink" title="4.接受加班/出差/驻场吗？"></a>4.接受加班/出差/驻场吗？</h2><ul>
<li></li>
</ul>
<h2 id="5-你的优点-缺点有哪些？"><a href="#5-你的优点-缺点有哪些？" class="headerlink" title="5.你的优点/缺点有哪些？"></a>5.你的优点/缺点有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="6-你的性格怎么样？"><a href="#6-你的性格怎么样？" class="headerlink" title="6.你的性格怎么样？"></a>6.你的性格怎么样？</h2><ul>
<li></li>
</ul>
<h2 id="7-你买过最贵的东西是什么？"><a href="#7-你买过最贵的东西是什么？" class="headerlink" title="7.你买过最贵的东西是什么？"></a>7.你买过最贵的东西是什么？</h2><ul>
<li></li>
</ul>
<h2 id="8-你是一个轴的人吗？"><a href="#8-你是一个轴的人吗？" class="headerlink" title="8.你是一个轴的人吗？"></a>8.你是一个轴的人吗？</h2><ul>
<li></li>
</ul>
<h1 id="七、思无界"><a href="#七、思无界" class="headerlink" title="七、思无界"></a>七、思无界</h1><h2 id="1-微信小程序中有什么常用的API？"><a href="#1-微信小程序中有什么常用的API？" class="headerlink" title="1.微信小程序中有什么常用的API？"></a>1.微信小程序中有什么常用的API？</h2><ul>
<li></li>
</ul>
<h2 id="2-单位除了px、rpx还有什么？"><a href="#2-单位除了px、rpx还有什么？" class="headerlink" title="2.单位除了px、rpx还有什么？"></a>2.单位除了px、rpx还有什么？</h2><ul>
<li></li>
</ul>
<h2 id="3-熟悉的Linux命令有哪些？"><a href="#3-熟悉的Linux命令有哪些？" class="headerlink" title="3.熟悉的Linux命令有哪些？"></a>3.熟悉的Linux命令有哪些？</h2><ul>
<li></li>
</ul>
<h2 id="4-CSS3中怎么做动画样式？"><a href="#4-CSS3中怎么做动画样式？" class="headerlink" title="4.CSS3中怎么做动画样式？"></a>4.CSS3中怎么做动画样式？</h2><ul>
<li></li>
</ul>
<h1 id="八、"><a href="#八、" class="headerlink" title="八、"></a>八、</h1>]]></content>
      <categories>
        <category>面试笔试</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>经验</tag>
      </tags>
  </entry>
</search>
